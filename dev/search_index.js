var documenterSearchIndex = {"docs":
[{"location":"api/analysis/#PowerCurrentAnalysisAPI","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"In the following section, we have provided a list of functions that can be utilized for post-processing analysis. Once the voltage values are obtained through power flow analysis or optimal power flow analysis, these functions can be used to calculate power or current values. The specific procedures for computing these values depend on the chosen analysis, which are described in separate manuals for further information.","category":"page"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#AC-Power-Analysis","page":"Power and Current Analysis","title":"AC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!","category":"page"},{"location":"api/analysis/#AC-Power-Breakdown-Analysis","page":"Power and Current Analysis","title":"AC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower\nsupplyPower\nshuntPower\nfromPower\ntoPower\nseriesPower\nchargingPower\ngeneratorPower","category":"page"},{"location":"api/analysis/#AC-Current-Analysis","page":"Power and Current Analysis","title":"AC Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"current!","category":"page"},{"location":"api/analysis/#AC-Current-Breakdown-Analysis","page":"Power and Current Analysis","title":"AC Current Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionCurrent\nfromCurrent\ntoCurrent\nseriesCurrent","category":"page"},{"location":"api/analysis/#DC-Power-Analysis","page":"Power and Current Analysis","title":"DC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!","category":"page"},{"location":"api/analysis/#DC-Power-Breakdown-Analysis","page":"Power and Current Analysis","title":"DC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower\nsupplyPower\nfromPower\ntoPower\ngeneratorPower","category":"page"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACPowerAnalysisAPI","page":"Power and Current Analysis","title":"AC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!(::PowerSystem, ::ACPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.power!","text":"power!(system::PowerSystem, analysis::AC)\n\nThe function computes the active and reactive powers associated with buses, branches, and generators in the AC framework.\n\nUpdates\n\nThis function updates the power field of the AC abstract type by computing the following electrical quantities:\n\ninjection: active and reactive power bus injections;\nsupply: active and reactive power bus injections from the generators;\nshunt: active and reactive power values associated with shunt element at each bus;\nfrom: active and reactive power flows at the \"from\" end of each branch;\nto: active and reactive power flows at the \"to\" end of each branch;\ncharging: active and reactive power values linked with branch charging admittances for each branch;\nseries active and reactive power losses through each branch series impedance;\ngenerator: produced active and reactive power outputs of each generator.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\npower!(system, analysis)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\npower!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACPowerBreakdownAnalysisAPI","page":"Power and Current Analysis","title":"AC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower(::PowerSystem, ::AC)\nsupplyPower(::PowerSystem, ::ACPowerFlow)\nshuntPower(::PowerSystem, ::AC)\nfromPower(::PowerSystem, ::AC)\ntoPower(::PowerSystem, ::AC)\nseriesPower(::PowerSystem, ::AC)\nchargingPower(::PowerSystem, ::AC)\ngeneratorPower(::PowerSystem, ::ACPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.injectionPower","text":"injectionPower(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power injections associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = injectionPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = injectionPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.supplyPower","text":"supplyPower(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power injections from the generators associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = supplyPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = supplyPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.shuntPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.shuntPower","text":"shuntPower(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power values of the shunt element associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = shuntPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = shuntPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.fromPower","text":"fromPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power flows at the \"from\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = fromPower(system, analysis; label = 2)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = fromPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.toPower","text":"toPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power flows at the \"to\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = toPower(system, analysis; label = 2)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = toPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.seriesPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.seriesPower","text":"seriesPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power losses across the series impedance of a specific branch within the AC framework. The label keyword argument should correspond to an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the power within the AC power flow;\nACOptimalPowerFlow: computes the power within the AC optimal power flow.\n\nExamples\n\nCompute the reactive power after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = seriesPower(system, analysis; label = 2)\n\nCompute the reactive power after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = seriesPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.chargingPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.chargingPower","text":"chargingPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power values associated with the charging admittances of a specific branch in the AC framework. The label keyword argument must correspond to an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the power within the AC power flow;\nACOptimalPowerFlow: computes the power within the AC optimal power flow.\n\nExamples\n\nCompute the reactive power after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = chargingPower(system, analysis; label = 2)\n\nCompute the reactive power after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = chargingPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.generatorPower-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.generatorPower","text":"generatorPower(system::PowerSystem, analysis::AC)\n\nThe function returns the active and reactive powers associated with a specific generator in the AC framework. The label keyword argument must match an existing generator label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = generatorPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = generatorPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACCurrentAnalysisAPI","page":"Power and Current Analysis","title":"AC Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"current!(::PowerSystem, ::AC)","category":"page"},{"location":"api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.current!","text":"current!(system::PowerSystem, analysis::AC)\n\nThe function computes the currents in the polar coordinate system associated with buses and branches in the AC framework.\n\nUpdates\n\nThis function calculates various electrical quantities in the polar coordinate system:\n\ninjection: current injections at each bus;\nfrom: current flows at each \"from\" bus end of the branch;\nto: current flows at each \"to\" bus end of the branch;\nseries: current flows through the series impedance of the branch in the direction from the \"from\" bus end to the \"to\" bus end of the branch.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the currents within the AC power flow;\nACOptimalPowerFlow: computes the currents within the AC optimal power flow.\n\nExamples\n\nCompute currents after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\ncurrent!(system, analysis)\n\nCompute currents after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\ncurrent!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACCurrentBreakdownAnalysisAPI","page":"Power and Current Analysis","title":"AC Current Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionCurrent(::PowerSystem, ::AC)\nfromCurrent(::PowerSystem, ::AC)\ntoCurrent(::PowerSystem, ::AC)\nseriesCurrent(::PowerSystem, ::AC)","category":"page"},{"location":"api/analysis/#JuliaGrid.injectionCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.injectionCurrent","text":"injectionCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = injectionCurrent(system, analysis; label = 1)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = injectionCurrent(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.fromCurrent","text":"fromCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the \"from\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = fromCurrent(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = fromCurrent(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.toCurrent","text":"toCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the \"to\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = toCurrent(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = toCurrent(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.seriesCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.seriesCurrent","text":"seriesCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system through series impedance associated with a specific branch in the direction from the \"from\" bus end to the \"to\" bus end of the branch within the AC framework. The label keyword argument must  match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = seriesCurrent(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = seriesCurrent(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#DCPowerAnalysisAPI","page":"Power and Current Analysis","title":"DC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.power!","text":"power!(system::PowerSystem, analysis::DC)\n\nThe function calculates the active power values related to buses, branches, and generators within the DC analysis framework. It modifies the power field of the abstract type DC.\n\nUpdates\n\nThis function computes the following electrical quantities:\n\ninjection: active power injections at each bus;\nsupply: active power injections from the generators at each bus;\nfrom: active power flows at each \"from\" bus end of the branch;\nto: active power flows at each \"to\" bus end of the branch;\ngenerator: output active powers of each generator.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the powers within the DC power flow;\nDCOptimalPowerFlow: computes the powers within the DC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\npower!(system, analysis)\n\nCompute powers after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\npower!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#DCPowerBreakdownAnalysisAPI","page":"Power and Current Analysis","title":"DC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower(::PowerSystem, ::DCPowerFlow)\nsupplyPower(::PowerSystem, ::DCPowerFlow)\nfromPower(::PowerSystem, ::DC)\ntoPower(::PowerSystem, ::DC)\ngeneratorPower(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.injectionPower","text":"injectionPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power injection associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow;\n\nExamples\n\nCompute the active power of a specific bus after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\ninjection = injectionPower(system, analysis; label = 2)\n\nCompute the active power of a specific bus after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\ninjection = injectionPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.supplyPower","text":"supplyPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power injection from the generators associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow,\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific bus after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nsupply = supplyPower(system, analysis; label = 2)\n\nCompute the active power of a specific bus after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nsupply = supplyPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, DC}","page":"Power and Current Analysis","title":"JuliaGrid.fromPower","text":"fromPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power flow at the \"from\" bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific branch after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nfrom = fromPower(system, analysis; label = 2)\n\nCompute the active power of a specific branch after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nfrom = fromPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, DC}","page":"Power and Current Analysis","title":"JuliaGrid.toPower","text":"toPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power flow at the \"to\" bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific branch after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nto = toPower(system, analysis; label = 2)\n\nCompute the active power of a specific branch after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nto = toPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.generatorPower-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.generatorPower","text":"generatorPower(system::PowerSystem, analysis::DC; label)\n\nThis function returns the output active power associated with a specific generator in the DC framework. The label keyword argument must match an existing generator label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific generator after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\ngenerator = generatorPower(system, analysis; label = 1)\n\nCompute the active power of a specific generator after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\ngenerator = generatorPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"manual/powerSystemModel/#PowerSystemModelManual","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid supports the composite type PowerSystem to preserve power system data, with the following fields: bus, branch, generator, base, model, and uuid. The fields bus, branch, and generator hold data related to buses, branches, and generators, respectively. The base field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes for the base power and line-to-line voltages measured in volts for base voltages. The model stores vectors and matrices that are related to the topology and parameters of the power system. Lastly, the uuid field contains a universally unique identifier, as assigned by JuliaGrid, which manages the behavior of the PowerSystem type across different functions.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The composite type PowerSystem can be created using a function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid supports three modes for populating the PowerSystem type: using built-in functions, using HDF5 file format, and using Matpower case files.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type is created, you can add buses, branches, and generators using the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!,\naddBranch!,\naddGenerator!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, JuliaGrid provides macros @bus, @branch, and @generator to define templates that aid in creating buses, branches, and generators. These templates help avoid entering the same parameters repeatedly.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To create vectors and matrices based on the power system topology and parameters, you can use the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!,\ndcModel!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Moreover, it is feasible to modify the parameters of buses, branches, and generators. When these functions are executed, all relevant fields within the PowerSystem composite type will be automatically updated, encompassing the ac and dc fields as well. These functions include:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateBus!,\nupdateBranch!,\nupdateGenerator!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, after adding the generator, JualiGrid provides the following function for adding or modifying costs for the active and reactive power generated by the generator:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"cost!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nThe functions addBranch!, addGenerator!, updateBus!, updateBranch!, updateGenerator!, and cost! serve a dual purpose. While their primary function is to modify the PowerSystem composite type, they are also designed to accept various analysis models like AC or DC power flow models. When feasible, these functions not only modify the PowerSystem type but also adapt the analysis model, often resulting in improved computational efficiency. Detailed instructions on utilizing this feature can be found in dedicated manuals for specific analyses.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#BuildModelManual","page":"Power System Model","title":"Build Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The powerSystem function generates the PowerSystem composite type and requires a string-formatted path to either Matpower case or HDF5 files as input. Alternatively, the PowerSystem can be created without any initial data by initializing it as empty, allowing the user to construct the power system from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Matpower-or-HDF5-File","page":"Power System Model","title":"Matpower or HDF5 File","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, to create the PowerSystem type using the Matpower case file for the IEEE 14-bus test case, which is named case14.m and located in the folder C:\\matpower, the following Julia code can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/matpower/case14.m\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In order to use the HDF5 file as input to create the PowerSystem object, it is necessary to have saved the data using the savePowerSystem function beforehand. As an example, let us say we saved the power system as case14.h5 in the directory C:\\hdf5. In this case, the following Julia code can be used to construct the PowerSystem composite type:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/hdf5/case14.h5\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIt is recommended to load the power system from the HDF5 file to reduce the loading time.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Model-from-Scratch","page":"Power System Model","title":"Model from Scratch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Alternatively, the model can be build from the scratch using built-in functions, for example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, base = 345e3)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Internal-Unit-System","page":"Power System Model","title":"Internal Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The PowerSystem composite type stores all electrical quantities in per-units and radians, except for the base values of power and voltages. The base power value is expressed in volt-amperes, while the base voltages are given in volts.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Base-Unit-Prefixes","page":"Power System Model","title":"Change Base Unit Prefixes","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As an example, if you execute the previous code snippet, you can retrieve the base power and base voltage values and units as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"By using the @base macro, users can change the prefixes of the base units. For instance, if the user wishes to convert base power and base voltage values to megavolt-amperes (MVA) and kilovolts (kV) respectively, they can execute the following macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, MVA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon execution of the macro, the base power and voltage values and units will be modified accordingly:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, by using the @base macro to modify the prefixes of the base units, users can convert the output data from various analyses to specific units with the desired prefixes.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#SaveModelManual","page":"Power System Model","title":"Save Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type has been created using one of the methods outlined in Build Model, the current data can be stored in the HDF5 file by using savePowerSystem function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem(system; path = \"C:/matpower/case14.h5\", reference = \"IEEE 14-bus test case\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"All electrical quantities saved in the HDF5 file are in per-units and radians, except for base values for power and voltages, which are given in volt-amperes and volts. It is important to note that even if the user modifies the base units using the @base macro, the units will still be saved in the default settings.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBusManual","page":"Power System Model","title":"Add Bus","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We have the option to add buses to a loaded power system or to one created from scratch. As an illustration, we can initiate the PowerSystem type and then incorporate two buses by utilizing the addBus! function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.034907, base = 345e3)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this case, we have created two buses where the active power demanded by the consumer at Bus 1 is specified in per-units, which are the same units used to store electrical quantities:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In addition, it is worth noting that the base keyword is used to specify the base voltages, and its default input unit is in volts (V).","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, we set the bus voltage angle in radians for the Bus 2 to its initial value:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.voltage.angle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nWe recommend reading the documentation for the addBus! function, where we have provided a list of all the keywords that can be used.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-for-Keywords","page":"Power System Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Typically, all keywords associated with electrical quantities are expected to be provided in per-units (pu) and radians (rad) by default, with the exception of base voltages, which should be specified in volts (V). However, users can choose to use different units than the default per-units and radians or modify the prefix of the base voltage unit by using macros such as the following:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\n@power(MW, MVAr, pu)\n@voltage(pu, deg, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This practical example showcases the customization approach. For keywords tied to active powers, the unit is set as megawatts (MW), while reactive powers employ megavolt-amperes reactive (MVAr). Apparent power, on the other hand, employs per-units (pu). As for keywords concerning voltage magnitude, per-units (pu) remain the choice, but voltage angle mandates degrees (deg). Lastly, the input unit for base voltage is elected to be kilovolts (kV). This unit configuration will be applied throughout subsequent function calls after the unit definitions are established.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Now we can create identical two buses as before using new system of units as follows:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 10.0, base = 345.0)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -2.0, base = 345.0)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As can be observed, electrical quantities will continue to be stored in per-units and radians format:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.bus.demand.active system.bus.voltage.angle]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The base voltage values will still be stored in volts (V) since we only changed the input unit prefix, and did not modify the internal unit prefix, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To modify the internal unit prefix, the following macro can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, VA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After executing this macro, the base voltage values will be stored in kilovolts (kV):","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBranchManual","page":"Power System Model","title":"Add Branch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After adding buses with unique labels, we can define branches between them. The branch cannot be added unless the buses are already defined, and the from and to keywords should correspond to the already defined bus labels. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit)  # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.2)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Here, we created the branch from Bus 1 to Bus 2 with following parameter:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to consult the documentation for the addBranch! function, where we have provided a list of all the keywords that can be used.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-for-Keywords-2","page":"Power System Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To use units other than per-units (pu) and radians (rad), macros can be employed to change the input units. For example, if the need arises to use ohms (Ω), the macros below can be employed:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@parameter(Ω, pu)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.2)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 22.8528)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Still, all electrical quantities are stored in per-units, and the same branch as before is created, as shown in the following output:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is important to note that, when working with impedance and admittance values in ohms (Ω) and siemens (S) that are related to a transformer, the assignment must be based on the primary side of the transformer.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddGeneratorManual","page":"Power System Model","title":"Add Generator","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After defining the buses, generators can be added to the power system. Each generator must have a unique label, and the bus keyword should correspond to the unique label of the bus it is connected to. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\", active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the above code, we add the generator to the Bus 2, with active and reactive power outputs set to:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.generator.output.active system.generator.output.reactive]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similar to buses and branches, the input units can be changed to units other than per-units using different macros.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to refer to the documentation for the addGenerator! function, where we have provided a list of all the keywords that can be used.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#LabelsManual","page":"Power System Model","title":"Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As we shown above, JuliaGrid mandates a distinctive label for every bus, branch, or generator. These labels are stored in dictionaries, functioning as pairs of strings and integers. The string signifies the exclusive label for the specific component, whereas the integer maintains an internal numbering of buses, branches, or generators.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In contrast to the simple labeling approach, JuliaGrid offers two additional methods for labeling. The choice of method depends on the specific needs and can potentially be more straightforward.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Integer-Based-Labeling","page":"Power System Model","title":"Integer-Based Labeling","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"If users prefer to utilize integers as labels in various functions, this is acceptable. However, it is important to note that despite using integers, these labels are still stored as strings. Let us take a look at the following illustration:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1)\naddBus!(system; label = 2, type = 1, angle = -0.2)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)\n\naddGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we create two buses labelled as 1 and 2. The branch is established between these two buses with a unique branch label of 1. Finally, the generator is connected to the bus labelled 2 and has its distinct label set to 1.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Automated-Labeling","page":"Power System Model","title":"Automated Labeling","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Users also possess the option to omit the label keyword, allowing JuliaGrid to independently allocate unique labels for buses, branches, or generators. In such instances, JuliaGrid employs an ordered set of incremental integers for labeling components. To illustrate, consider the subsequent example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; type = 3, active = 0.1)\naddBus!(system; type = 1, angle = -0.2)\n\naddBranch!(system; from = 1, to = 2, reactance = 0.12)\n\naddGenerator!(system; bus = 2, active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This example presents the same power system as the previous one. In the previous example, we used an ordered set of increasing integers for labels, which aligns with JuliaGrid's automatic labeling behaviour when the label keyword is omitted.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Retrieving-Labels","page":"Power System Model","title":"Retrieving Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, we will outline how users can retrieve stored labels. Let us consider the following power system creation:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 3\")\n\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 1\", reactance = 0.8)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.5)\n\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 1\")\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 3\")\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For instance, the bus labels can be accessed using the variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid utilizes an unordered dictionary format for storing labels, which enhances performance. If the objective is to obtain labels in the same order as the bus definitions sequence, the subsequent code can be employed:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"label = collect(keys(sort(system.bus.label; byvalue = true)))","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Subsequently, users can match these labels with bus voltages, powers, and currents associated with buses. These values can be computed through various analyses available in JuliaGrid.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This approach can also be extended to branch and generator labels by making use of the variables present within the PowerSystem composite type, namely system.branch.label or system.generator.label. These variables facilitate obtaining sequences of labels associated with these particular components of the power system.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Moreover, the from and to keywords associated with branches are stored based on internally assigned numerical values linked to bus labels. These values are stored in the variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.branch.layout.from system.branch.layout.to]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To recover the original from and to labels, you can utilize the following method:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[label[system.branch.layout.from] label[system.branch.layout.to]]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, the bus keywords related to generators are saved based on internally assigned numerical values corresponding to bus labels and can be accessed using:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.layout.bus","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To recover the original bus labels, you can utilize the following method:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"label[system.generator.layout.bus]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nJuliaGrid offers the capability to print labels alongside various types of data, such as power system parameters, voltages, powers, currents, or constraints used in optimal power flow analyses. For instance, users can use the following code to print labels in combination with specific data:print(system.branch.label, system.branch.parameter.reactance)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddTemplatesManual","page":"Power System Model","title":"Add Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The functions addBus!, addBranch!, and addGenerator! are used to add bus, branch, and generator to the power system, respectively. If certain keywords are not specified, default values are assigned to some parameters.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Default-Keyword-Values","page":"Power System Model","title":"Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Regarding the addBus! function, the bus type is automatically configured as a demand bus with type = 1. The initial bus voltage magnitude is set to magnitude = 1.0 per-unit, while the base voltage is established as base = 138e3 volts. These predefined values are crucial to prevent potential issues during algorithm execution, particularly to avoid encountering a singular Jacobian when magnitude = 0.0. Additionally, the minimum and maximum bus voltage magnitudes are set to minMagnitude = 0.9 per-unit and maxMagnitude = 1.1 per-unit, respectively.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Transitioning to the addBranch! function, the default operational status is status = 1, indicating that the branch is in-service. Additionally, the off-nominal turns ratio for the transformer is specified as turnsRatio = 1.0, and the phase shift angle is set to shiftAngle = 0.0, collectively defining the line configuration with these standard settings. The flow rating is also configured as type = 1. Moreover, the minimum and maximum voltage angle differences between the \"from\" and \"to\" buses are set to minDiffAngle = -2pi and maxDiffAngle = 2pi, respectively.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, the addGenerator! function designates an operational generator by employing status = 1, and it sets magnitude = 1.0 per-unit, denoting the desired voltage magnitude setpoint.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The remaining parameters are initialized with default values of zero.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Default-Keyword-Values","page":"Power System Model","title":"Change Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In JuliaGrid, users have the flexibility to adjust default values and assign customized values using the @bus, @branch, and @generator macros. These macros create bus, branch, and generator templates that are used every time the addBus!, addBranch!, and addGenerator! functions are called. For instance, the code block shows an example of creating bus, branch, and generator templates with customized default values:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 0.1)\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.5)\n\n@branch(reactance = 0.12)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\")\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.06)\n\n@generator(magnitude = 1.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 50)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 1\", active = 20)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This code example involves two uses of the addBus! and addBranch! functions. In the first use, the functions rely on the default values set by the templates created with the @bus and @branch macros. In contrast, the second use passes specific values that match the keywords used in the templates. As a result, the templates are ignored:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.layout.type\n[system.bus.demand.active system.branch.parameter.reactance]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the given example, the @generator macro is utilized instead of repeatedly specifying the magnitude keyword in the addGenerator! function. This macro creates a generator template with a default value for magnitude, which is automatically applied every time the addGenerator! function is called. Therefore, it eliminates the requirement to set the magnitude value for each individual generator:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.voltage.magnitude","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-for-Keywords-3","page":"Power System Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid requires users to specify electrical quantity-related keywords in per-units (pu) and radians (rad) by default. However, it provides macros, such as @power, that allow users to specify other units:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\n@power(MW, MVAr, MVA)\n\n@bus(active = 100, reactive = 200)\naddBus!(system; label = \"Bus 1\")\n\n@power(pu, pu, pu)\n\naddBus!(system; label = \"Bus 2\", active = 0.5)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we create the bus template and one bus using SI power units, and then we switch to per-units and add the second bus. It is important to note that once the template is defined in any unit system, it remains valid regardless of subsequent unit system changes. The resulting power values are:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.bus.demand.active system.bus.demand.reactive]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Thus, JuliaGrid automatically tracks the unit system used to create templates and provides the appropriate conversion to per-units and radians. Even if the user switches to a different unit system later on, the previously defined template will still be valid.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Multiple-Templates","page":"Power System Model","title":"Multiple Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the case of calling the @bus, @branch, or @generator macros multiple times, the provided keywords and values will be combined into a single template for the corresponding component (bus, branch, or generator), which will be used for generating the component.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Reset-Templates","page":"Power System Model","title":"Reset Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To reset the bus, branch, and generator templates to their default settings, users can utilize the following macros:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(bus)\n@default(branch)\n@default(generator)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, users can reset all templates for the bus, branch, and generator components using the macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(template)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ACDCModelManual","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"When we constructed the power system, we can create an AC and/or DC model, which include vectors and matrices related to the power system's topology and parameters. The following code snippet demonstrates this:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05)\naddBus!(system; label = \"Bus 3\", type = 1, susceptance = 0.05)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.008, reactance = 0.05)\n\nacModel!(system)\ndcModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIn all instances documented, we explicitly refer to these functions by their names, although it is not obligatory. If a user initiates any of the various AC or DC analyses without having previously created the AC or DC model using the acModel! or dcModel! function, the relevant function for setting the analysis will automatically generate the AC or DC model.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The nodal matrices are one of the components of both the AC and DC models and are stored in the variables:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix\nsystem.model.dc.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nThe AC model is used for performing AC power flow, AC optimal power flow, nonlinear state estimation, or state estimation with PMUs, whereas the DC model is essential for various DC or linear analyses. Consequently, once these models are developed, they can be applied to various types of simulations. We recommend that the reader refer to the tutorial on AC and DC models.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#New-Branch-Triggers-Model-Update","page":"Power System Model","title":"New Branch Triggers Model Update","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can execute the acModel! and dcModel! functions after defining the final number of buses, and each new branch added will trigger an update of the AC and DC vectors and matrices. Here is an example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05)\naddBus!(system; label = \"Bus 3\", type = 1, susceptance = 0.05)\n\nacModel!(system)\ndcModel!(system)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.008, reactance = 0.05)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, the nodal matrix in the DC framework has the same values as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.dc.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIt is not fully recommended to create AC and DC models before adding a large number of branches if the execution time of functions is important. Instead, triggering updates to the AC and DC models using the addBranch! function is useful for power systems that require the addition of several branches. This update avoids the need to recreate vectors and matrices from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#New-Bus-Triggers-Model-Erasure","page":"Power System Model","title":"New Bus Triggers Model Erasure","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The AC and DC models must be defined when a finite number of buses are defined, otherwise, adding a new bus will delete them. For example, if we attempt to add a new bus to the PowerSystem type that was previously created, the current AC and DC models will be completely erased:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!(system; label = \"Bus 4\", type = 2)\nsystem.model.ac.nodalMatrix\nsystem.model.dc.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#UpdateBusManual","page":"Power System Model","title":"Update Bus","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once a bus has been added to the PowerSystem composite type, users have the flexibility to modify all parameters defined within the addBus! function. This means that the updateBus! function not only updates the PowerSystem type but also, if AC and DC models have been created, automatically updates these models. This eliminates the need to recreate the AC and DC models from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To illustrate, let us consider the following power system:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, conductance = 0.01)\naddBus!(system; label = \"Bus 2\", type = 2, reactive = 0.05)\naddBus!(system; label = \"Bus 3\", type = 1, susceptance = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.05)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 1\", active = 0.2)\n\nacModel!(system)\ndcModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For instance, the nodal matrix in the AC framework has the following form:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Now, let us add a shunt element to Bus 2:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateBus!(system; label = \"Bus 2\", conductance = 0.4, susceptance = 0.5)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As we can observe, executing the function triggers an update of the AC nodal matrix:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#UpdateBranchManual","page":"Power System Model","title":"Update Branch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly to updating buses, once a branch has been added to the PowerSystem composite type, users have the freedom to modify all parameters defined within the addBranch! function. This means that the updateBranch! function not only updates the PowerSystem type but also, if AC and DC models have been created, automatically updates these models.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To illustrate, let us continue with the previous example and modify the parameters of Branch 1 as follows:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateBranch!(system; label = \"Branch 1\", resistance = 0.012, reactance = 0.3)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can observe the update in the AC nodal matrix:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Next, let us switch the status of Branch 2 from in-service to out-of-service:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateBranch!(system; label = \"Branch 2\", status = 0)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As before, the updated AC nodal matrix takes the following form:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Drop-Zeros","page":"Power System Model","title":"Drop Zeros","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After the last execution of the updateBranch! function, the nodal matrices will contain zeros, as demonstrated in the code example. If needed, the user can remove these zeros using the dropzeros! function, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using SparseArrays\ndropzeros!(system.model.ac.nodalMatrix)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt should be noted that in simulations conducted with the JuliaGrid package, the accuracy of the results will not be affected by leaving zeros.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#UpdateGeneratorManual","page":"Power System Model","title":"Update Generator","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, users can update all generator parameters defined within the addGenerator! function using the updateGenerator! function. The execution of this function will affect all variables within the PowerSystem type. To put it succinctly, in addition to the generator field, JuliaGrid also retains variables associated with generators within the bus field. As an illustration, let us examine one of these variables and its values derived from a previous example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.supply.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Next, we will change the active output power of Generator 1:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateGenerator!(system; label = \"Generator 1\", active = 0.9)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As we can see, executing the function triggers an update of the observed variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.supply.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Hence, this function ensures the adjustment of generator parameters and updates all fields of the PowerSystem composite type affected by them.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddUpdateCostsManual","page":"Power System Model","title":"Add and Update Costs","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The cost! function is responsible for adding and updating costs associated with the active or reactive power produced by the corresponding generator. These costs are added only if the corresponding generator is defined.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To start, let us create an example of a power system using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\")\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Polynomial-Cost","page":"Power System Model","title":"Polynomial Cost","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Let us define a quadratic polynomial cost function for the active power produced by the Generator 1 using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"cost!(system; label = \"Generator 1\", active = 2, polynomial = [1100.0; 500.0; 150.0])","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In essence, what we have accomplished is the establishment of a cost function depicted as f(P_textg1) = 1100 P_textg1^2 + 500 P_textg1 + 150 through the code provided. In general, when constructing a polynomial cost function, the coefficients must be ordered from the highest degree to the lowest.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As previously, the default input units are related with per-units (pu), and the coefficients of the cost function have units of currency/pu²hr for 1100, currency/puhr for 500, and currency/hr for 150. Hence, the coefficients are stored exactly as entered:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.polynomial","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"By setting active = 2 within the function, we express our intent to specify the active power cost using the active key. By using a value of 2, we signify our preference for employing a quadratic polynomial cost model for the associated generator. This flexibility proves invaluable when we have previously defined a piecewise linear cost function for the same generator. In such cases, we can set active = 1 to utilize the piecewise linear cost function to represent the cost of the corresponding generators. Thus, we retain the freedom to choose between these two cost functions according to the requirements of our simulation. Additionally, users have the option to define both piecewise and polynomial costs within a single function call, further enhancing the versatility of the implementation.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Piecewise-Linear-Cost","page":"Power System Model","title":"Piecewise Linear Cost","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can also create a piecewise linear cost function, for example, let us create the reactive power cost function for the same generator using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"cost!(system; label = \"Generator 1\", reactive = 1, piecewise = [0.11 12.3; 0.15 16.8])\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this case, the first column specifies the output reactive powers of the generator in per-units, while the second column specifies the corresponding costs for the specified reactive power in currency/hr. Thus, the data is stored exactly as entered:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.reactive.piecewise","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-for-Keywords-4","page":"Power System Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Changing input units from per-units (pu) can be particularly useful since cost functions are usually related to SI units of powers. To demonstrate this, let us set active powers in megawatts (MW) and reactive powers in megavolt-amperes reactive (MVAr) :","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@power(MW, MVAr, pu)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Now, we can add the quadratic polynomial function using megawatts:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"cost!(system; label = \"Generator 1\", active = 2, polynomial = [0.11; 5.0; 150.0])","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After inspecting the resulting cost data, we can see that it is the same as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.polynomial","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, we can define the linear piecewise cost using megavolt-amperes reactive:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"cost!(system; label = \"Generator 1\", reactive = 1, piecewise = [11.0 12.3; 15.0 16.8])\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon inspection, we can see that the stored data is the same as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.reactive.piecewise","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nThe cost! function not only adds costs but also allows users to update previously defined cost functions. This functionality is particularly valuable in optimal power flow analyses, as it allows users to modify generator power costs without the need to recreate models from scratch.","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimalPowerFlowManual","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similar to AC Optimal Power Flow, JuliaGrid utilizes the JuMP package to construct optimal power flow models, enabling users to manipulate these models using the standard functions provided by JuMP. JuliaGrid supports popular solvers mentioned in the JuMP documentation to solve the optimization problem.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To perform the DC optimal power flow, you first need to have the PowerSystem composite type that has been created with the dc model. After that, create the DCOptimalPowerFlow composite type to establish the DC optimal power flow framework using the function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"dcOptimalPowerFlow.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To solve the DC optimal power flow problem and acquire bus voltage angles and generator active power outputs, make use of the following function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"solve!.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After obtaining the solution for DC optimal power flow, JuliaGrid offers a post-processing analysis function to compute powers associated with buses and branches:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"power!.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Additionally, there are specialized functions dedicated to calculating specific types of active powers related to particular buses or branches:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"injectionPower,\nsupplyPower,\nfromPower,\ntoPower.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimalPowerFlowModelManual","page":"DC Optimal Power Flow","title":"Optimal Power Flow Model","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To set up the DC optimal power flow, we begin by creating the model. To illustrate this, consider the following example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, HiGHS\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, angle = 0.17)\naddBus!(system; label = \"Bus 2\", active = 0.1, conductance = 0.04)\naddBus!(system; label = \"Bus 3\", active = 0.05)\n\n@branch(minDiffAngle = -3.1, maxDiffAngle = 3.1, longTerm = 0.12)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\n@generator(minActive = 0.0)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.6, maxActive = 0.8)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.1, maxActive = 0.3)\naddGenerator!(system; label = \"Generator 3\", bus = \"Bus 2\", active = 0.2, maxActive = 0.4)\n\ncost!(system; label = \"Generator 1\", active = 2, polynomial = [1100.2; 500; 80])\ncost!(system; label = \"Generator 2\", active = 1, piecewise = [8.0 11.0; 14.0 17.0])\ncost!(system; label = \"Generator 3\", active = 1, piecewise = [6.8 12.3; 8.7 16.8; 11.2 19.8])\n\ndcModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, the dcOptimalPowerFlow function is utilized to formulate the DC optimal power flow problem:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\n\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimizationVariablesManual","page":"DC Optimal Power Flow","title":"Optimization Variables","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the DC optimal power flow, the active power outputs of the generators are represented as linear functions of the bus voltage angles. Therefore, the variables in this model are the active power outputs of the generators and the bus voltage angles:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.all_variables(analysis.jump)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Furthermore, it is important to highlight that when dealing with linear piecewise cost functions comprising multiple segments, as exemplified in the case of Generator 3, JuliaGrid automatically generates helper optimization variables, such as actwise[3], and formulates a set of linear constraints to appropriately handle these cost functions. However, in instances where a linear piecewise cost function consists of only a single segment, as demonstrated by Generator 2, the function is modelled as a standard linear function, eliminating the necessity for additional helper optimization variables.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Please note that JuliaGrid keeps references to all variables categorized into three fields:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"fieldnames(typeof(analysis.variable))","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Add-Variables","page":"DC Optimal Power Flow","title":"Add Variables","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The user has the ability to easily add new variables to the defined DC optimal power flow model by using the @variable macro from the JuMP package. Here is an example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.@variable(analysis.jump, newVariable)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We can verify that the new variable is included in the defined model by using the function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.is_valid(analysis.jump, newVariable)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Delete-Variables","page":"DC Optimal Power Flow","title":"Delete Variables","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To delete a variable, the delete function from the JuMP package can be used:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.delete(analysis.jump, newVariable)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After deletion, the variable is no longer part of the model:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.is_valid(analysis.jump, newVariable)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCConstraintFunctionsManual","page":"DC Optimal Power Flow","title":"Constraint Functions","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuliGrid keeps track of all the references to internally formed constraints in the constraint field of the DCOptimalPowerFlow composite type. These constraints are divided into six fields:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"fieldnames(typeof(analysis.constraint))","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nWe recommend that readers refer to the tutorial on DC Optimal Power Flow for insights into the implementation.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Slack-Bus-Constraint","page":"DC Optimal Power Flow","title":"Slack Bus Constraint","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The slack field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the addBus! function using the angle keyword:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.slack.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users have the flexibility to modify this constraint by changing which bus serves as the slack bus and by adjusting the value of the bus angle. This can be achieved using the updateBus! function, for example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBus!(system, analysis; label = \"Bus 1\", angle = -0.1)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Subsequently, the updated slack constraint can be inspected as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.slack.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Balance-Constraints","page":"DC Optimal Power Flow","title":"Active Power Balance Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The balance field contains references to the equality constraints associated with the active power balance equations defined for each bus. The constant terms in these equations are determined by the active and conductance keywords within the addBus! function. Additionally, if there are phase shift transformers in the system, the constant terms can also be affected by the shiftAngle keyword within the addBranch! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.balance.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"During the execution of functions that add or update power system components, these constraints are automatically adjusted to reflect the current configuration of the power system. An example of this adaptability is demonstrated below:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBus!(system, analysis; label = \"Bus 3\", active = 0.1)\nupdateGenerator!(system, analysis; label = \"Generator 2\", status = 0)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Subsequently, the updated set of active power balance constraints can be examined as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.balance.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Voltage-Angle-Difference-Constraints","page":"DC Optimal Power Flow","title":"Voltage Angle Difference Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The voltage field contains references to the inequality constraints associated with the minimum and maximum bus voltage angle difference between the \"from\" and \"to\" bus ends of each branch. These values are specified using the minDiffAngle and maxDiffAngle keywords within the addBranch! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Please note that if the limit constraints are set to minDiffAngle = -2π and maxDiffAngle = 2π for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Additionally, by employing the updateBranch! function, you have the ability to modify these specific constraints as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBranch!(system, analysis; label = \"Branch 1\", minDiffAngle = -1.7, maxDiffAngle = 1.7)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Subsequently, the updated set of voltage angle difference constraints can be examined as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Flow-Constraints","page":"DC Optimal Power Flow","title":"Active Power Flow Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The flow field contains references to the inequality constraints associated with the active power flow limits at the \"from\" and \"to\" bus ends of each branch. These limits are specified using the longTerm keyword within the addBranch! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.flow.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Please note that if the limit constraints are set to longTerm = 0.0 for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Additionally, by employing the updateBranch! function, you have the ability to modify these specific constraints, for example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBranch!(system, analysis; label = \"Branch 1\", status = 0)\nupdateBranch!(system, analysis; label = \"Branch 2\", reactance = 0.03, longTerm = 0.14)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Subsequently, the updated set of active power flow constraints can be examined as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.flow.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Capability-Constraints","page":"DC Optimal Power Flow","title":"Active Power Capability Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The capability field contains references to the inequality constraints associated with the minimum and maximum active power outputs of the generators. These limits are specified using the minActive and maxActive keywords within the addGenerator! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.constraint.capability.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As demonstrated, the active power output of Generator 2 is currently fixed at zero due to the earlier action of setting this generator out-of-service. Consequently, you can adjust these specific constraints using the updateGenerator! function, for example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateGenerator!(system, analysis; label = \"Generator 2\", status = 1, maxActive = 0.5)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Subsequently, the updated set of active power capability constraints can be examined as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.constraint.capability.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"It is important to note that by bringing back Generator 2 into service, it will also have an impact on the balance constraint, which will once again be influenced by the generator's output.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Piecewise-Constraints","page":"DC Optimal Power Flow","title":"Active Power Piecewise Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the context of active power modelling, the piecewise field serves as a reference to the inequality constraints related to linear piecewise cost functions. These constraints are created using the cost! function with active = 1 specified when dealing with linear piecewise cost functions comprising multiple segments. JuliaGrid takes care of establishing the appropriate inequality constraints for each segment of the linear piecewise cost:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.constraint.piecewise.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"It is worth noting that these constraints can also be automatically updated using the cost! function, and readers can find more details in the section about the objective function.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Add-Constraints","page":"DC Optimal Power Flow","title":"Add Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users can effortlessly introduce additional constraints into the defined DC optimal power flow model by utilizing the addBranch! or addGenerator! functions. Specifically, if a user wishes to include a new branch or generator in an already defined PowerSystem and DCOptimalPowerFlow type, using these functions will automatically add and update all constraints:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"addBranch!(system, analysis; label = \"Branch 4\", from = \"Bus 1\", to = \"Bus 2\", reactance = 1)\naddGenerator!(system, analysis; label = \"Generator 4\", bus = \"Bus 1\", maxActive = 0.2)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As a result, the flow and capability constraints will be adjusted as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.flow.active)\nprint(system.generator.label, analysis.constraint.capability.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Add-User-Defined-Constraints","page":"DC Optimal Power Flow","title":"Add User-Defined Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users also have the option to include their custom constraints within the established DC optimal power flow model by employing the @constraint macro. For example, the addition of a new constraint can be achieved as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.@constraint(analysis.jump, 0.0 <= analysis.variable.active[4] <= 0.3)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Delete-Constraints","page":"DC Optimal Power Flow","title":"Delete Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To delete a constraint, users can make use of the delete function from the JuMP package. When handling constraints that have been internally created, users can refer to the constraint references stored in the constraint field of the DCOptimalPowerFlow type.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"For example, if the intention is to eliminate constraints related to the capability of Generator 4, the following code snippet can be employed:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.delete(analysis.jump, analysis.constraint.capability.active[4])\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nIn the event that a user deletes a constraint and subsequently executes a function that updates bus, branch, or generator parameters, and if the deleted constraint is affected by these functions, JuliaGrid will automatically reinstate that constraint. Users should exercise caution when deleting constraints, as this action is considered potentially harmful since it operates independently of power system data.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCObjectiveFunctionManual","page":"DC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The objective function of the DC optimal power flow is constructed using polynomial and linear piecewise cost functions of the generators, which are defined using the cost! functions. It is important to note that only polynomial cost functions up to the second degree are included in the objective. If there are polynomials of higher degrees, JuliaGrid will exclude them from the objective function.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the provided example, the objective function that needs to be minimized to obtain the optimal values of the active power outputs of the generators and the bus voltage angles is as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.objective_function(analysis.jump)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Additionally, JuliaGrid stores the objective function in a separate variable, allowing users to access it by referencing the variable analysis.objective.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Update-Objective-Function","page":"DC Optimal Power Flow","title":"Update Objective Function","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"By utilizing the cost! functions, users have the flexibility to modify the objective function by adjusting polynomial or linear piecewise cost coefficients or by changing the type of polynomial or linear piecewise function employed. For instance, consider Generator 3, which incorporates a piecewise cost structure with two segments. Now, we can define a polynomial function for this generator and activate it by specifying the keyword active = 2 as shown:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"cost!(system, analysis; label = \"Generator 3\", active = 2, polynomial = [853.4; 257; 40])","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"This results in the updated objective function, which can be observed as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"analysis.objective","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#User-Defined-Objective-Function","page":"DC Optimal Power Flow","title":"User-Defined Objective Function","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users can modify the objective function using the set_objective_function function from the JuMP package. This operation is considered destructive because it is independent of power system data; however, in certain scenarios, it may be more straightforward than using the cost! function for updates. Moreover, using this methodology, users can combine a defined function with a newly defined expression. Here is an example of how it can be achieved:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"expr = 100.2 * analysis.variable.active[1] * analysis.variable.active[1] + 123\nJuMP.set_objective_function(analysis.jump, analysis.objective - expr)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"You can now observe the updated objective function as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.objective_function(analysis.jump)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#SetupStartingPrimalValuesManual","page":"DC Optimal Power Flow","title":"Setup Starting Primal Values","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In JuliaGrid, the assignment of starting primal values for optimization variables takes place when the solve! function is executed. Starting primal values are determined based on the generator and voltage fields within the DCOptimalPowerFlow type. By default, these values are initially established using the active power outputs of the generators and the initial bus voltage angles:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.power.generator.active)\nprint(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"You have the flexibility to adjust these values to your specifications, and they will be utilized as the starting primal values when you run the solve! function.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Using-DC-Power-Flow","page":"DC Optimal Power Flow","title":"Using DC Power Flow","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In this perspective, users have the capability to conduct the DC power flow analysis and leverage the resulting solution to configure starting primal values. Here is an illustration of how this can be achieved:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"flow = dcPowerFlow(system)\nsolve!(system, flow)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After obtaining the solution, we can calculate the active power outputs of the generators and utilize the bus voltage angles to set the starting values. In this case, the generator and voltage fields of the DCOptimalPowerFlow type can be employed to store the new starting values:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"for (key, value) in system.generator.label\n    analysis.power.generator.active[value] = generatorPower(system, flow; label = key)\nend\n\nfor i = 1:system.bus.number\n    analysis.voltage.angle[i] = flow.voltage.angle[i]\nend","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Using-DC-Optimal-Power-Flow","page":"DC Optimal Power Flow","title":"Using DC Optimal Power Flow","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Performing repeated executions of the DC optimal power flow problem, and opting to reuse the existing DCOptimalPowerFlow type without generating a new instance offers the benefit of a \"warm start\". In such a situation, the initial primal values for the subsequent solving step align with the solution achieved in the prior step. Additional information can be found in the section dedicated to Reusing Optimal Power Flow Model.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimalPowerFlowSolutionManual","page":"DC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To establish the DC optimal power flow problem, you can utilize the dcOptimalPowerFlow function. After setting up the problem, you can use the solve! function to compute the optimal values for the active power outputs of the generators and the bus voltage angles. Also, to turn off the solver output within the REPL, we use the set_silent function before calling solve! function. Here is an example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.set_silent(analysis.jump)\nsolve!(system, analysis)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"By executing this function, you will obtain the solution with the optimal values for the active power outputs of the generators and the bus voltage angles:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.power.generator.active)\nprint(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Objective-Value","page":"DC Optimal Power Flow","title":"Objective Value","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To obtain the objective value of the optimal power flow solution, you can use the objective_value function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.objective_value(analysis.jump)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimalPowerAnalysisManual","page":"DC Optimal Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches using the power! function. For instance, let us consider the power system for which we obtained the DC optimal power flow solution:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, HiGHS\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, angle = 0.17)\naddBus!(system; label = \"Bus 2\", active = 0.1, conductance = 0.04)\naddBus!(system; label = \"Bus 3\", active = 0.05)\n\n@branch(minDiffAngle = -pi, maxDiffAngle = pi, longTerm = 0.12)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\n@generator(minActive = 0.0)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2, maxActive = 0.5)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.2, maxActive = 0.2)\n\ncost!(system; label = \"Generator 1\", active = 2, polynomial = [1100.2; 500; 80])\ncost!(system; label = \"Generator 2\", active = 1, piecewise = [10.8 12.3; 14.7 16.8])\n\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nJuMP.set_silent(analysis.jump) # hide\nsolve!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Now we can calculate the active powers using the following function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"power!(system, analysis)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Finally, to display the active power injections at each bus and active power flows at each \"from\" bus end of the branch, we can use the following code:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.power.injection.active)\nprint(system.branch.label, analysis.power.from.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nTo better understand the powers associated with buses and branches that are calculated by the power! function, we suggest referring to the tutorials on DC Optimal Power Flow.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To compute specific quantities for particular components, rather than calculating powers or currents for all components, users can utilize one of the provided functions below.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Injection","page":"DC Optimal Power Flow","title":"Active Power Injection","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To calculate active power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"active = injectionPower(system, analysis; label = \"Bus 2\")","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Injection-from-Generators","page":"DC Optimal Power Flow","title":"Active Power Injection from Generators","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To calculate active power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"active = supplyPower(system, analysis; label = \"Bus 2\")","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Flow","page":"DC Optimal Power Flow","title":"Active Power Flow","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similarly, we can compute the active power flow at both the \"from\" and \"to\" bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"active = fromPower(system, analysis; label = \"Branch 2\")\nactive = toPower(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimalReusingPowerSystemModelManual","page":"DC Optimal Power Flow","title":"Reusing Power System Model","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similar to what we discussed in the section Reusing Power System Model concerning DC power flow, the PowerSystem composite type, along with its previously established dc field, offers remarkable versatility. This versatility extends to the use of the PowerSystem type in various DC analyses. As demonstrated when we employ initial conditions from DC power flow for DC optimal power flow, the PowerSystem type seamlessly integrates across different analysis types.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Furthermore, all fields within the PowerSystem type automatically adjust when any of the functions responsible for adding components or modifying their parameters are used. These functions encompass:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"addBranch!,\naddGenerator!,\nupdateBus!,\nupdateBranch!,\nupdateGenerator!.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"This implies that users have the flexibility to add or update parameters after creating the PowerSystem composite type. Subsequently, they can utilize dcOptimalPowerFlow to establish a DC optimal power flow model. However, as consistently emphasized throughout this manual, it is significantly more advantageous to reuse the optimal power flow model instead.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCReusingOptimalPowerFlowModelManual","page":"DC Optimal Power Flow","title":"Reusing Optimal Power Flow Model","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Efficiently modelling and solving large-scale power systems requires reusing the DCOptimalPowerFlow type, avoiding the need to run dcOptimalPowerFlow. Constructing an optimal power flow model can be time-consuming, especially for large systems. By creating the DCOptimalPowerFlow composite type once, users can easily adapt it to changes in the power system's structure, saving computational resources and time. This simplifies dynamic power system modifications without recreating the entire optimization model.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As demonstrated in this manual, this is achieved by using the DCOptimalPowerFlow type as an argument in functions that add or update components within the PowerSystem composite type. If these changes are valid and provide accurate solutions, these functions will automatically adjust the composite types, ensuring smooth integration for dynamic power system adjustments while maintaining the integrity of the DC optimal power flow analysis.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Starting-Primal-Values","page":"DC Optimal Power Flow","title":"Starting Primal Values","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Utilizing the DCOptimalPowerFlow type and proceeding directly to the solver offers the advantage of a \"warm start\". In this scenario, the starting primal values for the subsequent solving step correspond to the solution obtained from the previous step.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the previous example, we obtained the following solution:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.power.generator.active)\nprint(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Now, let us introduce changes to the power system from the previous example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateGenerator!(system, analysis; label = \"Generator 2\", maxActive = 0.08)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, solve this new power system. During the execution of the solve! function, the primal starting values will first be set, and these values will be defined according to the values given above.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"solve!(system, analysis)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As a result, we obtain a new solution:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.power.generator.active)\nprint(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users retain the flexibility to reset these initial primal values to their default configurations at any juncture. This can be accomplished by utilizing the active power outputs of the generators and the initial bus voltage angles extracted from the PowerSystem composite type, employing the startingPrimal! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"startingPrimal!(system, analysis)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"These values are precisely identical to what we would obtain if we executed the dcOptimalPowerFlow function following all the updates we performed:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.power.generator.active)\nprint(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"api/configuration/#configurationSetupAPI","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"For further information on this topic, please see the Power System Model section of the Manual.","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Base-Unit-Prefixes","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#Input-Unit-System","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@current\n@parameter","category":"page"},{"location":"api/configuration/#Default-Settings","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Base-Unit-Prefixes-2","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#JuliaGrid.@base","page":"Configuration Setup","title":"JuliaGrid.@base","text":"@base(system::PowerSystem, power, voltage)\n\nBy default, the units for base power and base voltages are set to volt-ampere (VA) and volt (V), but you can modify the prefixes using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of power (VA) or unit of voltage (V). Keep in mind that the macro must be used after creating the composite type PowerSystem.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n@base(system, MVA, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Input-Unit-System-2","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@current\n@parameter","category":"page"},{"location":"api/configuration/#JuliaGrid.@power","page":"Configuration Setup","title":"JuliaGrid.@power","text":"@power(active, reactive, apparent)\n\nJuliaGrid stores all data related with powers in per-units, and these cannot be altered. However, the power units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of active power (W), reactive power (VAr), or apparent power (VA). Also it is a possible to combine SI units with/without prefixes with per-units (pu).\n\nChanging the unit of active power is reflected in the following quantities:\n\naddBranch! if type = 2: longTerm, shortTerm, emergency;\naddGenerator!: active, minActive, maxActive, lowActive, upActive, loadFollowing, reserve10min, reserve30min;\nupdateBus!: active, conductance;\nupdateGenerator!: active;\ncost! if cost = :active: piecewise, polynomial.\n\nChanging the unit of reactive power unit is reflected in the following quantities:\n\naddBus!: reactive, susceptance;\naddGenerator!: reactive, minReactive, maxReactive, minLowReactive, maxLowReactive, minUpReactive, maxUpReactive, reactiveTimescale,\nupdateBus!: susceptance;\nupdateGenerator!: reactive;\ncost! if cost = :reactive: piecewise, polynomial.\n\nChanging the unit of apparent power unit is reflected in the following quantities:\n\naddBranch! if type = 1 or type = 3: longTerm, shortTerm, emergency.\n\nExample\n\n@power(MW, kVAr, VA)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@voltage","page":"Configuration Setup","title":"JuliaGrid.@voltage","text":"@voltage(magnitude, angle, base)\n\nJuliaGrid stores all data related with voltages in per-units and radians, and these cannot be altered. However, the voltage magnitude and angle units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nThe prefixes must adhere to the SI prefixes and should be specified along with the unit of voltage, either magnitude (V) or base (V). Alternatively, the unit of voltage magnitude can be expressed in per-unit (pu). The unit of voltage angle should be in radians (rad) or degrees (deg).\n\nChanging the unit of voltage magnitude is reflected in the following quantities:\n\naddBus!: magnitude, minMagnitude, maxMagnitude;\naddGenerator!: magnitude.\n\nChanging the unit of voltage angle is reflected in the following quantities:\n\naddBus!: angle;\naddBranch!: shiftAngle, minDiffAngle, maxDiffAngle;\nupdateBranch!: shiftAngle.\n\nChanging the unit prefix of voltage base is reflected in the following quantity:\n\naddBus!: base.\n\nExample\n\n@voltage(pu, deg, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@current","page":"Configuration Setup","title":"JuliaGrid.@current","text":"@current(magnitude, angle)\n\nJuliaGrid stores all data related with currents in per-units and radians, and these cannot be altered. However, the current magnitude and angle units of the built-in functions used to add or modified measurement devices can be modified using the macro.\n\nThe prefixes must adhere to the SI prefixes and should be specified along with the unit of current magnitude (V). Alternatively, the unit of current magnitude can be expressed in per-unit (pu). The unit of current angle should be in radians (rad) or degrees (deg).\n\nChanging the unit of current magnitude is reflected in the following quantities:\n\n...\n\nExample\n\n@current(pu, deg)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@parameter","page":"Configuration Setup","title":"JuliaGrid.@parameter","text":"@parameter(impedance, admittance)\n\nJuliaGrid stores all data related with impedances and admittancies in per-units, and these cannot be altered. However, units of impedance and admittance of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of impedance (Ω) or unit of admittance (S). The second option is to define the units in per-unit (pu).\n\nIn the case where impedance and admittance are being used in SI units (Ω and S) and these units are related to the transformer, the assignment must be based on the primary side of the transformer.\n\nChanging the units of impedance is reflected in the following quantities in specific functions:\n\naddBranch!: resistance, reactance;\nupdateBranch!: resistance, reactance.\n\nChanging the units of admittance is reflected in the following quantities:\n\naddBranch!: susceptance;\nupdateBranch!: susceptance.\n\nExample\n\n@parameter(Ω, pu)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Default-Settings-2","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/#JuliaGrid.@default","page":"Configuration Setup","title":"JuliaGrid.@default","text":"The macro is designed to reset various settings to their default values.\n\n@default(mode)\n\nThe mode argument can take on the following values:\n\nunit: resets all units to their default settings;\npower: sets active, reactive, and apparent power to per-units;\nvoltage: sets voltage magnitude to per-unit and voltage angle to radian;\nparameter: sets impedance and admittance to per-units;\ntemplate: resets bus, branch and generator templates to their default settings;\nbus: resets the bus template to its default settings;\nbranch: resets the branch template to its default settings;\ngenerator: resets the generator template to its default settings.\n\nExample\n\n@default(unit)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerFlow/#PowerFlowAPI","page":"Power Flow","title":"Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"For further information on this topic, please see the AC Power Flow or DC Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for power flow analysis.","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-AC-Power-Flow-Model","page":"Power Flow","title":"Build AC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel","category":"page"},{"location":"api/powerFlow/#Solve-AC-Power-Flow","page":"Power Flow","title":"Solve AC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"mismatch!\nsolve!","category":"page"},{"location":"api/powerFlow/#Additional-AC-Functions","page":"Power Flow","title":"Additional AC Functions","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"reactiveLimit!\nadjustAngle! \nstartingVoltage! ","category":"page"},{"location":"api/powerFlow/#Build-DC-Power-Flow-Model","page":"Power Flow","title":"Build DC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"dcPowerFlow","category":"page"},{"location":"api/powerFlow/#Solve-DC-Power-Flow","page":"Power Flow","title":"Solve DC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"solve!","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-AC-Power-Flow-Model-2","page":"Power Flow","title":"Build AC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel","category":"page"},{"location":"api/powerFlow/#JuliaGrid.newtonRaphson","page":"Power Flow","title":"JuliaGrid.newtonRaphson","text":"newtonRaphson(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Newton-Raphson method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the NewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nmethod: contains the Jacobian matrix, power injection mismatches, bus voltage increments, and indices;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonBX","text":"fastNewtonRaphsonBX(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the fast Newton-Raphson method of version BX to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field  within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nmethod: contains Jacobian matrices, power injection mismatches, bus voltage increments, and indices;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonBX(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonXB","text":"fastNewtonRaphsonXB(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the fast Newton-Raphson method of version XB to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nmethod: contains Jacobian matrices, power injection mismatches, bus voltage increments, and indices;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonXB(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.gaussSeidel","page":"Power Flow","title":"JuliaGrid.gaussSeidel","text":"gaussSeidel(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Gauss-Seidel method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the GaussSeidel subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nmethod: contains the bus complex voltages and indices;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = gaussSeidel(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Solve-AC-Power-Flow-2","page":"Power Flow","title":"Solve AC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"mismatch!(::PowerSystem, ::NewtonRaphson)\nsolve!(::PowerSystem, ::NewtonRaphson)","category":"page"},{"location":"api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}","page":"Power Flow","title":"JuliaGrid.mismatch!","text":"mismatch!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function calculates both active and reactive power injection mismatches and returns their maximum absolute values, which can be utilized to terminate the iteration loop of methods employed to solve the AC power flow problem.\n\nUpdates\n\nThis function updates the mismatch variables in the Newton-Raphson and fast Newton-Raphson methods. It should be employed during the iteration loop before invoking the solve! function.\n\nIn contrast, the Gauss-Seidel method does not need mismatches to obtain bus voltages, but the maximum absolute values are commonly employed to stop the iteration loop. The function does not save any data and should be utilized during the iteration loop before invoking the solve! function.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the power mismatches within the Newton-Raphson method;\nFastNewtonRaphson: computes the power mismatches within the fast Newton-Raphson method;\nGaussSeidel: computes the power mismatches within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nmismatch!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function employs the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel method to solve the AC power flow problem and calculate bus voltage magnitudes and angles.\n\nAfter the mismatch! function is called, this function should be executed to perform a single iteration of the method.\n\nUpdates\n\nThe calculated voltages are stored in the voltage field of the respective struct type.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method;\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method;\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Additional-AC-Functions-2","page":"Power Flow","title":"Additional AC Functions","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"reactiveLimit!\nadjustAngle!\nstartingVoltage!","category":"page"},{"location":"api/powerFlow/#JuliaGrid.reactiveLimit!","page":"Power Flow","title":"JuliaGrid.reactiveLimit!","text":"reactiveLimit!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function verifies whether the generators in a power system exceed their reactive power limits. This is done by setting the reactive power of the generators to within the limits if they are violated, after determining the bus voltage magnitudes and angles. If the limits are violated, the corresponding generator buses or the slack bus are converted to demand buses.\n\nUpdates\n\nThe function assigns values to the generator.output.active and bus.supply.active variables of the PowerSystem type. Additionally, it examines the reactive powers of the generator and adjusts them to their maximum or minimum values if they exceed the specified threshold. Subsequently, the generator.output.reactive variable of the PowerSystem type is modified accordingly. As a result of this adjustment, the bus.supply.reactive variable of the PowerSystem type is also updated, and the bus types specified in bus.layout.type are modified. If the slack bus is converted, the bus.layout.slack field is correspondingly adjusted.\n\nReturns\n\nThe function returns the violate variable to indicate which buses violate the limits, with -1 indicating a violation of the minimum limits and 1 indicating a violation of the maximum limits.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method,\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method,\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nviolate = reactiveLimit!(system, analysis)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.adjustAngle!","page":"Power Flow","title":"JuliaGrid.adjustAngle!","text":"adjustAngle!(system::PowerSystem, analysis::ACPowerFlow; slack)\n\nThe function modifies the bus voltage angles based on a different slack bus than the one identified by the bus.layout.slack field.\n\nFor instance, if the reactive power of the generator exceeds the limit on the slack bus, the reactiveLimit! function will change that bus to the demand bus and designate the first generator bus in the sequence as the new slack bus. After obtaining the updated AC power flow solution based on the new slack bus, it is possible to adjust the voltage angles to align with the angle of the original slack bus. The slack keyword specifies the bus label of the original slack bus.\n\nUpdates\n\nThis function only updates the voltage.angle variable of the ACPowerFlow abstract type.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method;\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method;\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nreactiveLimit!(system, analysis)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nadjustAngle!(system, analysis; slack = 1)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.startingVoltage!","page":"Power Flow","title":"JuliaGrid.startingVoltage!","text":"startingVoltage!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function extracts bus voltage magnitudes and angles from the PowerSystem composite  type and assigns them to the ACPowerFlow abstract type, enabling users to initialize  voltage values as required.\n\nUpdates\n\nThis function only updates the voltage field of the ACPowerFlow abstract type.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method;\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method;\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nupdateBus!(system, analysis; label = 14, reactive = 0.13, magnitude = 1.2, angle = -0.17)\n\nstartingVoltage!(system, analysis)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-DC-Power-Flow-Model-2","page":"Power Flow","title":"Build DC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"dcPowerFlow","category":"page"},{"location":"api/powerFlow/#JuliaGrid.dcPowerFlow","page":"Power Flow","title":"JuliaGrid.dcPowerFlow","text":"dcPowerFlow(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input, which is utilized to establish the structure for solving the DC power flow.\n\nIf the DC model was not created, the function will automatically initiate an update of the dc field within the PowerSystem composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.\n\nReturns\n\nThe function returns an instance of the DCPowerFlow composite type, which includes the following fields:\n\nvoltage: the variable allocated to store the bus voltage angles;\npower: the variable allocated to store the active powers;\nfactorization: the factorized nodal matrix.\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Solve-DC-Power-Flow-2","page":"Power Flow","title":"Solve DC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"solve!(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::DCPowerFlow)\n\nBy computing the bus voltage angles, the function solves the DC power flow problem.\n\nUpdates\n\nThe resulting bus voltage angles are stored in the voltage field of the DCPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/powerSystemModel/#powerSystemModelAPI","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For further information on this topic, please see the Power System Model section of the Manual. Below, we have provided a list of functions that can be used to create, save, and manipulate power system structures, as well as to build AC or DC models of power systems.","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System-Data","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nupdateBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nupdateBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nupdateGenerator!\ncost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System-Data-2","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.powerSystem","page":"Power System Model","title":"JuliaGrid.powerSystem","text":"powerSystem(file::String)\n\nThe function builds the composite type PowerSystem and populates bus, branch, generator and base fields. In general, once the composite type PowerSystem has been created, it is possible to add new buses, branches, or generators, or modify the parameters of existing ones.\n\nArgument\n\npassing the path to the HDF5 file with the .h5 extension,\npassing the path to Matpower file with the .m extension.\n\nReturns\n\nThe PowerSystem composite type with the following fields:\n\nbus: data related to buses;\nbranch: data related to branches;\ngenerator: data related to generators;\nbase: base power and base voltages;\nmodel: data associated with AC (nonlinear) or DC (linear) analyses;\nuuid: universally unique identifier for the power system.\n\nUnits\n\nJuliaGrid stores all data in per-units and radians format which are fixed, the exceptions are base values in volt-amperes and volts. The prefixes for these base values can be changed using the @base macro.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\n\n\n\n\npowerSystem()\n\nAlternatively, the PowerSystem composite type can be initialized by calling the function without any arguments. This allows the model to be built from scratch and modified as  needed. This generates an empty PowerSystem type, with only the base power initialized  to 1.0e8 volt-amperes (VA).\n\nExample\n\nsystem = powerSystem()\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.savePowerSystem","page":"Power System Model","title":"JuliaGrid.savePowerSystem","text":"savePowerSystem(system::PowerSystem; path::String, reference::String, note::String)\n\nThe function saves the power system's data in the HDF5 file using the fields bus, branch, generator, and base from the PowerSystem composite type.\n\nKeywords\n\nThe location and file name of the HDF5 file is specified by the mandatory keyword path in the format of \"path/name.h5\". Additional information can be provided by the optional keywords reference and note, which can be saved along with the power system data.\n\nView HDF5 File\n\nTo view the saved HDF5 file, you can use the HDFView software.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"D:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions-2","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nupdateBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBus!","page":"Power System Model","title":"JuliaGrid.addBus!","text":"addBus!(system::PowerSystem; label, type, active, reactive, conductance, susceptance,\n    magnitude, angle, minMagnitude, maxMagnitude, base, area, lossZone)\n\nThe function adds a new bus to the PowerSystem composite type.\n\nKeywords\n\nThe bus is defined with the following keywords:\n\nlabel: unique label for the bus;\ntype: the bus type:\ntype = 1: demand bus (PQ);\ntype = 2: generator bus (PV);\ntype = 3: slack bus (Vθ);\nactive (pu or W): the active power demand at the bus;\nreactive (pu or VAr): the reactive power demand at the bus;\nconductance (pu or W): the active power demanded of the shunt element;\nsusceptance (pu or VAr): the reactive power injected/demanded of the shunt element;\nmagnitude (pu or V): the initial value of the voltage magnitude;\nangle (rad or deg): the initial value of the voltage angle;\nminMagnitude (pu or V): the minimum voltage magnitude value;\nmaxMagnitude (pu or V): the maximum voltage magnitude value;\nbase (V): the voltage base value;\narea: the area number;\nlossZone: the loss zone.\n\nUpdates\n\nThe function updates the bus field of the PowerSystem composite type.\n\nDefault Settings\n\nThe default settings for certain keywords are as follows: type = 1, magnitude = 1.0, minMagnitude = 0.9, maxMagnitude = 1.1, and base = 138e3. The rest of the keywords  are initialized with a value of zero. However, the user can modify these default settings  by utilizing the @bus macro.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 0.25, angle = 0.175, base = 132e3)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 25.0, angle = 10.026, base = 132.0)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.updateBus!","page":"Power System Model","title":"JuliaGrid.updateBus!","text":"updateBus!(system::PowerSystem, analysis::Analysis; kwargs...)\n\nThe function allows for the alteration of parameters for an existing bus.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined process avoids the need to completely rebuild vectors and matrices when adjusting these parameters.\n\nKeywords\n\nTo update a specific bus, provide the necessary kwargs input arguments in accordance with the keywords specified in the addBus! function, along with their respective values. Ensure that the label keyword matches the label of the existing bus you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the bus field within the PowerSystem composite type, and in cases where parameters impact variables in the ac field, it automatically adjusts the field. Furthermore, it guarantees that any modifications to the parameters are transmitted to the Analysis type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addBus! function.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\nupdateBus!(system; label = \"Bus 1\", active = 0.15, susceptance = 0.15)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@bus","page":"Power System Model","title":"JuliaGrid.@bus","text":"@bus(kwargs...)\n\nThe macro generates a template for a bus, which can be utilized to define a bus using the addBus! function.\n\nKeywords\n\nTo define the bus template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBus! function, along with their corresponding values.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus template using the default unit system:\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 0.25, angle = 0.1745)\naddBus!(system; label = \"Bus 1\", reactive = -0.04, base = 132e3)\n\nCreating a bus template using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\n@bus(type = 2, active = 25.0, angle = 10.0, base = 132.0)\naddBus!(system; label = \"Bus 1\", reactive = -4.0)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions-2","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nupdateBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBranch!","page":"Power System Model","title":"JuliaGrid.addBranch!","text":"addBranch!(system::PowerSystem, analysis::Analysis; label, from, to, status,\n    resistance, reactance, conductance, susceptance, turnsRatio, shiftAngle,\n    minDiffAngle, maxDiffAngle, longTerm, shortTerm, emergency, type)\n\nThe function adds a new branch to the PowerSystem composite type. A branch can be added between already defined buses.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined approach circumvents the necessity for completely reconstructing vectors and matrices when adding a new branch.\n\nKeywords\n\nThe branch is defined with the following keywords:\n\nlabel: unique label for the branch;\nfrom: \"from\" bus label, corresponds to the bus label;\nto: \"to\" bus label, corresponds to the bus label;\nstatus: operating status of the branch:\nstatus = 1: in-service;\nstatus = 0: out-of-service;\nresistance (pu or Ω): series resistance;\nreactance (pu or Ω): series reactance;\nconductance (pu or S): total shunt conductance;\nsusceptance (pu or S): total shunt susceptance;\nturnsRatio: transformer off-nominal turns ratio, equal to one for a line;\nshiftAngle (rad or deg): transformer phase shift angle, where positive value defines delay;\nminDiffAngle (rad or deg): minimum voltage angle difference value between \"from\" and \"to\" bus end;\nmaxDiffAngle (rad or deg): maximum voltage angle difference value between \"from\" and \"to\" bus end;\nlongTerm (pu or VA, W): long-term flow rating (equal to zero for unlimited);\nshortTerm (pu or VA, W): short-term flow rating (equal to zero for unlimited);\nemergency (pu or VA, W): emergency flow rating (equal to zero for unlimited);\ntype: types of longTerm, shortTerm, and emergency flow ratings:\ntype = 1: apparent power flow (pu or VA);\ntype = 2: active power flow (pu or W);\ntype = 3: current magnitude flow (pu or VA at 1 pu voltage).\n\nUpdates\n\nThe function updates the branch field within the PowerSystem composite type, and in cases where parameters impact variables in the ac and dc fields, it automatically adjusts the fields. Furthermore, it guarantees that any modifications to the parameters are transmitted to the  Analysis type.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1, turnsRatio = 1.0, type = 1, minDiffAngle = -2pi, and maxDiffAngle = 2pi. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @branch macro.\n\nUnits\n\nThe default units for the keyword parameters are per-units (pu) and radians (rad). However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 0.1745)\n\nCreating a branch using a custom unit system:\n\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 10)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.updateBranch!","page":"Power System Model","title":"JuliaGrid.updateBranch!","text":"updateBranch!(system::PowerSystem, analysis::Analysis; kwargs...)\n\nThe function allows for the alteration of parameters for an existing branch.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined process avoids the need to completely rebuild vectors and matrices when adjusting these parameter\n\nKeywords\n\nTo update a specific branch, provide the necessary kwargs input arguments in accordance with the keywords specified in the addBranch! function, along with their respective values. Ensure that the label keyword matches the label of the existing branch you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the branch field within the PowerSystem composite type, and in cases where parameters impact variables in the ac and dc fields, it automatically adjusts the fields. Furthermore, it guarantees that any modifications to the parameters are transmitted to the Analysis type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addBranch! function.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\nupdateBranch!(system; label = \"Branch 1\", reactance = 0.02, susceptance = 0.062)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@branch","page":"Power System Model","title":"JuliaGrid.@branch","text":"@branch(kwargs...)\n\nThe macro generates a template for a branch, which can be utilized to define a branch using the addBranch! function.\n\nKeywords\n\nTo define the branch template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBranch! function, along with their corresponding values.\n\nUnits\n\nThe default units for the keyword parameters are per-units and radians. However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch template using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\n@branch(reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\")\n\nCreating a branch template using a custom unit system:\n\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1,  active = 0.15, reactive = 0.08)\n\n@branch(shiftAngle = 10)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions-2","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nupdateGenerator!\ncost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addGenerator!","page":"Power System Model","title":"JuliaGrid.addGenerator!","text":"addGenerator!(system::PowerSystem, analysis::Analysis; label, bus, status,\n    active, reactive, magnitude, minActive, maxActive, minReactive, maxReactive,\n    lowActive, minLowReactive, maxLowReactive, upActive, minUpReactive, maxUpReactive,\n    loadFollowing, reactiveTimescale, reserve10min, reserve30min, area)\n\nThe function adds a new generator to the PowerSystem composite type. The generator can be added to an already defined bus.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined approach circumvents the necessity for completely reconstructing vectors and matrices when adding a new generator.\n\nKeywords\n\nThe generator is defined with the following keywords:\n\nlabel: a unique label for the generator;\nbus: the label of the bus to which the generator is connected;\nstatus: the operating status of the generator:\nstatus = 1: in-service;\nstatus = 0: out-of-service;\nactive (pu or W): output active power;\nreactive (pu or VAr): output reactive power;\nmagnitude (pu or V): voltage magnitude setpoint;\nminActive (pu or W): minimum allowed output active power value;\nmaxActive (pu or W): maximum allowed output active power value;\nminReactive (pu or VAr): minimum allowed output reactive power value;\nmaxReactive (pu or VAr): maximum allowed output reactive power value;\nlowActive (pu or W): lower allowed active power output value of PQ capability curve;\nminLowReactive (pu or VAr): minimum allowed reactive power output value at lowActive value;\nmaxLowReactive (pu or VAr): maximum allowed reactive power output value at lowActive value;\nupActive (pu or W): upper allowed active power output value of PQ capability curve;\nminUpReactive (pu or VAr): minimum allowed reactive power output value at upActive value;\nmaxUpReactive (pu or VAr): maximum allowed reactive power output value at upActive value;\nloadFollowing (pu/min or W/min): ramp rate for load following/AG;\nreserve10min (pu or W): ramp rate for 10-minute reserves;\nreserve30min (pu or W): ramp rate for 30-minute reserves;\nreactiveTimescale (pu/min or VAr/min): ramp rate for reactive power, two seconds timescale;\narea: area participation factor.\n\nUpdates\n\nThe function updates the generator field within the PowerSystem composite type, and in cases where parameters impact variables in the bus field, it automatically adjusts the field. Furthermore, it guarantees that any modifications to the parameters are transmitted to the Analysis type.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1 and magnitude = 1.0 per-unit. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @generator macro.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 0.2, base = 132e3)\n\naddGenerator!(system; bus = \"Bus 1\", active = 0.5, magnitude = 1.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 20, base = 132)\n\naddGenerator!(system; bus = \"Bus 1\", active = 50, magnitude = 145.2)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.updateGenerator!","page":"Power System Model","title":"JuliaGrid.updateGenerator!","text":"updateGenerator!(system::PowerSystem, analysis::Analysis; kwargs...)\n\nThe function allows for the alteration of parameters for an existing generator.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined process avoids the need to completely rebuild vectors and matrices when adjusting these parameter\n\nKeywords\n\nTo update a specific generator, provide the necessary kwargs input arguments in accordance with the keywords specified in the addGenerator! function, along with their respective values. Ensure that the label keyword matches the label of the existing generator you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the generator field within the PowerSystem composite type, and in cases where parameters impact variables in the bus field, it automatically adjusts the field. Furthermore, it guarantees that any modifications to the parameters are transmitted to the Analysis type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addBranch! function.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 0.2, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5)\nupdateGenerator!(system; label = \"Generator 1\", active = 0.6, reactive = 0.2)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.cost!","page":"Power System Model","title":"JuliaGrid.cost!","text":"cost!(system::PowerSystem, analysis::Analysis; label, active, reactive,\n    piecewise, polynomial)\n\nThe function either adds a new cost or modifies an existing one for the active or reactive power generated by the corresponding generator within the PowerSystem composite type. It has the capability to append a cost to an already defined generator.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined approach circumvents the necessity for completely reconstructing vectors and matrices when adding a new branch.\n\nKeywords\n\nThe function accepts five keywords:\n\nlabel: corresponds to the already defined generator label;\nactive: cost model:\nactive = 1: adding or updating cost for the active power, and piecewise linear is being used;\nactive = 2: adding or updating cost for the active power, and polynomial is being used;\nreactive: cost model:\nreactive = 1: adding or updating cost for the reactive power, and piecewise linear is being used;\nreactive = 2: adding or updating cost for the reactive power, and polynomial is being used;\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or W): active power output of the generator;\nsecond column (currency/hr): cost for the specified active power output;\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/Wⁿhr): coefficient of the n-th degree term, ...;\npenultimate element (currency/puhr or currency/Whr): coefficient of the first degree term;\nlast element (currency/hr): constant coefficient.\n\nUpdates\n\nThe function updates the generator.cost field within the PowerSystem composite type. Furthermore, it guarantees that any modifications to the parameters are transmitted to the Analysis type.\n\nUnits\n\nBy default, the input units related with active powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 0.25, reactive = -0.04, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5)\ncost!(system; label = \"Generator 1\", active = 2, polynomial = [1100.0; 500.0; 150.0])\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 25, reactive = -4, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 50, reactive = 10)\ncost!(system; label = \"Generator 1\", active = 2, polynomial = [0.11; 5.0; 150.0])\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@generator","page":"Power System Model","title":"JuliaGrid.@generator","text":"@generator(kwargs...)\n\nThe macro generates a template for a generator, which can be utilized to define a generator using the addGenerator! function.\n\nKeywords\n\nTo define the generator template, the kwargs input arguments must be provided in accordance with the keywords specified within the addGenerator! function, along with their corresponding values.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 0.25, reactive = -0.04, base = 132e3)\n\n@generator(magnitude = 1.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5, reactive = 0.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 25, reactive = -4, base = 132)\n\n@generator(magnitude = 145.2)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 50, reactive = 10)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model-2","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.acModel!","page":"Power System Model","title":"JuliaGrid.acModel!","text":"acModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with AC analyses.\n\nUpdates\n\nThe function modifies the model.ac field within the PowerSystem composite type, populating the following variables:\n\nnodalMatrix: the nodal matrix;\nnodalMatrixTranspose: the transpose of the nodal matrix;\nnodalFromFrom: the Y-parameters of the two-port branches;\nnodalFromTo: the Y-parameters of the two-port branches;\nnodalToTo: the Y-parameters of the two-port branches;\nnodalToFrom: the Y-parameters of the two-port branches;\nadmittance: the branch admittances.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.dcModel!","page":"Power System Model","title":"JuliaGrid.dcModel!","text":"dcModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with DC analyses.\n\nUpdates\n\nThe function modifies the model.dc field within the PowerSystem composite type, populating the following variables:\n\nnodalMatrix: the nodal matrix;\nadmittance: the branch admittances;\nshiftPower: the active powers related to phase-shifting transformers.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"tutorials/dcPowerFlow/#DCPowerFlowTutorials","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid employs standard network components and the Unified Branch Model to obtain the DC power flow solution. To begin, the PowerSystem composite type must be provided to JuliaGrid through the use of the powerSystem function, as illustrated by the following example:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, V)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 21.7)\naddBus!(system; label = 3, type = 2, conductance = 0.07)\n\naddBranch!(system; from = 1, to = 2, reactance = 0.26)\naddBranch!(system; from = 1, to = 3, reactance = 0.38)\naddBranch!(system; from = 2, to = 3, reactance = 0.17, turnsRatio = 0.97)\n\naddGenerator!(system; bus = 1, active = 2.0)\naddGenerator!(system; bus = 1, active = 4.0)\naddGenerator!(system; bus = 3, active = 5.0)\nnothing #hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝒩 = collect(keys(sort(system.bus.label)))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"ukw: Notation\nIn this section, when referring to a vector mathbfa, we use the notation mathbfa = a_i or mathbfa = a_ij, where a_i denotes the generic element associated with bus i in mathcalN, and a_ij denotes the generic element associated with branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#DCPowerFlowSolutionTutorials","page":"DC Power Flow","title":"Power Flow Solution","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"As discussed in section DC Model, the DC power flow problem can be represented by a set of linear equations given by:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"  mathbf P = mathbfB bm theta + mathbfP_texttr + mathbfP_textsh","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Implementation","page":"DC Power Flow","title":"Implementation","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid offers a set of functions to solve the DC power flow problem and obtain the bus voltage angles. Firstly, the power system is loaded and the DC model is built using the following code sequence:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The DC power flow solution is obtained through a non-iterative approach by solving the system of linear equations:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    bm theta = mathbfB^-1(mathbf P - mathbfP_texttr - mathbfP_textsh)","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The initial step taken by JuliaGrid is to factorize the nodal matrix mathbfB using the function:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"analysis = dcPowerFlow(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The factorization of the nodal matrix can be accessed using:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"analysis.factorization\nusing SparseArrays\nsparse(analysis.factorization.L)","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"This enables the user to modify any of the vectors mathbf P, mathbfP_texttr, and mathbfP_textsh and reuse the factorization. This approach is more efficient compared to solving the system of equations from the beginning, as it saves computation time.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To acquire the bus voltage angles, the user must invoke the function:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"solve!(system, analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"It is important to note that the slack bus voltage angle is excluded from the vector bmtheta only during the computation step. As a analysis, the corresponding elements in the vectors mathbf P, mathbfP_texttr, mathbfP_textsh, and the corresponding row and column of the matrix mathbfB are removed. It is worth mentioning that this process is handled internally, and the stored elements remain unchanged.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, the resulting bus voltage angles are saved in the vector as follows:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝛉 = analysis.voltage.angle","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#DCPowerAnalysisTutorials","page":"DC Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"After obtaining the solution from the DC power flow, we can calculate powers related to buses, branches, and generators using the power! function:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power!(system, analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Active-Power-Injections","page":"DC Power Flow","title":"Active Power Injections","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To obtain the active power injection at buses, we can refer to section DC Model, which provides the following expression:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"   P_i = sum_j = 1^n B_ij theta_j + P_texttri + P_textshi forall i in mathcalN","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Active power injections are stored as the vector mathbfP = P_i, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏 = analysis.power.injection.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Active-Power-Injections-from-the-Generators","page":"DC Power Flow","title":"Active Power Injections from the Generators","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The active power supplied by generators to the buses can be calculated by summing the given generator active powers in the input data, except for the slack bus, which can be determined as:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_textsi = P_i + P_textdi forall i in mathcalN_textsb","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"where P_textdi represents the active power demanded by consumers at the slack bus. The vector of active power injected by generators to the buses, denoted by mathbfP_texts = P_textsi, can be obtained using the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ₛ = analysis.power.supply.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Active-Power-Flows","page":"DC Power Flow","title":"Active Power Flows","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The active power flow at each \"from\" bus end i in mathcalN of branches can be obtained using the following equations:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_ij = cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) forall (ij) in mathcalE","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The resulting active power flows are stored as the vector mathbfP_texti = P_ij, which can be retrieved using the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ᵢ = analysis.power.from.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Similarly, the active power flow at each \"to\" bus end j in mathcalN of branches can be obtained as:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_ji = - P_ij forall (ij) in mathcalE","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The resulting active power flows are stored as the vector mathbfP_textj = P_ji, which can be retrieved using the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ⱼ = analysis.power.to.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Generators-Active-Power-Output","page":"DC Power Flow","title":"Generators Active Power Output","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The output active power of each generator located at bus i in mathcalN_textpv cup mathcalN_textpq is equal to the active power specified in the input data. If there are multiple generators, their output active powers are also equal to the active powers specified in the input data. However, the output active power of a generator located at the slack bus is determined as:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_textgi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"In the case of multiple generators connected to the slack bus, the first generator in the input data is assigned the obtained value of P_textgi. Then, this amount of power is reduced by the output active power of the other generators. ","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To retrieve the vector of active power outputs of generators, denoted as mathbfP_textg = P_textgi, i in mathcalP, where the set mathcalP represents the set of generators, users can utilize the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ₒ = analysis.power.generator.active","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowTutorials","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To begin, the PowerSystem composite type must be provided to JuliaGrid through the use of the powerSystem function, as illustrated by the following example:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, Ipopt \n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\n@bus(minMagnitude = 0.95, maxMagnitude = 1.05)\naddBus!(system; label = 1, type = 3, active = 0.1, angle = -0.1)\naddBus!(system; label = 2, reactive = 0.01, magnitude = 1.1)\n\n@branch(minDiffAngle = -pi, maxDiffAngle = pi, reactance = 0.5, type = 2)\naddBranch!(system; label = 1, from = 1, to = 2, longTerm = 0.15)\n\n@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1)\naddGenerator!(system; label = 1, bus = 1, active = 0.4, reactive = 0.2)\naddGenerator!(system; label = 2, bus = 2, active = 0.2, reactive = 0.1)\n\ncost!(system; label = 1, active = 2, polynomial = [900.0; 500.0; 80.0; 5.0])\ncost!(system; label = 2, active = 1, piecewise =  [10.8 12.3; 14.7 16.8; 18 18.1])\n\ncost!(system; label = 1, reactive = 1, piecewise = [10.0 20.0; 20.0 40.0])\ncost!(system; label = 2, reactive = 2, polynomial = [2.0])\n\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system. This can be visualized as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝒩 = collect(keys(sort(system.bus.label)))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Moreover, we identify the set of generators as mathcalP = 1 dots n_g within the power system. For the specific example at hand, it can be represented as:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝒫 = collect(keys(sort(system.generator.label)))","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"ukw: Notation\nIn this section, when referring to a vector mathbfa, we use the notation mathbfa = a_i or mathbfa = a_ij, where a_i denotes the generic element associated with bus i in mathcalN or generator i in mathcalP, while a_ij denotes the generic element associated with branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowModelTutorials","page":"AC Optimal Power Flow","title":"Optimal Power Flow Model","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the AC optimal power flow model, the active power outputs of the generators denoted as mathbf P_textg = P_textgi, i in mathcalP, and reactive power outputs represented as mathbf Q_textg = Q_textgi, i in mathcalP, are expressed as nonlinear functions of the bus voltage magnitudes mathbf V = V_i, i in mathcalN, and angles boldsymboltheta = theta_i, i in mathcalN. Consequently, the optimization variables in this model consist of the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles. The AC optimal power flow problem can be formulated as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n     textminimize   sum_i in mathcalP left  f_i(P_textgi) + f_i(Q_textgi) right  \n     textsubjectto   theta_i - theta_textslack = 0 i in mathcalN_textsb  4pt\n       h_P_i(mathbf P_textg mathbf V boldsymboltheta) = 0  forall i in mathcalN \n       h_Q_i(mathbf Q_textg mathbf V boldsymboltheta) = 0  forall i in mathcalN 4pt\n       V_i^textmin leq V_i leq V_i^textmax forall i in mathcalN \n       theta_ij^textmin leq theta_i - theta_j leq theta_ij^textmax forall (ij) in mathcalE 4pt\n       h_ij(mathbf V boldsymboltheta) leq F_ij^textmax forall (ij) in mathcalE \n       h_ji(mathbf V boldsymboltheta) leq F_ij^textmax forall (ij) in mathcalE 4pt\n       P_textgi^textmin leq P_textgi leq P_textgi^textmax  forall i in mathcalP \n       Q_textgi^textmin leq Q_textgi leq Q_textgi^textmax  forall i in mathcalP\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In essence, the AC optimal power flow aims to minimize the objective function associated with the costs of generator active and reactive power output while ensuring the fulfillment of all constraints. This optimization task plays a pivotal role in effectively managing electrical power systems. By striking a balance between cost reduction and constraint adherence, the AC optimal power flow contributes to efficient and reliable electricity supply in complex grid environments.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Build-Optimal-Power-Flow-Model","page":"AC Optimal Power Flow","title":"Build Optimal Power Flow Model","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To build the AC optimal power flow model, we must first load the power system and establish the AC model using the following function:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"acModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Afterward, the AC optimal power flow model is created using the acOptimalPowerFlow function:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Optimization-Variables","page":"AC Optimal Power Flow","title":"Optimization Variables","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Hence, the variables within this model encompass the active and reactive power outputs of the generators, denoted as mathbfP_textg = P_textgi and mathbfQ_textg = Q_textgi, where i in mathcalP, and the bus voltage magnitudes and angles represented by mathbfV = V_i and boldsymboltheta = theta_i, where i in mathcalN. We can access these variables using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₒ = analysis.variable.active\n𝐐ₒ = analysis.variable.reactive\n𝐕 = analysis.variable.magnitude\n𝛉 = analysis.variable.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Objective-Function","page":"AC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The objective function represents the sum of the active and reactive power cost functions f_i(P_textgi) and f_i(Q_textgi), where i in mathcalP, for each generator, where these cost functions can be polynomial or linear piecewise functions. Typically, the AC optimal power flow focuses on minimizing the cost of active power outputs only, but for comprehensive analysis, we also consider the costs associated with reactive power outputs.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Polynomial-Cost-Function","page":"AC Optimal Power Flow","title":"Polynomial Cost Function","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the following analysis, we will focus on the cost function of generating active power, denoted as f_i(P_textgi). However, please note that the same analysis can be applied to the cost function f_i(Q_textgi) for reactive power.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the AC optimal power flow using JuliaGrid, the cost function f_i(P_textgi) can accept an n-th degree polynomial form:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"f_i(P_textgi) = sum_k=0^n a_k P_textgi^k","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Typically, cost functions are represented as linear, quadratic, or cubic, as shown in Figure 1:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n  f_i(P_textgi) = a_1P_textgi + a_0 \n  f_i(P_textgi) = a_2 P_textgi^2 + a_1P_textgi + a_0 \n  f_i(P_textgi) = a_3 P_textgi^3 + a_2 P_textgi^2 + a_1P_textgi + a_0 \nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<img src=\"../../assets/cost_function.svg\" class=\"center\" width=\"750\"/>\n<figcaption>Figure 1: The polynomial cost functions of generator active power output.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"When using the cost! function in JuliaGrid and specifying the polynomial keyword, the polynomial is constructed with coefficients arranged in descending order of their degrees, from the highest degree to the lowest. For example, in the case study provided, we generated a cubic polynomial cost function for the active output power of Generator 1, which is represented as:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n  f_1(P_textg1) = 900 P_textg1^3 + 500 P_textg1^2 + 80 P_textg1 + 5\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To access these coefficients, users can utilize the variable:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"f₁ = system.generator.cost.active.polynomial[1]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Linear-Piecewise-Cost-Function","page":"AC Optimal Power Flow","title":"Linear Piecewise Cost Function","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The second option for defining cost functions in the AC optimal power flow is to use linear piecewise functions as approximations of the polynomial functions, as illustrated in Figure 2.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<img src=\"../../assets/cost_function_piecewise.svg\" class=\"center\" width=\"750\"/>\n<figcaption>Figure 2: The linear piecewise cost functions of generator active power output.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To define linear piecewise functions in JuliaGrid, users can utilize the cost! function with the piecewise keyword. The linear piecewise function is constructed using a matrix where each row defines a single point. The first column holds the generator's active or reactive power output, while the second column corresponds to the associated cost value. For example, in the provided case study, a linear piecewise function is created and can be accessed as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"f₂ = system.generator.cost.active.piecewise[2]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid handles convex linear piecewise functions using a constrained cost variable method. In this approach, the piecewise linear cost function is replaced by a helper variable and a set of linear inequality constraints for each segment of the function defined by two neighboring points along the line. However, for linear piecewise functions that have only one segment defined by two points, JuliaGrid transforms it into a standard linear function without introducing a helper variable.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Hence, for a piecewise cost function denoted as f_i(P_textgi) with k segments (where k  1), the j-th segment, defined by the points P_textgij f_i(P_textgij) and P_textgij+1 f_i(P_textgij+1), is characterized by the following inequality constraints:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"cfracf_i(P_textgij+1) - f_i(P_textgij)P_textgij+1 - P_textgij(P_textgi - P_textgij) + f_i(P_textgij) leq H_i j = 1dotsk","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where H_i represents the helper variable. To finalize this method, we simply need to include the helper variable H_i in the objective function. This approach in JuliaGrid efficiently handles linear piecewise cost functions, providing the flexibility to capture nonlinear characteristics while still benefiting from the advantages of linear optimization techniques.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As an example, in the provided case study, the helper variable is defined as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"H₂ = analysis.variable.actwise[2]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Lastly, the set of constraints introduced by the linear piecewise cost function is displayed as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.piecewise.active)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Objective-Function-2","page":"AC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As previously explained, the objective function relies on the defined polynomial or linear piecewise cost functions and represents the sum of these costs. In the provided example, the objective function that must be minimized to obtain the optimal values for the active and reactive power outputs of the generators and the bus voltage magnitudes and angles can be accessed using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_function(analysis.jump)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Constraint-Functions","page":"AC Optimal Power Flow","title":"Constraint Functions","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the following section, we will examine the various constraints defined within the AC optimal power flow model.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Slack-Bus-Constraint","page":"AC Optimal Power Flow","title":"Slack Bus Constraint","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The first equality constraint is linked to the slack bus, where the bus voltage angle denoted as theta_i is fixed to a constant value theta_textslack. It can be expressed as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"theta_i - theta_textslack = 0 i in mathcalN_textsb","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where the set mathcalN_textsb contains the index of the slack bus. To access the equality constraint from the model, we can utilize the variable:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.slack.angle)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Power-Balance-Constraints","page":"AC Optimal Power Flow","title":"Power Balance Constraints","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The second equality constraint in the optimization problem is associated with the active power balance equation denoted as h_P_i(mathbf x) for each bus i in mathcalN:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\nh_P_i(mathbf P_textg mathbf V boldsymboltheta) = 0  forall i in mathcalN\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The active power balance equation is derived using the Unified Branch Model and can be represented as:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"h_P_i(mathbf P_textg mathbf V boldsymboltheta) = V_isumlimits_j=1^n V_j (G_ijcostheta_ij+B_ijsintheta_ij) - sum_k in mathcalP_i P_textgk + P_textdi","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In this equation, the set mathcalP_i subseteq mathcalP encompasses all generators connected to bus i in mathcalN, and P_textgk represents the active power output of the k-th generator within the set mathcalP_i. More Precisely, the variable P_textgk represents the optimization variable, along with the bus voltage angles theta_ij = theta_i - theta_j and the bus voltage magnitudes V_i and V_j.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The constant term is determined by the active power demand P_textdi at bus i in mathcalN. The values representing this constant term, denoted as mathbfP_textd = P_textdi, i in mathcalN, can be accessed using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₒ = system.bus.demand.active","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"You can access the references to the active power balance constraints using the following code snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.balance.active)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the next constraint in the optimization problem is associated with the reactive power balance equation denoted as h_Q_i(mathbf x) for each bus i in mathcalN:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\nh_Q_i(mathbf Q_textg mathbf V boldsymboltheta) = 0  forall i in mathcalN\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The reactive power balance equation is derived using the unified branch model and can be represented as:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"h_Q_i(mathbf Q_textg mathbf V boldsymboltheta) = V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij) - sum_k in mathcalP_i Q_textgk + Q_textdi","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, as mentioned earlier for active power, Q_textgk represents the reactive power output of the k-th generator within the set mathcalP_i. The variable Q_textgk serves as optimization variable, as well as the bus voltage angles theta_ij = theta_i - theta_j, and the bus voltage magnitudes V_i and V_j.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The constant term is determined by the reactive power demand Q_textdi at bus i in mathcalN. The values representing this constant term, denoted as mathbfQ_textd = Q_textdi, i in mathcalN, can be accessed using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐐ₒ = system.bus.demand.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"You can access the references to the reactive power balance constraints using the following code snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.balance.reactive)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Voltage-Constraints","page":"AC Optimal Power Flow","title":"Voltage Constraints","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The inequality constraints associated with the voltage magnitude ensure that the bus voltage magnitudes are within specified limits:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"V_i^textmin leq V_i leq V_i^textmax forall i in mathcalN","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where V_i^textmin represents the minimum voltage magnitude, and V_i^textmax represents the maximum voltage magnitude for bus i in mathcalN. The values representing these voltage magnitude limits, denoted as mathbfV_textlm = V_i^textmin V_i^textmax, i in mathcalN, can be accessed using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐕ₗₘ = [system.bus.voltage.minMagnitude system.bus.voltage.maxMagnitude]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To retrieve this inequality constraint from the model, we can use the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.voltage.magnitude)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The inequality constraint related to the minimum and maximum bus voltage angle difference between the \"from\" and \"to\" bus ends of each branch is defined as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"theta_ij^textmin leq theta_i - theta_j leq theta_ij^textmax forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where theta_ij^textmin represents the minimum, while theta_ij^textmax represents the maximum of the angle difference between adjacent buses. The values representing the voltage angle difference, denoted as boldsymboltheta_textlm = theta_ij^textmin theta_ij^textmax, (ij) in mathcalE, are provided as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝛉ₗₘ = [system.branch.voltage.minDiffAngle system.branch.voltage.maxDiffAngle]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To retrieve this inequality constraint from the model, we can use the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.voltage.angle)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Flow-Constraints","page":"AC Optimal Power Flow","title":"Flow Constraints","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The inequality constraints related to the branch flow ratings can be associated with the limits on apparent power flow, active power flow, or current magnitude at the \"from\" and \"to\" bus ends of each branch. The type of constraint applied is determined by the type keyword within the addBranch! function. Specifically, type = 1 is used for apparent power flow, type = 2 for active power flow, and type = 3 for current magnitude. These constraints can be expressed using the equations h_ij(mathbf V boldsymboltheta) and h_ji(mathbf V boldsymboltheta), representing the rating constraints at the \"from\" and \"to\" bus ends of each branch, respectively:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    h_ij(mathbf V boldsymboltheta) leq F_ij^textmax forall (ij) in mathcalE \n    h_ji(mathbf V boldsymboltheta) leq F_ij^textmax forall (ij) in mathcalE\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"These rating constraints ensure that the power flow or current in each branch does not exceed the specified limits, helping to maintain the security and reliability of the power system. The upper bounds are determined based on the vector mathbfF_textmax = F_ij^textmax, (ij) in mathcalE. These bounds can be accessed using the following variable:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐅ₘₐₓ = system.branch.flow.longTerm","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"By default, the rating constraints are associated with the apparent power flow (type = 1) at the \"from\" and \"to\" bus ends of each branch. These constraints are defined using the following equations:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    h_ij(mathbf V boldsymboltheta) = sqrt  A_ij V_i^4 + B_ij V_i^2 V_j^2 - 2 V_i^3 V_j C_ij cos(theta_ij - phi_ij) + D_ij sin(theta_ij - phi_ij)  \n    h_ji(mathbf V boldsymboltheta) = sqrt  A_ji V_j^4 + B_ji V_i^2 V_j^2 - 2 V_i V_j^3 C_ji cos(theta_ij - phi_ij) + D_ij sin(theta_ij - phi_ij) \nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where coefficients are:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    A_ij = cfracbarg_ij^2 + barb_ij^2tau_ij^4\n    B_ij = cfracg_ij^2 + b_ij^2tau_ij^2\n    C_ij = cfracg_ijbarg_ij + b_ijbarb_ijtau_ij^3\n    D_ij = cfracb_ijbarg_ij - g_ijbarb_ijtau_ij^3\n    A_ji = barg_ij^2 + barb_ij^2\n    B_ji = cfracg_ij^2 + b_ij^2tau_ij^2\n    C_ji = cfracg_ijbarg_ij + b_ijbarb_ijtau_ij\n    D_ji = cfracg_ijbarb_ij - b_ijbarg_ijtau_ij\n endaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Additionally, the values of barg_ij and barb_ij are given by:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    barg_ij = g_ij + g_textsijbarb_ij = b_ij + b_textsij\n endaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Since the quantity under the square root is always positive, these constraints are implemented by squaring them for computational efficiency. Thus, the squared rating constraints for the apparent power flow at the \"from\" and \"to\" bus ends of each branch can be expressed as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    h_ij(mathbf V boldsymboltheta)^2 leq (F_ij^textmax)^2  forall (ij) in mathcalE \n    h_ji(mathbf V boldsymboltheta)^2 leq (F_ij^textmax)^2  forall (ij) in mathcalE\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The second option is to define the longTerm keyword for the active power flow constraints (type = 2) at the \"from\" and \"to\" bus ends of each branch. In this case, the constraints are implemented without squaring the equations, but rather as they are originally defined:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"  beginaligned\n    h_ij(mathbf V boldsymboltheta) =\n    cfrac g_ij + g_textsijtau_ij^2 V_i^2 -\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) + b_ijsin(theta_ij - phi_ij)rightV_iV_j \n    h_ji(mathbf V boldsymboltheta) = (g_ij + g_textsij) V_j^2 -\n    cfrac1tau_ij leftg_ij cos(theta_ij - phi_ij) - b_ij sin(theta_ij- phi_ij)right V_i V_j\n  endaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In our example, we have chosen to utilize this type of flow constraints. To access the flow constraints of branches at the \"from\" bus end, you can use the following code snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.flow.from)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, to acces the \"to\" bus end flow constraints of branches you can use the following code snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.flow.to)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The last option involves defining the longTerm keyword for the current magnitude constraints (type = 3) at the \"from\" and \"to\" bus ends of each branch. In this case, the constraints are implemented as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"  beginaligned\n    h_ij(mathbf V boldsymboltheta) = sqrtA_ijV_i^2 + B_ijV_j^2 - 2V_iV_jC_ij cos(theta_ij - phi_ij) + D_ijsin(theta_ij - phi_ij) \n    h_ji(mathbf V boldsymboltheta) = sqrtA_jiV_j^2 + B_jiV_i^2 - 2V_iV_jC_ji cos(theta_ij - phi_ij) + D_jisin(theta_ij - phi_ij)\n  endaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"These coefficients remain the same as those specified for apparent powers. Similarly, for apparent power, these constraints are reformulated as squared inequalities:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    h_ij(mathbf V boldsymboltheta)^2 leq (F_ij^textmax)^2  forall (ij) in mathcalE \n    h_ji(mathbf V boldsymboltheta)^2 leq (F_ij^textmax)^2  forall (ij) in mathcalE\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACPowerCapabilityConstraintsTutorials","page":"AC Optimal Power Flow","title":"Power Capability Constraints","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The next set of constraints pertains to the minimum and maximum limits of active and reactive power outputs of the generators. These constraints ensure that the power outputs of the generators remain within specified bounds:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"P_textgi^textmin leq P_textgi leq P_textgi^textmax  forall i in mathcalP","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In this representation, the lower and upper limits are determined by the vector mathbfP_textlm = P_textgi^textmin P_textgi^textmax, i in mathcalP. We can access these bounds using the following variable:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₗₘ = [system.generator.capability.minActive system.generator.capability.maxActive]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To access these constraints, you can utilize the following code snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.capability.active)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, constraints related to the minimum and maximum limits of reactive power outputs of the generators ensure that the reactive powers remain within specified boundaries:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Q_textgi^textmin leq Q_textgi leq Q_textgi^textmax  forall i in mathcalP","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Thus, the lower and upper limits are determined by the vector mathbfQ_textlm = Q_textgi^textmin Q_textgi^textmax, i in mathcalP. We can access these bounds using the following variable:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐐ₗₘ = [system.generator.capability.minReactive system.generator.capability.maxReactive]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To access these constraints, you can use the following code snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.constraint.capability.reactive)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"These capability limits of the generators define the feasible region, represented as a gray area in Figure 3, which forms the solution space for the active and reactive output powers of the generators.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<img src=\"../../assets/pq_curve.svg\" class=\"center\" width=\"350\"/>\n<figcaption>Figure 3: The feasible region created by the active and reactive power capability constraints.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"However, this representation might not be the most accurate depiction of the generator's output power behavior. In reality, there exists a tradeoff between the active and reactive power outputs of the generators [1]. Specifically, when a generator operates at its maximum active power P_textgi^textmax, it may not be able to produce the maximum Q_textgi^textmax or minimum Q_textgi^textmin reactive power. To capture this tradeoff, we introduce the ability to include additional upper and lower constraints on the feasible region, leading to its reduction as shown in Figure 4.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<img src=\"../../assets/pq_curve_sloped.svg\" class=\"center\" width=\"350\"/>\n<figcaption>Figure 4: The feasible region created by the active and reactive power capability constraints with additional upper and lower constraints.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"If a user wishes to incorporate the tradeoff between active and reactive power outputs into the optimization model, they can define the points shown in Figure 4 within the addGenerator! function using the following keywords:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Keyword Coordinate\nlowActive P_textgi^textlow\nminLowReactive Q_textgitextlow^textmin\nmaxLowReactive Q_textgitextlow^textmax\nupActive P_textgi^textup\nminUpReactive Q_textgitextup^textmin\nmaxUpReactive Q_textgitextup^textmax","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"When using these points, JuliaGrid constructs two additional capability constraints per generator as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    (Q_textgitextlow^textmax - Q_textgitextup^textmax)P_textgi + (P_textgi^textup - P_textgi^textlow)Q_textgi\n    leq (Q_textgitextlow^textmax - Q_textgitextup^textmax)P_textgi^textlow +  (P_textgi^textup - P_textgi^textlow)Q_textgitextlow^textmax \n    (Q_textgitextup^textmin - Q_textgitextlow^textmin)P_textgi + (P_textgi^textlow - P_textgi^textup)Q_textgi\n    leq (Q_textgitextup^textmin - Q_textgitextlow^textmin)P_textgi^textlow +  (P_textgi^textlow - P_textgi^textup)Q_textgitextlow^textmin\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To ensure numerical stability, these constraints are normalized by introducing two scaling factors:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    s_1 = sqrt(Q_textgitextlow^textmax - Q_textgitextup^textmax)^2 + (P_textgi^textup - P_textgi^textlow)^2\n    s_2 = sqrt(Q_textgitextup^textmin - Q_textgitextlow^textmin)^2 + (P_textgi^textlow - P_textgi^textup)^2\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"When these constraints exist in the system, users can access them using the following variables:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis.constraint.capability.upper\nanalysis.constraint.capability.lower\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"These additional capability constraints allow us to accurately represent the tradeoff between active and reactive power outputs of the generators while maintaining numerical stability.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowSolutionTutorials","page":"AC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the optimal values of active and reactive power outputs for generators and the bus voltage magnitudes and angles, the user needs to invoke the following function:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.set_silent(analysis.jump) # hide\nsolve!(system, analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After solving the AC optimal power flow problem, you can retrieve the vectors of output active and reactive power for generators, denoted as mathbfP_textg = P_textgi and mathbfQ_textg = Q_textgi, where i in mathcalP, using the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₒ = analysis.power.generator.active\n𝐐ₒ = analysis.power.generator.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the resulting bus voltage magnitudes and angles, represented by mathbfV = V_i and bmtheta = theta_i, where i in mathcalN, are stored in the vectors as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐕 = analysis.voltage.magnitude\n𝛉 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"By accessing these vectors, you can analyze and utilize the optimal power flow solution for further studies or operational decision-making in the power system.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACOptimalPowerAnalysisTutorials","page":"AC Optimal Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the power! function, which enables the calculation of powers associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"power!(system, analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses and branches:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Bus Active Reactive\nPower injections mathbfP = P_i mathbfQ = Q_i\nPower injections from the generators mathbfP_texts = P_textsi mathbfQ_texts = Q_textsi\nPower at shunt elements mathbfP_textsh = P_textshi mathbfQ_textsh = Q_textshi","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Branch Active Reactive\nPower flows at \"from\" bus ends mathbfP_texti = P_ij mathbfQ_texti = Q_ij\nPower flows at \"to\" bus ends mathbfP_textj = P_ji mathbfQ_textj = Q_ji\nPower at charging admittances mathbfP_textc = P_textcij mathbfP_textc = P_textcij\nPower at series impedances mathbfP_textl = P_textlij mathbfQ_textl = Q_textlij","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Active-and-Reactive-Power-Injections","page":"AC Optimal Power Flow","title":"Active and Reactive Power Injections","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The computation of active and reactive power injection at buses is expressed by the following equation:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    S_i = P_i + textjQ_i = barV_isumlimits_j = 1^n Y_ij^* barV_j^* forall i in mathcalN","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Active and reactive power injections are stored as the vectors mathbfP = P_i and mathbfQ = Q_i, respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏 = analysis.power.injection.active\n𝐐 = analysis.power.injection.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To recall, when the active or reactive power values are positive, P_i  0 or Q_i  0, it signifies that power is being supplied into the power system from the specific bus. Conversely, negative values, P_i  0 or Q_i  0, indicate that the bus is drawing in active or reactive power from the power system.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Active-and-Reactive-Power-Injections-from-the-Generators","page":"AC Optimal Power Flow","title":"Active and Reactive Power Injections from the Generators","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The power! function in JuliaGrid also provides the computation of active and reactive power injections from the generators at each bus. To calculate the active power supplied by generators to the buses, one can simply sum the active power outputs of the generators obtained from the AC optimal power flow. This can be represented as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    P_textsi = sum_k in mathcalP_i P_textgk forall i in mathcalN","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where the set mathcalP_i subseteq mathcalP encompasses all generators connected to bus i in mathcalN. The active power injections from the generators at each bus are stored as a vector denoted by mathbfP_texts = P_textsi, and can be obtained using the following command:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₛ = analysis.power.supply.active","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, we can obtain the reactive power supplied by generators to the buses:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    Q_textsi = sum_k in mathcalP_i Q_textgk forall  i in mathcalN","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The vector of these reactive power injections by the generators to the buses, denoted by mathbfQ_texts = Q_textsi, can be retrieved using the following command:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐐ₛ = analysis.power.supply.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Active-and-Reactive-Power-at-Shunt-Elements","page":"AC Optimal Power Flow","title":"Active and Reactive Power at Shunt Elements","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the active and reactive power at the shunt element at buses, you can use the following equation:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"  S_textshi = P_textshi + textjQ_textshi = barV_ibarI_textshi^* = y_textshi^*V_i^2 forall i in mathcalN","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The active power demanded by the shunt element at each bus is represented by the vector mathbfP_textsh = P_textshi, while the reactive power injected or demanded by the shunt element at each bus is represented by the vector mathbfQ_textsh = Q_textshi. To retrieve these powers in JuliaGrid, use the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₛₕ = analysis.power.shunt.active\n𝐐ₛₕ = analysis.power.shunt.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The positive active power value P_textshi  0 indicates that the shunt element is consuming active power. In terms of power flow, this signifies that active power flows from bus i in mathcalN towards the ground. On the other hand, a negative reactive power value Q_textshi  0 suggests that the shunt element is injecting reactive power into the power system. This implies that the direction of reactive power is from the ground to bus i in mathcalN, illustrating the capacitive nature of the shunt component. Conversely, if Q_textshi  0, it indicates an inductive characteristic, implying that the shunt component is absorbing reactive power. In this case, the reactive power flows from bus i in mathcalN towards the ground.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Active-and-Reactive-Power-Flows","page":"AC Optimal Power Flow","title":"Active and Reactive Power Flows","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The active and reactive power flow at \"from\" bus end i in mathcalN of branches can be obtained using the following equation:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    S_ij = P_ij + textjQ_ij = barV_ileftcfrac1tau_ij^2(y_ij + y_textsij) barV_i - alpha_ij^*y_ij barV_jright^* forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The resulting active and reactive power flows at each \"from\" bus end are stored as the vectors mathbfP_texti = P_ij and mathbfQ_texti = Q_ij respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ᵢ = analysis.power.from.active\n𝐐ᵢ = analysis.power.from.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, we can determine the active and reactive power flow at the \"to\" bus end j in mathcalN of branches using the equation:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    S_ji = P_ji + textjQ_ji = barV_j left-alpha_ijy_ij barV_i + (y_ij + y_textsij) barV_jright^* forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The vectors of active and reactive power flows at the \"to\" bus end are stored as mathbfP_textj = P_ji and mathbfQ_textj = Q_ji, respectively, and can be retrieved using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ⱼ = analysis.power.to.active\n𝐐ⱼ = analysis.power.to.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Positive values of active or reactive power, such as P_ij  0 or Q_ij  0, indicate power flow originating from the \"from\" bus and moving towards the \"to\" bus. Conversely, negative values, like P_ij  0 or Q_ij  0, denote opposite power flow direction. The same holds true for P_ji  0 or Q_ji  0, indicating power flow from the \"to\" bus towards the \"from\" bus, while negative values, P_ji  0 or Q_ji  0, signify the reverse flow direction. A negative sign generally indicates a power flow direction contrary to the conventional current-defined direction in the Unified Branch Model.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Active-and-Reactive-Power-at-Charging-Admittances","page":"AC Optimal Power Flow","title":"Active and Reactive Power at Charging Admittances","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To compute the active and reactive power associated with charging admittances located near the \"from\" and \"to\" bus ends of branches, the following equation can be utilized:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    S_textcij = P_textcij + textj Q_textcij = alpha_ij barV_i barI_textsi^* + barV_j barI_textsj^* = y_textsij^*(alpha_ij^2 V_i^2 + V_j^2) forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The vectors containing active and reactive power values are stored as mathbfP_textc = P_textcij and mathbfQ_textc = Q_textcij, respectively. You can retrieve these values using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₒ = analysis.power.charging.active\n𝐐ₒ = analysis.power.charging.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Negative values of reactive power Q_textcij  0 signify that the branch injects reactive power due to its charging admittance. This indicates power flow originating from the ground. The negative sign implies that the power flow direction contradicts the assumed direction set by the current through charging admittance in the Unified Branch Model. Furthermore, active powers indicate active losses within the charging admittances of the branch.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Active-and-Reactive-Power-at-Series-Impedances","page":"AC Optimal Power Flow","title":"Active and Reactive Power at Series Impedances","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To compute the active and reactive power across the series impedance of branches, you can use the equation:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    S_textlij = P_textlij + textj Q_textlij = (alpha_ij barV_i - barV_j) barI_textsij^* = y_ij^* (alpha_ij barV_i - barV_j)  (alpha_ij barV_i - barV_j)^*  forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To retrieve the active and reactive power vectors, mathbfP_textl = P_textlij and mathbfQ_textl = Q_textlij, use the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₗ = analysis.power.series.active\n𝐐ₗ = analysis.power.series.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The active power accounts for losses originating from the series resistance r_ij of the branch, while the reactive power represents losses resulting from the inductive characteristics of the impedance defined by series reactance x_ij. This can be observed when the reactive power is positive Q_textlij  0.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Current-Analysis","page":"AC Optimal Power Flow","title":"Current Analysis","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid offers the current! function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"current!(system, analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Bus Magnitude Angle\nCurrent injections mathbfI = I_i bmpsi = psi_i","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Branch Magnitude Angle\nCurrent flows at \"from\" bus ends mathbfI_texti = I_ij bmpsi_texti = psi_ij\nCurrent flows at \"to\" bus ends mathbfI_textj = I_ji bmpsi_textj = psi_ji\nCurrent flows at series impedances mathbfI_texts = I_textsij bmpsi_texts = psi_textsij","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols provided below, as well as for a better grasp of current directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Current-Injections","page":"AC Optimal Power Flow","title":"Current Injections","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the complex current injection at buses, we use the following equation:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    barI_i = I_i texte^textjpsi_i = sumlimits_j = 1^n Y_ij barV_j forall i in mathcalN","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In JuliaGrid, these complex current injections are stored in the vector of magnitudes denoted as mathbfI = I_i and the vector of angles represented as bmpsi = psi_i. You can retrieve them using the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐈 = analysis.current.injection.magnitude\n𝛙 = analysis.current.injection.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Current-Flows","page":"AC Optimal Power Flow","title":"Current Flows","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the complex current flow at \"from\" bus end i in mathcalN of branches, we use the following equation:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    barI_ij = I_ij texte^textjpsi_ij = cfrac1tau_ij^2(y_ij + y_textsij) barV_i - alpha_ij^*y_ij barV_j forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the vectors of magnitudes mathbfI_texti = I_ij and angles bmpsi_texti = psi_ij for the resulting complex current flows, you can use the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐈ᵢ = analysis.current.from.magnitude\n𝛙ᵢ = analysis.current.from.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, we can obtain the complex current flow at \"to\" bus end j in mathcalN of branches:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    barI_ji = I_ji texte^textjpsi_ji = -alpha_ijy_ij barV_i + (y_ij + y_textsij) barV_j forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can obtain the vectors of magnitudes mathbfI_textj = I_ji and angles bmpsi_textj = psi_ji of the resulting complex current flows using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐈ⱼ = analysis.current.to.magnitude\n𝛙ⱼ = analysis.current.to.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Current-Flows-at-Series-Impedances","page":"AC Optimal Power Flow","title":"Current Flows at Series Impedances","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the complex current flow through series impedance of branches in the direction from bus i in mathcalN to bus j in mathcalN, one can use the expression:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    barI_textsij = I_textsij texte^psi_textsij =  y_ij (alpha_ijbarV_i - barV_j)  forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the vectors of magnitudes mathbfI_texts = I_textsij and angles bmpsi_texts = psi_textsij of the resulting complex current flows, one can use the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐈ₛ = analysis.current.series.magnitude\n𝛙ₛ = analysis.current.series.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowSolutionReferenceTutorials","page":"AC Optimal Power Flow","title":"References","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"[1] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER User’s Manual, Version 7.0. 2019.","category":"page"},{"location":"tutorials/acPowerFlow/#ACPowerFlowTutorials","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid utilizes standard network components and leverages the Unified Branch Model to perform power flow analysis, enabling the definition of load profiles, generator capacities, voltage specifications, contingency analysis, and planning.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To begin, the PowerSystem composite type must be provided to JuliaGrid through the use of the powerSystem function, as illustrated by the following example:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, V)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 21.7, reactive = 12.7)\naddBus!(system; label = 3, type = 1, active = 11.2, reactive = -3.0)\naddBus!(system; label = 4, type = 2, conductance = 2.1, susceptance = 1.2)\n\naddBranch!(system; from = 1, to = 2, resistance = 0.02, reactance = 0.06)\naddBranch!(system; from = 1, to = 3, resistance = 0.05, reactance = 0.21)\naddBranch!(system; from = 2, to = 3, resistance = 0.13, reactance = 0.26)\naddBranch!(system; from = 3, to = 4, reactance = 0.17, susceptance = 0.2, conductance = 1e-4)\n\naddGenerator!(system; bus = 1)\naddGenerator!(system; bus = 3, active = 40.0, reactive = 42.4)\nnothing #hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝒩 = collect(keys(sort(system.bus.label)))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"ukw: Notation\nIn this section, when referring to a vector mathbfa, we use the notation mathbfa = a_i or mathbfa = a_ij, where a_i denotes the generic element associated with bus i in mathcalN, and a_ij denotes the generic element associated with branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#BusTypesPowerInjectionsTutorials","page":"AC Power Flow","title":"Bus Types and Power Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As previously demonstrated in the section on the AC Model, we observe the system of equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbfbar I = mathbfY mathbfbar V","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The complex current injection at the bus i in mathcalN is defined as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barI_i = cfracS_i^*barV_i^*","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where barV_i = V_i texte^textjtheta_i. Thus, for any given bus i in mathcalN, we can express it as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  cfracS_i^*barV_i^* = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The complex power injection denoted by S_i comprises of both the active power P_i and reactive power Q_i. This relationship can be represented as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  cfracP_i - textjQ_ibarV_i = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As demonstrated by the above equation, the bus i in mathcalN contains four unknown variables, namely the active power injection P_i, reactive power injection Q_i, bus voltage magnitude V_i, and bus voltage angle theta_i. To solve the system of equations, two variables must be specified for each equation. Although any two variables can be selected mathematically, the choice is determined by the devices that are connected to a particular bus. The standard options are listed in the table below, and these options are used to define the bus types [1].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Bus Type Label Known Unknown\nDemand 1 P_i, Q_i V_i, theta_i\nGenerator 2 P_i, V_i Q_i, theta_i\nSlack 3 V_i, theta_i P_i, Q_i","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Consequently, JuliaGrid operates with sets mathcalN_textpq and mathcalN_textpv that contain demand and generator buses, respectively, and exactly one slack bus in the set mathcalN_textsb. The bus types are stored in the variable:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"system.bus.layout.type","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"It should be noted that JuliaGrid cannot handle systems with multiple slack buses. Additionally, when using functions such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, and gaussSeidel, the bus type can be modified as discussed in the section on Bus Type Modification.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Furthermore, the active power injections P_i and reactive power injections Q_i can be expressed as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  \tP_i = P_textsi - P_textdi \n    Q_i = Q_textsi - Q_textdi\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where P_textdi and Q_textdi denote the active and reactive power demanded at the bus i in mathcalN, while P_textsi and Q_textsi correspond to the active and reactive power injected by the generators at the bus i in mathcalN. ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To provide a more comprehensive understanding, it is important to note that each bus i in mathcalN has the capacity to host multiple generators. This scenario can be conceptualized by introducing the set mathcalP_i, which encompasses all generators connected to bus i in mathcalN. With this perspective in mind, we can calculate the values of P_textsi and Q_textsi as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  \tP_textsi = sum_k in mathcalP_i P_textgk\n     Q_textsi =  sum_k in mathcalP_i Q_textgk\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where P_textgk and Q_textgk represent the active and reactive power outputs of the k-th generator within the set mathcalP_i. ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As a way to summarize, the power injection vectors, represented as mathbfP = P_i and mathbfQ = Q_i can be computed based on the following variables and expressions:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏 = system.bus.supply.active - system.bus.demand.active\n𝐐 = system.bus.supply.reactive - system.bus.demand.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"When the active or reactive power values are positive, P_i  0 or Q_i  0, it signifies that power is being supplied into the power system from the specific bus. This indicates that the generators connected to this bus are producing more power than what the connected load is consuming. Conversely, negative values, P_i  0 or Q_i  0, indicate that the bus is drawing in active or reactive power from the power system. This suggests that the load's demand is exceeding the output from the generators.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#NewtonRaphsonMethodTutorials","page":"AC Power Flow","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Newton-Raphson method is commonly used in AC power flow calculations due to its quadratic rate of convergence. It provides an accurate approximation of the roots of the system of nonlinear equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbff(mathbfx) = mathbf0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This, in turn, allows for the determination of the unknown voltage magnitudes and angles of buses, represented by the state vector mathbf x = mathbf x_a mathbf x_m^T. The state vector comprises two components:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"mathbf x_a in mathbbR^n-1, which holds the bus voltage angles of demand and generator buses, represented by mathbf x_a = theta_i, where i in mathcalN_textpq cup mathcalN_textpv;\nmathbf x_m in mathbbR^n_textpq, which holds the bus voltage magnitudes of demand buses, represented by mathbf x_m = V_i, where i in mathcalN_textpq, and n_textpq = mathcalN_textpq.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Knowing the voltage magnitudes and angles for certain types of buses is a consequence of the structure of the state vector mathbf x. Specifically, the voltage magnitude and angle at the slack bus are known, as well as the voltage magnitude at generator buses.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The complex power injection S_i at a bus i in mathcalN is a function of the complex bus voltages. Therefore, the active and reactive power injection expressions can be defined based on the real and imaginary components of the complex power as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    P_i =V_isumlimits_j=1^n V_j (G_ijcostheta_ij+B_ijsintheta_ij)\n    Q_i =V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij)\n\tendaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Using the above equations, we can define the active power injection function for demand and generator buses as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n   forall i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"and the reactive power injection function for demand buses as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n   forall i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active and reactive mismatches, often denoted as Delta P_i(mathbf x) and Delta Q_i(mathbf x), respectively, are defined as the functions f_P_i(mathbf x) and f_Q_i(mathbf x). The first terms on the right-hand side represent power injections at a bus, while the second term is constant and is obtained based on the active and reactive powers of the generators that supply a bus and active and reactive powers demanded by consumers at the same bus. Therefore, the Newton-Raphson method solves the system of nonlinear equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbff(x) =\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where the first n - 1 equations correspond to demand and generator buses, and the last n_textpq equations correspond to demand buses.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Initialization","page":"AC Power Flow","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To compute the voltage magnitudes and angles of buses using the Newton-Raphson method in JuliaGrid, you must first execute the acModel! function to set up the system, followed by initializing the Newton-Raphson method using the newtonRaphson function. The following code snippet demonstrates this process:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nanalysis = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This results in the creation of the starting vectors of bus voltage magnitudes mathbfV^(0) and angles bmtheta^(0), as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕⁽⁰⁾ = analysis.voltage.magnitude\n𝛉⁽⁰⁾ = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Here, we utilize a \"flat start\" approach in our method. It is important to keep in mind that when dealing with initial conditions in this manner, the Newton-Raphson method may encounter difficulties.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Iterative-Process","page":"AC Power Flow","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To implement the Newton-Raphson method, the iterative approach based on the Taylor series expansion, JuliaGrid provides the mismatch! and solve! functions. These functions are utilized to carry out the Newton-Raphson method iteratively until a stopping criterion is reached, as demonstrated in the following code snippet:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The mismatch! function calculates the mismatch in active power injection for demand and generator buses and the mismatch in reactive power injection for demand buses at each iteration nu = 1 2 dots. The equations used for these computations are:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_P_i(mathbf x^(nu-1)) = V_i^(nu-1)sumlimits_j=1^n V_j^(nu-1)(G_ijcostheta_ij^(nu-1)+B_ijsintheta_ij^(nu-1)) - P_i\n   forall i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"as well as the reactive power injection mismatch for demand buses:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_Q_i(mathbf x^(nu-1)) = V_i^(nu)sumlimits_j=1^n V_j^(nu-1)(G_ijsintheta_ij^(nu-1)-B_ijcostheta_ij^(nu-1)) - Q_i\n   forall i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The resulting vector from these calculations is stored in the mismatch variable of the ACPowerFlow abstract type and can be accessed through the following line of code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐟 = analysis.method.mismatch","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In addition to computing the mismatches in active and reactive power injection, the mismatch! function also returns the maximum absolute values of these mismatches. These maximum values are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion epsilon:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  max f_P_i(mathbf x^(nu-1)) forall i in mathcalN_textpq cup mathcalN_textpv   epsilon \n  max f_Q_i(mathbf x^(nu-1)) forall i in mathcalN_textpq   epsilon","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the function solve! computes the increments of bus voltage angle and magnitude at each iteration using the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbfDelta mathbfx^(nu-1) = -mathbfJ(mathbfx^(nu-1))^-1 mathbff(mathbfx^(nu-1))","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where mathbfDelta mathbfx = mathbf Delta mathbf x_a mathbf Delta mathbf x_m^T consists of the vector of bus voltage angle increments mathbf Delta mathbf x_a in mathbbR^n-1 and bus voltage magnitude increments mathbf Delta mathbf x_m in mathbbR^n_textpq, and mathbfJ(mathbfx) in mathbbR^n_textu times n_textu is the Jacobian matrix, n_textu = n + n_textpq - 1. These values are stored in the ACPowerFlow abstract type and can be accessed after each iteration using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚫𝐱 = analysis.method.increment\n𝐉 = analysis.method.jacobian","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The JuliaGrid implementation of the AC power flow follows a specific order to store the increment and mismatch vectors. The first n-1 elements of both vectors correspond to the demand and generator buses in the same order as they appear in the input data. This order is not obtained by first extracting the demand and then generator buses but by excluding the slack bus in the input data. The first n-1 elements of the increment vector correspond to the voltage angle increments, while the first n-1 elements of the mismatch vector correspond to the mismatch in active power injections. The last n_textpq elements of the increment and mismatch vectors correspond to the demand buses in the order they appear in the input data. For the increment vector, it matches the bus voltage magnitude increments, while for the mismatch vector, it matches the mismatch in reactive power injections. As a analysis, this order defines the row and column order of the Jacobian matrix mathbfJ(mathbfx).","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Finally, the function solve! adds the computed increment term to the previous solution to obtain a new solution:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf x^(nu) = mathbf x^(nu-1) + mathbf Delta mathbf x^(nu-1)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The bus voltage magnitudes mathbfV = V_i and angles bmtheta = theta_i are then updated based on the obtained solution mathbf x. It is important to note that only the voltage magnitudes related to demand buses and angles related to demand and generator buses are updated; not all values are updated. Therefore, the final solution obtained by JuliaGrid is stored in the following vectors:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕 = analysis.voltage.magnitude\n𝛉 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Jacobian-Matrix","page":"AC Power Flow","title":"Jacobian Matrix","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To complete the tutorial on the Newton-Raphson method, we will now describe the Jacobian matrix and provide the equations involved in its evolution. Without loss of generality, we assume that the slack bus is the first bus, followed by the set of demand buses and the set of generator buses:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathcalN_textsb =  1  \n    mathcalN_textpq = 2 dots m \n    mathcalN_textpv = m + 1dots n\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where mathcalN = mathcalN_textsb cup mathcalN_textpq cup mathcalN_textpv. Therefore, we can express:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathbf x_a = theta_2dotstheta_n^T  mathbf Delta mathbf x_a = Delta theta_2dotsDelta theta_n^T \n    mathbf x_m = V_2dotsV_m^T  mathbf Delta mathbf x_m = Delta V_2dotsDelta V_m^T\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Jacobian matrix mathbfJ(x^(nu)) in mathbbR^n_textu times n_textu is:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbfJ(x^(nu))=\n  left\n  beginarraycccccc\n  cfracmathrm partialf_P_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_m\n  vdots  \n  cfracmathrm partialf_P_n(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_m 10pt\n  hline \n  cfracmathrm partialf_Q_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_m\n  vdots  \n  cfracmathrm partialf_Q_m(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_m\n  endarray\n  right","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Jacobian matrix can be expressed using four block matrices:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"\tmathbfJ(x^(nu)) =\n  beginbmatrix\n    mathbfJ_11(x^(nu)) mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu)) \n\t   mathbfJ_22(x^(nu))\n  endbmatrix","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where diagonal elements of the Jacobian sub-matrices are defined as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu)) mathrm partial theta_i =\n  V_i^(nu)sumlimits_j=1^n V_j^(nu)(-G_ij\n  sintheta_ij^(nu)+B_ijcostheta_ij^(nu)) - (V_i^(nu))^2B_ii\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_i^(nu) = sumlimits_\n  j=1^n V_j^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))+V_i^(nu) G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_i=V_i^(nu)\n  sumlimits_j=1^n V_j^(nu)\n  (G_ijcostheta_ij^(nu)+B_ijsintheta_ij^(nu))- (V_i^(nu))^2G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial V_i=sumlimits_j=1\n  ^n V_j^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))-V_i^(nu) B_ii\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"while non-diagonal elements of the Jacobian sub-matrices are:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu))\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_j^(nu) = V_i^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (-G_ijcostheta_ij^(nu) -B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))mathrm\n  partial V_j=V_i^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#FastNewtonRaphsonMethodTutorials","page":"AC Power Flow","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Although the fast Newton-Raphson method may converge more slowly than the traditional Newton-Raphson method, the shorter solution time for the updates often compensates for this slower convergence, resulting in a shorter overall solution time. This is particularly true for systems that are not heavily loaded, where a shorter overall solution time is almost always achieved. It is important to note that if the algorithm converges, it will converge to a correct solution [2].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The fast Newton-Raphson method involves decoupling the power flow equations. Namely, the Newton-Raphson method is based on the equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginbmatrix\n    mathbfJ_11(x) mathbfJ_12(x)  mathbfJ_21(x) \n\t   mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbf Delta mathbf x_a  mathbf Delta mathbf x_m\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where the iteration index has been omitted for simplicity. However, in transmission grids, there exists a strong coupling between active powers and voltage angles, as well as between reactive powers and voltage magnitudes. To achieve decoupling, two conditions must be satisfied: first, the resistance values r_ij of the branches must be small compared to their reactance values x_ij, and second, the angle differences must be small, i.e., theta_ij approx 0 [3]. Therefore, starting from the above equation, we have:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginbmatrix\n    mathbfJ_11(x)  mathbf0  mathbf0  mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbf Delta mathbf x_a  mathbf Delta mathbf x_m\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"which gives the decoupled system as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathbff_P(mathbf x) = -mathbfJ_11(x) mathbf Delta mathbf x_a \n    mathbff_Q(mathbf x) = -mathbfJ_22(x) mathbf Delta mathbf x_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To examine the problem, it is helpful to express it as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = -Delta theta_2cfracmathrm partialf_P_2(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_2(mathbf x)mathrm partial theta_n \n     vdots \n    f_P_n(mathbf x) = -Delta theta_2cfracmathrm partialf_P_n(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_i(mathbf x)mathrm partial theta_n\n    f_Q_2(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_n_textpq cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n     vdots \n    f_Q_m(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_m cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Firstly, the second part of the expressions is expanded as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  f_Q_2(mathbf x) =\n  -cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n   vdots \n  f_Q_m(mathbf x) =\n  - cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the Jacobian elements are derived. To achieve this, we can use the expressions defined for the Newton-Raphson method. For demand buses, the above expansions are applied as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  V_isumlimits_j=1^n V_j(-G_ij\n  sintheta_ij+B_ijcostheta_ij) - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = V_isumlimits_j=1\n  ^n V_j(G_ijsintheta_ij-\n  B_ijcostheta_ij)-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As the definition of reactive power is given by the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  Q_i =V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"the Jacobian elements can be expressed in the following manner:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  -Q_i - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = Q_i-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The decoupled model is established through the following approximations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    sin(theta_ij) approx 0 \n    cos(theta_ij) approx 1 \n    Q_i  B_iiV_i^2\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Thus, when the approximations are made, the Jacobian elements are simplified, resulting in the decoupled model where the Jacobian elements are:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i = -V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_j = -V_iV_jB_ij\n  V_i cfracmathrm partialf_Q_i(mathbf x) mathrm partial V_i = -V_i^2B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrmpartial V_j =  -V_iV_jB_ij\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Thus, the initial system of equations becomes:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = V_2^2B_22 Delta theta_2 + cdots + V_2V_nB_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_2V_nB_n2 Delta theta_2 + cdots + V_n^2B_nn Delta theta_n \n    f_Q_2(mathbf x) = V_2^2B_22 cfracDelta V_2V_2 + cdots +\n     V_2V_mB_2m cfracDelta V_mV_m \n     vdots \n    f_Q_m(mathbf x) = V_2V_mB_m2 cfracDelta V_2V_2 + cdots +\n    V_m^2 B_mm cfracDelta V_mV_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Using V_j approx 1, wherein V_i^2 = V_iV_j j=i, the first part of the equations can be simplified to:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = V_2B_22 Delta theta_2 + cdots + V_2B_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_nB_n2 Delta theta_2 + cdots + V_nB_nn Delta theta_n\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, the second part of the equations can be simplified to:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_Q_2(mathbf x) = V_2B_22 Delta V_2 + cdots +\n     V_2 B_2m Delta V_m\n    \n     vdots \n    f_Q_m(mathbf x) = V_mB_m2 Delta V_2 + cdots +\n    V_m B_mm Delta V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The fast Newton-Raphson method is ultimately based on the system of equations presented below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    cfracf_P_2(mathbf x)V_2 = B_22 Delta theta_2 + cdots + B_2n Delta theta_n \n     vdots \n    cfracf_P_n(mathbf x)V_n = B_n2 Delta theta_2 + cdots + B_nn Delta theta_n \n    cfracf_Q_2(mathbf x)V_2 = B_22 Delta V_2 + cdots + B_2m Delta V_m \n     vdots \n    cfracf_Q_m(mathbf x)V_m = B_m2 Delta V_2 + cdots +\n    B_mm Delta V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This system can be rewritten as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathbfh_P(mathbf x) = mathbfB_1 mathbf Delta mathbf x_a \n    mathbfh_Q(mathbf x) = mathbfB_2 mathbf Delta mathbf x_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"One of the main advantages of this approach is that the Jacobian matrices mathbfB_1 and mathbfB_2 are constant and need only be formed once. Furthermore, this method can be used to define both the XB and BX versions of the fast Newton-Raphson method.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#XB-Version","page":"AC Power Flow","title":"XB Version","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The matrix mathbfB_1 is formed by neglecting the resistance r_ij, shunt susceptance Im  y_textshi , charging susceptance Im  y_textsij , and transformer tap ratio magnitude tau_ij. The matrix mathbfB_2 is constructed by disregarding the transformer phase shift angle phi_ij. This approach corresponds to the standard fast Newton-Raphson method and is known to exhibit exceptional convergence properties in typical scenarios [3].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To initialize the XB version of the fast Newton-Raphson method, one can utilize the following code snippet:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nanalysis = fastNewtonRaphsonXB(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#BX-Version","page":"AC Power Flow","title":"BX Version","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The matrix mathbfB_1 ignores the shunt susceptanceIm  y_textshi , charging susceptance Im  y_textsij , and transformer tap ratio magnitude tau_ij. The matrix mathbfB_2 ignores the resistance r_ij and transformer phase shift angle phi_ij. In usual cases, the iteration count for the BX version is comparable to the XB scheme. However, for systems with high r_ijx_ij ratios, the BX scheme requires considerably fewer iterations than the XB scheme to solve the power flow [3].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To initialize the BX version of the fast Newton-Raphson method, you can use the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nanalysis = fastNewtonRaphsonBX(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Initialization-2","page":"AC Power Flow","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"When a user creates the fast Newton-Raphson method in JuliaGrid, the Jacobian matrices mathbfB_1 and mathbfB_2 are formed to correspond to the active and reactive power equations, respectively. You can access these matrices using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐁₁ = analysis.method.active.jacobian\n𝐁₂ = analysis.method.reactive.jacobian","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, JuliaGrid utilizes the LU factorization of matrices mathbfB_1 and mathbfB_2 to compute solutions through iterations, which can be accessed using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis.method.active.factorization\nanalysis.method.reactive.factorization","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Additionally, during this stage, JuliaGrid generates the starting vectors for bus voltage magnitudes mathbfV^(0) and angles bmtheta^(0) as demonstrated below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕⁽⁰⁾ = analysis.voltage.magnitude\n𝛉⁽⁰⁾ = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Iterative-Process-2","page":"AC Power Flow","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid offers the mismatch! and solve! functions to implement the fast Newton-Raphson method iterations. These functions are used iteratively until a stopping criterion is met, as shown in the code snippet below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The functions mathbff_P(mathbf x) and mathbff_Q(mathbf x) remain free of approximations, with only the calculation of the state variable increments affected [2]. As a result, we still use the following equations to compute the mismatches:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     forall i in mathcalN_textpq cup mathcalN_textpv\n    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     forall i in mathcalN_textpq\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Therefore, the mismatch! function calculates the mismatch in active power injection for demand and generator buses and the mismatch in reactive power injection for demand buses at each iteration nu = 1 2 dots:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  h_P_i(mathbf x^(nu-1)) =\n  sumlimits_j=1^n V_j^(nu-1)(G_ijcostheta_ij^(nu-1)+B_ijsintheta_ij^(nu-1)) - cfracP_iV_i^(nu-1)\n   forall i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"and in reactive power injection for PQ buses as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    h_Q_i(mathbf x^(nu-1)) =\n    sumlimits_j=1^n V_j^(nu-1) (G_ijsintheta_ij^(nu-1)-B_ijcostheta_ij^(nu-1)) - cfracQ_iV_i^(nu-1)\n     forall i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The resulting vectors from these calculations are stored in the ACPowerFlow abstract type and can be accessed through the following:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐡ₚ = analysis.method.active.increment\n𝐡ₒ = analysis.method.reactive.increment","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In addition to computing the mismatches in active and reactive power injection, the mismatch! function also returns the maximum absolute values of these mismatches. These maximum values are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion epsilon:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  max h_P_i(mathbf x^(nu)) forall i in mathcalN_textpq cup mathcalN_textpv   epsilon \n  max h_Q_i(mathbf x^(nu)) forall i in mathcalN_textpq   epsilon","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the function solve! computes the bus voltage angle increments:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf Delta mathbf x_a^(nu-1) = mathbfB_1^-1 mathbfh_P(mathbf x_a^(nu-1) mathbf x_m^(nu-1))","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vector of increments that corresponds to the active power equations can be accessed using the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚫𝐱ₐ = analysis.method.active.increment","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The solution is then updated as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf x_a^(nu) = mathbf x_a^(nu-1) + mathbf Delta mathbf x_a^(nu-1)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"It is important to note that only the voltage angles related to demand and generator buses are updated, while the vector of bus voltage angles of all buses is stored:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝛉 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The fast Newton-Raphson method then solves the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf Delta mathbf x_m^(nu-1) = mathbfB_2^-1 mathbfh_Q(mathbf x_a^(nu) mathbf x_m^(nu-1))","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vector of increments that corresponds to the reactive power equations can be accessed using the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚫𝐱ₘ = analysis.method.active.increment","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Finally, the solution is updated as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf x_m^(nu) = mathbf x_m^(nu-1) + mathbf Delta mathbf x_m^(nu-1)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Again, it is important to note that only the the voltage magnitudes of demand buses are updated, while the vector of bus voltage magnitude for all buses is stored:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕 = analysis.voltage.magnitude","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#GaussSeidelMethodTutorials","page":"AC Power Flow","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"By defining the complex current injection at bus i in mathcalN as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"\tbarI_i = fracP_i - jQ_ibarV_i^*","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"the power flow problem can be represented as the system of equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This system of equations can be expanded to n complex equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    Y_11  barV_1 + cdots+ Y_1nbarV_n = fracP_1 - jQ_1barV_1^* \n     vdots  \n    Y_n1  barV_1 + cdots+ Y_nnbarV_n = fracP_n - jQ_nbarV_n^*\n\tendaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"While the Gauss-Seidel method directly solves the system of equations, it suffers from very slow convergence, which increases almost linearly with the system size, necessitating numerous iterations to obtain the desired solution [4]. Moreover, the convergence time of the Gauss-Seidel method increases significantly for large-scale systems and can face convergence issues for systems with high active power transfers. Nevertheless, power flow programs utilize both the Gauss-Seidel and Newton-Raphson methods in a complementary manner. Specifically, the Gauss-Seidel method is employed to obtain a quick approximate solution from a \"flat start\", while the Newton-Raphson method is utilized to obtain the final accurate solution [5].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Gauss-Seidel method is typically based on the system of equations with n complex equations, one of which represents the slack bus. As a result, one equation can be eliminated, resulting in a power flow problem with n-1 equations.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Initialization-3","page":"AC Power Flow","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid provides a way to utilize the Gauss-Seidel method for solving the AC power flow problem and determining the magnitudes and angles of bus voltages. To use this method, we need to execute the acModel! function first to set up the system and then initialize the Gauss-Seidel method using the gaussSeidel function. The code snippet below demonstrates this process:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nanalysis = gaussSeidel(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This results in the creation of the starting vectors of bus voltage magnitudes mathbfV^(0) and angles bmtheta^(0), as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕⁽⁰⁾ = analysis.voltage.magnitude\n𝛉⁽⁰⁾ = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Iterative-Process-3","page":"AC Power Flow","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid offers the mismatch! and solve! functions to implement the Gauss-Seidel method iterations. These functions are used iteratively until a stopping criterion is met, as shown in the code snippet below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:300\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In contrast to the Newton-Raphson and Fast Newton-Raphson methods, the Gauss-Seidel method does not require the calculation of the mismatch in active and reactive power injection at each iteration. Instead, the mismatch! function is used solely to verify the convergence criteria. At each iteration nu = 1 2 dots, we calculate the active power injection mismatch for demand and generator buses, as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_P_i(mathbf x^(nu-1)) = RebarV_i^(nu - 1) barI_i^*(nu - 1) - P_i  forall i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We also compute the reactive power injection mismatch for demand buses, given by:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_Q_i(mathbf x^(nu-1)) = ImbarV_i^(nu - 1) barI_i^*(nu - 1) - Q_i  forall i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"However, these mismatches are not stored as they are only used to obtain the maximum absolute values of these mismatches. The maximum values of these mismatches are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion epsilon, as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  max f_P_i(mathbf x^(nu-1)) forall i in mathcalN_textpq cup mathcalN_textpv   epsilon \n  max f_Q_i(mathbf x^(nu-1)) forall i in mathcalN_textpq   epsilon","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After initializing complex bus voltages barV_i^(0) for all buses in the power system, the function solve! proceeds to compute the voltages for demand buses using the Gauss-Seidel method:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barV_i^(nu) =\n  cfrac1Y_ii Bigg(cfracP_i - jQ_ibarV_i^*(nu-1) -\n  sumlimits_substackj = 1^i - 1 Y_ijbarV_j^(nu) -\n  sumlimits_substackj = i + 1^n Y_ijbarV_j^(nu-1)Bigg)\n   forall i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The next step is to determine the solution for generator buses in two stages: first, the reactive power injection is calculated, and then the bus complex voltage is updated using the following equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    Q_i^(nu) =\n    -Im left barV_i^*(nu) sumlimits_j=1^n Y_ijbarV_j^(nu)right  forall i in mathcalN_textpv \n    barV_i^(nu ) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_i^(nu)barV_i^*(nu )-\n    sumlimits_substackj = 1j neq i^n Y_ijbarV_j^(nu) Bigg)  forall i in mathcalN_textpv\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The obtained voltage magnitude may not be equal to the magnitude specified for the generator bus, so a voltage correction step is necessary:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barV_i^(nu) = V_i^(0) cfracbarV_i^(nu)V_i^(nu)  forall i in mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid stores the final results in vectors that contain all bus voltage magnitudes and angles:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕 = analysis.voltage.magnitude\n𝛉 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#ACPowerAnalysisTutorials","page":"AC Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the power! function, which enables the calculation of powers associated with buses, branches, and generators. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power!(system, analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses, branches, and generators:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Bus Active Reactive\nPower injections mathbfP = P_i mathbfQ = Q_i\nPower injections from the generators mathbfP_texts = P_textsi mathbfQ_texts = Q_textsi\nPower at shunt elements mathbfP_textsh = P_textshi mathbfQ_textsh = Q_textshi","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Branch Active Reactive\nPower flows at \"from\" bus ends mathbfP_texti = P_ij mathbfQ_texti = Q_ij\nPower flows at \"to\" bus ends mathbfP_textj = P_ji mathbfQ_textj = Q_ji\nPower at charging admittances mathbfP_textc = P_textcij mathbfP_textc = P_textcij\nPower at series impedances mathbfP_textl = P_textlij mathbfQ_textl = Q_textlij","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Generator Active Reactive\nPower outputs mathbfP_textg = P_textgi mathbfQ_textg = Q_textgi","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Active-and-Reactive-Power-Injections","page":"AC Power Flow","title":"Active and Reactive Power Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The computation of active and reactive power injection at buses is expressed by the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    S_i = P_i + textjQ_i = barV_isumlimits_j = 1^n Y_ij^* barV_j^* forall i in mathcalN","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Active and reactive power injections are stored as the vectors mathbfP = P_i and mathbfQ = Q_i, respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏 = analysis.power.injection.active\n𝐐 = analysis.power.injection.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To recall, when the active or reactive power values are positive, P_i  0 or Q_i  0, it signifies that power is being supplied into the power system from the specific bus. Conversely, negative values, P_i  0 or Q_i  0, indicate that the bus is drawing in active or reactive power from the power system.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Active-and-Reactive-Power-Injections-from-the-Generators","page":"AC Power Flow","title":"Active and Reactive Power Injections from the Generators","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The power! function in JuliaGrid also computes the active and reactive power injections from the generators at each bus. The active power supplied by the generators to the buses can be calculated by summing the given generator active powers in the input data, except for the slack bus, which can be determined as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  P_textsi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where P_textdi represents the active power demanded by consumers at the slack bus. The active power injections from the generators at each bus are stored as the vector, denoted by mathbfP_texts = P_textsi, can be obtained using the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₛ = analysis.power.supply.active","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The calculation of reactive power injection from the generators at generator or slack buses can be achieved using the subsequent equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  Q_textsi = Q_i + Q_textdi forall i in mathcalN_textpv cup mathcalN_textsb","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where Q_textdi represents the reactive power demanded by consumers at the corresponding bus. Further, the reactive power injected by the generators at buses from mathcalN_textpq can be calculated by summing the given generator reactive powers in the input data. The vector of these reactive power injections by the generators to the buses, denoted by mathbfQ_texts = Q_textsi, can be retrieved using the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐐ₛ = analysis.power.supply.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Active-and-Reactive-Power-at-Shunt-Elements","page":"AC Power Flow","title":"Active and Reactive Power at Shunt Elements","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the active and reactive power at the shunt element at buses, you can use the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  S_textshi = P_textshi + textjQ_textshi = barV_ibarI_textshi^* = y_textshi^*V_i^2 forall i in mathcalN","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active power demanded by the shunt element at each bus is represented by the vector mathbfP_textsh = P_textshi, while the reactive power injected or demanded by the shunt element at each bus is represented by the vector mathbfQ_textsh = Q_textshi. To retrieve these powers in JuliaGrid, use the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₛₕ = analysis.power.shunt.active\n𝐐ₛₕ = analysis.power.shunt.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The positive active power value P_textshi  0 indicates that the shunt element is consuming active power. In terms of power flow, this signifies that active power flows from bus i in mathcalN towards the ground. On the other hand, a negative reactive power value Q_textshi  0 suggests that the shunt element is injecting reactive power into the power system. This implies that the direction of reactive power is from the ground to bus i in mathcalN, illustrating the capacitive nature of the shunt component. Conversely, if Q_textshi  0, it indicates an inductive characteristic, implying that the shunt component is absorbing reactive power. In this case, the reactive power flows from bus i in mathcalN towards the ground.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Active-and-Reactive-Power-Flows","page":"AC Power Flow","title":"Active and Reactive Power Flows","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active and reactive power flow at \"from\" bus end i in mathcalN of branches can be obtained using the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  S_ij = P_ij + textjQ_ij = barV_ileftcfrac1tau_ij^2(y_ij + y_textsij) barV_i - alpha_ij^*y_ij barV_jright^* forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The resulting active and reactive power flows at each \"from\" bus end are stored as the vectors mathbfP_texti = P_ij and mathbfQ_texti = Q_ij respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ᵢ = analysis.power.from.active\n𝐐ᵢ = analysis.power.from.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, we can determine the active and reactive power flow at the \"to\" bus end j in mathcalN of branches using the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  S_ji = P_ji + textjQ_ji = barV_j left-alpha_ijy_ij barV_i + (y_ij + y_textsij) barV_jright^* forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vectors of active and reactive power flows at the \"to\" bus end are stored as mathbfP_textj = P_ji and mathbfQ_textj = Q_ji, respectively, and can be retrieved using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ⱼ = analysis.power.to.active\n𝐐ⱼ = analysis.power.to.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Positive values of active or reactive power, such as P_ij  0 or Q_ij  0, indicate power flow originating from the \"from\" bus and moving towards the \"to\" bus. Conversely, negative values, like P_ij  0 or Q_ij  0, denote opposite power flow direction. The same holds true for P_ji  0 or Q_ji  0, indicating power flow from the \"to\" bus towards the \"from\" bus, while negative values, P_ji  0 or Q_ji  0, signify the reverse flow direction. A negative sign generally indicates a power flow direction contrary to the conventional current-defined direction in the Unified Branch Model.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Active-and-Reactive-Power-at-Charging-Admittances","page":"AC Power Flow","title":"Active and Reactive Power at Charging Admittances","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To compute the active and reactive power associated with charging admittances located near the \"from\" and \"to\" bus ends of branches, the following equation can be utilized:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  S_textcij = P_textcij + textj Q_textcij = alpha_ij barV_i barI_textsi^* + barV_j barI_textsj^* = y_textsij^*(alpha_ij^2 V_i^2 + V_j^2) forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vectors containing active and reactive power values are stored as mathbfP_textc = P_textcij and mathbfQ_textc = Q_textcij, respectively. You can retrieve these values using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₒ = analysis.power.charging.active\n𝐐ₒ = analysis.power.charging.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Negative values of reactive power Q_textcij  0 signify that the branch injects reactive power due to its charging admittance. This indicates power flow originating from the ground. The negative sign implies that the power flow direction contradicts the assumed direction set by the current through charging admittance in the Unified Branch Model. Furthermore, active powers indicate active losses within the charging admittances of the branch.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Active-and-Reactive-Power-at-Series-Impedances","page":"AC Power Flow","title":"Active and Reactive Power at Series Impedances","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To compute the active and reactive power across the series impedance of branches, you can use the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  S_textlij = P_textlij + textj Q_textlij = (alpha_ij barV_i - barV_j) barI_textsij^* = y_ij^* (alpha_ij barV_i - barV_j) (alpha_ij barV_i - barV_j)^*  forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To retrieve the active and reactive power vectors, mathbfP_textl = P_textlij and mathbfQ_textl = Q_textlij, use the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₗ = analysis.power.series.active\n𝐐ₗ = analysis.power.series.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active power accounts for losses originating from the series resistance r_ij of the branch, while the reactive power represents losses resulting from the inductive characteristics of the impedance defined by series reactance x_ij. This can be observed when the reactive power is positive Q_textlij  0.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Generators-Active-and-Reactive-Power-Outputs","page":"AC Power Flow","title":"Generators Active and Reactive Power Outputs","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the output active powers of each generator connected to bus i in mathcalN_textpq cup mathcalN_textpv, the given active power in the input data is utilized. For the generator connected to the slack bus, the output active power is determined using the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  P_textgi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In the case of multiple generators connected to the slack bus, the first generator in the input data is assigned the obtained value of P_textgi. Then, this amount of power is reduced by the output active power of the other generators. ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To retrieve the vector of active power outputs of generators, denoted as mathbfP_textg = P_textgi, i in mathcalP, where the set mathcalP represents the set of generators, users can utilize the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₒ = analysis.power.generator.active","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The output reactive powers of each generator located at the bus is obtained as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  Q_textgi = Q_i + Q_textdi i in mathcalN","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"If there are multiple generators at the same bus, the reactive power is allocated proportionally among the generators based on their reactive power capabilities. ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To retrieve the vector of reactive power outputs of generators, denoted as mathbfQ_textg = Q_textgi, i in mathcalP, users can utilize the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐐ₒ = analysis.power.generator.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#ACCurrentAnalysisTutorials","page":"AC Power Flow","title":"Current Analysis","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid offers the current! function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"current!(system, analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Bus Magnitude Angle\nCurrent injections mathbfI = I_i bmpsi = psi_i","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Branch Magnitude Angle\nCurrent flows at \"from\" bus ends mathbfI_texti = I_ij bmpsi_texti = psi_ij\nCurrent flows at \"to\" bus ends mathbfI_textj = I_ji bmpsi_textj = psi_ji\nCurrent flows at series impedances mathbfI_texts = I_textsij bmpsi_texts = psi_textsij","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols provided below, as well as for a better grasp of current directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-Injections","page":"AC Power Flow","title":"Current Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the complex current injection at buses, we use the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barI_i = I_i texte^textjpsi_i = sumlimits_j = 1^n Y_ij barV_j forall i in mathcalN","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In JuliaGrid, these complex current injections are stored in the vector of magnitudes denoted as mathbfI = I_i and the vector of angles represented as bmpsi = psi_i. You can retrieve them using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈 = analysis.current.injection.magnitude\n𝛙 = analysis.current.injection.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-Flows","page":"AC Power Flow","title":"Current Flows","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the complex current flow at \"from\" bus end i in mathcalN of branches, we use the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barI_ij = I_ij texte^textjpsi_ij = cfrac1tau_ij^2(y_ij + y_textsij) barV_i - alpha_ij^*y_ij barV_j forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the vectors of magnitudes mathbfI_texti = I_ij and angles bmpsi_texti = psi_ij for the resulting complex current flows, you can use the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈ᵢ = analysis.current.from.magnitude\n𝛙ᵢ = analysis.current.from.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, we can obtain the complex current flow at \"to\" bus end j in mathcalN of branches:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barI_ji = I_ji texte^textjpsi_ji = -alpha_ijy_ij barV_i + (y_ij + y_textsij) barV_j forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can obtain the vectors of magnitudes mathbfI_textj = I_ji and angles bmpsi_textj = psi_ji of the resulting complex current flows using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈ⱼ = analysis.current.to.magnitude\n𝛙ⱼ = analysis.current.to.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-Flows-at-Series-Impedances","page":"AC Power Flow","title":"Current Flows at Series Impedances","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the complex current flow through series impedance of branches in the direction from bus i in mathcalN to bus j in mathcalN, one can use the expression:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barI_textsij = I_textsij texte^psi_textsij = y_ij (alpha_ijbarV_i - barV_j)  forall (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the vectors of magnitudes mathbfI_texts = I_textsij and angles bmpsi_texts = psi_textsij of the resulting complex current flows, one can use the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈ₛ = analysis.current.series.magnitude\n𝛙ₛ = analysis.current.series.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#PowerFlowSolutionReferenceTutorials","page":"AC Power Flow","title":"References","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[1] A. Wood and B. Wollenberg, Power Generation, Operation, and Control, ser. A Wiley-Interscience publication. Wiley, 1996.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[2] G. Andersson, Modelling and analysis of electric power systems, EEH-Power Systems Laboratory, Swiss Federal Institute of Technology (ETH), Zürich, Switzerland (2008).","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[3] R. A. M. van Amerongen, \"A general-purpose version of the fast decoupled load flow,\" IEEE Trans. Power Syst., vol. 4, no. 2, pp. 760-770, May 1989.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[4] D. P. Chassin, P. R. Armstrong, D. G. Chavarria-Miranda, and R. T. Guttromson, \"Gauss-seidel accelerated: implementing flow solvers on field programmable gate arrays,\" in Proc. IEEE PES General Meeting, 2006, pp. 5.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[5] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER User’s Manual, Version 7.0. 2019.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowTutorials","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To begin, the PowerSystem composite type must be provided to JuliaGrid through the use of the powerSystem function, as illustrated by the following example:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, HiGHS\n@default(template) # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, angle = 0.17)\naddBus!(system; label = 2, type = 2, active = 0.1, conductance = 0.04)\naddBus!(system; label = 3, type = 1, active = 0.05)\n\n@branch(minDiffAngle = -pi, maxDiffAngle = pi)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05, longTerm = 0.15)\naddBranch!(system; label = 2, from = 1, to = 3, reactance = 0.01, longTerm = 0.10)\naddBranch!(system; label = 3, from = 2, to = 3, reactance = 0.01, longTerm = 0.25)\n\n@generator(minActive = 0.0)\naddGenerator!(system; label = 1, bus = 1, active = 3.2, maxActive = 0.5)\naddGenerator!(system; label = 2, bus = 2, active = 0.2, maxActive = 0.3)\n\ncost!(system; label = 1, active = 2, polynomial = [1100.2; 500; 80])\ncost!(system; label = 2, active = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])\n\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system. This can be visualized as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝒩 = collect(keys(sort(system.bus.label)))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Moreover, we identify the set of generators as mathcalP = 1 dots n_g within the power system. For the specific example at hand, it can be represented as:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝒫 = collect(keys(sort(system.generator.label)))","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"ukw: Notation\nIn this section, when referring to a vector mathbfa, we use the notation mathbfa = a_i or mathbfa = a_ij, where a_i denotes the generic element associated with bus i in mathcalN or generator i in mathcalP, while a_ij denotes the generic element associated with branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowModelTutorials","page":"DC Optimal Power Flow","title":"Optimal Power Flow Model","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the DC optimal power flow, the active power outputs of the generators mathbf P_textg = P_textgi, i in mathcalP, are represented as linear functions of the bus voltage angles boldsymboltheta = theta_i, i in mathcalN. Therefore, the optimization variables in this model are the active power outputs of the generators and the bus voltage angles. The DC optimal power flow model has the form:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"beginaligned\n     textminimize   sum_i in mathcalP f_i(P_textgi) \n     textsubjectto    theta_i - theta_textslack = 0 i in mathcalN_textsb  3pt\n       h_P_i(mathbf P_textg boldsymboltheta) = 0  forall i in mathcalN 3pt\n       theta_ij^textmin leq theta_i - theta_j leq theta_ij^textmax forall (ij) in mathcalE 3pt\n        - P_ij^textmax leq h_P_ij(theta_i theta_j) leq P_ij^textmax forall (ij) in mathcalE 3pt\n       P_textgi^textmin leq P_textgi leq P_textgi^textmax  forall i in mathcalP\nendaligned","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Essentially, the DC optimal power flow is focused on the minimization of the objective function related to the costs associated with the active power output of generators, all while ensuring the satisfaction of various constraints. This optimization task holds a crucial role in the efficient and timely management of electrical power systems. However, it is important to note that the solutions provided by the DC optimal power flow are approximate in nature.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Build-Optimal-Power-Flow-Model","page":"DC Optimal Power Flow","title":"Build Optimal Power Flow Model","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To build the DC optimal power flow model, we must first load the power system and establish the DC model using the following function:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Afterward, the DC optimal power flow model is created using the dcOptimalPowerFlow function:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Optimization-Variables","page":"DC Optimal Power Flow","title":"Optimization Variables","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Hence, the variables in this model encompass the active power outputs of the generators denoted as mathbfP_textg = P_textgi, where i in mathcalP, and the bus voltage angles represented by boldsymboltheta = theta_i, where i in mathcalN. You can access these variables using the following code:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₒ = analysis.variable.active\n𝛉 = analysis.variable.angle","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Objective-Function","page":"DC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The objective function represents the sum of the active power cost functions f_i(P_textgi), i in mathcalP, for each generator, where these cost functions can be polynomial or linear piecewise functions. It is important to note that only polynomial cost functions up to the second degree are included in the objective function. If higher-degree polynomials are present, they will be excluded from the objective function by JuliaGrid.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Polynomial-Active-Power-Cost-Function","page":"DC Optimal Power Flow","title":"Polynomial Active Power Cost Function","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The DC optimal power flow in JuliaGrid allows the cost function f_i(P_textgi) to be represented as a polynomial of up to the second degree, making it possible to express the cost function as linear or quadratic. The possible representations are as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"beginaligned\n  f_i(P_textgi) = a_1P_textgi + a_0 \n  f_i(P_textgi) = a_2 P_textgi^2 + a_1P_textgi + a_0 \nendaligned","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Furthermore, it is worth noting that the function can be given simply as a constant with only the coefficient a_0, which implies that the cost of the generator remains constant regardless of the active power outputs. In conclusion, as illustrated in Figure 1, typical scenarios involve linear or quadratic cost functions, resulting in a best-case scenario for a linear optimization problem and a worst-case scenario for a quadratic optimization problem.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<img src=\"../../assets/cost_function_dc.svg\" class=\"center\" width=\"500\"/>\n<figcaption>Figure 1: The polynomial cost functions of generator active power output.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"When utilizing the cost! function within JuliaGrid, employing the polynomial keyword results in the polynomial being constructed with coefficients ordered from the highest degree to the lowest. For instance, in the provided case study, we created a quadratic polynomial represented as:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"beginaligned\n  f_1(P_textg1) = 11002 P_textg1^2 + 500 P_textg1 + 80 \nendaligned","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To access these coefficients, users can utilize the variable:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"f₁ = system.generator.cost.active.polynomial[1]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Linear-Piecewise-Active-Power-Cost-Function","page":"DC Optimal Power Flow","title":"Linear Piecewise Active Power Cost Function","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The DC optimal power flow in JuliaGrid offers another option for defining cost functions by using linear piecewise functions as approximations of the polynomial functions, as depicted in Figure 2.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<img src=\"../../assets/cost_function_piecewise_dc.svg\" class=\"center\" width=\"500\"/>\n<figcaption>Figure 2: The linear piecewise cost functions of active power output.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To define linear piecewise functions in JuliaGrid, users can utilize the cost! function with the piecewise keyword. The linear piecewise function is constructed using a matrix where each row defines a single point. The first column holds the generator's active power output, while the second column corresponds to the associated cost value. For example, in the provided case study, a linear piecewise function is created and can be accessed as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"f₂ = system.generator.cost.active.piecewise[2]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similar to how convex linear piecewise functions are treated in the AC Optimal Power Flow, JuliaGrid adopts a constrained cost variable method for the linear piecewise functions. In this method, the piecewise linear cost function is converted into a series of linear inequality constraints for each segment, which are defined by two adjacent points along the line, along with a helper variable specific to the piecewise function. However, for linear piecewise functions that have only one segment defined by two points, JuliaGrid simplifies it into a standard linear function without requiring a helper variable.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Consequently, for a piecewise cost function denoted as f_i(P_textgi) with k segments (where k  1), the j-th segment, defined by the points P_textgij f_i(P_textgij) and P_textgij+1 f_i(P_textgij+1), is characterized by the following inequality constraints:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"cfracf_i(P_textgij+1) - f_i(P_textgij)P_textgij+1 - P_textgij(P_textgi - P_textgij) + f_i(P_textgij) leq H_i j = 1dotsk","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"where H_i represents the helper variable. To finalize this method, we simply need to include the helper variable H_i in the objective function. This approach in JuliaGrid efficiently handles linear piecewise cost functions, providing the flexibility to capture nonlinear characteristics while still benefiting from the advantages of linear optimization techniques.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As an example, in the provided case study, the helper variable is defined as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"H₂ = analysis.variable.actwise[2]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Lastly, the set of constraints introduced by the linear piecewise cost function is displayed as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.constraint.piecewise.active)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Objective-Function-2","page":"DC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As previously explained, the objective function relies on the defined polynomial or linear piecewise cost functions and represents the sum of these costs. In the provided example, the objective function that must be minimized to obtain the optimal values for the active power output of the generators and the bus voltage angles can be accessed using the following code:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.objective_function(analysis.jump)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Constraint-Functions","page":"DC Optimal Power Flow","title":"Constraint Functions","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the following section, we will examine the various constraints defined within the DC optimal power flow model.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Slack-Bus-Constraint","page":"DC Optimal Power Flow","title":"Slack Bus Constraint","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The first equality constraint is linked to the slack bus, where the bus voltage angle denoted as theta_i is fixed to a constant value theta_textslack. It can be expressed as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"theta_i - theta_textslack = 0 i in mathcalN_textsb","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"where the set mathcalN_textsb contains the index of the slack bus. To access the equality constraint from the model, we can utilize the variable:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.constraint.slack.angle)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Active-Power-Balance-Constraints","page":"DC Optimal Power Flow","title":"Active Power Balance Constraints","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The second equality constraint in the optimization problem is associated with the active power balance equation denoted as h_P_i(mathbf x) for each bus i in mathcalN:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"h_P_i(mathbf P_textg boldsymboltheta) = 0  forall i in mathcalN","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The equation is derived using the Unified Branch Model and can be represented as:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"h_P_i(mathbf P_textg boldsymboltheta) = sum_k in mathcalP_i P_textgk - sum_k = 1^n B_ik theta_k - P_textdi - P_textshi - P_texttri","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In this equation, the set mathcalP_i subseteq mathcalP encompasses all generators connected to bus i in mathcalN, and P_textgk represents the active power output of the k-th generator within the set mathcalP_i. More precisely, the variable P_textgk represents the optimization variable, as well as the bus voltage angle theta_k. ","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The constant terms in these equations are determined by the active power demand at bus P_textdi, the active power demanded by the shunt element P_textshi, and power related to the shift angle of the phase transformers P_texttri. The values representing these constant terms mathbfP_textd = P_textdi, mathbfP_textsh = P_textshi, and mathbfP_texttr = P_texttri, i in mathcalN, can be accessed as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₒ = system.bus.demand.active\n𝐏ₛₕ = system.bus.shunt.conductance\n𝐏ₜᵣ = system.model.dc.shiftPower","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To retrieve this equality constraint from the model and access the corresponding variable, you can use the following code:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.constraint.balance.active)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Voltage-Angle-Difference-Constraints","page":"DC Optimal Power Flow","title":"Voltage Angle Difference Constraints","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The inequality constraint related to the minimum and maximum bus voltage angle difference between the \"from\" and \"to\" bus ends of each branch is defined as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"theta_ij^textmin leq theta_i - theta_j leq theta_ij^textmax forall (ij) in mathcalE","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"where theta_ij^textmin represents the minimum, while theta_ij^textmax represents the maximum of the angle difference between adjacent buses. The values representing the voltage angle difference, denoted as boldsymboltheta_textlm = theta_ij^textmin theta_ij^textmax, (ij) in mathcalE, are provided as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝛉ₗₘ = [system.branch.voltage.minDiffAngle system.branch.voltage.maxDiffAngle]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To retrieve this inequality constraint from the model and access the corresponding variable, you can use the following code:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.constraint.voltage.angle)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Active-Power-Flow-Constraints","page":"DC Optimal Power Flow","title":"Active Power Flow Constraints","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The inequality constraint related to active power flow is used to represent thermal limits on power transmission. This constraint is defined as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"- P_ij^textmax leq h_P_ij(theta_i theta_j) leq P_ij^textmax forall (ij) in mathcalE","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Here, the lower and upper bounds are determined based on the vector mathbfP_textmax = P_ij^textmax, (ij) in mathcalE. These bounds can be accessed using the following variable:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₘₐₓ = system.branch.flow.longTerm","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The active power flow at branch (ij) in mathcalE can be derived using the Unified Branch Model and is given by the equation:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"h_P_ij(theta_i theta_j) = frac1tau_ij x_ij (theta_i - theta_j - phi_ij)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To retrieve this inequality constraint, we can use the following code:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.constraint.flow.active)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Active-Power-Capability-Constraints","page":"DC Optimal Power Flow","title":"Active Power Capability Constraints","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The inequality constraints associated with the minimum and maximum active power outputs of the generators are defined as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"P_textgi^textmin leq P_textgi leq P_textgi^textmax  forall i in mathcalP","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In this representation, the lower and upper bounds are determined by the vector mathbfP_textlm = P_textgi^textmin P_textgi^textmax, i in mathcalP. We can access these bounds using the following variable:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₗₘ = [system.generator.capability.minActive system.generator.capability.maxActive]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To retrieve this equality constraint from the model, we can utilize the following code:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.constraint.capability.active)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowSolutionTutorials","page":"DC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To acquire the output active power of generators and the bus voltage angles, the user must invoke the function:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.set_silent(analysis.jump) # hide\nsolve!(system, analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Therefore, to get the vector of output active power of generators mathbfP_textg = P_textgi, i in mathcalP, you can use the following command:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₒ = analysis.power.generator.active","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Further, the resulting bus voltage angles bmtheta = theta_i, i in mathcalN, are saved in the vector as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝛉 = analysis.voltage.angle","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#DCOptimalPowerAnalysisTutorials","page":"DC Optimal Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches using the power! function:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"power!(system, analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Active-Power-Injections","page":"DC Optimal Power Flow","title":"Active Power Injections","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To obtain the active power injection at buses, we can refer to section DC Model, which provides the following expression:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"   P_i = sum_j = 1^n B_ij theta_j + P_texttri + P_textshi forall i in mathcalN","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Active power injections are stored as the vector mathbfP = P_i, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏 = analysis.power.injection.active","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Active-Power-Injections-from-the-Generators","page":"DC Optimal Power Flow","title":"Active Power Injections from the Generators","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The active power supplied by generators to the buses can be calculated by summing the active power outputs of the generators obtained from the optimal DC power flow. This can be expressed as:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"    P_textsi = sum_k=1^n_textgi P_textgk forall i in mathcalN","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Here, P_textgk represents the active power output of the k-th generator connected to bus i in mathcalN, and n_textgi denotes the total number of generators connected to the same bus. We can obtain the vector of active power injected by generators to the buses, denoted as mathbfP_texts = P_textsi, using the following command:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₛ = analysis.power.supply.active","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Active-Power-Flows","page":"DC Optimal Power Flow","title":"Active Power Flows","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The active power flow at each \"from\" bus end i in mathcalN of branches can be obtained using the following equations:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"    P_ij = cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) forall (ij) in mathcalE","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The resulting active power flows are stored as the vector mathbfP_texti = P_ij, which can be retrieved using the following command:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ᵢ = analysis.power.from.active","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similarly, the active power flow at each \"to\" bus end j in mathcalN of branches can be obtained as:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"    P_ji = - P_ij forall (ij) in mathcalE","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The resulting active power flows are stored as the vector mathbfP_textj = P_ji, which can be retrieved using the following command:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ⱼ = analysis.power.to.active","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerFlowManual","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To perform the DC power flow, you first need to have the PowerSystem composite type that has been created with the dc model. Following that, you can construct the power flow model encapsulated within the DCPowerFlow composite type by employing the following function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"dcPowerFlow.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To solve the DC power flow problem and acquire bus voltage angles, make use of the following function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"solve!.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"After obtaining the solution for DC power flow, JuliaGrid offers a post-processing analysis function to compute active powers associated with buses, branches, and generators:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power!.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Additionally, there are specialized functions dedicated to calculating specific types of active powers related to particular buses, branches, or generators:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"injectionPower,\nsupplyPower,\nfromPower,\ntoPower,\ngeneratorPower.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCBusTypeModificationManual","page":"DC Power Flow","title":"Bus Type Modification","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"During the initialization process, the designated slack bus, which is initially set, undergoes examination and can be altered using the dcPowerFlow function. Here is an example:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2)\naddBus!(system; label = \"Bus 3\", type = 2)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 3\")\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"In this example, the slack bus (type = 3) corresponds to the Bus 1. However, this bus does not have an in-service generator connected to it. Consequently, JuliaGrid recognizes this as an error and attempts to assign a new slack bus from the available generator buses (type = 2) that have connected in-service generators. In this particular example, the Bus 3 will become the new slack bus. As a result, we can observe the updated array of bus types:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 2, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; bus = \"Bus 3\", active = 3.2)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"print(system.bus.label, system.bus.layout.type)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nThe bus that is defined as the slack bus (type = 3) but lacks a connected in-service generator will have its type changed to the demand bus (type = 1). Meanwhile, the first generator bus (type = 2) with an in-service generator connected to it will be assigned as the new slack bus (type = 3).","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerFlowSolutionManual","page":"DC Power Flow","title":"Power Flow Solution","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To solve the DC power flow problem using JuliaGrid, we start by creating the PowerSystem composite type and defining the DC model with the dcModel! function. Here is an example:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\ndcModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The dcPowerFlow function can be used to establish the DC power flow problem. It factorizes the nodal matrix to prepare for determining the bus voltage angles:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"analysis = dcPowerFlow(system)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To obtain the bus voltage angles, we can call the solve! function as follows:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"solve!(system, analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Once the solution is obtained, the bus voltage angles can be accessed using:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"print(system.bus.label, analysis.voltage.angle)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nWe recommend that readers refer to the tutorial on DC Power Flow Analysis for insights into the implementation.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerAnalysisManual","page":"DC Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"After obtaining the solution from the DC power flow, we can calculate powers related to buses, branches, and generators using the power! function. For instance, let us consider the power system for which we obtained the DC power flow solution:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Now we can calculate the active powers using the following function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, let us convert the base power unit to megavolt-amperes (MVA):","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"@base(system, MVA, V)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, here are the calculated active power values in megawatts (MW) corresponding to buses and branches:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"print(system.bus.label, system.base.power.value * analysis.power.injection.active)\nprint(system.branch.label, system.base.power.value * analysis.power.from.active)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nTo better understand the powers associated with buses, branches and generators that are calculated by the power! function, we suggest referring to the tutorials on DC Power Flow Analysis.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To compute specific quantities for particular components, rather than calculating powers or currents for all components, users can utilize one of the provided functions below.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Active-Power-Injection","page":"DC Power Flow","title":"Active Power Injection","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To calculate active power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = injectionPower(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Active-Power-Injection-from-Generators","page":"DC Power Flow","title":"Active Power Injection from Generators","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To calculate active power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = supplyPower(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Active-Power-Flow","page":"DC Power Flow","title":"Active Power Flow","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Similarly, we can compute the active power flow at both the \"from\" and \"to\" bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = fromPower(system, analysis; label = \"Branch 2\")\nactive = toPower(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Generator-Active-Power-Output","page":"DC Power Flow","title":"Generator Active Power Output","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, we can compute the active power output of a particular generator using the function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = generatorPower(system, analysis; label = \"Generator 1\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCReusingPowerSystemModelManual","page":"DC Power Flow","title":"Reusing Power System Model","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The PowerSystem composite type, along with its previously established dc field, offers unlimited versatility. This facilitates the seamless sharing of the PowerSystem type across various DC power flow analyses. All fields automatically adjust when any of the functions that add components or modify their parameters are utilized:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"addBranch!,\naddGenerator!,\nupdateBus!,\nupdateBranch!,\nupdateGenerator!.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To illustrate, let us consider a scenario where we initially establish a power system and find a solution:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 2.1)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, we want to find a solution in a situation where we make changes to the output power of Generator 1, take Generator 2 out-of-service, and modify the active power demand at Bus 2. Furthermore, we deactivate Branch 3 from its operational state and introduce a new branch called Branch 4. This entire process can be effortlessly accomplished by reusing the PowerSystem composite type and its dc field formed previously using the function dcModel!. As demonstrated in the following code snippet:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"updateGenerator!(system; label = \"Generator 1\", active = 0.3)\nupdateGenerator!(system; label = \"Generator 2\", status = 0)\nupdateBus!(system; label = \"Bus 2\", active = 0.2)\n\nupdateBranch!(system; label = \"Branch 3\", status = 0)\naddBranch!(system; label = \"Branch 4\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.03)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCReusingPowerFlowModelManual","page":"DC Power Flow","title":"Reusing Power Flow Model","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To reuse the DCPowerFlow composite type, you essentially skip running the dcPowerFlow function. This can be accomplished by using functions that add components or update their parameters and passing the DCPowerFlow composite type as an argument within the PowerSystem composite type. If the modifications the user intends to make are compatible with reusing the DCPowerFlow type, they will be executed and will consequently impact both types.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The dcPowerFlow function plays a role in conducting bus type checks, as explained in the Bus Type Modification section, and in factorizing the nodal matrix. In practical terms, reusing the DCPowerFlow composite type involves making adjustments exclusively to demand, shunt, or generator parameters, while keeping the power system's branch parameters unchanged. Consequently, there are situations where reusing may not be a viable option. In such cases, JuliGrid will trigger an error message.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Building upon the earlier example, we can continue to refine the power system by making changes to the output power of Generator 1 and adjusting the active power demand at Bus 2 within the existing system. Without invoking the dcPowerFlow function, we can move ahead to obtain a solution using the following code snippet:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"updateGenerator!(system, analysis; label = \"Generator 1\", status = 1)\nupdateBus!(system, analysis; label = \"Bus 2\", active = 0.4)\n\nsolve!(system, analysis)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"However, if the intention is to reuse the DCPowerFlow type once more, this time with the aim of modifying the status of Branch 3, it becomes apparent that in this scenario, reusing the DCPowerFlow type is not feasible:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"updateBranch!(system, analysis; label = \"Branch 3\", status = 0)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"info: Info\nWhen a user employs DCPowerFlow as an argument in functions for adding components or modifications, functions are checking if DCPowerFlow can be reused. If possible, both PowerSystem and DCPowerFlow types will be modified. This streamlined process allows for a seamless transition to the solve! function without intermediate steps.","category":"page"},{"location":"tutorials/acdcModel/#ACDCModelTutorials","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The power system analyses commonly utilize the unified branch model that provides linear relationships between voltages and currents. However, as the focus is on power calculations rather than current calculations, the resulting equations become nonlinear, posing challenges in solving them [1]. Hence, to accurately analyze power systems without any approximations, we use the AC model, which is a crucial component of our framework. In contrast, to obtain a linear system of equations for various DC analyses, we introduce approximations in the unified branch model, resulting in the DC model.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"A common way to describe the power system network topology is through the bus/branch model, which employs the two-port pi-model, which results in the unified branch model. The bus/branch model can be represented by a graph denoted by mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n corresponds to buses, and the set of edges mathcalE subseteq mathcalN times mathcalN represents the branches of the power network.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Let us now construct the power system:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, V)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 21.7, reactive = 12.7)\naddBus!(system; label = 3, type = 2, conductance = 2.1, susceptance = 1.2)\n\naddBranch!(system; from = 1, to = 2, resistance = 0.02, reactance = 0.06, susceptance = 0.05)\naddBranch!(system; from = 1, to = 3, reactance = 0.21, turnsRatio = 0.98, shiftAngle = 1.2)\naddBranch!(system; from = 2, to = 3, resistance = 0.13, reactance = 0.26, conductance = 1e-3)\n\naddGenerator!(system; bus = 1, active = 40.0, reactive = 42.4)\nnothing #hide","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The given example provides the set of buses and branches:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝒩 = collect(keys(sort(system.bus.label)))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"ukw: Notation\nIn this section, when referring to a vector mathbfa, we use the notation mathbfa = a_ij, where a_ij represents the generic element associated with the branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#ACModelTutorials","page":"AC and DC Model","title":"AC Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"JuliaGrid is based on common network elements and benefits from the unified branch model to perform various analyses based on the system of nonlinear equations. To generate matrices and vectors for AC or nonlinear analysis, JuliaGrid employs the acModel! function. To demonstrate the usage of this function, consider the power system defined in the previous example. In order to apply the acModel! function to this power system, the following code can be executed:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"acModel!(system)\nnothing #hide","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#UnifiedBranchModelTutorials","page":"AC and DC Model","title":"Unified Branch Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The equivalent unified pi-model for a branch (ij) in mathcalE incident to the buses ij in mathcalN is shown in Figure 1.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"<img src=\"../../assets/pi_model.svg\" class=\"center\" width=\"600\"/>\n<figcaption>Figure 1: The equivalent branch model, where the transformer is located at \"from\" bus end of the branch.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"note: Info\nThe directions of the currents barI_ij, barI_ji, barI_textsi, and barI_textsj are initially defined to come out from the nodes or buses. This convention proves particularly valuable during power flow analyses. In cases where active or reactive power is positive, it signifies alignment with the assumed current direction, flowing away from the bus. Conversely, when power is negative, the direction is reversed, indicating a flow towards the bus. These current directions, in conjunction with barI_textsij, are consistently employed by JuliaGrid in its calculations of powers or currents.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The branch series admittance y_ij is inversely proportional to the branch series impedance z_ij:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  y_ij = frac1z_ij =\n  frac1r_ij + textjx_ij =\n  fracr_ijr_ij^2 + x_ij^2 - textjfracx_ijr_ij^2 + x_ij^2 = g_ij + textjb_ij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where r_ij is a resistance, x_ij is a reactance, g_ij is a conductance and b_ij is a susceptance of the branch.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The vectors of resistances, denoted by mathbfr = r_ij, and reactances, denoted by mathbfx = x_ij, are stored in the variables:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐫 = system.branch.parameter.resistance\n𝐱 = system.branch.parameter.reactance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Moreover, the ac field stores the computed vector of branch series admittances mathbfy = y_ij:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐲 = system.model.ac.admittance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The branch shunt admittance y_textsij is equal to:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"y_textsij = g_textsij + textj b_textsij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where g_textsij represents the shunt conductance of the branch, and b_textsij represents the shunt susceptance. Both of these values are positive for real line sections. It is worth noting that while the shunt conductance g_textsij is often insignificantly small and can be ignored in many cases, it is included in the analyses to ensure comprehensive consideration of all potential scenarios.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Within JuliaGrid, the total shunt conductances and susceptances of branches are stored. In order to obtain the vectors mathbfg_texts = g_textsij and mathbfb_texts = b_textsij, the conductances and susceptances must be distributed by considering the ends of the branches:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐠ₛ = 0.5 * system.branch.parameter.conductance\n𝐛ₛ = 0.5 * system.branch.parameter.susceptance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The transformer complex ratio alpha_ij is defined:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  alpha_ij = cfrac1tau_ije^-textjphi_ij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where tau_ij neq 0 is a transformer turns ratio, while phi_ij is a transformer phase shift angle, always located \"from\" bus end of the branch. Note, if tau_ij = 1 and phi_ij = 0 the model describes the line. In-phase transformers are defined if tau_ij neq 1, phi_ij = 0, and y_textsij = 0, while phase-shifting transformers are obtained if tau_ij neq 1, phi_ij neq 0, and y_textsij = 0.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"These transformer parameters are stored in the vectors bmtau = tau_ij and bmphi = phi_ij, respectively:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝛕 = system.branch.parameter.turnsRatio\n𝚽 = system.branch.parameter.shiftAngle","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Using Kirchhoff's circuit laws, the unified branch model can be described by complex expressions:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2(y_ij + y_textsij)  -alpha_ij^*y_ij\n    -alpha_ijy_ij  y_ij + y_textsij\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The values of the vectors mathbfy_textii = (y_ij + y_textsij)  tau_ij^2, mathbfy_textij = -alpha_ij^*y_ij, mathbfy_textji = -alpha_ijy_ij, and mathbfy_textjj = y_ij + y_textsij can be found stored in the variables:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐲ᵢᵢ = system.model.ac.nodalFromFrom\n𝐲ᵢⱼ = system.model.ac.nodalFromTo\n𝐲ⱼᵢ = system.model.ac.nodalToFrom\n𝐲ⱼⱼ = system.model.ac.nodalToTo","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#SystemEquationsNodalMatrixTutorials","page":"AC and DC Model","title":"System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Let us consider an example, given in Figure 2, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with admittance y_textshk.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"<img src=\"../../assets/pi_model_example.svg\" class=\"center\" width=\"710\"/>\n<figcaption>Figure 2: The example of the system with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"note: Info\nThe current barI_textshk follows the convention of coming out from the bus in terms of its direction. When calculating powers related to shunt elements, this current direction is assumed. Therefore, in cases where power is positive, it signifies alignment with the assumed current direction, emerging away from the bus. Conversely, when power is negative, the direction is reversed, indicating a flow towards the bus.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"According to the Unified Branch Model each branch is described using the system of equations as follows:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_pk  barI_kp\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_pk^*y_pk\n    -alpha_pky_pk  y_pk + y_textspk\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_kq  barI_qk\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_kq^2(y_kq + y_textskq)  -alpha_kq^*y_kq\n    -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The complex current injections at buses are:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    barI_p = barI_pk = cfrac1tau_pk^2(y_pk + y_textspk) barV_p -alpha_kq^*y_kq barV_k \n    barI_k = barI_kp + barI_kq + barI_textshk =\n    -alpha_kqy_kq barV_p + (y_kq + y_textskq) barV_k +\n    cfrac1tau_kq^2(y_kq + y_textskq) barV_k -alpha_kq^*y_kq barV_q + y_textshk barV_k \n    barI_q = barI_qk = -alpha_kqy_kq barV_k + (y_kq + y_textskq) barV_q\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_p  barI_k  barI_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_kq^*y_kq  0 \n   -alpha_kqy_kq  y_kq + y_textskq + cfrac1tau_kq^2(y_kq + y_textskq) + y_textshk   -alpha_kq^*y_kq \n    0  -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Next, the system of equations for buses i=1 dots n can be written in the matrix form:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where mathbf bar V in mathbbC^n is the vector of bus complex voltages, and mathbf bar I in mathbbC^n is the vector of complex current injections at buses.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The matrix mathbfY = mathbfG + textjmathbfB in mathbbC^n times n is the bus or nodal admittance matrix, with elements:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"the diagonal elements, where i in mathcalN, are equal to:\nY_ii = G_ii + textjB_ii = y_textshi +\nsumlimits_e in mathcalE  e(1) = i cfrac1tau_ij^2(y_ij + y_textsij) + sumlimits_e in mathcalE  e(2) = i (y_ij + y_textsij)\nthe non-diagonal elements, where i = e(1) j = e(2)  e in mathcalE, are equal to:\nY_ij = G_ij + textjB_ij = -alpha_ij^*y_ij\nY_ji = G_ji + textjB_ji = -alpha_ijy_ij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix mathbfY is equal to zero. The nodal admittance matrix mathbfY is a sparse (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix mathbfY is symmetrical, it is not a general case, for example, in the presence of phase shifting transformers the matrix mathbfY is not symmetrical [2, Sec. 9.6]. JuliaGrid stores both the matrix mathbfY and its transpose mathbfY^T in the ac field of the PowerSystem composite type:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐘 = system.model.ac.nodalMatrix\n𝐘ᵀ = system.model.ac.nodalMatrixTranspose","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#DCModelTutorials","page":"AC and DC Model","title":"DC Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The DC model is obtained by linearisation of the nonlinear model, and it provides an approximate solution. In the typical operating conditions, the difference of bus voltage angles between adjacent buses (ij) in mathcalE is very small theta_i-theta_j approx 0, which implies cos theta_ijapprox 1 and sin theta_ij approx theta_ij. Further, all bus voltage magnitudes are V_i approx 1, i in mathcalN, and all branch shunt admittances and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers. Therefore, the DC power flow takes only bus voltage angles bm theta as variables. To create vectors and matrices related to DC or linear analyses, JuliaGrid uses the function dcModel!. Therefore, we can continue with the previous example:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#DCUnifiedBranchModelTutorials","page":"AC and DC Model","title":"Unified Branch Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"According to the above assumptions, we start from the Unified Branch Model:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix = cfrac1textjx_ij\n  beginbmatrix\n    cfrac1tau_ij^2  -alpha_ij^*\n    -alpha_ij  1\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where barV_i = texte^textjtheta_i and barV_j = texte^textjtheta_j. Further, we have:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    barI_ij = cfrac1textjx_ij leftcfrac1tau_ij^2 texte^textjtheta_i -\n    cfrac1tau_ije^textj(phi_ij + theta_j) right \n    barI_ji = cfrac1textjx_ij left-cfrac1tau_ije^textj(theta_i - phi_ij) + texte^textjtheta_j right\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The active power flows are derived as follows:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    P_ij = RebarV_ibarI_ij^* =\n    Re lefttextjcfrac1x_ij\n    leftcfrac1tau_ij^2 - cfrac1tau_ije^textj(theta_i - theta_j - phi_ij) right  right \n    P_ji = RebarV_jbarI_ji^* =\n    Re lefttextjcfrac1x_ij\n   left1-cfrac1tau_ije^textj(-theta_i +theta_j + phi_ij) right  right\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The real components are:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    P_ij =cfrac1tau_ijx_ij sin(theta_i -theta_j-phi_ij) approx cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) \n    P_ji =cfrac1tau_ijx_ij sin(theta_j -theta_i+phi_ij) approx -cfrac1tau_ij x_ij (theta_i - theta_j-phi_ij)\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where 1(tau_ij x_ij) represents the branch admittance in the DC framework. To recall, the PowerSystem composite type stores the reactances as vector mathbfx = x_ij in the variable:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐱 = system.branch.parameter.reactance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Furthermore, the computed branch admittances in the DC framework are stored in the vector mathbfy = 1(tau_ij x_ij):","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐲 = system.model.dc.admittance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"We can conclude that P_ij=-P_ji holds. With the DC model, the linear network equations relate active powers to bus voltage angles, versus complex currents to complex bus voltages in the AC model [3]. Consequently, analogous to the Unified Branch Model we can write:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix = cfrac1tau_ijx_ij\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix + cfracphi_ijtau_ijx_ij\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#SystemEquationsNodalMatrixTutorials-2","page":"AC and DC Model","title":"System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"As before, let us consider an example of the DC framework, given in Figure 3, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with conductance g_textshk.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"<img src=\"../../assets/dc_model.svg\" class=\"center\" width=\"600\" />\n<figcaption>Figure 3: The example of the system with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Each branch in the DC framework is described with a system of equations as follows:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_pk  P_kp\n  endbmatrix = cfrac1tau_pkx_pk\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k\n  endbmatrix + cfracphi_pktau_pkx_pk\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_kq  P_qk\n  endbmatrix = cfrac1tau_kqx_kq\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_k  theta_q\n  endbmatrix + cfracphi_kqtau_kqx_kq\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The active power injections at buses are:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    P_p = P_pk =cfrac1tau_pkx_pk theta_p - cfrac1tau_pkx_pk theta_k - cfracphi_pktau_pkx_pk \n    P_k = P_kp + P_kq + P_textshk = -cfrac1tau_pkx_pk theta_p + cfrac1tau_pkx_pk theta_k + cfracphi_pktau_pkx_pk +\n    cfrac1tau_kqx_kq theta_k - cfrac1tau_kqx_kq theta_q - cfracphi_kqtau_kqx_kq + g_textshk \n    P_q = P_qk = -cfrac1tau_kqx_kq theta_k +cfrac1tau_kqx_kq theta_q + cfracphi_kqtau_kqx_kq\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where the active power injected by the shunt element at the bus k is equal to:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  P_textshk = RebarV_kbarI_textshk^* = RebarV_ky_textshk^*barV_k^* = V_k^2 g_textshk = g_textshk","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_p  P_k  P_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pkx_pk  - cfrac1tau_pkx_pk  0 \n    -cfrac1tau_pkx_pk  cfrac1tau_pkx_pk + cfrac1tau_kqx_kq   -cfrac1tau_kqx_kq \n    0  -cfrac1tau_kqx_kq cfrac1tau_kqx_kq\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k  theta_q\n  endbmatrix +\n  beginbmatrix\n    - cfracphi_pktau_pkx_pk  cfracphi_pktau_pkx_pk - cfracphi_kqtau_kqx_kq  cfracphi_kqtau_kqx_kq\n  endbmatrix +\n  beginbmatrix\n    0  g_textshk  0\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Next, the system of equations for i=1dotsn can be written in the matrix form:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  mathbf P = mathbfB bm theta + mathbfP_texttr + mathbfP_textsh","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where bm theta in mathbbR^n is the vector of bus voltage angles.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The vector mathbf P in mathbbR^n contains active power injections at buses caused by generators and demands. In JuliaGrid, the vector can be recovered using a command:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐏 = system.bus.supply.active - system.bus.demand.active","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The vector mathbfP_texttr in mathbbR^n represents active powers related to the non-zero shift angle of transformers. This vector is stored in the dc field, and we can access it using:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐏ₜᵣ = system.model.dc.shiftPower","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The vector mathbfP_textsh in mathbbR^n represents active powers consumed by shunt elements. We can access this vector using:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐏ₛₕ = system.bus.shunt.conductance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The bus or nodal matrix in the DC framework is given as mathbfB in mathbbC^n times n, with elements:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"the diagonal elements, where i in mathcalN, are equal to:\nB_ii = sumlimits_e in mathcalE i in e cfrac1tau_ijx_ij\nthe non-diagonal elements, where i = e(1) j = e(2)  e in mathcalE, are equal to:\nB_ij = -cfrac1tau_ijx_ij\nB_ji = -cfrac1tau_ijx_ij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The sparse nodal matrix mathbfB is stored in the dc field, and we can access it using:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐁 = system.model.dc.nodalMatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#ACDCModelReferenceTutorials","page":"AC and DC Model","title":"References","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"[1] G. Andersson, Power system analysis, EEH-Power Systems Laboratory, ETH Zurich, Lecture Notes 2012.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"[2] J. Grainger and W. Stevenson, Power system analysis, ser. McGraw-Hill series in electrical and computer engineering: Power and energy. McGraw-Hill, 1994.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"[3] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER User’s Manual, Version 7.0. 2019.","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimalPowerFlowManual","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid utilizes the JuMP package to construct optimal power flow models, allowing users to manipulate these models using the standard functions provided by JuMP. As a result, JuliaGrid supports popular solvers mentioned in the JuMP documentation to solve the optimization problem.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To perform the AC optimal power flow, you first need to have the PowerSystem composite type that has been created with the ac model. After that, create the ACOptimalPowerFlow composite type to establish the AC optimal power flow framework using the function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"acOptimalPowerFlow.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To solve the AC optimal power flow problem and acquire bus voltage magnitudes and angles, and generator active and reactive power outputs, make use of the following function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"solve!.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After obtaining the AC optimal power flow solution, JuliaGrid offers post-processing analysis functions for calculating powers and currents associated with buses and branches:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"power!,\ncurrent!.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Furthermore, there are specialized functions dedicated to calculating specific types of powers related to particular buses, branches, or generators:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"injectionPower,\nsupplyPower,\nshuntPower,\nfromPower,\ntoPower,\nseriesPower,\nchargingPower,\ngeneratorPower.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Likewise, there are specialized functions dedicated to calculating specific types of currents related to particular buses or branches:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"injectionCurrent,\nfromCurrent,\ntoCurrent,\nseriesCurrent.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimalPowerFlowModelManual","page":"AC Optimal Power Flow","title":"Optimal Power Flow Model","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To set up the AC optimal power flow, we begin by creating the model. To illustrate this, consider the following example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, Ipopt\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\n@bus(minMagnitude = 0.95, maxMagnitude = 1.05)\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, angle = -0.1)\naddBus!(system; label = \"Bus 2\", reactive = 0.01, magnitude = 1.1)\n\n@branch(minDiffAngle = -pi, maxDiffAngle = pi, reactance = 0.5, type = 2)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", longTerm = 0.15)\n\n@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1, status = 0)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.4, reactive = 0.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.2, reactive = 0.1)\n\ncost!(system; label = \"Generator 1\", active = 2, polynomial = [800.0; 200.0; 80.0])\ncost!(system; label = \"Generator 2\", active = 1, piecewise = [10.8 12.3; 14.7 16.8; 18 18.1])\n\ncost!(system; label = \"Generator 1\", reactive = 2, polynomial = [2.0])\ncost!(system; label = \"Generator 2\", reactive = 1, piecewise = [2.0 4.0; 6.0 8.0])\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, the acOptimalPowerFlow function is utilized to formulate the AC optimal power flow problem:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\n\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimizationVariablesManual","page":"AC Optimal Power Flow","title":"Optimization Variables","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the AC optimal power flow model, the active and reactive power outputs of the generators are expressed as nonlinear functions of the bus voltage magnitudes and angles. As a result, the variables in this model include the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.all_variables(analysis.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"It is important to note that this is not a comprehensive set of optimization variables. When the cost function is defined as a linear piecewise function comprising multiple segments, as illustrated in the case of the active power output cost for Generator 2, JuliaGrid automatically generates helper optimization variables named actwise and reactwise, and formulates a set of linear constraints to effectively address these cost functions. It is worth emphasizing that in instances where a linear piecewise cost function consists of only a single segment, as demonstrated by the reactive power output cost of Generator 2, the function is modelled as a standard linear function, obviating the need for additional helper optimization variables.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For the sake of simplicity, we initially assume that both generators are out-of-service. Consequently, the helper variable is not included in the set of optimization variables. However, as we progress through this manual, we will activate the generators, introducing helper variables and additional constraints to the optimization model.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Please be aware that JuliaGrid maintains references to all variables, which are categorized into six fields:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"fieldnames(typeof(analysis.variable))","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Add-Variables","page":"AC Optimal Power Flow","title":"Add Variables","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The user has the ability to easily add new variables to the defined AC optimal power flow model by using the @variable macro from the JuMP package. Here is an example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.@variable(analysis.jump, newVariable)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can verify that the new variable is included in the defined model by using the function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.is_valid(analysis.jump, newVariable)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Delete-Variables","page":"AC Optimal Power Flow","title":"Delete Variables","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The variable can be deleted, but this operation is only applicable if the objective function is either affine or quadratic. To achieve this, you can utilize the delete function provided by the JuMP package, as demonstrated below:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.delete(analysis.jump, newVariable)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After deletion, the variable is no longer part of the model:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.is_valid(analysis.jump, newVariable)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#DCConstraintFunctionsManual","page":"AC Optimal Power Flow","title":"Constraint Functions","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid keeps track of all the references to internally formed constraints in the constraint field of the ACOptimalPowerFlow composite type. These constraints are divided into six fields:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"fieldnames(typeof(analysis.constraint))","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nWe recommend that readers refer to the tutorial on AC Optimal Power Flow for insights into the implementation.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Slack-Bus-Constraint","page":"AC Optimal Power Flow","title":"Slack Bus Constraint","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The slack field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the addBus! function using the angle keyword:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.slack.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users have the flexibility to modify this constraint by changing which bus serves as the slack bus and by adjusting the value of the bus angle. This can be achieved using the updateBus! function, for example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBus!(system, analysis; label = \"Bus 1\", type = 1)\nupdateBus!(system, analysis; label = \"Bus 2\", type = 3, angle = -0.2)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Subsequently, the updated slack constraint can be inspected as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.slack.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Power-Balance-Constraints","page":"AC Optimal Power Flow","title":"Power Balance Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The balance field contains references to the equality constraints associated with the active and reactive power balance equations defined for each bus. These constraints ensure that the total active and reactive power injected by the generators matches the total active and reactive power demanded at each bus.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The constant term in the active power balance equations is determined by the active keyword within the addBus! function, which defines the active power demanded at the bus. You can access the references to the active power balance constraints using the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.balance.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the constant term in the reactive power balance equations is determined by the reactive keyword within the addBus! function, which defines the reactive power demanded at the bus. You can access the references to the reactive power balance constraints using the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.balance.reactive)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"During the execution of functions that add or update power system components, these constraints are automatically adjusted to reflect the current configuration of the power system. An example of this adaptability is demonstrated below:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBus!(system, analysis; label = \"Bus 2\", active = 0.5)\nupdateBranch!(system, analysis; label = \"Branch 1\", reactance = 0.25)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For example, the updated set of active power balance constraints can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.balance.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Voltage-Constraints","page":"AC Optimal Power Flow","title":"Voltage Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The voltage field within the model contains references to the inequality constraints associated with the voltage magnitude and voltage angle difference limits. These constraints ensure that the bus voltage magnitudes and the angle differences between the \"from\" and \"to\" bus ends of each branch are within specified limits.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The minimum and maximum bus voltage magnitude limits are set using the minMagnitude and maxMagnitude keywords within the addBus! function. The constraints associated with these limits can be accessed using the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.voltage.magnitude)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the minimum and maximum voltage angle difference limits between the \"from\" and \"to\" bus ends of each branch are set using the minDiffAngle and maxDiffAngle keywords within the addBranch! function. The constraints associated with these limits can be accessed using the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Please note that if the limit constraints are set to minDiffAngle = -2π and maxDiffAngle = 2π for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Additionally, by employing the updateBus! and updateBranch! functions, user has the ability to modify these specific constraints as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBus!(system, analysis; label = \"Bus 1\", minMagnitude = 1.0, maxMagnitude = 1.0)\nupdateBranch!(system, analysis; label = \"Branch 1\", minDiffAngle = -1.7, maxDiffAngle = 1.7)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Subsequently, the updated set of constraints can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.constraint.voltage.magnitude)\nprint(system.branch.label, analysis.constraint.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Flow-Constraints","page":"AC Optimal Power Flow","title":"Flow Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The flow field contains references to the inequality constraints associated with the apparent power flow, active power flow, or current magnitude limits at the \"from\" and \"to\" bus ends of each branch. The type which one of the constraint will be applied is defined according to the type keyword within the addBranch! function, type = 1 for the apparent power flow, type = 2 for the active power flow, or type = 3 for the current magnitude. These limits are specified using the longTerm keyword within the addBranch! function.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"By default, the longTerm keyword is linked to apparent power (type = 1). However, in the example, we configured it to use active power flow by setting type = 2. To access the flow constraints of branches at the \"from\" bus end, you can utilize the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.flow.from)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, to access the \"to\" bus end flow constraints of branches you can use the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.flow.to)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Please note that if the flow constraints are set to longTerm = 0.0 for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Additionally, by employing the updateBranch! function, you have the ability to modify these specific constraints, for example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBranch!(system, analysis; label = \"Branch 1\", reactance = 0.8, longTerm = 0.14)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The updated set of flow constraints can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.flow.from)\nprint(system.branch.label, analysis.constraint.flow.to)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Power-Capability-Constraints","page":"AC Optimal Power Flow","title":"Power Capability Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The capability field contains references to the inequality constraints associated with the minimum and maximum active and reactive power outputs of the generators.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The constraints associated with the minimum and maximum active power output limits of the generators are defined using the minActive and maxActive keywords within the addGenerator! function. To access the constraints associated with these limits, you can use the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, analysis.constraint.capability.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the constraints associated with the minimum and maximum reactive power output limits of the generators are specified using the minReactive and maxReactive keywords within the addGenerator! function. To access these constraints, you can use the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, analysis.constraint.capability.reactive)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As demonstrated, the active and reactive power outputs of Generator 1 and Generator 2 are currently fixed at zero due to previous actions that set these generators out-of-service. However, you can modify these specific constraints by utilizing the updateGenerator! function, as shown below:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateGenerator!(system, analysis; label = \"Generator 1\", status = 1)\nupdateGenerator!(system, analysis; label = \"Generator 2\", status = 1, minActive = 0.1)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Subsequently, the updated set of constraints can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, analysis.constraint.capability.active)\nprint(system.generator.label, analysis.constraint.capability.reactive)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nThis representation may not provide the most accurate portrayal of the generator's power output behavior. In reality, there is a tradeoff between the active and reactive power outputs of the generators, and JuliaGrid has the capability to integrate this tradeoff into the optimization model. For more details, please refer to the tutorial on Power Capability Constraints.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Power-Piecewise-Constraints","page":"AC Optimal Power Flow","title":"Power Piecewise Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the context of cost modelling, the piecewise field acts as a reference to the inequality constraints associated with linear piecewise cost functions. These constraints are established using the cost! function, with active = 1 or reactive = 1 specified when working with linear piecewise cost functions that consist of multiple segments. In our example, only the active power cost of Generator 2 is modelled as a linear piecewise function with two segments, and JuliaGrid takes care of setting up the appropriate inequality constraints for each segment:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, analysis.constraint.piecewise.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"It is worth noting that these constraints can also be automatically updated using the cost! function. Readers can find more details in the section discussing the objective function. ","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As mentioned at the beginning, a linear piecewise cost functions with multiple segments will also introduce helper variables that are added to the objective function. In this specific example, the helper variable is:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis.variable.actwise[2]","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Add-Constraints","page":"AC Optimal Power Flow","title":"Add Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users can effortlessly introduce additional constraints into the defined AC optimal power flow model by utilizing the addBranch! or addGenerator! functions. Specifically, if a user wishes to include a new branch or generator in an already defined PowerSystem and ACOptimalPowerFlow type, using these functions will automatically add and update all constraints:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"addBranch!(system, analysis; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 1)\naddGenerator!(system, analysis; label = \"Generator 3\", bus = \"Bus 2\", active = 2, status = 1)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"This will affect all constraints related to branches and generators, but it will also update balance constraints to configure the optimization model to match the current state of the power system. For example, you can observe the following updated constraints:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.constraint.voltage.angle)\nprint(system.generator.label, analysis.constraint.capability.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Add-User-Defined-Constraints","page":"AC Optimal Power Flow","title":"Add User-Defined Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users also have the option to include their custom constraints within the established AC optimal power flow model by employing the @constraint macro. For example, the addition of a new constraint can be achieved as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.@constraint(analysis.jump, 0.0 <= analysis.variable.active[3] <= 0.3)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Delete-Constraints","page":"AC Optimal Power Flow","title":"Delete Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To delete a constraint, users can make use of the delete function from the JuMP package. When handling constraints that have been internally created, users can refer to the constraint references stored in the constraint field of the ACOptimalPowerFlow type.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For example, if the intention is to eliminate constraints related to the capability of Generator 3, the following code snippet can be employed:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.delete(analysis.jump, analysis.constraint.capability.active[3])\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nIn the event that a user deletes a constraint and subsequently executes a function that updates bus, branch, or generator parameters, and if the deleted constraint is affected by these functions, JuliaGrid will automatically reinstate that constraint. Users should exercise caution when deleting constraints, as this action is considered potentially harmful since it operates independently of power system data.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACObjectiveFunctionManual","page":"AC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The objective function of the AC optimal power flow is formulated using polynomial and linear piecewise cost functions associated with the generators, defined using the cost! functions.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the provided example, the objective function to be minimized in order to obtain optimal values for the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles, is as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_function(analysis.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid also stores the objective function in a separate variable, which can be accessed by referring to the variable analysis.objective. In this variable, the objective function is organized in a way that separates the quadratic and nonlinear components of the objective function.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Update-Objective-Function","page":"AC Optimal Power Flow","title":"Update Objective Function","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"By utilizing the cost! functions, users have the flexibility to modify the objective function by adjusting polynomial or linear piecewise cost coefficients or by changing the type of polynomial or linear piecewise function employed. For instance, consider Generator 1, which originally employs a quadratic polynomial cost function for active power. You can redefine the cost function for this generator as a cubic polynomial and thereby define a nonlinear objective function, as shown below:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"cost!(system, analysis; label = \"Generator 1\", active = 2, polynomial = [631; 257; 40; 5.0])\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"This leads to an updated objective function, which can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_function(analysis.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#User-Defined-Objective-Function","page":"AC Optimal Power Flow","title":"User-Defined Objective Function","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users can modify the objective function using the set_objective_function function from the JuMP package. This operation is considered destructive because it is independent of power system data; however, in certain scenarios, it may be more straightforward than using the cost! function for updates. Moreover, using this methodology, users can combine a defined function with a newly defined expression.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In this context, we can utilize the saved objective function within the objective field of the ACOptimalPowerFlow type. For example, you can easily eliminate nonlinear parts and alter the quadratic component of the objective as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"expr = 5.0 * analysis.variable.active[1] * analysis.variable.active[1]\nJuMP.set_objective_function(analysis.jump, analysis.objective.quadratic - expr)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"You can now observe the updated objective function as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_function(analysis.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACSetupPrimalStartingValuesManual","page":"AC Optimal Power Flow","title":"Setup Primal Starting Values","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In JuliaGrid, the assignment of starting primal values for optimization variables takes place when the solve! function is executed. Starting primal values are determined based on the generator and voltage fields within the ACOptimalPowerFlow type. By default, these values are initially established using the active and reactive power outputs of the generators and the initial bus voltage magnitudes and angles:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"generator = analysis.power.generator;\nprint(system.generator.label, generator.active, generator.reactive)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"You have the flexibility to adjust these values to your specifications, and they will be utilized as the starting primal values when you run the solve! function.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Using-AC-Power-Flow","page":"AC Optimal Power Flow","title":"Using AC Power Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In this perspective, users have the capability to conduct the AC power flow analysis and leverage the resulting solution to configure starting primal values. Here is an illustration of how this can be achieved:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"flow = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, flow)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, flow)\nend","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After obtaining the solution, we can calculate the active and reactive power outputs of the generators and utilize the bus voltage magnitudes and angles to set the starting values. In this case, the generator and voltage fields of the ACOptimalPowerFlow type can be employed to store the new starting values:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"for (key, value) in system.generator.label\n    active, reactive = generatorPower(system, flow; label = key)\n    analysis.power.generator.active[value] = active\n    analysis.power.generator.reactive[value] = reactive\nend\n\nfor i = 1:system.bus.number\n    analysis.voltage.magnitude[i] = flow.voltage.magnitude[i]\n    analysis.voltage.angle[i] = flow.voltage.angle[i]\nend","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Using-AC-Optimal-Power-Flow","page":"AC Optimal Power Flow","title":"Using AC Optimal Power Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Performing repeated executions of the AC optimal power flow problem, and opting to reuse the existing ACOptimalPowerFlow type without generating a new instance offers the benefit of a \"warm start\". In such a situation, the initial primal values for the subsequent solving step align with the solution achieved in the prior step. Additional information can be found in the section dedicated to Reusing the Optimal Power Flow Model.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimalPowerFlowSolutionManual","page":"AC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To establish the AC optimal power flow problem, you can utilize the acOptimalPowerFlow function. After setting up the problem, you can use the solve! function to compute the optimal values for the active and reactive power outputs of the generators and the bus voltage magnitudes angles. Also, to turn off the solver output within the REPL, we use the set_silent function before calling solve! function. Here is an example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.set_silent(analysis.jump)\nsolve!(system, analysis)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.set_silent(analysis.jump)\nsolve!(system, analysis)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"By executing this function, you will obtain the solution with the optimal values for the active power outputs of the generators and the bus voltage angles:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"generator = analysis.power.generator;\nprint(system.generator.label, generator.active, generator.reactive)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Objective-Value","page":"AC Optimal Power Flow","title":"Objective Value","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the objective value of the optimal power flow solution, you can use the objective_value function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_value(analysis.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimalPowerCurrentAnalysisManual","page":"AC Optimal Power Flow","title":"Power and Current Analysis","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After obtaining the solution from the AC optimal power flow, we can calculate various electrical quantities related to buses, branches, and generators using the power! and current! functions. For instance, let us consider the power system for which we obtained the AC optimal power flow solution:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, Ipopt\n\n@default(unit) # hide\n@default(template) # hide\nsystem = powerSystem()\n\n@bus(minMagnitude = 0.9, maxMagnitude = 1.1)\naddBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.05, angle = 0.17)\naddBus!(system; label = \"Bus 2\", active = 0.1, reactive = 0.01, conductance = 0.04)\naddBus!(system; label = \"Bus 3\", active = 0.05, reactive = 0.02)\n\n@branch(resistance = 0.5, reactance = 1.0, conductance = 1e-4, susceptance = 0.01)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", longTerm = 0.15)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", longTerm = 0.10)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", longTerm = 0.25)\n\n@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2, reactive = 0.5)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.2, reactive = 0.1)\n\ncost!(system; label = \"Generator 1\", active = 2, polynomial = [1100.2; 500; 80])\ncost!(system; label = \"Generator 2\", active = 1, piecewise = [10.8 12.3; 14.7 16.8; 18 18.1])\n\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nJuMP.set_silent(analysis.jump) # hide\nsolve!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can now utilize the following functions to calculate powers and currents:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"power!(system, analysis)\ncurrent!(system, analysis)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For instance, if we want to show the active power injections at each bus and the current flow magnitudes at each \"from\" bus end of the branch, we can employ the following code:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.power.injection.active)\nprint(system.branch.label, analysis.current.from.magnitude)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nTo better understand the powers and current associated with buses and branches that are calculated by the power! and current! functions, we suggest referring to the tutorials on AC Optimal Power Flow.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To compute specific quantities for particular components, rather than calculating powers or currents for all components, users can utilize one of the provided functions below.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-Injection","page":"AC Optimal Power Flow","title":"Active and Reactive Power Injection","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the active and reactive power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = injectionPower(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-Injection-from-Generators","page":"AC Optimal Power Flow","title":"Active and Reactive Power Injection from Generators","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = supplyPower(system, analysis; label = \"Bus 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-at-Shunt-Element","page":"AC Optimal Power Flow","title":"Active and Reactive Power at Shunt Element","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = shuntPower(system, analysis; label = \"Bus 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-Flow","page":"AC Optimal Power Flow","title":"Active and Reactive Power Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, we can compute the active and reactive power flow at both the \"from\" and \"to\" bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = fromPower(system, analysis; label = \"Branch 2\")\nactive, reactive = toPower(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-at-Charging-Admittances","page":"AC Optimal Power Flow","title":"Active and Reactive Power at Charging Admittances","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the total active and reactive power linked with branch charging admittances of the particular branch, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = chargingPower(system, analysis; label = \"Branch 1\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Active powers indicate active losses within the branch's charging or shunt admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-at-Series-Impedance","page":"AC Optimal Power Flow","title":"Active and Reactive Power at Series Impedance","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the active and reactive power across the series impedance of the particular branch, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = seriesPower(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance's inductive characteristics.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Current-Injection","page":"AC Optimal Power Flow","title":"Current Injection","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the current injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"magnitude, angle = injectionCurrent(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Current-Flow","page":"AC Optimal Power Flow","title":"Current Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can compute the current flow at both the \"from\" and \"to\" bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"magnitude, angle = fromCurrent(system, analysis; label = \"Branch 2\")\nmagnitude, angle = toCurrent(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Current-Through-Series-Impedance","page":"AC Optimal Power Flow","title":"Current Through Series Impedance","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the current passing through the series impedance of the branch in the direction from the \"from\" bus end to the \"to\" bus end, you can use the following function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"magnitude, angle = seriesCurrent(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimalReusingPowerSystemModelManual","page":"AC Optimal Power Flow","title":"Reusing Power System Model","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similar to what we discussed in the section Reusing Power System Model concerning AC power flow, the PowerSystem composite type, along with its previously established ac field, offers remarkable versatility. This versatility extends to the use of the PowerSystem type in various AC analyses. As demonstrated when we employ initial conditions from AC power flow for AC optimal power flow, the PowerSystem type seamlessly integrates across different analysis types.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Furthermore, all fields within the PowerSystem type automatically adjust when any of the functions responsible for adding components or modifying their parameters are used. These functions encompass:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"addBranch!,\naddGenerator!,\nupdateBus!,\nupdateBranch!,\nupdateGenerator!.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"This implies that users have the flexibility to add or update parameters after creating the PowerSystem composite type. Subsequently, they can utilize acOptimalPowerFlow to establish a AC optimal power flow model. However, as consistently emphasized throughout this manual, it is significantly more advantageous to reuse the optimal power flow model instead.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACReusingOptimalPowerFlowModelManual","page":"AC Optimal Power Flow","title":"Reusing Optimal Power Flow Model","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Efficiently modelling and solving large-scale power systems requires reusing the ACOptimalPowerFlow type, avoiding the need to run acOptimalPowerFlow. Constructing an optimal power flow model can be time-consuming, especially for large systems. By creating the ACOptimalPowerFlow composite type once, users can easily adapt it to changes in the power system's structure, saving computational resources and time. This simplifies dynamic power system modifications without recreating the entire optimization model.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As demonstrated in this manual, this is achieved by using the ACOptimalPowerFlow type as an argument in functions that add or update components within the PowerSystem composite type. If these changes are valid and provide accurate solutions, these functions will automatically adjust the composite types, ensuring smooth integration for dynamic power system adjustments while maintaining the integrity of the DC optimal power flow analysis.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Starting-Primal-Values","page":"AC Optimal Power Flow","title":"Starting Primal Values","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Utilizing the ACOptimalPowerFlow type and proceeding directly to the solver offers the advantage of a \"warm start\". In this scenario, the starting primal values for the subsequent solving step correspond to the solution obtained from the previous step.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the previous example, we obtained the following solution:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"generator = analysis.power.generator;\nprint(system.generator.label, generator.active, generator.reactive)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Now, let us introduce changes to the power system from the previous example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateGenerator!(system, analysis; label = \"Generator 2\", maxActive = 0.08)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, solve this new power system. During the execution of the solve! function, the primal starting values will first be set, and these values will be defined according to the values given above.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"solve!(system, analysis)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As a result, we obtain a new solution:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, generator.active, generator.reactive)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users retain the flexibility to reset these initial primal values to their default configurations at any juncture. This can be accomplished by utilizing the active and reactive power outputs of the generators and the initial bus voltage magnitudes and angles extracted from the PowerSystem composite type, employing the startingPrimal! function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"startingPrimal!(system, analysis)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"These values are precisely identical to what we would obtain if we executed the acOptimalPowerFlow function following all the updates we performed:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, generator.active, generator.reactive)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"#JuliaGrid","page":"Introduction","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid is an open-source and easy-to-use simulation tool and solver developed for researchers and educators. It is available as a Julia package, and its source code is released under the MIT License. JuliaGrid primarily focuses on steady-state power system analyses, providing a versatile set of algorithms while also allowing for easy manipulation of both the power system configuration and the analyses involved.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Our documentation is divided into three distinct categories. The manual provides users with guidance on using available functions, explaining the expected outcomes, and offering instructions for modifying power system configurations and specific analyses. The tutorials delve deeper into the mathematical implementation of algorithms, allowing users to gain an in-depth understanding of the formulas behind various functions. Lastly, the API references offer a comprehensive list of functions within the package, categorized according to specific analyses.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In order to encourage code reusability and give users the ability to customize their analyses as required, we deconstruct specific analyses. However, the overall logic can be simplified as follows: users should initially build a power system, then select between the AC or DC model, define the specific type of analysis, and ultimately, solve the generated framework.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Below, we have provided a list of examples to assist users in getting started with the JuliaGrid package. These examples highlight some of the possibilities that the package offers.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#AC-Power-Flow","page":"Introduction","title":"AC Power Flow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid\n\nsystem = powerSystem(\"case14.h5\")          # Build the power system model\nacModel!(system)                           # Generate matrices and vectors in the AC model\n\nanalysis = newtonRaphson(system)           # Initialize the Newton-Raphson method\nfor iteration = 1:10                       # Begin the iteration loop\n    stopping = mismatch!(system, analysis) # Compute power mismatches\n    if all(stopping .< 1e-8)               # Check if the stopping criterion is met\n        break                              # Stop the iteration loop if the criterion is met\n    end\n    solve!(system, analysis)               # Compute bus voltages\nend\n\npower!(system, analysis)                   # Compute powers within the power system\ncurrent!(system, analysis)                 # Compute currents within the power system","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#DC-Power-Flow","page":"Introduction","title":"DC Power Flow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid\n\n@power(MW, MVAr, MVA)                    # Specify the power units for input data\nsystem = powerSystem(\"case14.h5\")        # Build the power system model\ndcModel!(system)                         # Generate matrices and vectors in the DC model\n\nanalysis = dcPowerFlow(system)           # Initialize the DC power flow analysis\nsolve!(system, analysis)                 # Compute bus voltage angles\n\n@generator(active = 20)                  # Define a template for generators\naddGenerator!(system, analysis; bus = 1) # Add a new generator into the power system\nsolve!(system, analysis)                 # Compute bus voltage angles in the updated setup","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#AC-Optimal-Power-Flow","page":"Introduction","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid, Ipopt\n\nsystem = powerSystem(\"case14.h5\")              # Build the power system model\nacModel!(system)                               # Generate matrices and vectors in the AC model\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer) # Build the AC optimal power flow model\nsolve!(system, analysis)                       # Compute generator powers and bus voltages\n\ncurrent!(system, analysis)                     # Compute currents within the power system\n\n@branch(resistance = 0.01, reactance = 0.2)    # Define a new template for branches \naddBranch!(system, analysis; from = 1, to = 5) # Add a new branch into the power system\nsolve!(system, analysis)                       # Compute a new solution in the updated setup  ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#DC-Optimal-Power-Flow","page":"Introduction","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid, HiGHS\n\nsystem = powerSystem(\"case14.h5\")                 # Build the power system model\ndcModel!(system)                                  # Generate matrices and vectors in DC model\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer) # Build the DC optimal power flow model\nsolve!(system, analysis)                          # Compute generator powers and bus voltages\n\nupdateBus!(system, analysis; label = 1, type = 1) # Modify the existing bus\nupdateBus!(system, analysis; label = 2, type = 3) # Designate the new slack bus\nsolve!(system, analysis)                          # Compute new solution in the updated setup","category":"page"},{"location":"manual/acPowerFlow/#ACPowerFlowManual","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To perform the AC power flow analysis, you will first need the PowerSystem composite type that has been created with the ac model. Following that, you can construct the power flow model encapsulated within the ACPowerFlow abstract type by employing one of the following functions:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"newtonRaphson,\nfastNewtonRaphsonBX,\nfastNewtonRaphsonXB,\ngaussSeidel.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"These functions will set up the AC power flow framework. To obtain bus voltages and solve the power flow problem, you can use the following functions:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"mismatch!,\nsolve!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After obtaining the AC power flow solution, JuliaGrid offers post-processing analysis functions for calculating powers and currents associated with buses, branches, or generators:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power!,\ncurrent!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Furthermore, there are specialized functions dedicated to calculating specific types of powers related to particular buses, branches, or generators:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"injectionPower,\nsupplyPower,\nshuntPower,\nfromPower,\ntoPower,\nseriesPower,\nchargingPower,\ngeneratorPower.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Likewise, there are specialized functions dedicated to calculating specific types of currents related to particular buses or branches:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"injectionCurrent,\nfromCurrent,\ntoCurrent,\nseriesCurrent.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Additionally, the package provides two functions for reactive power limit validation of generators and adjusting the voltage angles to match an arbitrary bus angle:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"reactiveLimit!,\nadjustAngle!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#BusTypeModificationManual","page":"AC Power Flow","title":"Bus Type Modification","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Depending on how the system is constructed, the types of buses that are initially set are checked and can be changed during the initialization process, using one of the available functions such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel. Assuming the Newton-Raphson method has been chosen, to explain the details, we can observe a power system with only buses and generators. The following code snippet can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2)\naddBus!(system; label = \"Bus 3\", type = 2)\n\naddGenerator!(system; bus = \"Bus 2\")\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Initially, the Bus 1 is set as the slack bus (type = 3), and the Bus 2 and Bus 3 are generator buses (type = 2). However, the Bus 3 does not have a generator, and JuliaGrid considers this a mistake and changes the corresponding bus to a demand bus (type = 1).","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After this step, JuliaGrid verifies the slack bus. Initially, the slack bus (type = 3) corresponds to Bus 1, but since it does not have an in-service generator connected to it, JuliaGrid recognizes it as an error. Therefore, JuliaGrid assigns a new slack bus from the available generator buses (type = 2) that have connected in-service generators. In this specific example, Bus 2 becomes the new slack bus.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid\n@default(unit)\n@default(template)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2)\naddBus!(system; label = \"Bus 3\", type = 2)\n\naddGenerator!(system; bus = \"Bus 2\")\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As a result, we can observe the updated array of bus types:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, system.bus.layout.type)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Note that, if a bus is initially defined as the demand bus (type = 1) and later a generator is added to it, the bus type will not be changed to the generator bus (type = 2). Instead, it will remain as a demand bus.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThe type of only those buses that are defined as generator buses (type = 2) but do not have a connected in-service generator will be changed to demand buses (type = 1).The bus that is defined as the slack bus (type = 3) but lacks a connected in-service generator will have its type changed to the demand bus (type = 1). Meanwhile, the first generator bus (type = 2) with an in-service generator connected to it will be assigned as the new slack bus (type = 3).","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#SetupStartingVoltagesManual","page":"AC Power Flow","title":"Setup Starting Voltages","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To begin analysing the AC power flow in JuliaGrid, we must first establish the PowerSystem composite type and define the AC model by calling the acModel! function. Once the power system is set up, we can select one of the available methods for solving the AC power flow problem, such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel. Assuming we have selected the Newton-Raphson method, we can use the following code snippet:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.0, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, magnitude = 0.9, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 2, magnitude = 0.8, angle = -0.2)\n\naddGenerator!(system; bus = \"Bus 1\", magnitude = 1.3)\naddGenerator!(system; bus = \"Bus 2\", magnitude = 1.1)\naddGenerator!(system; bus = \"Bus 3\", magnitude = 1.2)\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Here, in this code snippet, the function newtonRaphson generates starting voltage vectors in polar coordinates, where the magnitudes and angles are constructed as:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)\n","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The starting voltage magnitudes are determined by a combination of the initial values specified within the buses and the setpoints provided within the generators:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[system.bus.voltage.magnitude system.generator.voltage.magnitude]","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"On the other hand, the starting values for the voltage angles are defined based on the initial values given within the buses:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"system.bus.voltage.angle","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThe rule governing the specification of starting voltage magnitudes is simple. If a bus has an in-service generator and is declared the generator bus (type = 2), then the starting voltage magnitudes are specified using the setpoint provided within the generator. This is because the generator bus has known values of voltage magnitude that are specified within the generator.On the other hand, the slack bus (type = 3) always requires an in-service generator. The starting value of the voltage magnitude at the slack bus is determined exclusively by the setpoints provided within the generators connected to it. This is a result of the slack bus having a known voltage magnitude that must be maintained.If there are multiple generators connected to the generator or slack bus, the initial voltage magnitude will align with the magnitude setpoint specified for the first in-service generator in the list.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Custom-Starting-Voltages","page":"AC Power Flow","title":"Custom Starting Voltages","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This method of specifying starting values has a significant advantage in that it allows the user to easily change the starting voltage magnitudes and angles, which play a crucial role in iterative methods. For instance, suppose we define our power system as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.0, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, magnitude = 0.9, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 2, magnitude = 0.8, angle = -0.2)\n\naddGenerator!(system; bus = \"Bus 1\", magnitude = 1.1)\naddGenerator!(system; bus = \"Bus 3\", magnitude = 1.2)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Now, the user can initiate a \"flat start\", this can be easily done as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for i = 1:system.bus.number\n    system.bus.voltage.magnitude[i] = 1.0\n    system.bus.voltage.angle[i] = 0.0\nend\n\nanalysis = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The starting voltage values are:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Consequently, when using the Newton-Raphson method, the iteration begins with a fixed set of voltage magnitude values that remain constant throughout the iteration process. The remaining values are initialized as part of the \"flat start\" approach.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACPowerFlowSolutionManual","page":"AC Power Flow","title":"Power Flow Solution","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To solve the AC power flow problem using JuliaGrid, we first need to create the PowerSystem composite type and define the AC model by calling the acModel! function. Here is an example:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", resistance = 0.01, reactance = 0.05)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 3\", resistance = 0.02, reactance = 0.01)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.01, reactance = 0.20)\n\naddGenerator!(system; bus = \"Bus 1\", active = 3.2, magnitude = 1.1)\naddGenerator!(system; bus = \"Bus 2\", active = 3.2, magnitude = 1.2)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Once the AC model is defined, we can choose the method to solve the power flow problem. JuliaGrid provides four methods: newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, and gaussSeidel. For example, to use the Newton-Raphson method to solve the power flow problem, we can call the newtonRaphson function as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This function sets up the desired method for an iterative process based on two functions: mismatch! and solve!. The mismatch! function calculates the active and reactive power injection mismatches using the given voltage magnitudes and angles, while solve! computes the voltage magnitudes and angles.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To perform an iterative process with the Newton-Raphson or fast Newton-Raphson methods in JuliaGrid, the mismatch! function must be included inside the iteration loop. For instance:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:100\n    mismatch!(system, analysis)\n    solve!(system, analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Upon completion of the AC power flow analysis, the solution is conveyed through the bus voltage magnitudes and angles. Here are the values corresponding to the buses:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In contrast, the iterative loop of the Gauss-Seidel method does not require the mismatch! function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = gaussSeidel(system)\nfor iteration = 1:100\n    solve!(system, analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In these examples, the algorithms run until the specified number of iterations is reached.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nWe recommend that the reader refer to the tutorial on AC Power Flow Analysis, where we explain the implementation of the methods and algorithm structures in detail.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Breaking-the-Iterative-Process","page":"AC Power Flow","title":"Breaking the Iterative Process","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"You can terminate the iterative process using the mismatch! function, which is why mismatches are computed separately. The following code shows an example of how to use the the function to break out of the iteration loop:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The mismatch! function returns the maximum absolute values of active and reactive power injection mismatches, which are commonly used as a convergence criterion in iterative AC power flow algorithms. Note that the function can also be used to terminate the loop when using the Gauss-Seidel method, even though it is not required.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"tip: Tip\nTo ensure an accurate count of iterations, it is important for the user to place the iteration counter after the condition expressions within the if construct. Counting the iterations before this point can result in an incorrect number of iterations, as it leads to an additional iteration being performed.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACPowerCurrentAnalysisManual","page":"AC Power Flow","title":"Power and Current Analysis","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After obtaining the solution from the AC power flow, we can calculate various electrical quantities related to buses, branches, and generators using the power! and current! functions. For instance, let us consider the power system for which we obtained the AC power flow solution:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, susceptance = 0.03)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.5, conductance = 0.02)\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can now utilize the provided functions to compute powers and currents. The following functions can be used for this purpose:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power!(system, analysis)\ncurrent!(system, analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"For instance, if we want to show the active power injections at each bus and the current flow angles at each \"to\" bus end of the branch, we can employ the following code:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.power.injection.active)\nprint(system.branch.label, analysis.current.to.angle)\n","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nTo better understand the powers and currents associated with buses, branches and generators that are calculated by the power! and current! functions, we suggest referring to the tutorials on AC Power Flow Analysis.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To compute specific quantities for particular components, rather than calculating powers or currents for all components, users can utilize one of the provided functions below.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-Injection","page":"AC Power Flow","title":"Active and Reactive Power Injection","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = injectionPower(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-Injection-from-Generators","page":"AC Power Flow","title":"Active and Reactive Power Injection from Generators","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = supplyPower(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-at-Shunt-Element","page":"AC Power Flow","title":"Active and Reactive Power at Shunt Element","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = shuntPower(system, analysis; label = \"Bus 3\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-Flow","page":"AC Power Flow","title":"Active and Reactive Power Flow","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, we can compute the active and reactive power flow at both the \"from\" and \"to\" bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = fromPower(system, analysis; label = \"Branch 2\")\nactive, reactive = toPower(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-at-Charging-Admittances","page":"AC Power Flow","title":"Active and Reactive Power at Charging Admittances","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = chargingPower(system, analysis; label = \"Branch 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Active powers indicate active losses within the branch's charging or shunt admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-at-Series-Impedance","page":"AC Power Flow","title":"Active and Reactive Power at Series Impedance","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power across the series impedance of the particular branch, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = seriesPower(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance's inductive characteristics.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Generator-Active-and-Reactive-Power-Output","page":"AC Power Flow","title":"Generator Active and Reactive Power Output","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can compute the active and reactive power output of a particular generator using the function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = generatorPower(system, analysis; label = \"Generator 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Current-Injection","page":"AC Power Flow","title":"Current Injection","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the current injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"magnitude, angle = injectionCurrent(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Current-Flow","page":"AC Power Flow","title":"Current Flow","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can compute the current flow at both the \"from\" and \"to\" bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"magnitude, angle = fromCurrent(system, analysis; label = \"Branch 2\")\nmagnitude, angle = toCurrent(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Current-Through-Series-Impedance","page":"AC Power Flow","title":"Current Through Series Impedance","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the current passing through the series impedance of the branch in the direction from the \"from\" bus end to the \"to\" bus end, you can use the following function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"magnitude, angle = seriesCurrent(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACReusingPowerSystemModelManual","page":"AC Power Flow","title":"Reusing Power System Model","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In essence, the power system model's reusability entails that once a user creates a PowerSystem composite type, they can share it across various functions without the necessity of recreating the type from scratch.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Reusability-for-Diverse-Methods","page":"AC Power Flow","title":"Reusability for Diverse Methods","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The initial application of the reusable PowerSystem type is simple: it can be shared among various methods, which can yield benefits. For example, the Gauss-Seidel method is commonly used for a speedy approximate solution, whereas the Newton-Raphson method is typically utilized for the precise final solution. Thus, we can execute the Gauss-Seidel method for a limited number of iterations, as exemplified below:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5)\naddBus!(system; label = \"Bus 2\", type = 2, reactive = 0.05, susceptance = 0.03)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.5, conductance = 0.02)\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 2.3)\n\nacModel!(system)\n\ngs = gaussSeidel(system)\nfor iteration = 1:3\n    solve!(system, gs)\nend","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, we can initialize the Newton-Raphson method with the voltages obtained from the Gauss-Seidel method and start the algorithm from that point:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\n\nfor i = 1:system.bus.number\n    analysis.voltage.magnitude[i] = gs.voltage.magnitude[i]\n    analysis.voltage.angle[i] = gs.voltage.angle[i]\nend\n\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThe functions newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel only modify the PowerSystem type to eliminate mistakes in the bus types as explained in the section Bus Type Modification. Further, the functions mismatch! and solve! do not modify the PowerSystem type at all. Therefore, it is safe to use the same PowerSystem type for multiple analyses once it has been created.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Reusability-for-Diverse-Power-System-Reconfiguration","page":"AC Power Flow","title":"Reusability for Diverse Power System Reconfiguration","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the PowerSystem composite type, along with its previously established ac field, offers unlimited versatility. This facilitates the seamless sharing of the PowerSystem type across various AC power flow analyses. All fields automatically adjust when any of the functions that add components or update their parameters are utilized:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"addBranch!,\naddGenerator!,\nupdateBus!,\nupdateBranch!,\nupdateGenerator!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To provide an example, let us continue the previous example where we created a power system with the ac field. Now, we are interested in a scenario where we introduce a new branch labelled as Branch 4, make adjustments to the power output of Generator 2, modify the active power demand at Bus 2, and deactivate Branch 3 from its operational state. This entire process can be effortlessly executed by reusing the PowerSystem composite type:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"addBranch!(system; label = \"Branch 4\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.03)\nupdateGenerator!(system; label = \"Generator 2\", active = 2.5)\nupdateBus!(system; label = \"Bus 2\", active = 0.2)\nupdateBranch!(system; label = \"Branch 3\", status = 0)\n\nanalysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACReusingPowerFlowModelManual","page":"AC Power Flow","title":"Reusing Power Flow Model","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Reusing the ACPowerFlow abstract type essentially involves circumventing the repetitive execution of functions such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This can be accomplished by using functions that add components or update their parameters and passing the ACPowerFlow abstract type as an argument within the PowerSystem composite type. If the modifications the user intends to make are compatible with reusing the ACPowerFlow type, they will be executed and will consequently impact both types.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"It is important to note that in some cases, reusing is not feasible. For example, the fast Newton-Raphson algorithm relies on constant Jacobian matrices created during the instantiation of the ACPowerFlow type. This means that making modifications using functions that add branches or update branch parameters is not possible. In such instances, JuliGrid will provide an error message.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Continuing from the previous example, let us add Branch 5 to the existing system and proceed with the iterations without executing the newtonRaphson function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"addBranch!(system, analysis; label = \"Branch 5\", from = \"Bus 1\", to = \"Bus 3\")\n\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The solutions obtained for the AC power flow are as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"However, attempting to take Generator 2 out-of-service is not possible, as this operation would yield incorrect results if we proceed directly to the iterations. In this case, executing the newtonRaphson function is mandatory:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateGenerator!(system, analysis; label = \"Generator 2\", status = 0)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"info: Info\nWhen a user employs ACPowerFlow as an argument in functions for adding components or modifications, functions are checking if ACPowerFlow can be reused. If possible, both PowerSystem and ACPowerFlow types will be modified, allowing for a seamless transition to subsequent iterations without extra steps.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Starting-Voltages","page":"AC Power Flow","title":"Starting Voltages","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Reusing the ACPowerFlow type and proceeding directly to the iterations provides the advantage of a \"warm start\", where the starting voltages for the next iteration step match the solution from the previous example, allowing for efficient continuation of the power flow analysis.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Furthermore, users have the flexibility to modify these values as required by utilizing the magnitude and angle keywords within the updateBus! and updateGenerator! functions. Let us update Bus 3 and Generator 2 as an example:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateBus!(system, analysis; label = \"Bus 3\", magnitude = 0.95, angle = -0.07)\nupdateGenerator!(system, analysis; label = \"Generator 2\", magnitude = 1.1)\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, let us observe the new starting voltages for the updated power system:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As we can see, JuliaGrid accepts new values and combines them with the last obtained bus voltages. If user wants to set starting voltages as per the usual scenario using the PowerSystem composite type, you can achieve this by using the startingVoltage! function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"startingVoltage!(system, analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Now, we have starting voltages defined exclusively according to the PowerSystem. These values are exactly the same as if we executed the newtonRaphson function after all the updates we performed:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Following this, we can run the Newton-Raphson method once more to solve the AC power flow:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#GeneratorReactivePowerLimitsManual","page":"AC Power Flow","title":"Generator Reactive Power Limits","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The function reactiveLimit! can be used by the user to check if the generators' output of reactive power is within the defined limits after obtaining the solution from the AC power flow analysis. This can be done by using the example code provided:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.5)\naddBus!(system; label = \"Bus 3\", type = 2, reactive = 0.05)\naddBus!(system; label = \"Bus 4\", type = 2, reactive = 0.05)\n\n@branch(resistance = 0.015)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 4\", reactance = 0.004)\n\n@generator(minReactive = -0.4, maxReactive = 0.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\")\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 3\", reactive = 0.8)\naddGenerator!(system; label = \"Generator 3\", bus = \"Bus 4\", reactive = 0.9)\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nviolate = reactiveLimit!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The output reactive power of the observed generators is subject to limits which are defined as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[system.generator.capability.minReactive system.generator.capability.maxReactive]","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After obtaining the solution of the AC power flow analysis, the reactiveLimit! function is used to internally calculate the output powers of the generators and verify if these values exceed the defined limits. Consequently, the variable violate indicates whether there is a violation of limits. In the provided example, it can be observed that the Generator 2 and Generator 3 violate the maximum limit:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.generator.label, violate)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Due to these violations of limits, the PowerSystem type undergoes modifications, and the output reactive power at the limit-violating generators is adjusted as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.generator.label, system.generator.output.reactive)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To ensure that these values stay within the limits, the bus type must be changed from the generator bus (type = 2) to the demand bus (type = 1), as shown below:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, system.bus.layout.type)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After modifying the PowerSystem type as described earlier, we can run the simulation again with the following code:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Once the simulation is complete, we can verify that all generator reactive power outputs now satisfy the limits by checking the violate variable again:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"violate = reactiveLimit!(system, analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThe reactiveLimit! function changes the PowerSystem composite type deliberately because it is intended to help users create the power system where all reactive power outputs of the generators are within limits.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#New-Slack-Bus","page":"AC Power Flow","title":"New Slack Bus","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Looking at the following code example, we can see that the output limits of the generator are set only for Generator 1 that is connected to the slack bus:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5, reactive = 0.05)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.5)\naddBus!(system; label = \"Bus 3\", type = 2)\naddBus!(system; label = \"Bus 4\", type = 2)\n\n@branch(resistance = 0.01)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 4\", reactance = 0.004)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", maxReactive = 0.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 4\", reactive = 0.3)\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Upon checking the limits, we can observe that the slack bus has been transformed by executing the following code:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"violate = reactiveLimit!(system, analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Here, the generator connected to the slack bus is violating the minimum reactive power limit, which indicates the need to convert the slack bus. It is important to note that the new slack bus can be created only from the generator bus (type = 2). We will now perform another AC power flow analysis on the modified system using the following code:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After examining the bus voltages, we will focus on the angles:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can observe that the angles have been calculated based on the new slack bus. JuliaGrid offers the function to adjust these angles to match the original slack bus as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"adjustAngle!(system, analysis; slack = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Here, the slack keyword should correspond to the label of the slack bus. After executing the above code, the updated results can be viewed:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"api/optimalPowerFlow/#OptimalPowerFlowAPI","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"For further information on this topic, please see the AC Optimal Power Flow or DC Optimal Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for optimal power flow analysis.","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Build-AC-Optimal-Power-Flow-Model","page":"Optimal Power Flow","title":"Build AC Optimal Power Flow Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"acOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#Solve-AC-Optimal-Power-Flow","page":"Optimal Power Flow","title":"Solve AC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!","category":"page"},{"location":"api/optimalPowerFlow/#Build-DC-Optimal-Power-Flow-Model","page":"Optimal Power Flow","title":"Build DC Optimal Power Flow Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"dcOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#Solve-DC-Optimal-Power-Flow","page":"Optimal Power Flow","title":"Solve DC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!","category":"page"},{"location":"api/optimalPowerFlow/#Additional-Function","page":"Optimal Power Flow","title":"Additional Function","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"startingPrimal! ","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Build-AC-Optimal-Power-Flow-Model-2","page":"Optimal Power Flow","title":"Build AC Optimal Power Flow Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"acOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.acOptimalPowerFlow","text":"acOptimalPowerFlow(system::PowerSystem, optimizer; bridge, name)\n\nThe function takes the PowerSystem composite type as input to establish the structure for solving the AC optimal power flow. The optimizer argument is also required to create and solve the optimization problem. If the ac field within the PowerSystem composite type has not been created, the function will initiate an update automatically.\n\nAdditionally, the optimizer argument is a necessary component for formulating and solving the optimization problem. Specifically, JuliaGrid constructs the AC optimal power flow using the JuMP package and provides support for commonly employed solvers. For more detailed information, please consult the JuMP documenatation.\n\nKeywords\n\nJuliaGrid offers the ability to manipulate the jump model based on the guidelines provided in the JuMP documentation. However, certain configurations may require different method calls, such as:\n\nbridge: used to manage the bridging mechanism;\nname: used to manage the creation of string names.\n\nBy default, these keyword settings are configured as true.\n\nReturns\n\nThe function returns an instance of the ACOptimalPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\njump: the JuMP model;\nvariable: holds the variable references to the JuMP model;\nconstraint: holds the constraint references to the JuMP model;\nobjective: holds the objective expression of the JuMP model;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExamples\n\nCreate the complete AC optimal power flow model:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Solve-AC-Optimal-Power-Flow-2","page":"Optimal Power Flow","title":"Solve AC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!(::PowerSystem, ::ACOptimalPowerFlow)","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::ACOptimalPowerFlow)\n\nThe function finds the AC optimal power flow solution and calculate the bus voltage magnitudes and angles, and output active and reactive powers of each generators.\n\nThe calculated voltage magnitudes and angles and active and reactive powers are then stored in the variables of the voltage and power fields of the ACOptimalPowerFlow composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Build-DC-Optimal-Power-Flow-Model-2","page":"Optimal Power Flow","title":"Build DC Optimal Power Flow Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"dcOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.dcOptimalPowerFlow","text":"dcOptimalPowerFlow(system::PowerSystem, optimizer; bridge, name)\n\nThe function takes the PowerSystem composite type as input to establish the structure for solving the DC optimal power flow. If the dc field within the PowerSystem composite type has not been created, the function will automatically  initiate an update process.\n\nAdditionally, the optimizer argument is a necessary component for formulating and solving the optimization problem. Specifically, JuliaGrid constructs the DC optimal power flow using the JuMP package and provides support for commonly employed solvers. For more detailed information, please consult the JuMP documenatation.\n\nKeywords\n\nJuliaGrid offers the ability to manipulate the jump model based on the guidelines provided in the JuMP documentation. However, certain configurations may require different method calls, such as:\n\nbridge: used to manage the bridging mechanism;\nname: used to manage the creation of string names.\n\nBy default, these keyword settings are configured as true.\n\nReturns\n\nThe function returns an instance of the DCOptimalPowerFlow type, which includes the following fields:\n\nvoltage: the variable allocated to store the bus voltage angle;\npower: the variable allocated to store the active powers;\njump: the JuMP model;\nvariable: holds the variable references to the JuMP model;\nconstraint: holds the constraint references to the JuMP model;\nobjective: holds the objective expression of the JuMP model;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExamples\n\nCreate the complete DC optimal power flow model:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Solve-DC-Optimal-Power-Flow-2","page":"Optimal Power Flow","title":"Solve DC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!(::PowerSystem, ::DCOptimalPowerFlow)","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::DCOptimalPowerFlow)\n\nThe function finds the DC optimal power flow solution and calculate the bus voltage angles and output active powers of the generators.\n\nThe calculated voltage angles and active powers are then stored in the angle variable of the voltage field and the generator variable of the power field.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Additional-Function-2","page":"Optimal Power Flow","title":"Additional Function","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"startingPrimal!(::PowerSystem, ::ACOptimalPowerFlow)","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.startingPrimal!-Tuple{PowerSystem, ACOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.startingPrimal!","text":"startingPrimal!(system::PowerSystem, analysis::OptimalPowerFlow)\n\nIn the context of the ACOptimalPowerFlow composite type, this function retrieves the active and reactive power outputs of the generators, as well as the voltage magnitudes and angles from the PowerSystem composite type. It then assigns these values to the ACOptimalPowerFlow type, allowing users to initialize starting primal values as needed.\n\nFor the DCOptimalPowerFlow composite type, this function retrieves the active power outputs of the generators and the bus voltage angles from the PowerSystem composite type. These values are then assigned to the DCOptimalPowerFlow type, enabling users to initialize starting primal values according to their requirements.\n\nUpdates\n\nThis function only updates the voltage and generator fields of the OptimalPowerFlow abstract type.\n\nAbstract type\n\nThe abstract type OptimalPowerFlow can have the following subtypes:\n\nACOptimalPowerFlow: employed to initializing starting primal values within the AC optimal power flow;\nDCOptimalPowerFlow: employed to initialize starting primal values within the DC optimal power flow.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\n\nupdateBus!(system, analysis; label = 14, reactive = 0.13, magnitude = 1.2, angle = -0.17)\n\nstartingPrimal!(system, analysis)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"}]
}
