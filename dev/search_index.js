var documenterSearchIndex = {"docs":
[{"location":"operatingState/bus/#operatingStateBus","page":"Operating State of Buses","title":"Operating State of Buses","text":"","category":"section"},{"location":"operatingState/bus/","page":"Operating State of Buses","title":"Operating State of Buses","text":"Once the bus voltages are obtained from one of the analyses, it is possible to determine powers related to the buses. The function receives composite types PowerSystem and Result.","category":"page"},{"location":"operatingState/bus/","page":"Operating State of Buses","title":"Operating State of Buses","text":"bus!","category":"page"},{"location":"operatingState/bus/#JuliaGrid.bus!","page":"Operating State of Buses","title":"JuliaGrid.bus!","text":"The function computes powers related to buses.\n\nbus!(system::PowerSystem, result::Result)\n\nThe function updates the field result.bus of the composite type Result.\n\nAC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nbus!(system, result)\n\nDC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\nbus!(system, result)\n\n\n\n\n\n","category":"function"},{"location":"operatingState/branch/#operatingStateBranch","page":"Operating State of Branches","title":"Operating State of Branches","text":"","category":"section"},{"location":"operatingState/branch/","page":"Operating State of Branches","title":"Operating State of Branches","text":"Once the bus voltages are obtained from one of the analyses, it is possible to determine powers nad currents related to the branches. The function receives composite types PowerSystem and Result.","category":"page"},{"location":"operatingState/branch/","page":"Operating State of Branches","title":"Operating State of Branches","text":"branch!","category":"page"},{"location":"operatingState/branch/#JuliaGrid.branch!","page":"Operating State of Branches","title":"JuliaGrid.branch!","text":"The function computes powers and currents related to branches for the AC power flow analysis. For the DC power flow analysis, the function computes only active powers.\n\nbranch!(system::PowerSystem, result::Result)\n\nThe function updates the field result.branch of the composite type Result.\n\nAC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nbranch!(system, result)\n\nDC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\nbranch!(system, result)\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/inDepthPowerFlow/#inDepthPowerFlowSolution","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"JuliaGrid is based on common network elements and benefits the unified branch model to perform the power flow analysis, which is used for defining load profiles, generator capabilities, voltage specification, contingency analysis, and planning. At the beginning, JuliaGrid requires the formation of the composite type PowerSystem using the function powerSystem(), for example:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To recall, we observe the bus/branch model as a graph mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n represents the set of buses, while the set of edges mathcalE subseteq mathcalN times mathcalN represents the set of branches of the power network. As shown in section In-depth AC Model, the power flow problem is described by the system of non-linear equations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    mathbfbar I = mathbfY mathbfbar V","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where the complex injection current into the bus i in mathcalN is defined as:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  \tbarI_i = cfracS_i^*barV_i^*","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where barV_i = V_i texte^textjtheta_i. Thus, for the bus i in mathcalN we have:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  \tcfracS_i^*barV_i^* = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The apparent power injection S_i consists of the active power P_i and reactive power Q_i, therefore we have:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  \tcfracP_i - textjQ_ibarV_i = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"According to the last equation, for the bus i in mathcalN there are four unknown variables: active power injection P_i, reactive power injection Q_i, voltage magnitude V_i and voltage angle theta_i. To solve the system of equations, two variables for each equation need to be specified. Mathematically, any two variables may be selected, but the choice is dictated by the devices connected to a particular bus. Standard options are summarized in Table below and these options define bus types [1].","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Bus Type Label JuliaGrid Known Unknown\nSlack generator V theta 3 V_i, theta_i P_i, Q_i\nGenerator PV 2 P_i, V_i Q_i, theta_i\nDemand PQ 1 P_i, Q_i V_i, theta_i","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Consequently, JuliaGrid operates with sets mathcalN_textpv and mathcalN_textpq that contain PV and PQ buses, respectively, and exactly one slack bus mathcalN_textsb. Note that JuliaGrid does not support systems with multiple slack buses.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> system.bus.layout.type","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Finally, we note according to Tellegen's theorem, the bus active P_i and reactive Q_i power injections are equal to:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  \tP_i = P_textgi - P_textdi \n    Q_i = Q_textgi - Q_textdi\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where P_textgi and Q_textgi denote the active and reactive powers of the generators that supply the bus i in mathcalN, while P_textdi and Q_textdi indicate active and reactive powers demanded by consumers at the bus i in mathcalN.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> system.bus.supply.active - system.bus.demand.active\njulia> system.bus.supply.reactive - system.bus.demand.reactive","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#inDepthNewtonRaphson","page":"In-depth Power Flow Solution","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The Newton-Raphson method is generally preferred in power flow calculations because this method has quadratic rate of convergence. First of all, the Newton-Raphson method provides a good approximation for the roots of the system of non-linear equations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbff(mathbfx) = mathbf0","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Hence, the Newton-Raphson method solves the system of non-linear equations mathbff(mathbfx), and reveals bus voltage magnitudes and angles mathbfx. According to bus types, some buses have known values of bus voltage magnitudes and angles:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"at the slack bus i in mathcalN_textsb voltage angle theta_i and magnitude V_i are known;\nat PV buses i in mathcalN_textpv voltage magnitude V_i is known.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Thus, we observe the state vector mathbf x = bm theta mathbf V^T, where bm theta in mathbbR^n-1 and mathbf V in mathbbR^n_textpq, while n_textpq = mathcalN_textpq is the number of PQ buses.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The apparent power injection S_i into the bus i in mathcalN is a function of the complex bus voltages. Hence, the real and imaginary components of the apparent power define the active and reactive power injection expressions:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    P_i =V_isumlimits_j=1^n V_j (G_ijcostheta_ij+B_ijsintheta_ij)\n    Q_i =V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij)\n\tendaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Based on the above equations, it is possible to define the active power injection functions for PV and PQ buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"and reactive power injection functions for PQ buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalN_textpq","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Functions f_P_i(mathbf x) and f_Q_i(mathbf x) are called active and reactive mismatch, respectively, and are often marked as Delta P_i(mathbf x) and Delta Q_i(mathbf x). The first terms on the right-hand side represents power injections into a bus, while the second term is constant and is obtained based on the active and reactive powers of the generators that supply a bus and active and reactive powers demanded by consumers at the same bus. Thus, the Newton-Raphson method solves the system of non-linear equations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbff(x) =\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where the first n - 1 equations are defined according to PV and PQ buses, while the last n_textpq equations are defined according to PQ buses.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#Implementation-Aspects-of-the-Newton-Raphson-Method","page":"In-depth Power Flow Solution","title":"Implementation Aspects of the Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To solve the AC power flow analysis and find the bus voltage magnitudes and angles using Newton-Raphson method, JuliaGrid provides the following sequence of functions:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The Newton-Raphson method or Newton's method is essentially based on the Taylor series expansion, neglecting the quadratic and high order terms. The Newton-Raphson is an iterative method, where we iteratively compute the increments:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfDelta x^(nu) = -mathbfJ(x^(nu))^-1mathbf f(x^(nu))","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where mathbfDelta x^(nu) = mathbf Delta bm theta^(nu) mathbf Delta mathbf V^(nu)^T represents the vector of bus voltage angels mathbf Delta bm theta^(nu) in mathbbR^n-1 and magnitudes mathbf Delta mathbf V^(nu) in mathbbR^n_textpq increments, and mathbfJ(x^(nu))in mathbbR^n_textu times n_textu is the Jacobian matrix, n_textu = n + n_textpq - 1.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.increment\njulia> result.algorithm.jacobian\njulia> result.algorithm.mismatch","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The increment mathbf Delta x^(nu) and mismatch mathbff(x^(nu)) vectors in JuliaGrid is stored identically as defined, the first n - 1 elements are bus voltage angles increments and active mismatches defined according to PV and PQ buses, while the last n_textpq elements are bus voltage magnitudes increments and and reactive mismatches defined according to PQ buses. According to this arrangement, the Jacobian matrix mathbfJ(x^(nu)) was also formed.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"After that, we update the solution:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbf x^(nu + 1) = mathbf x^(nu) + mathbf Delta mathbf x^(nu)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"JuliaGrid saves the final results after updating in vectors that contain all bus voltage magnitudes and angles:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.bus.voltage.magnitude\njulia> result.bus.voltage.angle","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The current number of iterations nu can be accessed using the command:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.iteration.number","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The iteration loop is repeated until the stopping criteria is met. Namely, after each iteration, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  f_P_i(mathbf x^(nu)) = V_i^(nu)sumlimits_j=1^n V_j^(nu)(G_ijcostheta_ij^(nu)+B_ijsintheta_ij^(nu)) - P_i\n   i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f_Q_i(mathbf x^(nu)) = V_i^(nu)sumlimits_j=1^n V_j^(nu)(G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu)) - Q_i\n     i in mathcalN_textpq","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The iteration loop is stopped when the following conditions are met:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    max f_P_i(mathbf x^(nu)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max f_Q_i(mathbf x^(nu)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where epsilon is predetermined stopping criteria. JuliaGrid stores these values in order to break the iteration loop:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.stopping.active\njulia> result.stopping.reactive","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Note that the Newton-Raphson method can have difficulties with initial conditions under \"flat start\".","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#Jacobian-Matrix","page":"In-depth Power Flow Solution","title":"Jacobian Matrix","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Without loss of generality, we assume that the slack bus is the first bus, followed by the set of PQ buses and the set of PV buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    mathcalN_textsb =  1  \n    mathcalN_textpq = 2 dots m \n    mathcalN_textpv = m + 1dots n\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where mathcalN = mathcalN_textsb cup mathcalN_textpq cup mathcalN_textpv. Hence, we have","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    bm theta = theta_2dotstheta_n^T  mathbf Delta bm theta = Delta theta_2dotsDelta theta_n^T \n    mathbf V = V_2dotsV_m^T  mathbf Delta mathbf V = Delta V_2dotsDelta V_m^T\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The Jacobian matrix mathbfJ(x^(nu)) in mathbbR^n_textu times n_textu is:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfJ(x^(nu))=\n  left\n  beginarraycccccc\n  cfracmathrm partialf_P_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_P_n(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_m 10pt\n  hline \n  cfracmathrm partialf_Q_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_Q_m(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_m\n  endarray\n  right","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"As we can see, the Jacobian matrix can be written using four block matrices:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"\t  mathbfJ(x^(nu)) =\n  beginbmatrix\n    mathbfJ_11(x^(nu)) mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu)) \n\t   mathbfJ_22(x^(nu))\n  endbmatrix","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where diagonal elements of the Jacobian sub-matrices are defined according to:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu)) mathrm partial theta_i =\n  V_i^(nu)sumlimits_j=1^n V_j^(nu)(-G_ij\n  sintheta_ij^(nu)+B_ijcostheta_ij^(nu)) - (V_i^(nu))^2B_ii\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_i^(nu) = sumlimits_\n  j=1^n V_j^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))+V_i^(nu) G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_i=V_i^(nu)\n  sumlimits_j=1^n V_j^(nu)\n  (G_ijcostheta_ij^(nu)+B_ijsintheta_ij^(nu))- (V_i^(nu))^2G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial V_i=sumlimits_j=1\n  ^n V_j^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))-V_i^(nu) B_ii\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"while non-diagonal elements of the Jacobian sub-matrices are:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu))\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_j^(nu) = V_i^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (-G_ijcostheta_ij^(nu) -B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))mathrm\n  partial V_j=V_i^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#inDepthFastNewtonRaphson","page":"In-depth Power Flow Solution","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The convergence of the fast Newton-Raphson method is in fact slower than the Newton-Raphson method, but often, shorter solution time for the updates compensates for slower convergence, resulting in overall shorter solution time. For not too heavily loaded systems a shorter overall solution time is almost always obtained. It should be noted that if the algorithm converges, it converges to a correct solution [2].","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The fast Newton-Raphson method is based on the decoupling of the power flow equations. Namely, the Newton-Raphson method is based on the equations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginbmatrix\n    mathbfJ_11(x mathbfJ_12(x  mathbfJ_21(x \n\t   mathbfJ_22(x\n  endbmatrix\n  beginbmatrix\n    mathbfDelta theta^(nu)  mathbfDelta V^(nu)\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x  mathbff_Q(mathbf x\n  endbmatrix = mathbf 0","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where we dropped the iteration index for simplicity. In transmission grids a strong coupling can be found between active powers and voltage angles, and between reactive powers and voltage magnitudes. In order to obtain decoupling, two conditions are assumed to have been satisfied: first, the resistances r_ij of the branches are small with respect to their respective reactances x_ij and, second, the angle differences are small theta_ij approx 0 [5]. Respectively, we start from the equation:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginbmatrix\n    mathbfJ_11(x)  mathbf0  mathbf0  mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbfDelta bm theta  mathbfDelta V\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where, for simplicity, we drop the iteration index. Thus, decoupled system can be written as:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    mathbff_P(mathbf x) = -mathbfJ_11(x) mathbfDelta bm  theta \n    mathbff_Q(mathbf x) = -mathbfJ_22(x) mathbfDelta V\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Here, it would be useful to observe the problem in the form:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_P_2(mathbf x) = -Delta theta_2cfracmathrm partialf_P_2(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_2(mathbf x)mathrm partial theta_n \n     vdots \n    f_P_n(mathbf x) = -Delta theta_2cfracmathrm partialf_P_n(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_i(mathbf x)mathrm partial theta_n\n    f_Q_2(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_n_textpq  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n     vdots \n    f_Q_m(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_m  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"First of all, we expand the second part of the expressions as follows:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  f_Q_2(mathbf x) =\n  -cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n   vdots \n  f_Q_m(mathbf x) =\n  - cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The next step is deriving the Jacobian elements. For this purpose, let us consider the expressions defined for the Newton-Raphson method, where we applied the above expansions for PQ buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  V_isumlimits_j=1^n V_j(-G_ij\n  sintheta_ij+B_ijcostheta_ij) - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = V_isumlimits_j=1\n  ^n V_j(G_ijsintheta_ij-\n  B_ijcostheta_ij)-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Since the reactive power is defined as:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    Q_i =V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Jacobian elements can be written in the form:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  -Q_i - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = Q_i-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The decoupled model is based on the following approximations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    sin(theta_ij) approx 0 \n    cos(theta_ij) approx 1 \n    Q_i  B_iiV_i^2\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Consequently, Jacobian elements become:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i = -V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_j = -V_iV_jB_ij\n  V_i cfracmathrm partialf_Q_i(mathbf x) mathrm partial V_i = -V_i^2B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrmpartial V_j =  -V_iV_jB_ij\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Then, the initial system of equations is:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_P_2(mathbf x) = V_2^2B_22 Delta theta_2 + cdots + V_2V_nB_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_2V_nB_n2 Delta theta_2 + cdots + V_n^2B_nn Delta theta_n \n    f_Q_2(mathbf x) =  V_2^2B_22 cfracDelta V_2V_2 + cdots +\n     V_2V_mB_2m cfracDelta V_mV_m \n     vdots \n    f_Q_m(mathbf x) = V_2V_mB_m2 cfracDelta V_2V_2 + cdots +\n    V_m^2 B_mm cfracDelta V_mV_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Using V_j approx 1, wherein V_i^2 = V_iV_j j=i, the first part of the equations have a form:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_P_2(mathbf x) = V_2B_22 Delta theta_2 + cdots + V_2B_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_nB_n2 Delta theta_2 + cdots + V_nB_nn Delta theta_n\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Simplifying the second part of the equations, we obtain:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_Q_2(mathbf x) =  V_2B_22 Delta V_2 + cdots +\n     V_2 B_2m Delta V_m\n    \n     vdots \n    f_Q_m(mathbf x) = V_mB_m2 Delta V_2 + cdots +\n    V_m B_mm Delta V_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Finally, the fast Newton-Raphson method is based on the following system of equations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    cfracf_P_2(mathbf x)V_2 = B_22 Delta theta_2 + cdots + B_2n Delta theta_n \n     vdots \n    cfracf_P_n(mathbf x)V_n = B_n2 Delta theta_2 + cdots + B_nn Delta theta_n \n    cfracf_Q_2(mathbf x)V_2 =  B_22 Delta V_2 + cdots + B_2m Delta V_m \n     vdots \n    cfracf_Q_m(mathbf x)V_m = B_m2 Delta V_2 + cdots +\n    B_mm Delta V_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"which can be written as:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    mathbfh_P(mathbf x) = mathbfB_1 mathbfDelta bm theta \n    mathbfh_Q(mathbf x) = mathbfB_2 mathbfDelta V\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"True benefits from these equations is that Jacobian matrices mathbfB_1 and mathbfB_2 are constant and should be formed only once. Note that no approximations have been introduced to the functions mathbff_P(mathbf x) or mathbff_Q(mathbf x), only in the way we calculate the increments of the state variables [2]. Consequently, we still use:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalN_textpq cup mathcalN_textpv\n    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalN_textpq\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"It is now possible to define XB and BX versions of the fast Newton-Raphson method.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#XB-Version","page":"In-depth Power Flow Solution","title":"XB Version","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The resistance r_ij, shunt susceptance Im  y_textshi , charging susceptance Im  y_textsij  and transformer tap ratio magnitude tau_ij are ignored while forming the matrix mathbfB_1. The transformer phase shift angle phi_ij is ignored while building the matrix mathbfB_2. This version is the standard fast Newton-Raphson method and has excellent convergence properties for usual cases.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To initialize the XB version of the fast Newton-Raphson method, we can use:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = fastNewtonRaphsonXB(system)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#BX-Version","page":"In-depth Power Flow Solution","title":"BX Version","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The shunt susceptance Im  y_textshi , charging susceptance Im  y_textsij  and transformer tap ratio magnitude tau_ij are ignored while forming the matrix mathbfB_1. The resistance r_ij and transformer phase shift angle phi_ij are ignored while building the matrix mathbfB_2. For usual cases, the iteration count will be similar to the XB scheme, but for systems with a few or with general high r_ijx_ij ratios the number of iterations needed to solve the power flow is considerably smaller than the number of the XB scheme [5].","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To initialize the BX version of the fast Newton-Raphson method, we can use:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = fastNewtonRaphsonBX(system)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#Implementation-Aspects-of-the-Fast-Newton-Rapshson-Method","page":"In-depth Power Flow Solution","title":"Implementation Aspects of the Fast Newton-Rapshson Method","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"In the beginning, we evaluate matrices mathbfB_1 and mathbfB_2 related with active and reactive power equations, respectively. These matrices can be accessed using commands:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.active.jacobian\njulia> result.algorithm.reactive.jacobian","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Then, JuliaGrid uses the LU factorization of matrices mathbfB_1 and mathbfB_2 to reveal solutions through iterations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.active.lower\njulia> result.algorithm.active.upper\njulia> result.algorithm.active.right\njulia> result.algorithm.active.left\njulia> result.algorithm.active.scaling\n\njulia> result.algorithm.reactive.lower\njulia> result.algorithm.reactive.upper\njulia> result.algorithm.reactive.right\njulia> result.algorithm.reactive.left\njulia> result.algorithm.reactive.scaling","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Finally, to solve the AC power flow analysis and find the bus voltage magnitudes and angles, JuliaGrid provides the following sequence of functions:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"stopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The fast Newton-Raphson method first solves the equation:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfDelta bm theta^(nu) = mathbfB_1^-1 mathbfh_P(bm theta^(nu) mathbf V^(nu))","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.active.increment\njulia> result.algorithm.active.mismatch","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"After that, we update the solution:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  bmtheta^(nu+1) = bmtheta^(nu) + mathbf Delta bm theta^(nu)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.bus.voltage.angle","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The fast Newton-Raphson method further solves the equation:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfDelta V^(nu) = mathbfB_2^-1 mathbfh_Q(bm theta^(nu + 1) mathbf V^(nu))","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.reactive.increment\njulia> result.algorithm.reactive.mismatch","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Finally, we update the solution:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfV^(nu+1) = mathbfV^(nu) + mathbfDelta V^(nu)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.bus.voltage.magnitude","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Then, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  h_P_i(bm theta^(nu+1) mathbf V^(nu+1)) =\n  sumlimits_j=1^n V_j^(nu+1)(G_ijcostheta_ij^(nu+1)+B_ijsintheta_ij^(nu+1)) - cfracP_iV_i^(nu+1)\n    i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    h_Q_i(bm theta^(nu+1) mathbf V^(nu+1)) =\n    sumlimits_j=1^n V_j^(nu+1) (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu+1)) - cfracQ_iV_i^(nu+1)\n     i in mathcalN_textpq","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The iteration loop is stopped when the following conditions are met:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    max f_P_i(mathbf x^(nu)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max f_Q_i(mathbf x^(nu)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where epsilon is predetermined stopping criteria. JuliaGrid stores these values in order to break the iteration loop:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.stopping.active\njulia> result.stopping.reactive","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"operatingState/generator/#operatingStateGenerator","page":"Operating State of Generators","title":"Operating State of Generators","text":"","category":"section"},{"location":"operatingState/generator/","page":"Operating State of Generators","title":"Operating State of Generators","text":"Once the bus voltages are obtained from one of the analyses, it is possible to determine powers related to the generators. The function receives composite types PowerSystem and Result.","category":"page"},{"location":"operatingState/generator/","page":"Operating State of Generators","title":"Operating State of Generators","text":"generator!","category":"page"},{"location":"operatingState/generator/#JuliaGrid.generator!","page":"Operating State of Generators","title":"JuliaGrid.generator!","text":"The function computes powers related to generators.\n\ngenerator!(system::PowerSystem, result::Result)\n\nThe function updates the field result.generator of the composite type Result.\n\nAC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\ngenerator!(system, result)\n\nDC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\ngenerator!(system, result)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#buildPowerSystemModel","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The composite type PowerSystem with fields bus, branch, generator, acModel, dcModel, and basePower can be created using a function:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"powerSystem().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Once the model is created, it is possible to add buses, branches and generators using the functions:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addBus!()\naddBranch!()\naddGenerator!().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"In addition, it is possible to manipulate the parameters of buses, branches and generators using functions:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"shuntBus!()\nstatusBranch!()\nparameterBranch!()\nstatusGenerator!()\noutputGenerator!().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The execution of these functions will automatically trigger the update of all fields affected by these functions. Changing other parameters of the power system can be done by changing variables by accessing their values in fields bus, branch and generator of the composite type powerSystem.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"At any moment after the composite type PowerSystem is formed, it is possible to save the data in HDF5 format that describe the power system:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"savePowerSystem().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"To create vectors and matrices obtained based on the power system topology and parameters, following functions are used:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"acModel!()\ndcModel!().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Note that, functions can be executed at any time, and when all power system buses are defined. More precisely, once the field acModel and dcModel are formed, using function addBranch!(), will automatically trigger the update of these fields. In contrast, adding a new bus, using addBus!(), requires executing the functions acModel!() and dcModel!() again. Further, the execution of the functions related to parameter manipulation of buses and branches will automatically trigger the update of the fields acModel and dcModel.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Build-Model","page":"Build Power System Model","title":"Build Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The function builds the composite type PowerSystem and populates fields bus, branch, generator and basePower.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"powerSystem","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.powerSystem","page":"Build Power System Model","title":"JuliaGrid.powerSystem","text":"The path to the HDF5 file with the .h5 extension should be passed to the function:\n\npowerSystem(\"pathToExternalData/name.h5\")\n\nSimilarly, the path to the Matpower file with the .m extension should be passed to the same function:\n\npowerSystem(\"pathToExternalData/name.m\")\n\nIgnoring the function argument initializes the composite type PowerSystem, which enables building the model from scratch:\n\npowerSystem()\n\nOnce the composite type PowerSystem is created it is possible to add new buses, branches or generators, and also change the parameters of the existing ones.\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Bus-Functions","page":"Build Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Functions receive the composite type PowerSystem and arguments by keyword to set or change bus parameters and update the field bus.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addBus!\nshuntBus!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.addBus!","page":"Build Power System Model","title":"JuliaGrid.addBus!","text":"The function adds a new bus, and updates the field bus. Names, descriptions and units of keywords are given in the table bus group.\n\naddBus!(system::PowerSystem; label, slackLabel, area, lossZone, active, reactive,\n    conductance, susceptance, magnitude, angle, minMagnitude, maxMagnitude, base)\n\nThe keyword label is mandatory. Default keyword values are set to zero, except for keywords lossZone = 1, area = 1, magnitude = 1.0, minMagnitude = 0.9, and maxMagnitude = 1.1.\n\nThe slack bus, using the keyword slackLabel, can be specified in each function call with the label of the bus being defined or already existing. If the bus is not defined as slack, the function addBus!() automatically defines the bus as the demand bus (PQ). If a generator is connected to a bus, using the function addGenerator!(), the bus becomes a generator bus (PV).\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, slackLabel = 1, active = 0.25, reactive = -0.04)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.shuntBus!","page":"Build Power System Model","title":"JuliaGrid.shuntBus!","text":"The function allows changing conductance and susceptance parameters of the shunt element connected to the bus.\n\nshuntBus!(system::PowerSystem; label, conductance, susceptance)\n\nThe keyword label should correspond to the already defined bus label. Keywords conductance or susceptancecan be omitted, then the value of the omitted parameter remains unchanged. The function also updates the field acModel, if field exist.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\nshuntBus!(system; label = 1, conductance = 0.04)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Branch-Functions","page":"Build Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Functions receive the composite type PowerSystem and arguments by keyword to set or change branch parameters. Further, functions update the field branch, but also fields acModel and dcModel. More precisely, once acModel and dcModel are created, the execution of functions will automatically trigger the update of these fields.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.addBranch!","page":"Build Power System Model","title":"JuliaGrid.addBranch!","text":"The function adds a new branch. Names, descriptions and units of keywords are given in the table branch group. A branch can be added between already defined buses.\n\naddBranch!(system::PowerSystem; label, from, to, status, resistance, reactance,\n    susceptance, turnsRatio, shiftAngle, longTerm, shortTerm, emergency,\n    minAngleDifference, maxAngleDifference)\n\nThe keywords label, from, to, and one of the parameters resistance or reactance are mandatory. Default keyword values are set to zero, except for keywords status = 1, minAngleDifference = -2*pi, maxAngleDifference = 2*pi.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.statusBranch!","page":"Build Power System Model","title":"JuliaGrid.statusBranch!","text":"The function allows changing the operating status of the branch, from in-service to out-of-service, and vice versa.\n\nstatusBranch!(system::PowerSystem; label, status)\n\nThe keywords label should correspond to the already defined branch label.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nstatusBranch!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.parameterBranch!","page":"Build Power System Model","title":"JuliaGrid.parameterBranch!","text":"The function parameterBranch! allows changing resistance, reactance, susceptance, turnsRatio and shiftAngle parameters of the branch.\n\nparameterBranch!(system::PowerSystem; label, resistance, reactance, susceptance,\n    turnsRatio, shiftAngle)\n\nThe keywords label should correspond to the already defined branch label. Keywords resistance, reactance, susceptance, turnsRatio or shiftAngle can be omitted, and then the value of the omitted parameter remains unchanged.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nparameterBranch!(system; label = 1, susceptance = 0.062)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Generator-Functions","page":"Build Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Functions receive the composite type PowerSystem and arguments by keyword to set or change generator parameters. Further, functions update fields generator and bus.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addGenerator!\nstatusGenerator!\noutputGenerator!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.addGenerator!","page":"Build Power System Model","title":"JuliaGrid.addGenerator!","text":"The function adds a new generator. Names, descriptions and units of keywords are given in the table generator group. A generator can be added to an already-defined bus.\n\naddGenerator!(system::PowerSystem; label, bus, area, status, active, reactive, magnitude,\n    minActive, maxActive, minReactive, maxReactive, lowerActive, minReactiveLower,\n    maxReactiveLower, upperActive, minReactiveUpper, maxReactiveUpper, loadFollowing,\n    reserve10minute, reserve30minute, reactiveTimescale, activeModel, activeStartup,\n    activeShutdown, activeDataPoint, activeCoefficient, reactiveModel, reactiveStartup,\n    reactiveShutdown, reactiveDataPoint, reactiveCoefficient)\n\nThe keywords label and bus are mandatory. Default keyword values are set to zero, except for keywords status = 1, magnitude = 1.0, maxActive = Inf, minReactive = -Inf, maxReactive = Inf, activeModel = 2, activeDataPoint = 3, reactiveModel = 2, and reactiveDataPoint = 3.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\n\naddGenerator!(system; label = 1, bus = 1, active = 0.5 reactive = 0.1)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.statusGenerator!","page":"Build Power System Model","title":"JuliaGrid.statusGenerator!","text":"The function allows changing the operating status of the generator, from in-service to out-of-service, and vice versa.\n\nstatusGenerator!(system::PowerSystem; label, status)\n\nThe keywords label should correspond to the already defined generator label.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\n\naddGenerator!(system; label = 1, bus = 1, active = 0.5 reactive = 0.1)\nstatusGenerator!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.outputGenerator!","page":"Build Power System Model","title":"JuliaGrid.outputGenerator!","text":"The function allows changing active and reactive output power of the generator.\n\noutputGenerator!(system::PowerSystem; label, active, reactive)\n\nThe keywords label should correspond to the already defined generator label. Keywords active or reactive can be omitted, then the value of the omitted parameter remains unchanged.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\n\naddGenerator!(system; label = 1, bus = 1, active = 0.5 reactive = 0.1)\noutputGenerator!(system; label = 1, active = 0.85)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#saveModel","page":"Build Power System Model","title":"Save Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Function receives the composite type PowerSystem and arguments by keyword to set the path, reference and note of the data set.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"savePowerSystem","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.savePowerSystem","page":"Build Power System Model","title":"JuliaGrid.savePowerSystem","text":"The function saves power system data in the HDF5 file using fields bus, branch, generator and basePower of the composite type PowerSystem.\n\nsavePowerSystem(system::PowerSystem; path, reference, note)\n\nThe keyword path::String is mandatory in the form \"path/name.h5\", while keywords reference::String and note::String are optional.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"C:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Build-AC-and-DC-Model","page":"Build Power System Model","title":"Build AC and DC Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The functions receive the composite type PowerSystem and form vectors and matrices related to AC or DC simulations.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.acModel!","page":"Build Power System Model","title":"JuliaGrid.acModel!","text":"We advise the reader to read the section in-depth AC Model, that explains all the data involved in the field acModel.\n\nacModel!(system::PowerSystem)\n\nThe function updates the field acModel. Once formed, the field will be automatically updated when using functions addBranch!(), shuntBus!(), statusBranch!(), parameterBranch!().\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.dcModel!","page":"Build Power System Model","title":"JuliaGrid.dcModel!","text":"We advise the reader to read the section in-depth DC Model, that explains all the data involved in the field dcModel.\n\ndcModel!(system::PowerSystem)\n\nThe function updates the field dcModel. Once formed, the field will be automatically updated when using functions addBranch!(), statusBranch!(), parameterBranch!().\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#powerFlowSolution","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"The solution of the power flow analysis implies the determination of the bus voltages. To obtain a solution, the framework requires the composite type PowerSystem with fields bus, branch, generator. In addition, depending on whether AC or DC power flow analysis is used, acModel or dcModel is required.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"JuliaGrid stores results in the composite type Result with fields:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"bus\nbranch\ngenerator\nalgorithm.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Once the composite type PowerSystem is created, it is possible to create the composite type Result. The composite type Result in the DC power flow analysis is created when determining the bus voltage angle using the function dcPowerFlow(). In contrast, the AC power flow analysis first requires the initialization of the iterative method, during which the composite type Result is created:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson()\nfastNewtonRaphsonBX()\nfastNewtonRaphsonXB()\ngaussSeidel().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"The calculation of the bus voltages, depending on the type of analysis and the selected method, can be performed using one of the functions:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson!()\nfastNewtonRaphson!()\ngaussSeidel!()\ndcPowerFlow().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Note that methods for solving the AC power flow problem should be called inside a loop, thus simulating an iterative process.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Then, it is possible to calculate powers related to buses, powers and currents related to branches, and powers related to generators:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"bus!()\nbranch!()\ngenerator!().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Newton-Raphson-Method","page":"Power Flow Solution","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson\nnewtonRaphson!","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.newtonRaphson","page":"Power Flow Solution","title":"JuliaGrid.newtonRaphson","text":"The function receives the composite type PowerSystem, initializes the Newthon-Raphson method, and returns the composite type Result.\n\nnewtonRaphson(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.newtonRaphson!","page":"Power Flow Solution","title":"JuliaGrid.newtonRaphson!","text":"The function receives the composite type PowerSystem and Result. Using the Newthon-Raphson method, the function computes bus voltage magnitudes and angles.\n\nnewtonRaphson!(system::PowerSystem, result::Result)\n\nThe function updates fields bus.voltage and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Fast-Newton-Raphson-Method","page":"Power Flow Solution","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"fastNewtonRaphsonBX\nfastNewtonRaphsonXB\nfastNewtonRaphson!","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphsonBX","text":"The function receives the composite type PowerSystem, initializes the fast Newthon-Raphson method of version BX, and returns the composite type Result.\n\nfastNewtonRaphsonBX(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphsonXB","text":"The function receives the composite type PowerSystem, initializes the fast Newthon-Raphson method of version XB, and returns the composite type Result.\n\nfastNewtonRaphsonXB(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.fastNewtonRaphson!","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphson!","text":"The function receives the composite type PowerSystem and Result. Using the fast Newthon-Raphson method, the function computes bus voltage magnitudes and angles.\n\nfastNewtonRaphson!(system::PowerSystem, result::Result)\n\nThe function updates fields bus.voltage and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = fastNewtonRaphsonBX(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:100\n    fastNewtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Gauss-Seidel-Method","page":"Power Flow Solution","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"gaussSeidel\ngaussSeidel!","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.gaussSeidel","page":"Power Flow Solution","title":"JuliaGrid.gaussSeidel","text":"The function receives the composite type PowerSystem, initializes the Gauss-Seidel method, and returns the composite type Result.\n\ngaussSeidel(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.gaussSeidel!","page":"Power Flow Solution","title":"JuliaGrid.gaussSeidel!","text":"The function receives the composite type PowerSystem and Result. Using the Gauss-Seidel method, the function computes bus voltage magnitudes and angles.\n\ngaussSeidel!(system::PowerSystem, result::Result)\n\nThe function updates fields bus.voltage and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:1000\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#DC-Power-Flow-Solution","page":"Power Flow Solution","title":"DC Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"dcPowerFlow","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.dcPowerFlow","page":"Power Flow Solution","title":"JuliaGrid.dcPowerFlow","text":"The function receives the composite type PowerSystem, solves the DC power flow problem by determining bus voltage angles, and returns the composite type Result.\n\ndcPowerFlow(system::PowerSystem)\n\nThe function updates field result.bus.voltage.angle and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\n\n\n\n\n\n","category":"function"},{"location":"#JuliaGrid","page":"Home","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver, and allows a variety of display and manipulation options.","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthACDCModel","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Network equations obtained using the unified branch model and defined below represent the basic setup used for the power system analysis. The power system network topology is usually described by the bus/branch model, where branches of the network are defined using the two-port pi-model. The bus/branch model can be represented using a graph mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n represents the set of buses, while the set of edges mathcalE subseteq mathcalN times mathcalN represents the set of branches of the power network.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthACModel","page":"In-depth AC and DC Model","title":"AC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"JuliaGrid is based on common network elements and benefits the unified branch model to perform various analyses based on the system of non-linear equations. To create vectors and matrices related with AC or non-linear analyses, JuliaGrid uses the function acModel!(), for example:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#ACBranchModel","page":"In-depth AC and DC Model","title":"AC Branch Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The equivalent unified pi-model for a branch (ij) in mathcalE incident to the buses ij in mathcalN is shown in Figure 2.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"<img src=\"../../assets/pi_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The equivalent branch model, where transformer is located at \"from bus end\" of the branch.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The branch series admittance y_ij is inversely proportional to the branch series impedance z_ij:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"    y_ij = frac1z_ij =\n    frac1r_ij + textjx_ij =\n    fracr_ijr_ij^2 + x_ij^2 - textjfracx_ijr_ij^2 + x_ij^2 = g_ij + textjb_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where r_ij is a resistance, x_ij is a reactance, g_ij is a conductance and b_ij is a susceptance of the branch.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.branch.parameter.resistance\njulia> system.branch.parameter.reactance\njulia> system.acModel.admittance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The branch shunt capacitive admittance (i.e. charging admittance) y_textsij at buses ij is equal to:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"y_textsij = textj b_textsij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Note that JuliaGrid stores the total branch shunt capacitive susceptance 2b_textsij:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.branch.parameter.susceptance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The transformer complex ratio alpha_ij is defined:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"    alpha_ij = cfrac1tau_ije^-textjphi_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where tau_ij is the transformer turns ratio, while phi_ij is the transformer phase shift angle, always located \"from bus end\" of the branch.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.branch.parameter.turnsRatio\njulia> system.branch.parameter.shiftAngle\njulia> system.acModel.transformerRatio","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Using Kirchhoff's circuit laws, the unified branch model can be described by complex expressions:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2(y_ij + y_textsij)  -alpha_ij^*y_ij\n    -alpha_ijy_ij  y_ij + y_textsij\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The values of the terms left((y_ij + y_textsij)  tau_ij^2right), left(-alpha_ij^*y_ijright), left(-alpha_ijy_ijright), and left(y_ij + y_textsijright) can be found stored in four separate arrays, respectively:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.acModel.nodalFromFrom\njulia> system.acModel.nodalFromTo\njulia> system.acModel.nodalToFrom\njulia> system.acModel.nodalToTo","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Note, if tau_ij = 1 and phi_ij = 0 the model describes the line. In-phase transformers are defined if phi_ij = 0 and y_textsij = 0, while phase-shifting transformers are obtained if y_textsij = 0.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#ACNodalMatrix","page":"In-depth AC and DC Model","title":"AC Equations and Nodal Matrix","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Let us consider an example, given in Figure 3, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with admittance y_textshk.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"<img src=\"../../assets/pi_model_example.png\" class=\"center\"/>\n<figcaption>Figure 3: The example with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"According to the unified branch model each branch is described using the system of equations as follows:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_pk  barI_kp\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_pk^*y_pk\n    -alpha_pky_pk  y_pk + y_textspk\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_kq  barI_qk\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_kq^2(y_kq + y_textskq)  -alpha_kq^*y_kq\n    -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The injection complex currents into buses are:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    barI_p = barI_pk = cfrac1tau_pk^2(y_pk + y_textspk) barV_p -alpha_kq^*y_kq barV_k \n    barI_k = barI_kp + barI_kq - barI_textshk =\n    -alpha_kqy_kq barV_p + (y_kq + y_textskq) barV_k +\n    cfrac1tau_kq^2(y_kq + y_textskq) barV_k -alpha_kq^*y_kq barV_q + y_textshk barV_k \n    barI_q = barI_qk = -alpha_kqy_kq barV_k + (y_kq + y_textskq) barV_q\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_p  barI_k  barI_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_kq^*y_kq  0 \n   -alpha_kqy_kq  y_kq + y_textskq + cfrac1tau_kq^2(y_kq + y_textskq) + y_textshk   -alpha_kq^*y_kq \n    0  -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Next, the system of equations for buses i=1 dots n can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where mathbf bar V in mathbbC^n is the vector of bus complex voltages, and mathbf bar I in mathbbC^n is the vector of injection complex currents.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The matrix mathbfY = mathbfG + textjmathbfB in mathbbC^n times n is the bus or nodal admittance matrix, with elements:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nY_ii = G_ii + textjB_ii = y_textshi +\nsumlimits_e in mathcalE  e(1) = i cfrac1tau_ij^2(y_ij + y_textsij) + sumlimits_e in mathcalE  e(2) = i (y_ij + y_textsij)\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nY_ij = G_ij + textjB_ij = -alpha_ij^*y_ij\nY_ji = G_ji + textjB_ji =  -alpha_ijy_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix mathbfY is equal to zero. The nodal admittance matrix mathbfY is a sparse matrix (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix mathbfY is symmetrical, it is not a general case, for example, in the presence of phase shifting transformers the matrix mathbfY is not symmetrical [1, Sec. 9.6].","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.acModel.nodalMatrix\njulia> system.acModel.nodalMatrixTranspose","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthDCModel","page":"In-depth AC and DC Model","title":"DC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The DC model is obtained by linearisation of the non-linear model, and it provides an approximate solution. In the typical operating conditions, the difference of bus voltage angles between adjacent buses (ij) in mathcalE is very small theta_i-theta_j approx 0, which implies cos theta_ijapprox 1 and sin theta_ij approx theta_ij. Further, all bus voltage magnitudes are V_i approx 1, i in mathcalN, and all shunt susceptance elements and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers. Therefore, the DC power flow takes only bus voltage angles bm theta as state variables. To create vectors and matrices related with DC or linear analyses, JuliaGrid uses the function dcModel!(), for example:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"system = powerSystem(\"case14.h5\")\ndcModel!(system)","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#DCBranchModel","page":"In-depth AC and DC Model","title":"DC Branch Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"According to the above assumptions, we start from the unified branch model:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"    beginbmatrix\n      barI_ij  barI_ji\n    endbmatrix = cfrac1textjx_ij\n    beginbmatrix\n      cfrac1tau_ij^2  -alpha_ij^*\n      -alpha_ij  1\n    endbmatrix\n    beginbmatrix\n      barV_i  barV_j\n    endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where barV_i = texte^textjtheta_i and barV_j = texte^textjtheta_j. Further, we have:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    barI_ij = cfrac1textjx_ij leftcfrac1tau_ij^2 texte^textjtheta_i -\n    cfrac1tau_ije^textj(phi_ij + theta_j) right \n    barI_ji = cfrac1textjx_ij left-cfrac1tau_ije^textj(theta_i - phi_ij) + texte^textjtheta_j right\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The active power flows are derived as follows:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    P_ij = RebarV_ibarI_ij^* =\n    Re lefttextjcfrac1x_ij\n    leftcfrac1tau_ij^2 - cfrac1tau_ije^textj(theta_i - theta_j - phi_ij) right  right \n    P_ji = RebarV_jbarI_ji^* =\n    Re lefttextjcfrac1x_ij\n   left1-cfrac1tau_ije^textj(-theta_i +theta_j + phi_ij) right  right\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The real components are:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    P_ij =cfrac1tau_ijx_ij sin(theta_i -theta_j-phi_ij) approx cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) \n    P_ji =cfrac1tau_ijx_ij sin(theta_j -theta_i+phi_ij) approx -cfrac1tau_ij x_ij (theta_i - theta_j-phi_ij)\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where 1(tau_ij x_ij) represents the branch admittance in the DC framework.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.dcModel.admittance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"We can conclude that P_ij=-P_ji holds. With the DC model, the linear network equations relate active power to bus voltage angles, versus complex currents to complex bus voltages in the AC case [2]. Consequently, analogous to the unified branch model we can write:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix = cfrac1tau_ijx_ij\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix + cfracphi_ijtau_ijx_ij\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#DCNodalMatrix","page":"In-depth AC and DC Model","title":"DC Equations and Nodal Matrix","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"As before, let us consider an example of the DC framework, given in Figure 2, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with conductance g_textshk.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"<img src=\"../../assets/dc_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The example with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Each branch in the DC framework is described with system of equations as follows:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_pk  P_kp\n  endbmatrix = cfrac1tau_pkx_pk\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k\n  endbmatrix + cfracphi_pktau_pkx_pk\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_kq  P_qk\n  endbmatrix = cfrac1tau_kqx_kq\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_k  theta_q\n  endbmatrix + cfracphi_kqtau_kqx_kq\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The injection active powers into buses are:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    P_p = P_pk =cfrac1tau_pkx_pk theta_p - cfrac1tau_pkx_pk theta_k - cfracphi_pktau_pkx_pk \n    P_k = P_kp + P_kq - P_textshk = -cfrac1tau_pkx_pk theta_p + cfrac1tau_pkx_pk theta_k + cfracphi_pktau_pkx_pk +\n    cfrac1tau_kqx_kq theta_k - cfrac1tau_kqx_kq theta_q - cfracphi_kqtau_kqx_kq + g_textshk \n    P_q = P_qk = -cfrac1tau_kqx_kq theta_k +cfrac1tau_kqx_kq theta_q + cfracphi_kqtau_kqx_kq\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Note that the active power injected by the shunt element into the bus i in mathcalN is equal to:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  P_textshi = RebarV_ibarI_textshi^* = Re-barV_iy_textshi^*barV_i^* = - g_textshi","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_p  P_k  P_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pkx_pk  - cfrac1tau_pkx_pk  0 \n    -cfrac1tau_pkx_pk  cfrac1tau_pkx_pk + cfrac1tau_kqx_kq   -cfrac1tau_kqx_kq \n    0  -cfrac1tau_kqx_kq cfrac1tau_kqx_kq\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k  theta_q\n  endbmatrix +\n  beginbmatrix\n    - cfracphi_pktau_pkx_pk  cfracphi_pktau_pkx_pk - cfracphi_kqtau_kqx_kq  cfracphi_kqtau_kqx_kq\n  endbmatrix +\n  beginbmatrix\n    0  g_textshk  0\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Next, the system of equations for i=1dotsn can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  mathbf P = mathbfB bm theta + mathbfP_textgs + mathbfP_textsh","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where bm theta in mathbbR^n is the vector of bus voltage angles.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The vector mathbf P in mathbbR^n contains injected active powers into buses caused by generators and demands. In JuliaGrid, the vector can be recovered using an expression:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.bus.supply.active - system.bus.demand.active","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The vector mathbfP_textgs in mathbbR^n represents active powers related with non-zero shift angle of transformers.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.dcModel.shiftActivePower","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The vector mathbfP_textsh in mathbbR^n represents active powers consumed by shunt elements.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.bus.shunt.conductance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The bus or nodal matrix in the DC framework is given as mathbfB in mathbbC^n times n, with elements:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nB_ii = sumlimits_e in mathcalE i in e cfrac1tau_ijx_ij\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nB_ij = -cfrac1tau_ijx_ij\nB_ji = -cfrac1tau_ijx_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.dcModel.nodalMatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthACDCModelReference","page":"In-depth AC and DC Model","title":"References","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"[1] J. Grainger and W. Stevenson, Power system analysis, ser. McGraw-Hill series in electrical and computer engineering: Power and energy. McGraw-Hill, 1994.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"[2] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER User’s Manual, Version 7.0. 2019.","category":"page"},{"location":"powerSystem/model/#powerSystemModel","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid supports the composite type PowerSystem to preserve power system data, with fields:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"bus\nbranch\ngenerator\nacModel\ndcModel\nbasePower.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The function powerSystem() returns the composite type PowerSystem with all fields. The fields bus, branch, generator hold the data related to buses, branches and generators, respectively. Fields acModel and dcModel store vectors and matrices obtained based on the power system topology and parameters. The base power of the system is kept in the field basePower, given in volt-ampere unit. JuliaGrid supports three modes to build the composite type PowerSystem:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"using built-in functions,\nusing HDF5 file format,\nusing Matpower case files.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Note that, in the case of large-scale systems, we strongly recommend to use the HDF5 file format for the input. Therefore, JuliaGrid has the function savePowerSystem() that any system loaded from Matpower case files or a system formed using built-in functions can be saved in the HDF5 format.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The HDF5 file format contains three groups: bus, branch and generator. In addition, the file contains basePower variable, given in volt-ampere. Each group is divided into subgroups that gather the same type of physical quantities, with the corresponding datasets. Note that, dataset names are identical to the keywords, which are used when the power system model is formed using built-in functions.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#busGroup","page":"Power System Model","title":"Bus Group","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The bus group is divided into four subgroups: layout, demand, shunt, and voltage. Each of the subgroups contains datasets that define the features of the buses.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Subgroup Dataset Description Unit Type\nlayout label unique bus label - positive integer\nlayout slackLabel bus label of the slack bus - positive integer\nlayout lossZone loss zone - positive integer\nlayout area area number - positive integer\ndemand active active power demand per-unit float\ndemand reactive reactive power demand per-unit float\nshunt conductance active power demanded of the shunt element at voltage magnitude equal to 1 per-unit per-unit float\nshunt susceptance reactive power injected of the shunt element at voltage magnitude equal to 1 per-unit per-unit float\nvoltage magnitude initial value of the voltage magnitude per-unit float\nvoltage angle initial value of the voltage angle radian float\nvoltage minMagnitude minimum allowed voltage magnitude value per-unit float\nvoltage maxMagnitude maximum allowed voltage magnitude value per-unit float\nvoltage base base value of the voltage magnitude volt float","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#branchGroup","page":"Power System Model","title":"Branch Group","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The branch group is divided into four subgroups: layout, parameter, voltage, and rating. Each of the subgroups contains datasets that define the features of the branches.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Subgroup Dataset Description Unit Type\nlayout label unique branch label - positive integer\nlayout from from bus label (corresponds to the bus label) - positive integer\nlayout to to bus label (corresponds to the bus label) - positive integer\nlayout status operating status of the branch, in-service = 1, out-of-service = 0 - zero-one integer\nparameter resistance branch resistance per-unit float\nparameter reactance branch reactance per-unit float\nparameter susceptance total line charging susceptance per-unit float\nparameter turnsRatio transformer off-nominal turns ratio, equal to zero for a line - float\nparameter shiftAngle transformer phase shift angle where positive value defines delay radian float\nvoltage minAngleDifference minimum allowed voltage angle difference value between from and to bus radian float\nvoltage maxAngleDifference maximum allowed voltage angle difference value between from and to bus radian float\nrating shortTerm short-term rating (equal to zero for unlimited) per-unit float\nrating longTerm long-term rating (equal to zero for unlimited) per-unit float\nrating emergency emergency rating (equal to zero for unlimited) per-unit positive integer","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#generatorGroup","page":"Power System Model","title":"Generator Group","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The generator group is divided into six subgroups: layout, output, voltage, capability, ramRate, and cost. Each of the subgroups contains datasets that define the features of the generators.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Subgroup Dataset Description Unit Type\nlayout label unique generator label - positive integer\nlayout bus bus label to which the generator is connected - positive integer\nlayout status operating status of the generator, in-service = 1, out-of-service = 0 - zero-one integer\nlayout area area participation factor - float\noutput active output active power of the generator per-unit float\noutput reactive output reactive power of the generator per-unit float\nvoltage magnitude voltage magnitude setpoint per-unit float\ncapability minActive minimum allowed output active power value of the generator per-unit float\ncapability maxActive maximum allowed output active power value of the generator per-unit float\ncapability minReactive minimum allowed output reactive power value of the generator per-unit float\ncapability maxReactive maximum allowed output reactive power value of the generator per-unit float\ncapability lowerActive lower allowed active power output value of PQ capability curve per-unit float\ncapability minReactiveLower minimum allowed reactive power output value at lowerActive value per-unit float\ncapability maxReactiveLower maximum allowed reactive power output value at lowerActive value per-unit float\ncapability upperActive upper allowed active power output value of PQ capability curve per-unit float\ncapability minReactiveUpper minimum allowed reactive power output value at upperActive value per-unit float\ncapability maxReactiveUpper maximum allowed reactive power output value at upperActive value per-unit float\nrampRate loadFollowing ramp rate for load following/AGC per-unit/minute float\nrampRate reserve10minute ramp rate for 10-minute reserves per-unit float\nrampRate reserve30minute ramp rate for 30-minute reserves per-unit float\nrampRate reactiveTimescale ramp rate for reactive power (two seconds timescale) per-unit/minute float\ncost activeModel active power cost model, piecewise linear = 1, polynomial = 2 - one-two integer\ncost activeStartup active power startup cost currency float\ncost activeShutdown active power shutdown cost currency float\ncost activeDataPoint number of data points for active power cost model - positive integer\ncost activeCoefficient coefficients for forming the active power cost function (*) float\ncost reactiveModel reactive power cost model, piecewise linear = 1, polynomial = 2 - one-two integer\ncost reactiveStartup reactive power startup cost currency float\ncost reactiveShutdown reactive power shutdown cost currency float\ncost reactiveDataPoint number of data points for reactive power cost model - positive integer\ncost reactiveCoefficient coefficients for forming the reactive power cost function (*) float","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"&nbsp;","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The interpretation of the datasets activeCoefficient and reactiveCoefficient, given as matrices, depends on the activeModel and reactiveModel that is selected:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"piecewise linear cost model is defined according to input-output points, where the i-th row of the matrix is given as:\nactiveCoefficient: p_1 f(p_1) p_2 f(p_2) dots p_n f(p_n),\nreactiveCoefficient: q_1 f(q_1) q_2 f(q_2) dots q_n f(q_n).\npolynomial cost model is defined using the n-th degree polynomial, where the i-th row of the matrix is given as:\nactiveCoefficient: a_n dots a_1 a_0 to define f(p) = a_n p^n + dots + a_1 p + a_0,\nreactiveCoefficient: b_n dots b_1 b_0 to define f(q) = b_n q^n + dots + b_1 q + b_0.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"(*) Thus, for the piecewise linear model p_i and q_i are given in per-unit, while f(p_i) and f(q_i) have a dimension of currency/hour. In the polynomial model coefficients are dimensionless.","category":"page"}]
}
