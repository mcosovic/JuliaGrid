var documenterSearchIndex = {"docs":
[{"location":"manual/dcPowerFlow/#DCPowerFlowManual","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To perform the DC power flow, you first need to have the PowerSystem composite type that has been created with the dc model. After that, create the DCPowerFlow composite type to establish the DC power flow framework using the function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"dcPowerFlow.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To solve the DC power flow problem and acquire bus voltage angles, make use of the following function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"solve!.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"After obtaining the solution for DC power flow, JuliaGrid offers a post-processing analysis function to compute active powers associated with buses, branches, and generators:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power!.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Additionally, there are specialized functions dedicated to calculating specific types of active powers related to particular buses, branches, or generators:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"injectionPower,\nsupplyPower,\nfromPower,\ntoPower,\ngeneratorPower.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCBusTypeModificationManual","page":"DC Power Flow","title":"Bus Type Modification","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"During the initialization process, the designated slack bus, which is initially set, undergoes examination and can be altered using the dcPowerFlow function. Here is an example:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 2, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; bus = \"Bus 3\", active = 3.2)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"In this example, the slack bus (type = 3) corresponds to the Bus 1. However, this bus does not have an in-service generator connected to it. Consequently, JuliaGrid recognizes this as an error and attempts to assign a new slack bus from the available generator buses (type = 2) that have connected in-service generators. In this particular example, the Bus 3 will become the new slack bus. As a result, we can observe the updated array of bus types within the defined set of buses:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 2, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; bus = \"Bus 3\", active = 3.2)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"[collect(keys(sort(system.bus.label; byvalue = true))) system.bus.layout.type]","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nThe bus that is defined as the slack bus (type = 3) but lacks a connected in-service generator will have its type changed to the demand bus (type = 1). Meanwhile, the first generator bus (type = 2) with an in-service generator connected to it will be assigned as the new slack bus (type = 3).","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerFlowSolutionManual","page":"DC Power Flow","title":"Power Flow Solution","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To solve the DC power flow problem using JuliaGrid, we start by creating the PowerSystem composite type and defining the DC model with the dcModel! function. Here is an example:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\ndcModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The dcPowerFlow function can be used to establish the DC power flow problem. It factorizes the nodal matrix to prepare for determining the bus voltage angles:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"analysis = dcPowerFlow(system)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To obtain the bus voltage angles, we can call the solve! function as follows:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"solve!(system, analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Once the solution is obtained, the bus voltage angles can be accessed using:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"[collect(keys(sort(system.bus.label; byvalue = true)))  analysis.voltage.angle]\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nWe recommend that readers refer to the tutorial on DC power flow for insights into the implementation.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerAnalysisManual","page":"DC Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"After obtaining the solution from the DC power flow, we can calculate powers related to buses, branches, and generators using the power! function. For instance, let us consider the power system for which we obtained the DC power flow solution:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Now we can calculate the active powers using the following function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"First, let us create label arrays to display active power injections at each bus and active power flows at each \"from\" end of the branch:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"labelBus = collect(keys(sort(system.bus.label; byvalue = true)))\nlabelBranch = collect(keys(sort(system.branch.label; byvalue = true)))\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, let us convert the base power unit to megavolt-amperes (MVA):","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"@base(system, MVA, V)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, here are the calculated active power values in megawatts (MW) corresponding to buses and branches:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"[labelBus system.base.power.value * analysis.power.injection.active]\n[labelBranch system.base.power.value * analysis.power.from.active]","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nTo better understand the powers associated with buses, branches and generators that are calculated by the power! function, we suggest referring to the tutorials on DC power flow analysis.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To calculate specific quantities for particular components rather than calculating active powers for all components, users can make use of the provided functions below.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Active-Power-Injection","page":"DC Power Flow","title":"Active Power Injection","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To calculate active power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = injectionPower(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Active-Power-Injection-from-Generators","page":"DC Power Flow","title":"Active Power Injection from Generators","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To calculate active power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = supplyPower(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Active-Power-Flow","page":"DC Power Flow","title":"Active Power Flow","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Similarly, we can compute the active power flow at both the \"from\" and \"to\" bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = fromPower(system, analysis; label = \"Branch 2\")\nactive = toPower(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Generator-Active-Power-Output","page":"DC Power Flow","title":"Generator Active Power Output","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, we can compute the active power output of a particular generator using the function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = generatorPower(system, analysis; label = \"Generator 1\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCReusingPowerSystemTypeManual","page":"DC Power Flow","title":"Reusing PowerSystem Type","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The PowerSystem composite type, including its incorporated dc field, can be employed without limitations. It can be automatically modified using functions like shuntBus!, statusBranch!, parameterBranch!, statusGenerator!, and outputGenerator!, allowing for seamless sharing of the PowerSystem type across different DC power flow analyses.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To illustrate, consider a scenario where we have initially established a power system. We are keen on observing the power system's behavior under normal operational conditions compared to a situation where one branch is transitioned from in-service to out-of-service, concurrently with adjustments in generator output power. This task can be effortlessly accomplished by reusing the PowerSystem composite type. It is noteworthy that we only need to employ the dcModel! function once in this context.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\n\nstatusBranch!(system; label = \"Branch 3\", status = 0)\noutputGenerator!(system; label = \"Generator 1\", active = 2.5)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Please take note that following the execution of the dcModel! function, users retain the capability to introduce additional branches by utilizing the addBranch! function. This action will also initiate an update within the dc field. Additionally, users can seamlessly include new generators into the system using the addGenerator! function as well.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCReusingDCPowerFlowTypeManual","page":"DC Power Flow","title":"Reusing DCPowerFlow Type","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"If a user wishes to also reuse the DCPowerFlow composite type, this can be accomplished by making modifications solely to shunt or generator parameters while maintaining the power system's branch parameters unchanged. The DCPowerFlow composite type encompasses a factorized nodal matrix, and reusing it results in more efficient computations as the factorization step is not redundantly performed.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To offer a straightforward method for reusing the DCPowerFlow composite type, users can pass this type to any functions that mutate the PowerSystem composite type. If modifications are permitted, they will be executed. In contrast, JuliaGrid issues an error. As an illustration, let us consider the same power system as previously discussed, where we find the solution:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"If you intend to utilize the DCPowerFlow type for modifying generator output power and demand power, and you want to ensure that this is permissible, you can execute the outputGenerator! and demandBus! functions, specifying the DCPowerFlow type as an argument. Following these adjustments, you can efficiently address the DC power flow problem, as demonstrated below:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"outputGenerator!(system, analysis; label = \"Generator 1\", active = 2.5)\ndemandBus!(system, analysis; label = \"Bus 2\", active = 0.2)\nsolve!(system, analysis)\n\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid enables users to modify both generator and demand power and reuse the DCPowerFlow type, which is enhanced with a factorized nodal matrix to obtain computationally efficient solutions.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"However, if you intend to reuse the DCPowerFlow type once more, this time with the aim of modifying the status of a branch:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"statusBranch!(system, analysis; label = \"Branch 3\", status = 0)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"It becomes apparent that in this scenario, reusing the DCPowerFlow type is not feasible.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"In conclusion, we will present a scenario that highlights the importance of this validation method. Suppose a user decides to eliminate generators from the slack bus through the statusGenerator! function. In such an instance, utilizing the DCPowerFlow type as an argument for the statusGenerator! function will facilitate the transition of the slack bus, as described in the Bus Type Modification, ensuring an accurate solution.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"info: Info\nWhen you provide the DCPowerFlow type as an argument to functions responsible for adding components or making modifications, you are essentially inquiring about the feasibility of reusing the DCPowerFlow type. This action allows you to seamlessly transition to the solve! function without any intermediate steps.","category":"page"},{"location":"api/configuration/#configurationSetupAPI","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"For further information on this topic, please see the Power System Model section of the Manual.","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#API-Index","page":"Configuration Setup","title":"API Index","text":"","category":"section"},{"location":"api/configuration/#Base-Unit-Prefixes","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#Input-Unit-System","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@parameter","category":"page"},{"location":"api/configuration/#Default-Settings","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Base-Unit-Prefixes-2","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#JuliaGrid.@base","page":"Configuration Setup","title":"JuliaGrid.@base","text":"@base(system::PowerSystem, power, voltage)\n\nBy default, the units for base power and base voltages are set to volt-ampere (VA) and volt (V), but you can modify the prefixes using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of power (VA) or unit of voltage (V). Keep in mind that the macro must be used after creating the composite type PowerSystem.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n@base(system, MVA, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Input-Unit-System-2","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@parameter","category":"page"},{"location":"api/configuration/#JuliaGrid.@power","page":"Configuration Setup","title":"JuliaGrid.@power","text":"@power(active, reactive, apparent)\n\nJuliaGrid stores all data related with powers in per-units, and these cannot be altered. However, the power units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of active power (W), reactive power (VAr), or apparent power (VA). Also it is a possible to combine SI units with/without prefixes with per-units (pu).\n\nChanging the unit of active power is reflected in the following quantities:\n\naddBus!: active, conductance,\nshuntBus!: conductance,\naddGenerator!: active, minActive, maxActive, lowActive, upActive, loadFollowing, reserve10min, reserve30min,\naddActiveCost!: piecewise, polynomial,\noutputGenerator!: active,\naddBranch!: longTerm, shortTerm, emergency if rating type = 2.\n\nChanging the unit of reactive power unit is reflected in the following quantities:\n\naddBus!: reactive, susceptance,\nshuntBus!: susceptance,\naddGenerator!: reactive, minReactive, maxReactive, minLowReactive, maxLowReactive, minUpReactive, maxUpReactive, reactiveTimescale,\naddReactiveCost!: piecewise, polynomial,\noutputGenerator!: reactive.\n\nChanging the unit of apparent power unit is reflected in the following quantities:\n\naddBranch!: longTerm, shortTerm, emergency if rating type = 1 or type = 3.\n\nExample\n\n@power(MW, kVAr, VA)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@voltage","page":"Configuration Setup","title":"JuliaGrid.@voltage","text":"@voltage(magnitude, angle, base)\n\nJuliaGrid stores all data related with voltages in per-units and radians, and these cannot be altered. However, the voltage magnitude and angle units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nThe prefixes must adhere to the SI prefixes and should be specified along with the unit of voltage, either magnitude (V) or base (V). Alternatively, the unit of voltage magnitude can be expressed in per-unit (pu). The unit of voltage angle should be in radians (rad) or degrees (deg).\n\nChanging the unit of voltage magnitude is reflected in the following quantities:\n\naddBus!: magnitude, minMagnitude, maxMagnitude,\naddGenerator!: magnitude.\n\nChanging the unit of voltage angle is reflected in the following quantities:\n\naddBus!: angle,\naddBranch!: shiftAngle, minDiffAngle, maxDiffAngle,\nparameterBranch!: shiftAngle.\n\nChanging the unit prefix of voltage base is reflected in the following quantity:\n\naddBus!: base.\n\nExample\n\n@voltage(pu, deg, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@parameter","page":"Configuration Setup","title":"JuliaGrid.@parameter","text":"@parameter(impedance, admittance)\n\nJuliaGrid stores all data related with impedances and admittancies in per-units, and these cannot be altered. However, units of impedance and admittance of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of impedance (Ω) or unit of admittance (S). The second option is to define the units in per-unit (pu).\n\nIn the case where impedance and admittance are being used in SI units (Ω and S) and these units are related to the transformer, the assignment must be based on the primary side of the transformer.\n\nChanging the units of impedance is reflected in the following quantities in specific functions:\n\naddBranch!: resistance, reactance,\nparameterBranch!: resistance, reactance.\n\nChanging the units of admittance is reflected in the following quantities:\n\naddBranch!: susceptance,\nparameterBranch!: susceptance.\n\nExample\n\n@parameter(Ω, pu)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Default-Settings-2","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/#JuliaGrid.@default","page":"Configuration Setup","title":"JuliaGrid.@default","text":"The macro is designed to reset various settings to their default values.\n\n@default(mode)\n\nThe mode argument can take on the following values:\n\nunit: resets all units to their default settings\npower: sets active, reactive, and apparent power to per-units\nvoltage: sets voltage magnitude to per-unit and voltage angle to radian\nparameter: sets impedance and admittance to per-units\ntemplate: resets bus, branch and generator templates to their default settings\nbus: resets the bus template to its default settings\nbranch: resets the branch template to its default settings\ngenerator: resets the generator template to its default settings.\n\nExample\n\n@default(unit)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerFlow/#PowerFlowAPI","page":"Power Flow","title":"Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"For further information on this topic, please see the AC Power Flow or DC Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for power flow analysis.","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-AC-Power-Flow-Model","page":"Power Flow","title":"Build AC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel","category":"page"},{"location":"api/powerFlow/#Solve-AC-Power-Flow","page":"Power Flow","title":"Solve AC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"mismatch!\nsolve!","category":"page"},{"location":"api/powerFlow/#Additional-AC-Functions","page":"Power Flow","title":"Additional AC Functions","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"reactiveLimit!\nadjustAngle! ","category":"page"},{"location":"api/powerFlow/#Build-DC-Power-Flow-Model","page":"Power Flow","title":"Build DC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"dcPowerFlow","category":"page"},{"location":"api/powerFlow/#Solve-DC-Power-Flow","page":"Power Flow","title":"Solve DC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"solve!","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-AC-Power-Flow-Model-2","page":"Power Flow","title":"Build AC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel","category":"page"},{"location":"api/powerFlow/#JuliaGrid.newtonRaphson","page":"Power Flow","title":"JuliaGrid.newtonRaphson","text":"newtonRaphson(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Newton-Raphson method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the NewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\njacobian: the Jacobian matrix;\nmismatch: the active and reactive power injection mismatches;\nincrement: the bus voltage magnitude and angle increments;\npq: indices of demand buses;\npvpq: indices of demand and generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonBX","text":"fastNewtonRaphsonBX(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the fast Newton-Raphson method of version BX to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field  within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nactive:\njacobian: the Jacobian matrix associated with active power equations;\nmismatch: the active power injection mismatches;\nincrement: the bus voltage angle increments;\nfactorization: the factorized Jacobian matrix;\nreactive:\njacobian: the Jacobian matrix associated with reactive power equations;\nmismatch: the reative power injection mismatches;\nincrement: the bus voltage magnitude increments;\nfactorization: the factorized Jacobian matrix;\npq: indices of demand buses;\npvpq: indices of demand and generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonBX(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonXB","text":"fastNewtonRaphsonXB(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the fast Newton-Raphson method of version XB to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nactive:\njacobian: the Jacobian matrix associated with active power equations;\nmismatch: the active power injection mismatches;\nincrement: the bus voltage angle increments;\nfactorization: the factorized Jacobian matrix;\nreactive:\njacobian: the Jacobian matrix associated with reactive power equations;\nmismatch: the reative power injection mismatches;\nincrement: the bus voltage magnitude increments;\nfactorization: the factorized Jacobian matrix;\npq: indices of demand buses;\npvpq: indices of demand and generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonXB(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.gaussSeidel","page":"Power Flow","title":"JuliaGrid.gaussSeidel","text":"gaussSeidel(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Gauss-Seidel method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the GaussSeidel subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\ncomplex: the bus complex voltages;\npq: indices of demand buses;\npv: indices of generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = gaussSeidel(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Solve-AC-Power-Flow-2","page":"Power Flow","title":"Solve AC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"mismatch!(::PowerSystem, ::NewtonRaphson)\nsolve!(::PowerSystem, ::NewtonRaphson)","category":"page"},{"location":"api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}","page":"Power Flow","title":"JuliaGrid.mismatch!","text":"mismatch!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function calculates both active and reactive power injection mismatches and returns their maximum absolute values, which can be utilized to terminate the iteration loop of methods employed to solve the AC power flow problem.\n\nUpdates\n\nThis function updates the mismatch variables in the Newton-Raphson and fast Newton-Raphson methods. It should be employed during the iteration loop before invoking the solve! function.\n\nIn contrast, the Gauss-Seidel method does not need mismatches to obtain bus voltages, but the maximum absolute values are commonly employed to stop the iteration loop. The function does not save any data and should be utilized during the iteration loop before invoking the solve! function.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the power mismatches within the Newton-Raphson method;\nFastNewtonRaphson: computes the power mismatches within the fast Newton-Raphson method;\nGaussSeidel: computes the power mismatches within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nmismatch!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function employs the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel method to solve the AC power flow problem and calculate bus voltage magnitudes and angles.\n\nAfter the mismatch! function is called, this function should be executed to perform a single iteration of the method.\n\nUpdates\n\nThe calculated voltages are stored in the voltage field of the respective struct type.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method;\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method;\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Additional-AC-Functions-2","page":"Power Flow","title":"Additional AC Functions","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"reactiveLimit!\nadjustAngle!","category":"page"},{"location":"api/powerFlow/#JuliaGrid.reactiveLimit!","page":"Power Flow","title":"JuliaGrid.reactiveLimit!","text":"reactiveLimit!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function verifies whether the generators in a power system exceed their reactive power limits. This is done by setting the reactive power of the generators to within the limits if they are violated, after determining the bus voltage magnitudes and angles. If the limits are violated, the corresponding generator buses or the slack bus are converted to demand buses.\n\nUpdates\n\nThe function assigns values to the generator.output.active and bus.supply.active variables of the PowerSystem type. Additionally, it examines the reactive powers of the generator and adjusts them to their maximum or minimum values if they exceed the specified threshold. Subsequently, the generator.output.reactive variable of the PowerSystem type is modified accordingly. As a result of this adjustment, the bus.supply.reactive variable of the PowerSystem type is also updated, and the bus types specified in bus.layout.type are modified. If the slack bus is converted, the bus.layout.slack field is correspondingly adjusted.\n\nReturns\n\nThe function returns the violate variable to indicate which buses violate the limits, with -1 indicating a violation of the minimum limits and 1 indicating a violation of the maximum limits.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method,\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method,\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nviolate = reactiveLimit!(system, analysis)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.adjustAngle!","page":"Power Flow","title":"JuliaGrid.adjustAngle!","text":"adjustAngle!(system::PowerSystem, analysis::ACPowerFlow; slack)\n\nThe function modifies the bus voltage angles based on a different slack bus than the one identified by the bus.layout.slack field.\n\nFor instance, if the reactive power of the generator exceeds the limit on the slack bus, the reactiveLimit! function will change that bus to the demand bus and designate the first generator bus in the sequence as the new slack bus. After obtaining the updated AC power flow solution based on the new slack bus, it is possible to adjust the voltage angles to align with the angle of the original slack bus. The slack keyword specifies the bus label of the original slack bus.\n\nUpdates\n\nThis function only updates the voltage.angle variable of the ACPowerFlow abstract type.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method;\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method;\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nreactiveLimit!(system, analysis)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nadjustAngle!(system, analysis; slack = 1)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-DC-Power-Flow-Model-2","page":"Power Flow","title":"Build DC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"dcPowerFlow","category":"page"},{"location":"api/powerFlow/#JuliaGrid.dcPowerFlow","page":"Power Flow","title":"JuliaGrid.dcPowerFlow","text":"dcPowerFlow(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input, which is utilized to establish the structure for solving the DC power flow.\n\nIf the DC model was not created, the function will automatically initiate an update of the dc field within the PowerSystem composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.\n\nReturns\n\nThe function returns an instance of the DCPowerFlow composite type, which includes the following fields:\n\nvoltage: the variable allocated to store the bus voltage angles;\npower: the variable allocated to store the active powers;\nfactorization: the factorized nodal matrix.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Solve-DC-Power-Flow-2","page":"Power Flow","title":"Solve DC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"solve!(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::DCPowerFlow)\n\nBy computing the bus voltage angles, the function solves the DC power flow problem.\n\nUpdates\n\nThe resulting bus voltage angles are stored in the voltage field of the DCPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#PowerCurrentAnalysisAPI","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"In the following section, we have provided a list of functions that can be utilized for post-processing analysis. Once the voltage values are obtained through power flow analysis or optimal power flow analysis, these functions can be used to calculate power or current values. The specific procedures for computing these values depend on the chosen analysis, which are described in separate manuals for further information.","category":"page"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#AC-Power-Analysis","page":"Power and Current Analysis","title":"AC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!","category":"page"},{"location":"api/analysis/#AC-Power-Breakdown-Analysis","page":"Power and Current Analysis","title":"AC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower\nsupplyPower\nshuntPower\nfromPower\ntoPower\nseriesPower\nchargingPower\ngeneratorPower","category":"page"},{"location":"api/analysis/#AC-Current-Analysis","page":"Power and Current Analysis","title":"AC Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"current!","category":"page"},{"location":"api/analysis/#AC-Current-Breakdown-Analysis","page":"Power and Current Analysis","title":"AC Current Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionCurrent\nfromCurrent\ntoCurrent\nseriesCurrent","category":"page"},{"location":"api/analysis/#DC-Power-Analysis","page":"Power and Current Analysis","title":"DC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!","category":"page"},{"location":"api/analysis/#DC-Power-Breakdown-Analysis","page":"Power and Current Analysis","title":"DC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower\nsupplyPower\nfromPower\ntoPower\ngeneratorPower","category":"page"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACPowerAnalysisAPI","page":"Power and Current Analysis","title":"AC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!(::PowerSystem, ::ACPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.power!","text":"power!(system::PowerSystem, analysis::AC)\n\nThe function computes the active and reactive powers associated with buses, branches, and generators in the AC framework.\n\nUpdates\n\nThis function updates the power field of the AC abstract type by computing the following electrical quantities:\n\ninjection: active and reactive power bus injections;\nsupply: active and reactive power bus injections from the generators;\nshunt: active and reactive power values associated with shunt element at each bus;\nfrom: active and reactive power flows at the \"from\" end of each branch;\nto: active and reactive power flows at the \"to\" end of each branch;\ncharging: active and reactive power values linked with branch charging admittances for each branch;\nseries active and reactive power losses through each branch series impedance;\ngenerator: produced active and reactive power outputs of each generator.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\npower!(system, analysis)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\npower!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACPowerBreakdownAnalysisAPI","page":"Power and Current Analysis","title":"AC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower(::PowerSystem, ::AC)\nsupplyPower(::PowerSystem, ::ACPowerFlow)\nshuntPower(::PowerSystem, ::AC)\nfromPower(::PowerSystem, ::AC)\ntoPower(::PowerSystem, ::AC)\nseriesPower(::PowerSystem, ::AC)\nchargingPower(::PowerSystem, ::AC)\ngeneratorPower(::PowerSystem, ::ACPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.injectionPower","text":"injectionPower(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power injections associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = injectionPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = injectionPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.supplyPower","text":"supplyPower(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power injections from the generators associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = supplyPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = supplyPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.shuntPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.shuntPower","text":"shuntPower(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power values of the shunt element associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = shuntPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = shuntPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.fromPower","text":"fromPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power flows at the \"from\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = fromPower(system, analysis; label = 2)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = fromPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.toPower","text":"toPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power flows at the \"to\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = toPower(system, analysis; label = 2)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = toPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.seriesPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.seriesPower","text":"seriesPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power losses across the series impedance of a specific branch within the AC framework. The label keyword argument should correspond to an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the power within the AC power flow;\nACOptimalPowerFlow: computes the power within the AC optimal power flow.\n\nExamples\n\nCompute the reactive power after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = seriesPower(system, analysis; label = 2)\n\nCompute the reactive power after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = seriesPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.chargingPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.chargingPower","text":"chargingPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power values associated with the charging admittances of a specific branch in the AC framework. The label keyword argument must correspond to an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the power within the AC power flow;\nACOptimalPowerFlow: computes the power within the AC optimal power flow.\n\nExamples\n\nCompute the reactive power after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = chargingPower(system, analysis; label = 2)\n\nCompute the reactive power after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = chargingPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.generatorPower-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.generatorPower","text":"generatorPower(system::PowerSystem, analysis::AC)\n\nThe function returns the active and reactive powers associated with a specific generator in the AC framework. The label keyword argument must match an existing generator label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = generatorPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = generatorPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACCurrentAnalysisAPI","page":"Power and Current Analysis","title":"AC Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"current!(::PowerSystem, ::AC)","category":"page"},{"location":"api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.current!","text":"current!(system::PowerSystem, analysis::AC)\n\nThe function computes the currents in the polar coordinate system associated with buses and branches in the AC framework.\n\nUpdates\n\nThis function calculates various electrical quantities in the polar coordinate system:\n\ninjection: current injections at each bus;\nfrom: current flows at each \"from\" bus end of the branch;\nto: current flows at each \"to\" bus end of the branch;\nseries: current flows through the series impedance of the branch in the direction from the \"from\" bus end to the \"to\" bus end of the branch.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the currents within the AC power flow;\nACOptimalPowerFlow: computes the currents within the AC optimal power flow.\n\nExamples\n\nCompute currents after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\ncurrent!(system, analysis)\n\nCompute currents after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\ncurrent!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACCurrentBreakdownAnalysisAPI","page":"Power and Current Analysis","title":"AC Current Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionCurrent(::PowerSystem, ::AC)\nfromCurrent(::PowerSystem, ::AC)\ntoCurrent(::PowerSystem, ::AC)\nseriesCurrent(::PowerSystem, ::AC)","category":"page"},{"location":"api/analysis/#JuliaGrid.injectionCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.injectionCurrent","text":"injectionCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = injectionCurrent(system, analysis; label = 1)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = injectionCurrent(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.fromCurrent","text":"fromCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the \"from\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = fromCurrent(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = fromCurrent(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.toCurrent","text":"toCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the \"to\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = toCurrent(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = toCurrent(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.seriesCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.seriesCurrent","text":"seriesCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system through series impedance associated with a specific branch in the direction from the \"from\" bus end to the \"to\" bus end of the branch within the AC framework. The label keyword argument must  match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = seriesCurrent(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = seriesCurrent(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#DCPowerAnalysisAPI","page":"Power and Current Analysis","title":"DC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.power!","text":"power!(system::PowerSystem, analysis::DC)\n\nThe function calculates the active power values related to buses, branches, and generators within the DC analysis framework. It modifies the power field of the abstract type DC.\n\nUpdates\n\nThis function computes the following electrical quantities:\n\ninjection: active power injections at each bus;\nsupply: active power injections from the generators at each bus;\nfrom: active power flows at each \"from\" bus end of the branch;\nto: active power flows at each \"to\" bus end of the branch;\ngenerator: output active powers of each generator.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the powers within the DC power flow;\nDCOptimalPowerFlow: computes the powers within the DC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\npower!(system, analysis)\n\nCompute powers after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\npower!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#DCPowerBreakdownAnalysisAPI","page":"Power and Current Analysis","title":"DC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower(::PowerSystem, ::DCPowerFlow)\nsupplyPower(::PowerSystem, ::DCPowerFlow)\nfromPower(::PowerSystem, ::DC)\ntoPower(::PowerSystem, ::DC)\ngeneratorPower(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.injectionPower","text":"injectionPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power injection associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow;\n\nExamples\n\nCompute the active power of a specific bus after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\ninjection = injectionPower(system, analysis; label = 2)\n\nCompute the active power of a specific bus after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\ninjection = injectionPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.supplyPower","text":"supplyPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power injection from the generators associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow,\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific bus after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nsupply = supplyPower(system, analysis; label = 2)\n\nCompute the active power of a specific bus after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nsupply = supplyPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, DC}","page":"Power and Current Analysis","title":"JuliaGrid.fromPower","text":"fromPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power flow at the \"from\" bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific branch after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nfrom = fromPower(system, analysis; label = 2)\n\nCompute the active power of a specific branch after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nfrom = fromPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, DC}","page":"Power and Current Analysis","title":"JuliaGrid.toPower","text":"toPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power flow at the \"to\" bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific branch after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nto = toPower(system, analysis; label = 2)\n\nCompute the active power of a specific branch after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nto = toPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.generatorPower-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.generatorPower","text":"generatorPower(system::PowerSystem, analysis::DC; label)\n\nThis function returns the output active power associated with a specific generator in the DC framework. The label keyword argument must match an existing generator label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific generator after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\ngenerator = generatorPower(system, analysis; label = 1)\n\nCompute the active power of a specific generator after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\ngenerator = generatorPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/powerSystemModel/#powerSystemModelAPI","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For further information on this topic, please see the Power System Model section of the Manual. Below, we have provided a list of functions that can be used to create, save, and manipulate power system structures, as well as to build AC or DC models of power systems.","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System-Data","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\ndemandBus!\nshuntBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nstatusGenerator!\noutputGenerator!\naddActiveCost!\naddReactiveCost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System-Data-2","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.powerSystem","page":"Power System Model","title":"JuliaGrid.powerSystem","text":"powerSystem(file::String)\n\nThe function builds the composite type PowerSystem and populates bus, branch, generator and base fields. In general, once the composite type PowerSystem has been created, it is possible to add new buses, branches, or generators, or modify the parameters of existing ones.\n\nArgument\n\npassing the path to the HDF5 file with the .h5 extension,\npassing the path to Matpower file with the .m extension.\n\nReturns\n\nThe PowerSystem composite type with the following fields:\n\nbus: data related to buses;\nbranch: data related to branches;\ngenerator: data related to generators;\nbase: base power and base voltages;\nmodel: data associated with AC (nonlinear) or DC (linear) analyses;\nuuid: universally unique identifier for the power system.\n\nUnits\n\nJuliaGrid stores all data in per-units and radians format which are fixed, the exceptions are base values in volt-amperes and volts. The prefixes for these base values can be changed using the @base macro.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\n\n\n\n\nAlternatively, the PowerSystem composite type can be initialized by calling the function without any arguments.\n\npowerSystem()\n\nThis allows the model to be built from scratch and modified as needed. This generates an empty PowerSystem type, with only the base power initialized to 1.0e8 volt-amperes (VA).\n\nExample\n\nsystem = powerSystem()\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.savePowerSystem","page":"Power System Model","title":"JuliaGrid.savePowerSystem","text":"savePowerSystem(system::PowerSystem; path::String, reference::String, note::String)\n\nThe function saves the power system's data in the HDF5 file using the fields bus, branch, generator, and base from the PowerSystem composite type.\n\nKeywords\n\nThe location and file name of the HDF5 file is specified by the mandatory keyword path in  the format of \"path/name.h5\". Additional information can be provided by the optional  keywords reference and note, which can be saved along with the power system data.\n\nView HDF5 File\n\nTo view the saved HDF5 file, you can use the HDFView software.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"D:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions-2","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\ndemandBus!\nshuntBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBus!","page":"Power System Model","title":"JuliaGrid.addBus!","text":"addBus!(system::PowerSystem; label, type, active, reactive, conductance, susceptance,\n    magnitude, angle, minMagnitude, maxMagnitude, base, area, lossZone)\n\nThe function adds a new bus to the PowerSystem composite type, updating its bus field.\n\nKeywords\n\nThe bus is defined with the following keywords:\n\nlabel: unique label for the bus;\ntype: the bus type:\ntype = 1: demand bus (PQ);\ntype = 2: generator bus (PV);\ntype = 3: slack bus (Vθ);\nactive (pu or W): the active power demand at the bus;\nreactive (pu or VAr): the reactive power demand at the bus;\nconductance (pu or W): the active power demanded of the shunt element;\nsusceptance (pu or VAr): the reactive power injected of the shunt element;\nmagnitude (pu or V): the initial value of the voltage magnitude;\nangle (rad or deg): the initial value of the voltage angle;\nminMagnitude (pu or V): the minimum voltage magnitude value;\nmaxMagnitude (pu or V): the maximum voltage magnitude value;\nbase (V): the base value of the voltage magnitude;\narea: the area number;\nlossZone: the loss zone.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: type = 1, magnitude = 1.0 per-unit, and base = 138e3 volts. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @bus macro.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, angle = 0.1745, base = 132e3)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 25, reactive = -4, angle = 10, base = 132)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.demandBus!","page":"Power System Model","title":"JuliaGrid.demandBus!","text":"demandBus!(system::PowerSystem; label, active, reactive)\n\nThis function allows for the adjustment of active and reactive power demand at a  specific bus.\n\nKeywords\n\nThe keyword label must match an existing bus label. If either active or reactive is left out, the corresponding value will remain unchanged.\n\nUpdates\n\nThis function modifies the bus.demand field in the PowerSystem composite type. \n\nUnits\n\nThe input units are in per-units by default, but they can be modified using the @power macro.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\ndemandBus!(system; label = 1, active = 0.15)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.shuntBus!","page":"Power System Model","title":"JuliaGrid.shuntBus!","text":"shuntBus!(system::PowerSystem; label, conductance, susceptance)\n\nThis function enables the modification of the conductance and susceptance parameters of a shunt element connected to a bus.\n\nKeywords\n\nThe keyword label must match an existing bus label. If either conductance or susceptance is left out, the corresponding value will remain unchanged.\n\nUpdates\n\nThis function modifies the bus.shunt field in the PowerSystem composite type. Moreover, it also automatically updates the ac field within the PowerSystem type, thereby removing the requirement to completely rebuild the vectors and matrices when adjustments are made to these parameters.\n\nUnits\n\nThe input units are in per-units by default, but they can be modified using the @power macro.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\nshuntBus!(system; label = 1, conductance = 0.04)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@bus","page":"Power System Model","title":"JuliaGrid.@bus","text":"@bus(kwargs...)\n\nThe macro generates a template for a bus, which can be utilized to define a bus using the addBus! function.\n\nKeywords\n\nTo define the bus template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBus! function, along with their corresponding values.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus template using the default unit system:\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 0.25, angle = 0.1745)\naddBus!(system; label = 1, reactive = -0.04, base = 132e3)\n\nCreating a bus template using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\n@bus(type = 2, active = 25, angle = 10, base = 132)\naddBus!(system; label = 1, reactive = -4)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions-2","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBranch!","page":"Power System Model","title":"JuliaGrid.addBranch!","text":"addBranch!(system::PowerSystem; label, from, to, status, resistance, reactance,\n    conductance, susceptance, turnsRatio, shiftAngle, minDiffAngle, maxDiffAngle,\n    longTerm, shortTerm, emergency, type)\n\nThe function adds a new branch to the PowerSystem type and updates its branch field. A branch can be added between already defined buses.\n\nKeywords\n\nThe branch is defined with the following keywords:\n\nlabel: unique label for the branch;\nfrom: from bus label, corresponds to the bus label;\nto: to bus label, corresponds to the bus label;\nstatus: operating status of the branch:\nstatus = 1: in-service;\nstatus = 0: out-of-service;\nresistance (pu or Ω): series resistance;\nreactance (pu or Ω): series reactance;\nconductance (pu or S): total shunt conductance;\nsusceptance (pu or S): total shunt susceptance;\nturnsRatio: transformer off-nominal turns ratio, equal to one for a line;\nshiftAngle (rad or deg): transformer phase shift angle, where positive value defines delay;\nminDiffAngle (rad or deg): minimum voltage angle difference value between from and to bus;\nmaxDiffAngle (rad or deg): maximum voltage angle difference value between from and to bus;\nlongTerm (pu or VA, W): long-term rating (equal to zero for unlimited);\nshortTerm (pu or VA, W): short-term rating (equal to zero for unlimited);\nemergency (pu or VA, W): emergency rating (equal to zero for unlimited);\ntype: types of longTerm, shortTerm, and emergency ratings:\ntype = 1: apparent power flow (pu or VA);\ntype = 2: active power flow (pu or W);\ntype = 3: current magnitude (pu or VA at 1 pu voltage).\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1, turnsRatio = 1.0, and type = 1. The  rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @branch macro.\n\nUnits\n\nThe default units for the keyword parameters are per-units (pu) and radians (rad). However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)\n\nCreating a branch using a custom unit system:\n\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1,  active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 10)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.statusBranch!","page":"Power System Model","title":"JuliaGrid.statusBranch!","text":"statusBranch!(system::PowerSystem; label, status)\n\nThe function alters the operational status of a branch within the PowerSystem composite type, toggling between in-service and out-of-service.\n\nKeywords\n\nThe label keyword should correspond to the existing branch label, while the status keyword modifies the operational status of the branch.\n\nUpdates\n\nThis function modifies the branch.layout.status variable in the PowerSystem composite type. Moreover, it also automatically updates the ac and dc fields within the PowerSystem type, thereby removing the requirement to completely rebuild the vectors and matrices when the operational status of a branch changes.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nstatusBranch!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.parameterBranch!","page":"Power System Model","title":"JuliaGrid.parameterBranch!","text":"parameterBranch!(system::PowerSystem; label, resistance, reactance, conductance,\n    susceptance, turnsRatio, shiftAngle)\n\nThe function allows for the modification of branch parameters within the PowerSystem composite type.\n\nKeywords\n\nThe function modifies the resistance, reactance, conductance, susceptance, turnsRatio, and shiftAngle parameters of a branch, which is identified by its label. If any of these parameters are left out, their existing values will remain unchanged.\n\nUpdates\n\nIt updates the branch.parameter field of the PowerSystem composite type. Additionally, this function automatically updates the ac and dc fields within the PowerSystem type, thereby removing the requirement to completely rebuild the vectors and matrices when adjustments are made to these parameters.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units. However, users have the option to use other units instead of per-units and radians using the @voltage and @parameter macros.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nparameterBranch!(system; label = 1, susceptance = 0.062)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@branch","page":"Power System Model","title":"JuliaGrid.@branch","text":"@branch(kwargs...)\n\nThe macro generates a template for a branch, which can be utilized to define a branch using the addBranch! function.\n\nKeywords\n\nTo define the branch template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBranch! function, along with their corresponding values.\n\nUnits\n\nThe default units for the keyword parameters are per-units and radians. However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch template using the default unit system:\n\nsystem = powerSystem()\n\n@branch(reactance = 0.12, shiftAngle = 0.1745)\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2)\n\nCreating a branch template using a custom unit system:\n\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\n@branch(shiftAngle = 10)\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1,  active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions-2","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nstatusGenerator!\noutputGenerator!\naddActiveCost!\naddReactiveCost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addGenerator!","page":"Power System Model","title":"JuliaGrid.addGenerator!","text":"addGenerator!(system::PowerSystem; label, bus, status, active, reactive, magnitude,\n    minActive, maxActive, minReactive, maxReactive, lowActive, minLowReactive,\n    maxLowReactive, upActive, minUpReactive, maxUpReactive,\n    loadFollowing, reactiveTimescale, reserve10min, reserve30min, area)\n\nThe function is used to add a new generator to the PowerSystem composite type and update its generator field. The generator can be added to an already defined bus.\n\nKeywords\n\nThe generator is defined with the following keywords:\n\nlabel: a unique label for the generator;\nbus: the label of the bus to which the generator is connected;\nstatus: the operating status of the generator:\nstatus = 1: in-service;\nstatus = 0: out-of-service;\nactive (pu or W): output active power;\nreactive (pu or VAr): output reactive power;\nmagnitude (pu or V): voltage magnitude setpoint;\nminActive (pu or W): minimum allowed output active power value;\nmaxActive (pu or W): maximum allowed output active power value;\nminReactive (pu or VAr): minimum allowed output reactive power value;\nmaxReactive (pu or VAr): maximum allowed output reactive power value;\nlowActive (pu or W): lower allowed active power output value of PQ capability curve;\nminLowReactive (pu or VAr): minimum allowed reactive power output value at lowActive value;\nmaxLowReactive (pu or VAr): maximum allowed reactive power output value at lowActive value;\nupActive (pu or W): upper allowed active power output value of PQ capability curve;\nminUpReactive (pu or VAr): minimum allowed reactive power output value at upActive value;\nmaxUpReactive (pu or VAr): maximum allowed reactive power output value at upActive value;\nloadFollowing (pu/min or W/min): ramp rate for load following/AG;\nreserve10min (pu or W): ramp rate for 10-minute reserves;\nreserve30min (pu or W): ramp rate for 30-minute reserves;\nreactiveTimescale (pu/min or VAr/min): ramp rate for reactive power, two seconds timescale;\narea: area participation factor.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1 and magnitude = 1.0 per-unit. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @generator macro.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 2, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1, magnitude = 1.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 2, active = 25, reactive = -4, base = 132)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10, magnitude = 145.2)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.statusGenerator!","page":"Power System Model","title":"JuliaGrid.statusGenerator!","text":"statusGenerator!(system::PowerSystem; label, status)\n\nThe function changes the operating status of a generator by switching it from in-service to out-of-service, or vice versa.\n\nKeywords\n\nIt has two parameters, label and status, where the label corresponds to the generator label that has already been defined.\n\nUpdates\n\nThe main purpose of the function is to update the bus.supply field within the PowerSystem type. Additionally, the function alters the generator.layout.status variable.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\nstatusGenerator!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.outputGenerator!","page":"Power System Model","title":"JuliaGrid.outputGenerator!","text":"outputGenerator!(system::PowerSystem; label, active, reactive)\n\nThe function modifies the active and reactive output powers of a generator.\n\nKeywords\n\nIt has three parameters, label, active, and reactive, where the label corresponds to the generator label that has already been defined. The active and reactive parameters can be left, in which case their values will remain unchanged.\n\nUpdates\n\nThe main purpose of the function is to update the bus.supply field within the PowerSystem type. Additionally, the function alters the generator.output field.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\noutputGenerator!(system; label = 1, active = 0.85)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.addActiveCost!","page":"Power System Model","title":"JuliaGrid.addActiveCost!","text":"addActiveCost!(system::PowerSystem; label, model, piecewise, polynomial)\n\nThe function updates the generator.cost field of the PowerSystem type by adding costs for the active power produced by the corresponding generator. It can add a cost to an already defined generator.\n\nKeywords\n\nThe function accepts four keywords:\n\nlabel: corresponds to the already defined generator label;\nmodel: cost model:\nmodel = 1: piecewise linear is being used;\nmodel = 2: polynomial is being used;\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or W): active power output of the generator;\nsecond column (currency/hr): cost for the specified active power output;\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/Wⁿhr): coefficient of the n-th degree term, ...;\npenultimate element (currency/puhr or currency/Whr): coefficient of the first degree term;\nlast element (currency/hr): constant coefficient.\n\nUnits\n\nBy default, the input units related with active powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\naddActiveCost!(system; label = 1, model = 1, polynomial = [1100.0; 500.0; 150.0])\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 25, reactive = -4, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\naddActiveCost!(system; label = 1, model = 1, polynomial = [0.11; 5.0; 150.0])\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.addReactiveCost!","page":"Power System Model","title":"JuliaGrid.addReactiveCost!","text":"addReactiveCost!(system::PowerSystem; label, model, piecewise, polynomial)\n\nThe function updates the generator.cost field of the PowerSystem type by adding costs for the reactive power produced by the corresponding generator. It can add a cost to an already defined generator.\n\nKeywords\n\nThe function accepts four keywords:\n\nlabel: corresponds to the already defined generator label;\nmodel: cost model:\nmodel = 1: piecewise linear is being used;\nmodel = 2: polynomial is being used;\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or VAr): reactive power output of the generator;\nsecond column (currency/hr): cost for the specified reactive power output;\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/VArⁿhr): coefficient of the n-th degree term, ...;\npenultimate element (currency/puhr or currency/VArhr): coefficient of the first degree term;\nlast element (currency/hr): constant coefficient.\n\nUnits\n\nBy default, the input units related with reactive powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\naddReactiveCost!(system; label = 1, model = 2, piecewise = [0.1085 12; 0.1477 16])\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 25, reactive = -4, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\naddReactiveCost!(system; label = 1, model = 2, piecewise = [10.85 12; 14.77 16])\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@generator","page":"Power System Model","title":"JuliaGrid.@generator","text":"@generator(kwargs...)\n\nThe macro generates a template for a generator, which can be utilized to define a generator using the addGenerator! function.\n\nKeywords\n\nTo define the generator template, the kwargs input arguments must be provided in accordance with the keywords specified within the addGenerator! function, along with their corresponding values.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\n@generator(magnitude = 1.1)\naddBus!(system; label = 1, type = 2, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\nsystem = powerSystem()\n\n@generator(magnitude = 145.2)\naddBus!(system; label = 1, type = 2, active = 25, reactive = -4, base = 132)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model-2","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.acModel!","page":"Power System Model","title":"JuliaGrid.acModel!","text":"acModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with AC analyses.\n\nUpdates\n\nThe function modifies the model.ac field within the PowerSystem composite type, populating the following variables:\n\nnodalMatrix: the nodal matrix;\nnodalMatrixTranspose: the transpose of the nodal matrix;\nnodalFromFrom: the Y-parameters of the two-port branches;\nnodalFromTo: the Y-parameters of the two-port branches;\nnodalToTo: the Y-parameters of the two-port branches;\nnodalToFrom: the Y-parameters of the two-port branches;\nadmittance: the branch admittances.\n\nOnce these variables are established, they will be automatically adjusted upon using the following functions:\n\nshuntBus!,\naddBranch!,\nstatusBranch!,\nparameterBranch!.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.dcModel!","page":"Power System Model","title":"JuliaGrid.dcModel!","text":"dcModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with DC analyses.\n\nUpdates\n\nThe function modifies the model.dc field within the PowerSystem composite type, populating the following variables:\n\nnodalMatrix: the nodal matrix;\nadmittance: the branch admittances;\nshiftActivePower: the active powers related to phase-shifting transformers.\n\nOnce these variables are established, they will be automatically adjusted upon using the following functions:\n\naddBranch!,\nstatusBranch!,\nparameterBranch!.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"manual/powerSystemModel/#PowerSystemModelManual","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid supports the composite type PowerSystem to preserve power system data, with the following fields: bus, branch, generator, base, model, and uuid. The fields bus, branch, and generator hold data related to buses, branches, and generators, respectively. The base field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes for the base power and line-to-line voltages measured in volts for base voltages. The model stores vectors and matrices that are related to the topology and parameters of the power system. Lastly, the uuid field contains a universally unique identifier, as assigned by JuliaGrid, which manages the behavior of the PowerSystem type across different functions.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The composite type PowerSystem can be created using a function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid supports three modes for populating the PowerSystem type: using built-in functions, using HDF5 file format, and using Matpower case files.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type is created, you can add buses, branches, and generators using the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!,\naddBranch!,\naddGenerator!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, JuliaGrid provides macros @bus, @branch, and @generator to define templates that aid in creating buses, branches, and generators. These templates help avoid entering the same parameters repeatedly.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To create vectors and matrices based on the power system topology and parameters, you can use the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!,\ndcModel!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In addition, it is possible to manipulate the parameters of buses, branches, and generators using the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"demandBus!,\nshuntBus!,\nstatusBranch!,\nparameterBranch!,\nstatusGenerator!,\noutputGenerator!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Executing these functions will automatically update all fields affected by them within PowerSystem composite type. You can also change other parameters of the power system by accessing and modifying the values in the bus, branch, generator, and base fields of the PowerSystem type.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, after adding the generator, JualiGrid provides the following functions to incorporate costs for the active and reactive power generated by the generator:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!,\naddReactiveCost!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#BuildModelManual","page":"Power System Model","title":"Build Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The powerSystem function generates the PowerSystem composite type and requires a string-formatted path to either Matpower case or HDF5 files as input. Alternatively, the PowerSystem can be created without any initial data by initializing it as empty, allowing the user to construct the power system from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Matpower-or-HDF5-File","page":"Power System Model","title":"Matpower or HDF5 File","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, to create the PowerSystem type using the Matpower case file for the IEEE 14-bus test case, which is named case14.m and located in the folder C:\\matpower, the following Julia code can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/matpower/case14.m\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In order to use the HDF5 file as input to create the PowerSystem object, it is necessary to have saved the data using the savePowerSystem function beforehand. As an example, let us say we saved the power system as case14.h5 in the directory C:\\hdf5. In this case, the following Julia code can be used to construct the PowerSystem composite type:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/hdf5/case14.h5\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIt is recommended to load the power system from the HDF5 file to reduce the loading time.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Model-from-Scratch","page":"Power System Model","title":"Model from Scratch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Alternatively, the model can be build from the scratch using built-in functions, for example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, base = 345e3)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Internal-Unit-System","page":"Power System Model","title":"Internal Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The PowerSystem composite type stores all electrical quantities in per-units and radians, except for the base values of power and voltages. The base power value is expressed in volt-amperes, while the base voltages are given in volts.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Base-Unit-Prefixes","page":"Power System Model","title":"Change Base Unit Prefixes","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As an example, if you execute the previous code snippet, you can retrieve the base power and base voltage values and units as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"By using the @base macro, users can change the prefixes of the base units. For instance, if the user wishes to convert base power and base voltage values to megavolt-amperes (MVA) and kilovolts (kV) respectively, they can execute the following macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, MVA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon execution of the macro, the base power and voltage values and units will be modified accordingly:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, by using the @base macro to modify the prefixes of the base units, users can convert the output data from various analyses to specific units with the desired prefixes.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#SaveModelManual","page":"Power System Model","title":"Save Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type has been created using one of the methods outlined in Build Model, the current data can be stored in the HDF5 file by using  savePowerSystem function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem(system; path = \"C:/matpower/case14.h5\", reference = \"IEEE 14-bus test case\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"All electrical quantities saved in the HDF5 file are in per-units and radians, except for base values for power and voltages, which are given in volt-amperes and volts. It is important to note that even if the user modifies the base units using the @base macro, the units will still be saved in the default settings.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBusManual","page":"Power System Model","title":"Add Bus","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We have the option to add buses to a loaded power system or to one created from scratch. As an illustration, we can initiate the PowerSystem type and then incorporate two buses by utilizing the addBus! function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.034907, base = 345e3)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this case, we have created two buses where the active power demanded by the consumer at Bus 1 is specified in per-units, which are the same units used to store electrical quantities:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In addition, it is worth noting that the base keyword is used to specify the base voltages, and its default input unit is in volts (V).","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, we set the bus voltage angle in radians for the Bus 2 to its initial value:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.voltage.angle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nWe recommend reading the documentation for the addBus! function, where all the keywords used in the function are explained in detail.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-for-Keywords","page":"Power System Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Typically, all keywords associated with electrical quantities are expected to be provided in per-units (pu) and radians (rad) by default, with the exception of base voltages, which should be specified in volts (V). However, users can choose to use different units than the default per-units and radians or modify the prefix of the base voltage unit by using macros such as the following:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\n@power(MW, MVAr, pu)\n@voltage(pu, deg, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This practical example showcases the customization approach. For keywords tied to active powers, the unit is set as megawatts (MW), while reactive powers employ megavolt-amperes reactive (MVAr). Apparent power, on the other hand, employs per-units (pu). As for keywords concerning voltage magnitude, per-units (pu) remain the choice, but voltage angle mandates degrees (deg). Lastly, the input unit for base voltage is elected to be kilovolts (kV). This unit configuration will be applied throughout subsequent function calls after the unit definitions are established.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Now we can create identical two buses as before using new system of units as follows:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 10.0, base = 345.0)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -2.0, base = 345.0)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As can be observed, electrical quantities will continue to be stored in per-units and radians format:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.bus.demand.active system.bus.voltage.angle]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The base voltage values will still be stored in volts (V) since we only changed the input unit prefix, and did not modify the internal unit prefix, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To modify the internal unit prefix, the following macro can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, VA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After executing this macro, the base voltage values will be stored in kilovolts (kV):","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBranchManual","page":"Power System Model","title":"Add Branch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After adding buses with unique labels, we can define branches between them. The branch cannot be added unless the buses are already defined, and the from and to keywords should correspond to the already defined bus labels. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit)  # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.2)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Here, we created the branch from Bus 1 to Bus 2 with following parameter:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to consult the documentation for the addBranch! function, which provides an explanation of all the keywords used in the function.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-for-Keywords-2","page":"Power System Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To use units other than per-units (pu) and radians (rad), macros can be employed to change the input units. For example, if the need arises to use ohms (Ω), the macros below can be employed:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@parameter(Ω, pu)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.2)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\",  reactance = 22.8528)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Still, all electrical quantities are stored in per-units, and the same branch as before is created, as shown in the following output:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is important to note that, when working with impedance and admittance values in ohms (Ω) and siemens (S) that are related to a transformer, the assignment must be based on the primary side of the transformer.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddGeneratorManual","page":"Power System Model","title":"Add Generator","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After defining the buses, generators can be added to the power system. Each generator must have a unique label, and the bus keyword should correspond to the unique label of the bus it is connected to. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\", active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the above code, we add the generator to the Bus 2, with active and reactive power outputs set to:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.generator.output.active system.generator.output.reactive]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similar to buses and branches, the input units can be changed to units other than per-units using different macros.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to refer to the documentation for the addGenerator! function, which explains all the keywords used in the function.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#LabelsManual","page":"Power System Model","title":"Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As we shown above, JuliaGrid mandates a distinctive label for every bus, branch, or generator. These labels are stored in dictionaries, functioning as pairs of strings and integers. The string signifies the exclusive label for the specific component, whereas the integer maintains an internal numbering of buses, branches, or generators.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In contrast to the simple labeling approach, JuliaGrid offers two additional methods for labeling. The choice of method depends on the specific needs and can potentially be more straightforward.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Integer-Based-Labeling","page":"Power System Model","title":"Integer-Based Labeling","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"If users prefer to utilize integers as labels in various functions, this is acceptable. However, it is important to note that despite using integers, these labels are still stored as strings. Let us take a look at the following illustration:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1)\naddBus!(system; label = 2, type = 1, angle = -0.2)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)\n\naddGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we create two buses labelled as 1 and 2. The branch is established between these two buses with a unique branch label of 1. Finally, the generator is connected to the bus labelled 2 and has its distinct label set to 1.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Automated-Labeling","page":"Power System Model","title":"Automated Labeling","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Users also possess the option to omit the label keyword, allowing JuliaGrid to independently allocate unique labels for buses, branches, or generators. In such instances, JuliaGrid employs an ordered set of incremental integers for labeling components. To illustrate, consider the subsequent example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; type = 3, active = 0.1)\naddBus!(system; type = 1, angle = -0.2)\n\naddBranch!(system; from = 1, to = 2, reactance = 0.12)\n\naddGenerator!(system; bus = 2, active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This example presents the same power system as the previous one. In the previous example, we used an ordered set of increasing integers for labels, which aligns with JuliaGrid's automatic labeling behaviour when the label keyword is omitted.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Retrieving-Labels","page":"Power System Model","title":"Retrieving Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, we will outline how users can retrieve stored labels. Let us consider the following power system creation:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 30)\naddBus!(system; label = 20)\naddBus!(system; label = 40)\n\naddBranch!(system; label = 100, from = 30, to = 20, reactance = 0.8)\naddBranch!(system; label = 200, from = 20, to = 40, reactance = 0.5)\n\naddGenerator!(system; label = 200, bus = 40)\naddGenerator!(system; label = 100, bus = 30)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For instance, the bus labels can be accessed using the variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid utilizes an unordered dictionary format for storing labels, which enhances performance. If the objective is to obtain labels in the same order as the bus definitions sequence, the subsequent code can be employed:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"label = collect(keys(sort(system.bus.label; byvalue = true)))","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Subsequently, users can match these labels with bus voltages, powers, and currents associated with buses. These values can be computed through various analyses available in JuliaGrid.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This approach can also be extended to branch and generator labels by making use of the variables present within the PowerSystem composite type, namely system.branch.label or system.generator.label. These variables facilitate obtaining sequences of labels associated with these particular components of the power system.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Moreover, the from and to keywords associated with branches are stored based on internally assigned numerical values linked to bus labels. These values are stored in the variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.branch.layout.from system.branch.layout.to]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To recover the original from and to labels, you can utilize the following method:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[label[system.branch.layout.from] label[system.branch.layout.to]]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, the bus keywords related to generators are saved based on internally assigned numerical values corresponding to bus labels and can be accessed using:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.layout.bus","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To recover the original bus labels, you can utilize the following method:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"label[system.generator.layout.bus]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddTemplatesManual","page":"Power System Model","title":"Add Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The functions addBus!, addBranch!, and addGenerator! are used to add bus, branch, and generator to the power system, respectively. If certain keywords are not specified, default values are assigned to some parameters.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Default-Keyword-Values","page":"Power System Model","title":"Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Concerning the addBus! function, in case the type keyword is not supplied, the bus type is automatically configured as a demand bus, with type = 1 as its value. The initial bus voltage magnitude is set to magnitude = 1.0 per-unit, while the base voltage is set to base = 138e3 volts. These predefined values hold significant importance to avert potential issues during algorithm execution, such as encountering a singular Jacobian when magnitude = 0.0.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Transitioning to the addBranch! function, the default status is set to status = 1, indicating the branch's operational status as in-service. Moreover, the transformer's off-nominal turns ratio assumes a value of turnsRatio = 1.0, accompanied by a shiftAngle = 0.0, which collectively establish the line configuration using these standard settings. Additionally, the type keyword defaults to type = 1, aligning with a specific rating category.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, the addGenerator! function designates an operational generator by employing status = 1, and it sets magnitude = 1.0 per-unit, denoting the desired voltage magnitude setpoint.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The remaining parameters are initialized with default values of zero.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Default-Keyword-Values","page":"Power System Model","title":"Change Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In JuliaGrid, users are allowed to modify default values and assign non-zero values to other keywords using the @bus, @branch, and @generator macros. These macros create bus, branch, and generator templates that are used every time the addBus!, addBranch!, and addGenerator! functions are called. For instance, the code block shows an example of creating bus, branch, and generator templates with customized default values:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 0.1)\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.5)\n\n@branch(reactance = 0.12)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\")\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.06)\n\n@generator(magnitude = 1.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 50)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 1\", active = 20)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This code example involves two uses of the addBus! and addBranch! functions. In the first use, the functions rely on the default values set by the templates created with the @bus and @branch macros. In contrast, the second use passes specific values that match the keywords used in the templates. As a result, the templates are ignored:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.layout.type\n[system.bus.demand.active system.branch.parameter.reactance]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the given example, the @generator macro is utilized instead of repeatedly specifying the magnitude keyword in the addGenerator! function. This macro creates a generator template with a default value for magnitude, which is automatically applied every time the addGenerator! function is called. Therefore, it eliminates the requirement to set the magnitude value for each individual generator:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.voltage.magnitude","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-for-Keywords-3","page":"Power System Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid requires users to specify electrical quantity-related keywords in per-units (pu) and radians (rad) by default. However, it provides macros, such as @power, that allow users to specify other units:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\n@power(MW, MVAr, MVA)\n\n@bus(active = 100, reactive = 200)\naddBus!(system; label = \"Bus 1\")\n\n@power(pu, pu, pu)\n\naddBus!(system; label = \"Bus 2\", active = 0.5)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we create the bus template and one bus using SI power units, and then we switch to per-units and add the second bus. It is important to note that once the template is defined in any unit system, it remains valid regardless of subsequent unit system changes. The resulting power values are:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.bus.demand.active system.bus.demand.reactive]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Thus, JuliaGrid automatically tracks the unit system used to create templates and provides the appropriate conversion to per-units and radians. Even if the user switches to a different unit system later on, the previously defined template will still be valid.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Multiple-Templates","page":"Power System Model","title":"Multiple Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the case of calling the @bus, @branch, or @generator macros multiple times, the provided keywords and values will be combined into a single template for the corresponding component (bus, branch, or generator), which will be used for generating the component.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Reset-Templates","page":"Power System Model","title":"Reset Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To reset the bus, branch, and generator templates to their default settings, users can utilize the following macros:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(bus)\n@default(branch)\n@default(generator)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, users can reset all templates for the bus, branch, and generator components using the macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(template)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ACDCModelManual","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"When we constructed the power system, we can create an AC and/or DC model, which include vectors and matrices related to the power system's topology and parameters. The following code snippet demonstrates this:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05)\naddBus!(system; label = \"Bus 3\", type = 1, susceptance = 0.05)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.008, reactance = 0.05)\n\nacModel!(system)\ndcModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIn every case mentioned in the documentation, we specifically mention these functions by their names, even though it is not mandatory. When a user triggers any of the different AC or DC analyses and if the AC or DC model has not been established using the acModel! or dcModel! function, the corresponding model will be automatically generated upon initiation. Additionally, all the associated fields will be populated.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The nodal matrices are one of the components of both the AC and DC models and are stored in the variables:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.dc.nodalMatrix\nsystem.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nThe AC model is used for performing AC power flow, AC optimal power flow, nonlinear state estimation, or state estimation with PMUs, whereas the DC model is essential for various DC or linear analyses. Consequently, once these models are developed, they can be applied to various types of simulations. We recommend that the reader refer to the tutorial on AC and DC models.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#New-Branch-Triggers-Model-Update","page":"Power System Model","title":"New Branch Triggers Model Update","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can execute the acModel! and dcModel! functions after defining the final number of buses, and each new branch added will trigger an update of the AC and DC vectors and matrices. Here is an example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05)\naddBus!(system; label = \"Bus 3\", type = 1, susceptance = 0.05)\n\nacModel!(system)\ndcModel!(system)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.008, reactance = 0.05)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, the nodal matrix in the DC framework has the same values as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.dc.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIt is not fully recommended to create AC and DC models before adding a large number of branches if the execution time of functions is important. Instead, triggering updates to the AC and DC models using the addBranch! function is useful for power systems that require the addition of several branches. This update avoids the need to recreate vectors and matrices from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#New-Bus-Triggers-Model-Erasure","page":"Power System Model","title":"New Bus Triggers Model Erasure","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The AC and DC models must be defined when a finite number of buses are defined, otherwise, adding a new bus will delete them. For example, if we attempt to add a new bus to the PowerSystem type that was previously created, the current AC and DC models will be completely erased:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!(system; label = \"Bus 4\", type = 2)\nsystem.model.dc.nodalMatrix\nsystem.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeDemandPowerManual","page":"Power System Model","title":"Change Demand Power","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To modify or introduce new power demand at a specific bus, you can utilize the demandBus! function. This function directly alters the bus.demand field within the PowerSystem type. For instance, if we want to include an active power demand at Bus 1 after the bus has been created, we can employ the subsequent code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, susceptance = 2.1)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\ndemandBus!(system; lable = \"Bus 1\", active = 0.5)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After executing this code, we can observe the following update:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeShuntElementsManual","page":"Power System Model","title":"Change Shunt Elements","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To modify or add new shunt element at bus, you can use the shuntBus! function. If the AC and DC models have not yet been created, you can directly modify the bus.shunt field of the PowerSystem type to change their values. However, if AC and DC models have been created, using the shuntBus! function will automatically update all relevant fields in these models. This avoids the need to recreate the AC and DC models from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, it is recommended to use this function after executing the acModel! and dcModel! functions. For example, let us start by creating the AC model:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, susceptance = 2.1)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Then, the nodal matrix is given as:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, to add a shunt element at Bus 1 with a specified conductance value and modify the susceptance value of the shunt element at Bus 2, we can execute the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"shuntBus!(system; label = \"Bus 1\", conductance = 0.04)\nshuntBus!(system; label = \"Bus 2\", susceptance = 0.25)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon examining the nodal matrix, it can be inferred that the shuntBus! function automatically updates this matrix:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeBranchStatusManual","page":"Power System Model","title":"Change Branch Status","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can use the statusBranch! function to switch the branch's status between in-service and out-of-service. If the AC and DC models are not created, the function will perform the same operation as accessing the status variable of the branch.layout field and changing the value from 1 to 0 or vice versa. However, if the AC and DC models are created, the function will trigger updates to all affected vectors and matrices.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, it is recommended to use this function after executing the acModel! and dcModel! functions. The following code demonstrates the usage of the statusBranch! function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\naddBus!(system; label = 3)\n\naddBranch!(system; label = \"Branch 1\", from = 1, to = 2, reactance = 0.12, shiftAngle = 0.175)\naddBranch!(system; label = \"Branch 2\", from = 2, to = 3, resistance = 0.008, reactance = 0.05)\n\nacModel!(system)\ndcModel!(system)\n\nstatusBranch!(system; label = \"Branch 1\", status = 0)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This code sets the Branch 1 to out-of-service. For example, the nodal matrix in the DC framework has the following form:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.dc.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Drop-Zeros","page":"Power System Model","title":"Drop Zeros","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After the execution of the statusBranch! function, the nodal matrices will contain zeros, as demonstrated in the code example. If needed, the user can remove these zeros by using the dropzeros! function, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using SparseArrays\ndropzeros!(system.model.dc.nodalMatrix)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt should be noted that in simulations conducted with the JuliaGrid package, the accuracy of the results will not be affected by leaving zeros.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeBranchParametersManual","page":"Power System Model","title":"Change Branch Parameters","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The parameterBranch! function is used to modify the parameters of a branch, which include resistance, reactance, conductance, susceptance, turns ratio, and shift angle. Although one can modify these parameters by accessing the corresponding variables within the branch.parameter field, using the parameterBranch! function will update all affected vectors and matrices, provided that the AC and DC models have been created.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, this function is useful after executing the acModel! and dcModel! functions. For example, let us start by creating the AC model:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\n\naddBranch!(system; label = \"Branch 1\", from = 1, to = 2, reactance = 0.12, shiftAngle = 0.175)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Then the nodal matrix is:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can modify the reactance value of the branch and add resistance to it while keeping the shift angle constant, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"parameterBranch!(system; label = \"Branch 1\", reactance = 0.10, resistance = 0.02)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Next, we can observe that the nodal matrix is updated automatically by the function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeGeneratorStatusManual","page":"Power System Model","title":"Change Generator Status","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The statusGenerator! function can be used to change the status of a generator between in-service and out-of-service. It is important to always use this function when changing the status of a previously defined generator. Directly accessing the corresponding variable to change the status can result in incorrect results because it will not affect the variable that holds the active and reactive powers generated by the generators that supply buses.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, using the function is the safe way to put a generator in or out of service. Let us create the power system with two generators connected to the same bus:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\", active = 0.4)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.6)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To check the the powers being generated by the generators that supply the buses and outputs of the generators, you can use:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.supply.active\nsystem.generator.output.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To put the second generator out-of-service, you can use the function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"statusGenerator!(system; label = \"Generator 2\", status = 0)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Here, we can see the updated variables, where the second generator has been taken out of the system:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.supply.active\nsystem.generator.output.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is worth noting that even if the generator is out-of-service, the output.active variable still reflects its production. This is because it allows the same generator to be put back in-service with the same output power as before.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeGeneratorOutputsManual","page":"Power System Model","title":"Change Generator Outputs","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The function outputGenerator! can be utilized to change the output of a generator. This function provides the safe way to modify the active and reactive powers produced by the previously defined generator.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To demonstrate how to use this function, we can use the example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\", active = 0.5, reactive = 0.1)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.5, reactive = 0.1)\n\noutputGenerator!(system; label = \"Generator 1\", active = 1.0)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we increase the output active power of the Generator 1, and the results can be observed below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.output.active\nsystem.bus.supply.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is worth noting that the output reactive power of the generators remains the same:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.output.reactive\nsystem.bus.supply.reactive","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddActiveReactiveCostsManual","page":"Power System Model","title":"Add Active and Reactive Costs","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The addActiveCost! and addReactiveCost! functions are responsible for adding costs for the active and reactive power produced by the corresponding generator. These costs are added only if the corresponding generator is defined.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The addActiveCost! function will be used consistently throughout this manual. The same steps can be applied for the addReactiveCost! function. To begin, let us create an example of the power system using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\", active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Polynomial-Cost","page":"Power System Model","title":"Polynomial Cost","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Let us define a quadratic polynomial cost function for the active power produced by the Generator 1 using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!(system; label = \"Generator 1\", model = 2, polynomial = [1100.0; 500.0; 150.0])","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In essence, what we have accomplished is the establishment of a cost function depicted as f(P_textg1) = 1100 P_textg1^2 + 500 P_textg1 + 150 through the code provided.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As previously, the default input units are related with per-units (pu), and the coefficients of the cost function have units of currency/pu²hr for 1100, currency/puhr for 500, and currency/hr for 150. Hence, the coefficients are stored exactly as entered:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.polynomial","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"By setting model = 2 in the function, we specify that the quadratic polynomial cost is being used for the corresponding generator. This can be particularly useful if we have also defined a piecewise linear cost function for the same generator. In such cases, we can choose between these two cost functions depending on our simulation requirements.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Piecewise-Linear-Cost","page":"Power System Model","title":"Piecewise Linear Cost","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can also create a piecewise linear cost function for the active power of the same generator by using:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!(system; label = \"Generator 1\", piecewise =  [0.11 12.3; 0.15 16.8; 0.18 18.1])\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this case, the first column specifies the output active powers of the generator in per-units, while the second column specifies the corresponding costs for the specified active power in currency/hr. Thus, the data is stored exactly as entered:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.piecewise","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"If we want to use this piecewise linear cost function instead of the polynomial cost function that was defined earlier, we need to set model = 1.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-for-Keywords-4","page":"Power System Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Changing input units from per-units (pu) can be particularly useful since cost functions are usually related to SI units of powers. To demonstrate this, let us set active powers in megawatts (MW) while keeping the rest of the units in per-units:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@power(MW, pu, pu)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\", active = 50, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Now, we can add the quadratic polynomial function using megawatts:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!(system; label = \"Generator 1\", model = 2, polynomial = [0.11; 5.0; 150.0])","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After inspecting the resulting cost data, we can see that it is the same as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.polynomial","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, we can define the linear piecewise cost:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!(system; label = \"Generator 1\", piecewise =  [11.0 12.3; 15.0 16.8; 18.0 18.1])\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon inspection, we can see that the stored data is the same as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.piecewise","category":"page"},{"location":"#JuliaGrid","page":"Introduction","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver, and allows a variety of display and manipulation options.","category":"page"},{"location":"manual/acPowerFlow/#ACPowerFlowManual","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To perform the AC power flow analysis, you will first need the PowerSystem composite type that has been created with the ac model. Then, you can create the ACPowerFlow abstract type using one of the following functions:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"newtonRaphson,\nfastNewtonRaphsonBX,\nfastNewtonRaphsonXB,\ngaussSeidel.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"These functions will set up the AC power flow framework. To obtain bus voltages and solve the power flow problem, you can use the following functions:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"mismatch!,\nsolve!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After obtaining the AC power flow solution, JuliaGrid offers post-processing analysis functions for calculating powers and currents associated with buses, branches, or generators:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power!,\ncurrent!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Furthermore, there are specialized functions dedicated to calculating specific types of powers related to particular buses, branches, or generators:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"injectionPower,\nsupplyPower,\nshuntPower,\nfromPower,\ntoPower,\nseriesPower,\nchargingPower,\ngeneratorPower.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Likewise, there are specialized functions dedicated to calculating specific types of currents related to particular buses or branches:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"injectionCurrent,\nfromCurrent,\ntoCurrent,\nseriesCurrent.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Additionally, the package provides two functions for reactive power limit validation of generators and adjusting the voltage angles to match an arbitrary bus angle:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"reactiveLimit!,\nadjustAngle!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#BusTypeModificationManual","page":"AC Power Flow","title":"Bus Type Modification","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Depending on how the system is constructed, the types of buses that are initially set are checked and can be changed during the initialization process, using one of the available functions such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel. Assuming the Newton-Raphson method has been chosen, to explain the details, we can observe a power system with only buses and generators. The following code snippet can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2)\naddBus!(system; label = \"Bus 3\", type = 2)\n\naddGenerator!(system; bus = \"Bus 2\")\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Initially, the Bus 1 is set as the slack bus (type = 3), and the Bus 2 and Bus 3 are generator buses (type = 2). However, the Bus 3 does not have a generator, and JuliaGrid considers this a mistake and changes the corresponding bus to a demand bus (type = 1).","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After this step, JuliaGrid verifies the slack bus. Initially, the slack bus (type = 3) corresponds to Bus 1, but since it does not have an in-service generator connected to it, JuliaGrid recognizes it as an error. Therefore, JuliaGrid assigns a new slack bus from the available generator buses (type = 2) that have connected in-service generators. In this specific example, Bus 2 becomes the new slack bus.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid\n@default(unit)\n@default(template)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2)\naddBus!(system; label = \"Bus 3\", type = 2)\n\naddGenerator!(system; bus = \"Bus 2\")\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As a result, we can observe the updated array of bus types within the defined set of buses:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[collect(keys(sort(system.bus.label; byvalue = true))) system.bus.layout.type]","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Note that, if a bus is initially defined as the demand bus (type = 1) and later a generator is added to it, the bus type will not be changed to the generator bus (type = 2). Instead, it will remain as a demand bus.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThe type of only those buses that are defined as generator buses (type = 2) but do not have a connected in-service generator will be changed to demand buses (type = 1).The bus that is defined as the slack bus (type = 3) but lacks a connected in-service generator will have its type changed to the demand bus (type = 1). Meanwhile, the first generator bus (type = 2) with an in-service generator connected to it will be assigned as the new slack bus (type = 3).","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#SetupStartingVoltagesManual","page":"AC Power Flow","title":"Setup Starting Voltages","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To begin analysing the AC power flow in JuliaGrid, we must first establish the PowerSystem composite type and define the AC model by calling the acModel! function. Once the power system is set up, we can select one of the available methods for solving the AC power flow problem, such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel. Assuming we have selected the Newton-Raphson method, we can use the following code snippet:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.0, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, magnitude = 0.9, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 2, magnitude = 0.8, angle = -0.2)\n\naddGenerator!(system; bus = \"Bus 1\", magnitude = 1.3)\naddGenerator!(system; bus = \"Bus 2\", magnitude = 1.1)\naddGenerator!(system; bus = \"Bus 3\", magnitude = 1.2)\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Here, in this code snippet, the function newtonRaphson generates starting voltage vectors in polar coordinates, where the magnitudes and angles are constructed as:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[analysis.voltage.magnitude analysis.voltage.angle]","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The starting voltage magnitudes are determined by a combination of the initial values specified within the buses and the setpoints provided within the generators:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[system.bus.voltage.magnitude system.generator.voltage.magnitude]","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"On the other hand, the starting values for the voltage angles are defined based on the initial values given within the buses:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"system.bus.voltage.angle","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThe rule governing the specification of starting voltage magnitudes is simple. If a bus has an in-service generator and is declared the generator bus (type = 2), then the starting voltage magnitudes are specified using the setpoint provided within the generator. This is because the generator bus has known values of voltage magnitude that are specified within the generator.On the other hand, the slack bus (type = 3) always requires an in-service generator. The starting value of the voltage magnitude at the slack bus is determined exclusively by the setpoints provided within the generators connected to it. This is a result of the slack bus having a known voltage magnitude that must be maintained.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Custom-Starting-Voltages","page":"AC Power Flow","title":"Custom Starting Voltages","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This method of specifying starting values has a significant advantage in that it allows the user to easily change the starting voltage magnitudes and angles, which play a crucial role in iterative methods. For instance, suppose we define our power system as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.0, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, magnitude = 0.9, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 2, magnitude = 0.8, angle = -0.2)\n\naddGenerator!(system; bus = \"Bus 1\", magnitude = 1.1)\naddGenerator!(system; bus = \"Bus 3\", magnitude = 1.2)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Now, the user can initiate a \"flat start\" without interfering with the input data. This can be easily done as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for i = 1:system.bus.number\n    system.bus.voltage.magnitude[i] = 1.0\n    system.bus.voltage.angle[i] = 0.0\nend\n\nanalysis = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The starting voltage values are:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[analysis.voltage.magnitude analysis.voltage.angle]","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Consequently, when using the Newton-Raphson method, the iteration begins with a fixed set of voltage magnitude values that remain constant throughout the process. The remaining values are initialized as part of the \"flat start\" approach.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACPowerFlowSolutionManual","page":"AC Power Flow","title":"Power Flow Solution","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To solve the AC power flow problem using JuliaGrid, we first need to create the PowerSystem composite type and define the AC model by calling the acModel! function. Here is an example:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", resistance = 0.01, reactance = 0.05)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 3\", resistance = 0.02, reactance = 0.01)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.01, reactance = 0.20)\n\naddGenerator!(system; bus = \"Bus 1\", active = 3.2, magnitude = 1.1)\naddGenerator!(system; bus = \"Bus 2\", active = 3.2, magnitude = 1.2)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Once the AC model is defined, we can choose the method to solve the power flow problem. JuliaGrid provides four methods: newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, and gaussSeidel. For example, to use the Newton-Raphson method to solve the power flow problem, we can call the newtonRaphson function as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This function sets up the desired method for an iterative process based on two functions: mismatch! and solve!. The mismatch! function calculates the active and reactive power injection mismatches using the given voltage magnitudes and angles, while solve! computes the voltage magnitudes and angles.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To perform an iterative process with the Newton-Raphson or fast Newton-Raphson methods in JuliaGrid, the mismatch! function must be included inside the iteration loop. For instance:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:100\n    mismatch!(system, analysis)\n    solve!(system, analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Upon completion of the AC power flow analysis, the solution is conveyed through the bus voltage magnitudes and angles. Here are the values corresponding to the buses:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"label = collect(keys(sort(system.bus.label; byvalue = true)));\n\n[label analysis.voltage.magnitude analysis.voltage.angle]","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In contrast, the iterative loop of the Gauss-Seidel method does not require the mismatch! function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = gaussSeidel(system)\nfor iteration = 1:100\n    solve!(system, analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In these examples, the algorithms run until the specified number of iterations is reached.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nWe recommend that the reader refer to the tutorial on AC power flow analysis, where we explain the implementation of the methods and algorithm structures in detail.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Breaking-the-Iterative-Process","page":"AC Power Flow","title":"Breaking the Iterative Process","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"You can terminate the iterative process using the mismatch! function, which is why mismatches are computed separately. The following code shows an example of how to use the the function to break out of the iteration loop:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The mismatch! function returns the maximum absolute values of active and reactive power injection mismatches, which are commonly used as a convergence criterion in iterative AC power flow algorithms. Note that the function can also be used to terminate the loop when using the Gauss-Seidel method, even though it is not required.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"tip: Tip\nTo ensure an accurate count of iterations, it is important for the user to place the iteration counter after the condition expressions within the if construct. Counting the iterations before this point can result in an incorrect number of iterations, as it leads to an additional iteration being performed.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACPowerCurrentAnalysisManual","page":"AC Power Flow","title":"Power and Current Analysis","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After obtaining the solution from the AC power flow, we can calculate various electrical quantities related to buses, branches, and generators using the power! and current! functions. For instance, let us consider the power system for which we obtained the AC power flow solution:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, susceptance = 0.03)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.5, conductance = 0.02)\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can now utilize the provided functions to compute powers and currents. The following functions can be used for this purpose:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power!(system, analysis)\ncurrent!(system, analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"For instance, if we want to show the active power injections at each bus and the current flow angles at each \"to\" bus end of the branch, we can employ the following code:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[collect(keys(sort(system.bus.label; byvalue = true))) analysis.power.injection.active]\n[collect(keys(sort(system.branch.label; byvalue = true))) analysis.current.to.angle]\n","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nTo better understand the powers associated with buses, branches and generators that are calculated by the power! and current! functions, we suggest referring to the tutorials on AC power flow analysis.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate specific quantities for particular components rather than calculating powers or currents for all components, users can make use of the provided functions below.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-Injection","page":"AC Power Flow","title":"Active and Reactive Power Injection","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = injectionPower(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-Injection-from-Generators","page":"AC Power Flow","title":"Active and Reactive Power Injection from Generators","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = supplyPower(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-at-Shunt-Element","page":"AC Power Flow","title":"Active and Reactive Power at Shunt Element","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = shuntPower(system, analysis; label = \"Bus 3\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-Flow","page":"AC Power Flow","title":"Active and Reactive Power Flow","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, we can compute the active and reactive power flow at both the \"from\" and \"to\" bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = fromPower(system, analysis; label = \"Branch 2\")\nactive, reactive = toPower(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-at-Charging-Admittances","page":"AC Power Flow","title":"Active and Reactive Power at Charging Admittances","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = chargingPower(system, analysis; label = \"Branch 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Active powers indicate active losses within the branch's charging or shunt admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-at-Series-Impedance","page":"AC Power Flow","title":"Active and Reactive Power at Series Impedance","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power across the series impedance of the particular branch, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = seriesPower(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance's inductive characteristics.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Generator-Active-and-Reactive-Power-Output","page":"AC Power Flow","title":"Generator Active and Reactive Power Output","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can compute the active and reactive power output of a particular generator using the function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = generatorPower(system, analysis; label = \"Generator 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Current-Injection","page":"AC Power Flow","title":"Current Injection","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the current injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"magnitude, angle = injectionCurrent(system, analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Current-Flow","page":"AC Power Flow","title":"Current Flow","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can compute the current flow at both the \"from\" and \"to\" bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"magnitude, angle = fromCurrent(system, analysis; label = \"Branch 2\")\nmagnitude, angle = toCurrent(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Current-Through-Series-Impedance","page":"AC Power Flow","title":"Current Through Series Impedance","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the current passing through the series impedance of the branch in the direction from the \"from\" bus end to the \"to\" bus end, you can use the following function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"magnitude, angle = seriesCurrent(system, analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#OptimalPowerFlowAPI","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"For further information on this topic, please see the AC Optimal Power Flow or DC Optimal Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for optimal power flow analysis.","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Build-Model","page":"Optimal Power Flow","title":"Build Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"acOptimalPowerFlow\ndcOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#Solve-Optimal-Power-Flow","page":"Optimal Power Flow","title":"Solve Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!","category":"page"},{"location":"api/optimalPowerFlow/#Power-Analysis","page":"Optimal Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"power!\npowerInjection\npowerSupply\npowerShunt\npowerFrom\npowerTo\npowerCharging\npowerSeries","category":"page"},{"location":"api/optimalPowerFlow/#Current-Analysis","page":"Optimal Power Flow","title":"Current Analysis","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"current!\ncurrentInjection\ncurrentFrom\ncurrentTo\ncurrentSeries","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Build-Model-2","page":"Optimal Power Flow","title":"Build Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"acOptimalPowerFlow\ndcOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.acOptimalPowerFlow","text":"acOptimalPowerFlow(system::PowerSystem, optimizer; bridge, name, balance, limit,\n    rating, capability)\n\nThe function takes the PowerSystem composite type as input to establish the structure for solving the AC optimal power flow. The optimizer argument is also required to create and solve the optimization problem. If the ac field within the PowerSystem composite type has not been created, the function will initiate an update automatically.\n\nKeywords\n\nJuliaGrid offers the ability to manipulate the jump model based on the guidelines provided in the JuMP documentation. However, certain configurations may require different method calls, such as:\n\nbridge: used to manage the bridging mechanism;\nname: used to manage the creation of string names.\n\nMoreover, we have included keywords that regulate the usage of different types of constraints:\n\nbalance: controls the equality constraints that relate to the active and reactive power balance equations;\nlimit: controls the inequality constraints that relate to the voltage magnitude and angle differences between buses;\nrating: controls the inequality constraints that relate to the long-term rating of branches;\ncapability: controls the inequality constraints that relate to the active and reactive power generator outputs.\n\nBy default, all of these keywords are set to true and are of the Bool type.\n\nJuMP\n\nThe JuliaGrid builds the AC optimal power flow around the JuMP package and supports commonly used solvers. For more information, refer to the JuMP documenatation.\n\nReturns\n\nThe function returns an instance of the ACOptimalPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\njump: the JuMP model;\nconstraint: holds the constraint references to the JuMP model.\n\nExamples\n\nCreate the complete AC optimal power flow model:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\n\nCreate the AC optimal power flow model without rating constraints:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer; rating = false)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.dcOptimalPowerFlow","text":"dcOptimalPowerFlow(system::PowerSystem, optimizer; bridge, name, balance, limit,\n    rating, capability)\n\nThe function takes the PowerSystem composite type as input to establish the structure for solving the DC optimal power flow. The optimizer argument is also required to create and solve the optimization problem. If the dc field within the PowerSystem composite type has not been created, the function will initiate an update automatically.\n\nKeywords\n\nJuliaGrid offers the ability to manipulate the jump model based on the guidelines provided in the JuMP documentation. However, certain configurations may require different method calls, such as:\n\nbridge: used to manage the bridging mechanism;\nname: used to manage the creation of string names.\n\nMoreover, we have included keywords that regulate the usage of different types of constraints:\n\nbalance: controls the equality constraints that relate to the active power balance equations;\nlimit: controls the inequality constraints that relate to the voltage angle differences between buses;\nrating: controls the inequality constraints that relate to the long-term rating of branches;\ncapability: controls the inequality constraints that relate to the active power generator outputs.\n\nBy default, all of these keywords are set to true and are of the Bool type.\n\nJuMP\n\nThe JuliaGrid builds the DC optimal power flow around the JuMP package and supports commonly used solvers. For more information, refer to the JuMP documenatation.\n\nReturns\n\nThe function returns an instance of the DCOptimalPowerFlow type, which includes the following fields:\n\nvoltage: the variable allocated to store the bus voltage angle,\npower: the variable allocated to store the active powers,\njump: the JuMP model,\nconstraint: holds the constraint references to the JuMP model.\n\nExamples\n\nCreate the complete DC optimal power flow model:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\n\nCreate the DC optimal power flow model without rating constraints:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer; rating = false)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Solve-Optimal-Power-Flow-2","page":"Optimal Power Flow","title":"Solve Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!(::PowerSystem, ::ACOptimalPowerFlow)\nsolve!(::PowerSystem, ::DCOptimalPowerFlow)","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::ACOptimalPowerFlow)\n\nThe function finds the AC optimal power flow solution and calculate the bus voltage magnitudes and angles, and output active and reactive powers of each generators.\n\nThe calculated voltage magnitudes and angles and active and reactive powers are then stored in the variables of the voltage and power fields of the ACOptimalPowerFlow composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::DCOptimalPowerFlow)\n\nThe function finds the DC optimal power flow solution and calculate the bus voltage angles and output active powers of the generators.\n\nThe calculated voltage angles and active powers are then stored in the angle variable of the voltage field and the generator variable of the power field.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"}]
}
