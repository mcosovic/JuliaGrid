var documenterSearchIndex = {"docs":
[{"location":"apireference/powerFlow/#powerFlowAnalysis","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"section"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"The calculation of bus voltages is essential to solving the power flow problem. The composite type PowerSystem, which includes bus, branch, and generator fields, is required to obtain a solution. Additionally, depending on the type of power flow used, either acModel or dcModel must be used.","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"After creating the composite type PowerSystem, the next step is to create the composite type Result, which has fields bus, branch, generator, and algorithm. In the DC power flow, Result is created when determining the bus voltage angles using the dcPowerFlow() function. On the other hand, the AC power flow requires the iterative method to be initialized, which is when the composite type Result is created using one of the following functions:","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"newtonRaphson()\nfastNewtonRaphsonBX()\nfastNewtonRaphsonXB()\ngaussSeidel().","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"To calculate bus voltages, the appropriate function can be used depending on the type of power flow and method selected. The following functions are available:","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"newtonRaphson!()\nfastNewtonRaphson!()\ngaussSeidel!()\ndcPowerFlow().","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"Note that when solving the AC power flow problem, the methods should be called inside a loop to simulate an iterative process.","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"JuliaGrid offers a set of post-processing analysis functions for calculating powers, losses, and currents associated with buses, branches, or generators after obtaining AC or DC power flow solutions:","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"bus!()\nbranch!()\ngenerator!().","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"It's important to note that complex currents are stored in the polar coordinate system, while complex powers are stored in the rectangular coordinate system within JuliaGrid.","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"The JuliaGrid package provides two additional functions. One function validates the reactive power limits of generators once the AC power flow solution has been computed. The other function adjusts the voltage angles to match the angle of an arbitrary slack bus:","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"reactivePowerLimit!()\nadjustVoltageAngle!().","category":"page"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"page"},{"location":"apireference/powerFlow/#Newton-Raphson-Method","page":"Power Flow Analysis","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"newtonRaphson\nnewtonRaphson!","category":"page"},{"location":"apireference/powerFlow/#JuliaGrid.newtonRaphson","page":"Power Flow Analysis","title":"JuliaGrid.newtonRaphson","text":"The function accepts the PowerSystem composite type as input, uses it to set up the  Newton-Raphson method, and then produces the Result composite type as output.\n\nnewtonRaphson(system::PowerSystem)\n\nThe algorithm field of the Result type is updated during the function's execution.\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/#JuliaGrid.newtonRaphson!","page":"Power Flow Analysis","title":"JuliaGrid.newtonRaphson!","text":"The function updates the bus.voltage and algorithm fields of the Result composite  type by computing the magnitudes and angles of bus voltages using the Newton-Raphson  method.\n\nnewtonRaphson!(system::PowerSystem, result::Result)\n\nIt is intended to be used within a for loop as it performs only one iteration of the  Newton-Raphson method. It is recommended that the reader peruses the section on the  Newton-Raphson Method to gain a comprehensive understanding  of its implementation, including all relevant data.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"page"},{"location":"apireference/powerFlow/#Fast-Newton-Raphson-Method","page":"Power Flow Analysis","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"fastNewtonRaphsonBX\nfastNewtonRaphsonXB\nfastNewtonRaphson!","category":"page"},{"location":"apireference/powerFlow/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow Analysis","title":"JuliaGrid.fastNewtonRaphsonBX","text":"The function accepts the PowerSystem composite type as input, uses it to set up the  fast Newton-Raphson method of version BX, and then produces the Result composite type as  output.\n\nfastNewtonRaphsonBX(system::PowerSystem)\n\nThe algorithm field of the Result type is updated during the function's execution.\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow Analysis","title":"JuliaGrid.fastNewtonRaphsonXB","text":"The function accepts the PowerSystem composite type as input, uses it to set up the  fast Newton-Raphson method of version XB, and then produces the Result composite type as  output.\n\nfastNewtonRaphsonXB(system::PowerSystem)\n\nThe algorithm field of the Result type is updated during the function's execution.\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/#JuliaGrid.fastNewtonRaphson!","page":"Power Flow Analysis","title":"JuliaGrid.fastNewtonRaphson!","text":"The function updates the bus.voltage and algorithm fields of the Result composite  type by computing the magnitudes and angles of bus voltages using the fast Newton-Raphson  method.\n\nfastNewtonRaphson!(system::PowerSystem, result::Result)\n\nIt is intended to be used within a for loop as it performs only one iteration of the  fast Newton-Raphson method. It is recommended that the reader peruses the section on the  Fast Newton-Raphson Method to gain a comprehensive  understanding of its implementation, including all relevant data.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = fastNewtonRaphsonBX(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:100\n    fastNewtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"page"},{"location":"apireference/powerFlow/#Gauss-Seidel-Method","page":"Power Flow Analysis","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"gaussSeidel\ngaussSeidel!","category":"page"},{"location":"apireference/powerFlow/#JuliaGrid.gaussSeidel","page":"Power Flow Analysis","title":"JuliaGrid.gaussSeidel","text":"The function accepts the PowerSystem composite type as input, uses it to set up the  Gauss-Seidel method, and then produces the Result composite type as output.\n\ngaussSeidel(system::PowerSystem)\n\nThe algorithm field of the Result type is updated during the function's execution.  \n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/#JuliaGrid.gaussSeidel!","page":"Power Flow Analysis","title":"JuliaGrid.gaussSeidel!","text":"The function updates the bus.voltage and algorithm fields of the Result composite  type by computing the magnitudes and angles of bus voltages using the Gauss-Seidel method.\n\ngaussSeidel!(system::PowerSystem, result::Result)\n\nIt is intended to be used within a for loop as it performs only one iteration of the  Gauss-Seidel method. It is recommended that the reader peruses the section on the  Gauss-Seidel Method to gain a comprehensive understanding of  its implementation, including all relevant data.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:1000\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"page"},{"location":"apireference/powerFlow/#DC-Power-Flow-Solution","page":"Power Flow Analysis","title":"DC Power Flow Solution","text":"","category":"section"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"dcPowerFlow","category":"page"},{"location":"apireference/powerFlow/#JuliaGrid.dcPowerFlow","page":"Power Flow Analysis","title":"JuliaGrid.dcPowerFlow","text":"The function takes a PowerSystem composite type as input and uses it to solve the DC  power flow problem by calculating the voltage angles for each bus. \n\ndcPowerFlow(system::PowerSystem)\n\nThe function returns a composite type Result as output, which includes updated  bus.voltage.angle and algorithm fields. These fields are modified during the execution  of the function. It is recommended that the reader peruses the section on the  DC Power Flow Solution to gain a comprehensive  understanding of its implementation, including all relevant data.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"page"},{"location":"apireference/powerFlow/#Post-processing-Analysis","page":"Power Flow Analysis","title":"Post-processing Analysis","text":"","category":"section"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"bus!\nbranch!\ngenerator!","category":"page"},{"location":"apireference/powerFlow/#JuliaGrid.bus!","page":"Power Flow Analysis","title":"JuliaGrid.bus!","text":"This function calculates the powers and currents associated with buses.\n\nbus!(system::PowerSystem, result::Result)\n\nAfter the function is executed, the bus field within the Result type gets updated. To  gain a comprehensive understanding of the equations used, along with all relevant data, it  is recommended that the reader examines either the section on  AC Bus Post-processing Analysis or the section on  DC Bus Post-processing Analysis.\n\nAC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nbus!(system, result)\n\nDC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\nbus!(system, result)\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/#JuliaGrid.branch!","page":"Power Flow Analysis","title":"JuliaGrid.branch!","text":"The function is used to calculate the powers and currents associated with branches for AC  power flow analysis and, in relation to DC power flow analysis, it only calculates active  powers. \n\nbranch!(system::PowerSystem, result::Result)\n\nThe function is responsible for updating the branch field within the Result type after  it has been executed. To gain a comprehensive understanding of the equations used, along  with all relevant data, it is recommended that the reader examines either the section on  AC Branch Post-processing Analysis or the section  on DC Branch Post-processing Analysis.\n\nAC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nbranch!(system, result)\n\nDC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\nbranch!(system, result)\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/#JuliaGrid.generator!","page":"Power Flow Analysis","title":"JuliaGrid.generator!","text":"The function computes powers related to generators.\n\ngenerator!(system::PowerSystem, result::Result)\n\nOnce executed, the generator field within the Result type is updated accordingly. To  gain a comprehensive understanding of the equations used, along with all relevant data, it  is recommended that the reader examines either the section on  AC Generator Post-processing Analysis or the  section on DC Generator Post-processing Analysis.\n\nAC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\ngenerator!(system, result)\n\nDC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\ngenerator!(system, result)\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"page"},{"location":"apireference/powerFlow/#Additional-Functions","page":"Power Flow Analysis","title":"Additional Functions","text":"","category":"section"},{"location":"apireference/powerFlow/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"reactivePowerLimit!\nadjustVoltageAngle!","category":"page"},{"location":"apireference/powerFlow/#JuliaGrid.reactivePowerLimit!","page":"Power Flow Analysis","title":"JuliaGrid.reactivePowerLimit!","text":"The function verifies whether the generators in a power system exceed their reactive power  limits. This is done by setting the reactive power of the generators to within the limits  if they are violated, after determining the bus voltage magnitudes and angles. If the  limits are violated, the corresponding PV buses or the slack bus are converted to PQ buses. \n\nThe function returns the violate variable to indicate which buses violate the limits,  with -1 indicating a violation of the minimum limits and 1 indicating a violation of the  maximum limits.\n\nreactivePowerLimit!(system::PowerSystem, result::Result)\n\nFirst, if the generator!() function has not been executed,  reactivePowerLimit!() will execute it and update the  generator field of the Result type. \n\nAfterward, the function uses the results from generator!() to assign  values to the generator.output.active and bus.supply.active fields of the System  type.\n\nAt the end of the process, the function inspects the reactive powers of the generator and  adjusts them to their maximum or minimum values if they violate the threshold. The  generator.output.reactive field of the System type is then modified accordingly. In  light of this modification, the bus.supply.reactive field of the System type is also  updated, and the bus types in bus.layout.type are adjusted. If the slack bus is  converted, the bus.layout.slack field is modified accordingly.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nviolate = reactivePowerLimit!(system, result)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"apireference/powerFlow/#JuliaGrid.adjustVoltageAngle!","page":"Power Flow Analysis","title":"JuliaGrid.adjustVoltageAngle!","text":"The function modifies the bus voltage angles based on a different slack bus than the one  identified by the bus.layout.slack field. This function only updates the  bus.voltage.angle field of the Result type.\n\nadjustVoltageAngle!(system::PowerSystem, result::Result; slack)\n\nFor instance, if the reactive power of the generator exceeds the limit on the slack bus,  the reactivePowerLimit!() function will change that bus to a  PQ bus and designate the first PV bus in the sequence as the new slack bus. After  obtaining the updated AC power flow solution based on the new slack bus, it is possible to  adjust the voltage angles to align with the angle of the original slack bus. The slack  keyword specifies the bus label of the original slack bus.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nreactivePowerLimit!(system, result)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nadjustVoltageAngle!(system, result; slack = 1)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/#powerSystemModel","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid supports the composite type PowerSystem to preserve power system data, with the following fields: bus, branch, generator, base, acModel, and dcModel. The fields bus, branch, and generator hold data related to buses, branches, and generators, respectively. The base field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes (VA) for the base power and line-to-line voltages measured in volts (V) for base voltages. The macro command @base can be used to change the default unit settings for the base quantities of the composite type PowerSystem after it is created. Finally, the acModel and dcModel fields store vectors and matrices calculated based on the power system's topology and parameters.","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"The composite type PowerSystem can be created using a function:","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem().","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid supports three modes for populating the PowerSystem type: using built-in functions, using HDF5 file format, and using Matpower case files. It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem().","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"This function allows to save power systems that were either loaded from Matpower case files or created using built-in functions in the HDF5 format.","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type is created, you can add buses, branches, and generators using the following functions:","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"addBus!()\naddBranch!()\naddGenerator!().","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"In addition, it is possible to manipulate the parameters of buses, branches, and generators using the following functions:","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"shuntBus!()\nstatusBranch!()\nparameterBranch!()\nstatusGenerator!()\noutputGenerator!().","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"Executing these functions will automatically update all fields affected by them. You can also change other parameters of the power system by accessing and modifying the values in the bus, branch, generator, and base fields of the PowerSystem composite type. The input electrical quantities should be entered in per-units or radians, but this default setting can be altered using the following macros @power, @voltage, and @parameter.","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"To create vectors and matrices based on the power system topology and parameters, you can use the following functions:","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"acModel!()\ndcModel!().","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"Note that these functions can be executed at any time once all power system buses are defined. Specifically, using the addBranch!() function to add a new branch will automatically update the acModel and dcModel fields. However, adding a new bus using addBus!() requires executing the acModel!() and dcModel!() functions again. In addition, executing functions related to parameter manipulation of buses and branches will also automatically update the acModel and dcModel fields.","category":"page"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"apireference/acdcModel/#Build-Model","page":"Power System Model","title":"Build Model","text":"","category":"section"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem","category":"page"},{"location":"apireference/acdcModel/#JuliaGrid.powerSystem","page":"Power System Model","title":"JuliaGrid.powerSystem","text":"The function builds the composite type PowerSystem and populates bus, branch,  generator and base fields. The function can be used by passing the path to the HDF5  file with the .h5 extension or a Matpower file with the .m extension as an argument.  \n\npowerSystem(\"pathToExternalData/name.extension\")\n\nIn general, once the composite type PowerSystem has been created, it is possible to add  new buses, branches, or generators, or modify the parameters of existing ones.\n\nUnits\n\nJuliaGrid stores all data in per-unit (pu) and radian (rad) format which are fixed, the  exceptions are base values in volt-ampere (VA) and volt (V) which can be changed using the  macro @base.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\n\n\n\n\nAlternatively, the PowerSystem composite type can be initialized by calling the function  without any arguments. \n\npowerSystem()\n\nThis allows the model to be built from scratch and modified as needed.\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"apireference/acdcModel/#Save-Model","page":"Power System Model","title":"Save Model","text":"","category":"section"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem","category":"page"},{"location":"apireference/acdcModel/#JuliaGrid.savePowerSystem","page":"Power System Model","title":"JuliaGrid.savePowerSystem","text":"The function saves the power system's data in the HDF5 file using the fields bus,  branch, generator, and base from the PowerSystem composite type. \n\nsavePowerSystem(system::PowerSystem; path, reference, note)\n\nThe location and file name of the HDF5 file is specified by the mandatory keyword  path::String in the format of \"path/name.h5\". Additional information can be provided  by the optional keywords reference::String and note::String.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"D:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"apireference/acdcModel/#Bus-Functions","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nshuntBus!","category":"page"},{"location":"apireference/acdcModel/#JuliaGrid.addBus!","page":"Power System Model","title":"JuliaGrid.addBus!","text":"The function adds a new bus to the PowerSystem type, updating its bus field.\n\naddBus!(system::PowerSystem; label, type, active, reactive, conductance, susceptance,\n    magnitude, angle, minMagnitude, maxMagnitude, base, area, lossZone)\n\nThe bus is defined with the following parameters:\n\nlabel: a unique label for the bus\ntype: the bus type:\ntype = 1: demand bus (PQ)\ntype = 2: generator bus (PV)\ntype = 3: slack bus (Vθ)  \nactive (pu or W): the active power demand at the bus\nreactive (pu or VAr): the reactive power demand at the bus\nconductance (pu or W): the active power demanded of the shunt element\nsusceptance (pu or VAr): the reactive power injected of the shunt element\nmagnitude (pu or V): the initial value of the voltage magnitude\nangle (rad or deg): the initial value of the voltage angle\nminMagnitude (pu or V): the minimum voltage magnitude value\nmaxMagnitude (pu or V): the maximum voltage magnitude value\nbase (V): the base value of the voltage magnitude\narea: the area number\nlossZone: the loss zone.\n\nUnits\n\nThe input units are in per-units (pu) and radians (rad) by default as shown, except for  the keyword base which is given by default in volt (V). The unit settings, such as the selection between the per-unit system or the SI system with the appropriate prefixes, can be modified using macros @base, @power, and @voltage.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, angle = 0.1745, base = 132e3)\n\nCreating a bus using a custom unit system:\n\nsystem = powerSystem()\n@base(system, MVA, kV)\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg)\naddBus!(system; label = 1, active = 25, reactive = -4, angle = 10, base = 132)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/#JuliaGrid.shuntBus!","page":"Power System Model","title":"JuliaGrid.shuntBus!","text":"This function enables the modification of the conductance and susceptance parameters of a shunt element connected to a bus.\n\nshuntBus!(system::PowerSystem; label, conductance, susceptance)\n\nThe label keyword must match an existing bus label. If either conductance or susceptance is left out, the corresponding value will remain unchanged. Additionally, this function automatically updates the acModel field, eliminating the need to rebuild the model from scratch when making changes to these parameters.\n\nUnits\n\nThe input units are in per-units by default, but they can be modified using the @power macro.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\nshuntBus!(system; label = 1, conductance = 0.04)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"apireference/acdcModel/#Branch-Functions","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!","category":"page"},{"location":"apireference/acdcModel/#JuliaGrid.addBranch!","page":"Power System Model","title":"JuliaGrid.addBranch!","text":"The function adds a new branch to the PowerSystem type and updates its branch field. A branch can be added between already defined buses.\n\naddBranch!(system::PowerSystem; label, from, to, status, resistance, reactance,\n    susceptance, turnsRatio, shiftAngle, minDiffAngle, maxDiffAngle,\n    longTerm, shortTerm, emergency, type)\n\nThe branch is defined with the following parameters:\n\nlabel: unique branch label\nfrom: from bus label, corresponds to the bus label\nto: to bus label, corresponds to the bus label\nstatus: operating status of the branch:\nstatus = 1: in-service\nstatus = 0: out-of-service \nresistance (pu or Ω): branch resistance\nreactance (pu or Ω): branch reactance\nsusceptance (pu or S): total line charging susceptance\nturnsRatio: transformer off-nominal turns ratio, equal to zero for a line\nshiftAngle (rad or deg): transformer phase shift angle, where positive value defines delay\nminDiffAngle (rad or deg): minimum voltage angle difference value between from and to bus\nmaxDiffAngle (rad or deg): maximum voltage angle difference value between from and to bus.\nlongTerm (pu or VA, W): short-term rating (equal to zero for unlimited)\nshortTerm (pu or VA, W): long-term rating (equal to zero for unlimited)\nemergency (pu or VA, W): emergency rating (equal to zero for unlimited)\ntype: types of longTerm, shortTerm, and emergency ratings:\ntype = 1: apparent power flow (pu or VA) \ntype = 2: active power flow (pu or W)  \ntype = 3: current magnitude (pu or VA at 1 pu voltage).\n\nUnits\n\nThe input units are in per-units (pu) and radians (rad) by default. The unit settings, such as the selection between the per-unit system or the SI system with the appropriate prefixes, can be modified using macros @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)\n\nCreating a branch using a custom unit system:\n\nsystem = powerSystem()\n\n@voltage(pu, deg)\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1,  active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 10)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/#JuliaGrid.statusBranch!","page":"Power System Model","title":"JuliaGrid.statusBranch!","text":"The function enables the switching of the operational status of a branch, identified by its label, within the PowerSystem system between in-service and out-of-service.\n\nstatusBranch!(system::PowerSystem; label, status)\n\nThis function updates the acModel and dcModel fields automatically when the operating status of a branch is changed, thus eliminating the need to rebuild the model from scratch.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nstatusBranch!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/#JuliaGrid.parameterBranch!","page":"Power System Model","title":"JuliaGrid.parameterBranch!","text":"This function enables the alteration of the resistance, reactance, susceptance, turnsRatio and shiftAngle parameters of a branch, identified by its label, within the PowerSystem.\n\nparameterBranch!(system::PowerSystem; label, resistance, reactance, susceptance,\n    turnsRatio, shiftAngle)\n\nIf any of these parameters are omitted, their current values will be retained. Additionally, this function updates the acModel and dcModel fields automatically, removing the need to rebuild the model from scratch.\n\nUnits\n\nThe input units are in per-units (pu) by default, but they can be modified using the following macros @voltage and @parameter.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nparameterBranch!(system; label = 1, susceptance = 0.062)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"apireference/acdcModel/#Generator-Functions","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\naddActiveCost!\naddReactiveCost!\nstatusGenerator!\noutputGenerator!","category":"page"},{"location":"apireference/acdcModel/#JuliaGrid.addGenerator!","page":"Power System Model","title":"JuliaGrid.addGenerator!","text":"The function is used to add a new generator to the PowerSystem type and update its generator field. The generator can be added to an already defined bus.\n\naddGenerator!(system::PowerSystem; label, bus, status, active, reactive, magnitude,\n    minActive, maxActive, minReactive, maxReactive, lowActive, minLowReactive,\n    maxLowReactive, upActive, minUpReactive, maxUpReactive,\n    loadFollowing, reactiveTimescale, reserve10min, reserve30min, area)\n\nThe generator is defined with the following parameters:\n\nlabel: a unique label for the generator\nbus: the label of the bus to which the generator is connected\nstatus: the operating status of the generator, in-service = 1, out-of-service = 0\nactive (pu or W): output active power\nreactive (pu or VAr): output reactive power\nmagnitude (pu or V): voltage magnitude setpoint\nminActive (pu or W): minimum allowed output active power value\nmaxActive (pu or W): maximum allowed output active power value\nminReactive (pu or VAr): minimum allowed output reactive power value\nmaxReactive (pu or VAr): maximum allowed output reactive power value\nlowActive (pu or W): lower allowed active power output value of PQ capability curve\nminLowReactive (pu or VAr): minimum allowed reactive power output value at lowActive value\nmaxLowReactive (pu or VAr): maximum allowed reactive power output value at lowActive value\nupActive (pu or W): upper allowed active power output value of PQ capability curve\nminUpReactive (pu or VAr): minimum allowed reactive power output value at upActive value\nmaxUpReactive (pu or VAr): maximum allowed reactive power output value at upActive value\nloadFollowing (pu/min or W/min): ramp rate for load following/AG\nreserve10min (pu or W): ramp rate for 10-minute reserves\nreserve30min (pu or W): ramp rate for 30-minute reserves\nreactiveTimescale (pu/min or VAr/min): ramp rate for reactive power, two seconds timescale\narea: area participation factor.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. The unit settings, such as the selection between the per-unit system or the SI system with the appropriate prefixes, can be modified using macros @power and @voltage.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 2, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1, magnitude = 1.1)\n\nCreating a bus using a custom unit system:\n\nsystem = powerSystem()\n@base(system, MVA, kV)\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg)\naddBus!(system; label = 1, type = 2, active = 25, reactive = -4, base = 132)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10, magnitude = 145.2)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/#JuliaGrid.addActiveCost!","page":"Power System Model","title":"JuliaGrid.addActiveCost!","text":"The function updates the generator field of the PowerSystem type by adding costs for the active power produced by the corresponding generator. It can add a cost to an already defined generator.\n\naddActiveCost!(system::PowerSystem; label, model, piecewise, polynomial)\n\nThe function takes in four keywords as arguments:\n\nlabel: corresponds to the already defined generator label\nmodel: cost model, piecewise linear = 1, polynomial = 2\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or W): active power output of the generator\nsecond column (currency/hr): cost for the specified active power output\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/Wⁿhr): coefficient of the n-th degree term, ...\npenultimate element (currency/puhr or currency/Whr): coefficient of the first degree term\nlast element (currency): constant coefficient.\n\nUnits\n\nBy default, the input units related with active powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\naddActiveCost!(system; label = 1, model = 1, polynomial = [1100.0; 500.0; 150.0])\n\nCreating a bus using a custom unit system:\n\nsystem = powerSystem()\n\n@power(MW, MVAr, MVA)\naddBus!(system; label = 1, active = 25, reactive = -4, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\naddActiveCost!(system; label = 1, model = 1, polynomial = [0.11; 5.0; 150.0])\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/#JuliaGrid.addReactiveCost!","page":"Power System Model","title":"JuliaGrid.addReactiveCost!","text":"The function updates the generator field of the PowerSystem type by adding costs for the reactive power produced by the corresponding generator. It can add a cost to an already defined generator.\n\naddReactiveCost!(system::PowerSystem; label, model, piecewise, polynomial)\n\nThe function takes in four keywords as arguments:\n\nlabel: corresponds to the already defined generator label\nmodel: cost model, piecewise linear = 1, polynomial = 2\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or VAr): reactive power output of the generator\nsecond column (currency/hr): cost for the specified reactive power output\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/VArⁿhr): coefficient of the n-th degree term, ...\npenultimate element (currency/puhr or currency/VArhr): coefficient of the first degree term\nlast element (currency): constant coefficient.\n\nUnits\n\nBy default, the input units related with reactive powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\naddReactiveCost!(system; label = 1, model = 2, piecewise = [0.1085 12; 0.1477 16])\n\nCreating a bus using a custom unit system:\n\nsystem = powerSystem()\n\n@power(MW, MVAr, MVA)\naddBus!(system; label = 1, active = 25, reactive = -4, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\naddReactiveCost!(system; label = 1, model = 2, piecewise = [10.85 12; 14.77 16])\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/#JuliaGrid.statusGenerator!","page":"Power System Model","title":"JuliaGrid.statusGenerator!","text":"The function changes the operating status of a generator by switching it from in-service to out-of-service, or vice versa.\n\nstatusGenerator!(system::PowerSystem; label, status)\n\nIt has two parameters, label and status, where the label corresponds to the generator label that has already been defined. It updates the bus.layout.type field of the PowerSystem type. More precisely, if the bus is not slack and all generators are out-of-service, the bus will be designated as a PQ bus. On the other hand, if at least one generator is in-service, the bus will be designated as a PV bus. The function also updates the bus.supply field of the PowerSystem type.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\nstatusGenerator!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/#JuliaGrid.outputGenerator!","page":"Power System Model","title":"JuliaGrid.outputGenerator!","text":"The function modifies the active and reactive output power of a generator.\n\noutputGenerator!(system::PowerSystem; label, active, reactive)\n\nIt has three parameters, label, active, and reactive, where the label corresponds to the generator label that has already been defined. The active and reactive parameters can be left, in which case their values will remain unchanged. The function also updates the bus.supply field of the PowerSystem type.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\noutputGenerator!(system; label = 1, active = 0.85)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"apireference/acdcModel/#AC-and-DC-Model","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"apireference/acdcModel/#JuliaGrid.acModel!","page":"Power System Model","title":"JuliaGrid.acModel!","text":"The function generates vectors and matrices based on the power system topology and parameters associated with AC analysis. We advise the reader to read the section in-depth AC Model, which explains all the data involved in the field acModel.\n\nacModel!(system::PowerSystem)\n\nThe function updates the field acModel. Once formed, the field will be automatically updated when using functions addBranch!(), shuntBus!(), statusBranch!(), parameterBranch!().\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/#JuliaGrid.dcModel!","page":"Power System Model","title":"JuliaGrid.dcModel!","text":"The function generates vectors and matrices based on the power system topology and parameters associated with DC analysis. We advise the reader to read the section in-depth DC Model, which explains all the data involved in the field dcModel.\n\ndcModel!(system::PowerSystem)\n\nThe function updates the field dcModel. Once formed, the field will be automatically updated when using functions addBranch!(), statusBranch!(), parameterBranch!().\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"apireference/acdcModel/#Units","page":"Power System Model","title":"Units","text":"","category":"section"},{"location":"apireference/acdcModel/","page":"Power System Model","title":"Power System Model","text":"@base\n@power\n@voltage\n@parameter\n@default","category":"page"},{"location":"apireference/acdcModel/#JuliaGrid.@base","page":"Power System Model","title":"JuliaGrid.@base","text":"By default, the units for base power and base voltages are set to volt-ampere (VA) and volt (V), but you can modify the prefixes using the macro:\n\n@base(system::PowerSystem, power, voltage)\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of power (VA) or unit of voltage (V). Keep in mind that the macro must be used after creating the composite type PowerSystem.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n@base(system, MVA, kV)\n\n\n\n\n\n","category":"macro"},{"location":"apireference/acdcModel/#JuliaGrid.@power","page":"Power System Model","title":"JuliaGrid.@power","text":"JuliaGrid stores all data related with powers in per-units, and these cannot be altered. However, the power units of the built-in functions used to add or modified power system elements can be modified using the macro:\n\n@power(active, reactive, apparent)\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of active power (W), reactive power (VAr), or apparent power (VA). Also it is a possible to combine SI units with/without prefixes with per-units (pu).\n\nChanging the unit of active power is reflected in the following quantities:\n\naddBus!(): active, conductance\nshuntBus!(): conductance\naddGenerator!(): active, minActive, maxActive, lowActive, upActive, loadFollowing, reserve10min, reserve30min\naddActiveCost!(): piecewise, polynomial\noutputGenerator!(): active\naddBranch!(): longTerm, shortTerm, emergency if rating type = 2.\n\nChanging the unit of reactive power unit is reflected in the following quantities:\n\naddBus!(): reactive, susceptance\nshuntBus!(): susceptance\naddGenerator!(): reactive, minReactive, maxReactive, minLowReactive, maxLowReactive, minUpReactive, maxUpReactive, reactiveTimescale\naddReactiveCost!(): piecewise, polynomial\noutputGenerator!(): reactive.\n\nChanging the unit of apparent power unit is reflected in the following quantities:\n\naddBranch!(): longTerm, shortTerm, emergency if rating type = 1 or type = 3.\n\nExample\n\n@power(MW, kVAr, VA)\n\n\n\n\n\n","category":"macro"},{"location":"apireference/acdcModel/#JuliaGrid.@voltage","page":"Power System Model","title":"JuliaGrid.@voltage","text":"JuliaGrid stores all data related with voltages in per-units and radians, and these cannot be altered. However, the voltage magnitude and angle units of the built-in functions used to add or modified power system elements can be modified using the macro:\n\n@voltage(magnitude, angle)\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of voltage magnitude (V). The second option is to define the unit of voltage magnitude in per-unit (pu). The unit of the voltage angle should be given in radian (rad) or degree (deg).\n\nChanging the unit of voltage magnitude is reflected in the following quantities:\n\naddBus!(): magnitude, minMagnitude, maxMagnitude\naddGenerator!(): magnitude.\n\nChanging the unit of voltage angle is reflected in the following quantities:\n\naddBus!(): angle\naddBranch!(): shiftAngle, minDiffAngle, maxDiffAngle\nparameterBranch!(): shiftAngle.\n\nExample\n\n@voltage(kV, deg)\n\n\n\n\n\n","category":"macro"},{"location":"apireference/acdcModel/#JuliaGrid.@parameter","page":"Power System Model","title":"JuliaGrid.@parameter","text":"JuliaGrid stores all data related with impedances and admittancies in per-units, and these cannot be altered. However, units of impedance and admittance of the built-in functions used to add or modified power system elements can be modified using the macro:\n\n@parameter(impedance, admittance)\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of impedance (Ω) or unit of admittance (S). The second option is to define the units in per-unit (pu).\n\nIn the case where impedance and admittance are being used in SI units (Ω and S) and these units are related to the transformer, the assignment must be based on the primary side of the transformer.\n\nChanging the units of impedance is reflected in the following quantities in specific functions:\n\naddBranch!(): resistance, reactance\nparameterBranch!(): resistance, reactance.\n\nChanging the units of admittance is reflected in the following quantities:\n\naddBranch!(): susceptance\nparameterBranch!(): susceptance.\n\nExample\n\n@parameter(Ω, pu)\n\n\n\n\n\n","category":"macro"},{"location":"apireference/acdcModel/#JuliaGrid.@default","page":"Power System Model","title":"JuliaGrid.@default","text":"We have a macro that resets the units of the built-in functions to their default  settings of per-units (pu) and radians (rad). \n\n@default(mode)\n\nThe mode argument can take on the following values:\n\nall: resets all units to their default settings\npower: sets active, reactive, and apparent power to per-units (pu)\nvoltage: sets voltage magnitude to per-unit (pu) and voltage angle to radian (rad)\nparameter: sets impedance and admittance to per-units (pu).\n\nExample\n\n@default(all)\n\n\n\n\n\n","category":"macro"},{"location":"tutorials/powerFlowSolution/#inDepthPowerFlowAnalysis","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"JuliaGrid utilizes standard network components and leverages the unified branch model to achieve power flow analysis, enabling the definition of load profiles, generator capacities, voltage specifications, contingency analysis, and planning. To begin, the PowerSystem composite type must be provided to JuliaGrid through the use of the powerSystem() function, as illustrated by the following example:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To review, we can conceptualize the bus/branch model as a graph denoted by mathcalG = (mathcalN mathcalE), where the collection of nodes mathcalN = 1 dots n signifies the buses of the power network, and the set of edges mathcalE subseteq mathcalN times mathcalN represents the branches within the network. As previously demonstrated in the section on the In-depth AC Model, we can express the network as a system of nonlinear equations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    mathbfbar I = mathbfY mathbfbar V","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The complex current injection at the bus i in mathcalN is defined as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  \tbarI_i = cfracS_i^*barV_i^*","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where barV_i = V_i texte^textjtheta_i. Thus, for any given bus i in mathcalN, we can express it as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  \tcfracS_i^*barV_i^* = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The complex power injection denoted by S_i comprises of both the active power P_i and reactive power Q_i. This relationship can be represented as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  \tcfracP_i - textjQ_ibarV_i = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"As demonstrated by the above equation, the bus i in mathcalN contains four unknown variables, namely the active power injection P_i, reactive power injection Q_i, bus voltage magnitude V_i, and bus voltage angle theta_i. To solve the system of equations, two variables must be specified for each equation. Although any two variables can be selected mathematically, the choice is determined by the devices that are connected to a particular bus. The standard options are listed in the table below, and these options are used to define the bus types [1].","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Bus Type Label JuliaGrid Known Unknown\nSlack V theta 3 V_i, theta_i P_i, Q_i\nGenerator PV 2 P_i, V_i Q_i, theta_i\nDemand PQ 1 P_i, Q_i V_i, theta_i","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Consequently, JuliaGrid operates with sets mathcalN_textpv and mathcalN_textpq that contain PV and PQ buses, respectively, and exactly one slack bus in the set mathcalN_textsb. The bus types are stored in the variable: ","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> system.bus.layout.type","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"It should be noted that JuliaGrid cannot handle systems with multiple slack buses. Additionally, when using functions such as newtonRaphson(), fastNewtonRaphsonBX(), fastNewtonRaphsonXB(), and gaussSeidel(), the bus type can be modified in the following manner: If a bus was originally classified as a PV bus but does not have any in-service generators, it will be converted to a PQ bus.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Furthermore, the active power injections P_i and reactive power injections Q_i can be expressed as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n  \tP_i = P_textsi - P_textdi \n    Q_i = Q_textsi - Q_textdi\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where P_textsi and Q_textsi correspond to the active and reactive power generated by the generators supplying the bus i in mathcalN, while P_textdi and Q_textdi denote the active and reactive power consumed by the consumers at the bus i in mathcalN. These values can be computed in JuliaGrid as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> system.bus.supply.active - system.bus.demand.active\njulia> system.bus.supply.reactive - system.bus.demand.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#inDepthNewtonRaphson","page":"In-depth Power Flow Analysis","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The Newton-Raphson method is commonly used in power flow calculations due to its quadratic rate of convergence. It provides an accurate approximation of the roots of the system of nonlinear equations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  mathbff(mathbfx) = mathbf0","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"which in turn allows for the determination of the voltage magnitudes and angles of each bus, denoted as the state vector mathbf x = bm theta mathbf V^T. The state vector comprises of bm theta in mathbbR^n-1 and mathbf V in mathbbR^n_textpq, where n_textpq = mathcalN_textpq is the total number of PQ buses. The voltage magnitudes and angles are known for certain types of buses, including:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The voltage magnitude V_i and angle theta_i at the slack bus i in mathcalN_textsb are known.\nThe voltage magnitude V_i at PV buses i in mathcalN_textpv is known.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The complex power injection S_i at a bus i in mathcalN is a function of the complex bus voltages. Therefore, the active and reactive power injection expressions can be defined based on the real and imaginary components of the complex power as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    P_i =V_isumlimits_j=1^n V_j (G_ijcostheta_ij+B_ijsintheta_ij)\n    Q_i =V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij)\n\tendaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Using the above equations, we can define the active power injection function for PV and PQ buses as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"and the reactive power injection function for PQ buses as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalN_textpq","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active and reactive mismatches, often denoted as Delta P_i(mathbf x) and Delta Q_i(mathbf x), respectively, are defined as the functions f_P_i(mathbf x) and f_Q_i(mathbf x). The first terms on the right-hand side represent power injections at a bus, while the second term is constant and is obtained based on the active and reactive powers of the generators that supply a bus and active and reactive powers demanded by consumers at the same bus. Therefore, the Newton-Raphson method solves the system of nonlinear equations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  mathbff(x) =\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where the first n - 1 equations correspond to PV and PQ buses, and the last n_textpq equations correspond to PQ buses.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#Method-Implementation","page":"In-depth Power Flow Analysis","title":"Method Implementation","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To apply the Newton-Raphson method and determine the bus voltage magnitudes and angles for AC power flow in JuliaGrid, execute the following sequence of functions:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The Newton-Raphson method, also known as Newton's method, is an iterative approach based on the Taylor series expansion, where higher-order terms are neglected. In each iteration, the increments of bus voltage angle and magnitude are computed as: ","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  mathbfDelta x^(nu) = -mathbfJ(x^(nu))^-1mathbf f(x^(nu))","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where mathbfDelta x^(nu) = mathbf Delta bm theta^(nu) mathbf Delta mathbf V^(nu)^T consists of the vector of bus voltage angle increments mathbf Delta bm theta^(nu) in mathbbR^n-1 and bus voltage magnitude increments mathbf Delta mathbf V^(nu) in mathbbR^n_textpq, and mathbfJ(x^(nu))in mathbbR^n_textu times n_textu is the Jacobian matrix, n_textu = n + n_textpq - 1.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.increment\njulia> result.algorithm.jacobian\njulia> result.algorithm.mismatch","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The JuliaGrid implementation stores the increment vector mathbf Delta x^(nu) and mismatch vector mathbff(x^(nu)) follows the same order as the one defined previously. The first n - 1 elements represent bus voltage angle increments and active mismatches defined based on PV and PQ buses, in the same order as they appear in the input data. The last n_textpq elements represent bus voltage magnitude increments and reactive mismatches defined based on PQ buses. Consequently, the Jacobian matrix mathbfJ(x^(nu)) is also constructed accordingly.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Subsequently, we modify the solution by adding an increment term:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  mathbf x^(nu + 1) = mathbf x^(nu) + mathbf Delta mathbf x^(nu)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The final outcomes of JuliaGrid are stored in arrays that hold the magnitudes and angles of the bus voltages:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.voltage.magnitude\njulia> result.bus.voltage.angle","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To obtain the current iteration number nu, use the following command:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.iteration.number","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The iteration process continues until the termination condition is met. Specifically, at each iteration, we evaluate the active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  f_P_i(mathbf x^(nu+1)) = V_i^(nu+1)sumlimits_j=1^n V_j^(nu+1)(G_ijcostheta_ij^(nu+1)+B_ijsintheta_ij^(nu+1)) - P_i\n   i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"as well as the reactive power injection mismatch for PQ buses:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    f_Q_i(mathbf x^(nu+1)) = V_i^(nu+1)sumlimits_j=1^n V_j^(nu+1)(G_ijsintheta_ij^(nu+1)-B_ijcostheta_ij^(nu+1)) - Q_i\n     i in mathcalN_textpq","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The iteration stops when the following criteria are satisfied:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    max f_P_i(mathbf x^(nu+1)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max f_Q_i(mathbf x^(nu+1)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Here, epsilon is a predefined stopping criterion. These values are stored in JuliaGrid's variables, which can be used to terminate the iteration loop:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.iteration.stopping.active\njulia> result.algorithm.iteration.stopping.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Finally, it is worth noting that the Newton-Raphson method may encounter difficulties when dealing with initial conditions during a \"flat start\".","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#Jacobian-Matrix","page":"In-depth Power Flow Analysis","title":"Jacobian Matrix","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Without loss of generality, we assume that the slack bus is the first bus, followed by the set of PQ buses and the set of PV buses:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    mathcalN_textsb =  1  \n    mathcalN_textpq = 2 dots m \n    mathcalN_textpv = m + 1dots n\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where mathcalN = mathcalN_textsb cup mathcalN_textpq cup mathcalN_textpv. Therefore, we can express:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    bm theta = theta_2dotstheta_n^T  mathbf Delta bm theta = Delta theta_2dotsDelta theta_n^T \n    mathbf V = V_2dotsV_m^T  mathbf Delta mathbf V = Delta V_2dotsDelta V_m^T\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The Jacobian matrix mathbfJ(x^(nu)) in mathbbR^n_textu times n_textu is:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  mathbfJ(x^(nu))=\n  left\n  beginarraycccccc\n  cfracmathrm partialf_P_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_P_n(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_m 10pt\n  hline \n  cfracmathrm partialf_Q_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_Q_m(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_m\n  endarray\n  right","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The Jacobian matrix can be expressed using four block matrices:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"\t  mathbfJ(x^(nu)) =\n  beginbmatrix\n    mathbfJ_11(x^(nu)) mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu)) \n\t   mathbfJ_22(x^(nu))\n  endbmatrix","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where diagonal elements of the Jacobian sub-matrices are defined as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu)) mathrm partial theta_i =\n  V_i^(nu)sumlimits_j=1^n V_j^(nu)(-G_ij\n  sintheta_ij^(nu)+B_ijcostheta_ij^(nu)) - (V_i^(nu))^2B_ii\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_i^(nu) = sumlimits_\n  j=1^n V_j^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))+V_i^(nu) G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_i=V_i^(nu)\n  sumlimits_j=1^n V_j^(nu)\n  (G_ijcostheta_ij^(nu)+B_ijsintheta_ij^(nu))- (V_i^(nu))^2G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial V_i=sumlimits_j=1\n  ^n V_j^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))-V_i^(nu) B_ii\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"while non-diagonal elements of the Jacobian sub-matrices are:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu))\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_j^(nu) = V_i^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (-G_ijcostheta_ij^(nu) -B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))mathrm\n  partial V_j=V_i^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#inDepthFastNewtonRaphson","page":"In-depth Power Flow Analysis","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Although the fast Newton-Raphson method may converge more slowly than the traditional Newton-Raphson method, the shorter solution time for the updates often compensates for this slower convergence, resulting in a shorter overall solution time. This is particularly true for systems that are not heavily loaded, where a shorter overall solution time is almost always achieved. It is important to note that if the algorithm converges, it will converge to a correct solution [2].","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The fast Newton-Raphson method involves decoupling the power flow equations. Namely, the Newton-Raphson method is based on the equations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginbmatrix\n    mathbfJ_11(x) mathbfJ_12(x)  mathbfJ_21(x) \n\t   mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbfDelta theta  mathbfDelta V\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where the iteration index has been omitted for simplicity. However, in transmission grids, there exists a strong coupling between active powers and voltage angles, as well as between reactive powers and voltage magnitudes. To achieve decoupling, two conditions must be satisfied: first, the resistance values r_ij of the branches must be small compared to their reactance values x_ij, and second, the angle differences must be small, i.e., theta_ij approx 0 [3]. Therefore, starting from the above equation, we have:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginbmatrix\n    mathbfJ_11(x)  mathbf0  mathbf0  mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbfDelta bm theta  mathbfDelta V\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"which gives the decoupled system as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    mathbff_P(mathbf x) = -mathbfJ_11(x) mathbfDelta bm  theta \n    mathbff_Q(mathbf x) = -mathbfJ_22(x) mathbfDelta V\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To examine the problem, it is helpful to express it as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    f_P_2(mathbf x) = -Delta theta_2cfracmathrm partialf_P_2(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_2(mathbf x)mathrm partial theta_n \n     vdots \n    f_P_n(mathbf x) = -Delta theta_2cfracmathrm partialf_P_n(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_i(mathbf x)mathrm partial theta_n\n    f_Q_2(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_n_textpq  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n     vdots \n    f_Q_m(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_m  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Firstly, the second part of the expressions is expanded as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n  f_Q_2(mathbf x) =\n  -cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n   vdots \n  f_Q_m(mathbf x) =\n  - cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Next, the Jacobian elements are derived. To achieve this, we can use the expressions defined for the Newton-Raphson method. For PQ buses, the above expansions are applied as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  V_isumlimits_j=1^n V_j(-G_ij\n  sintheta_ij+B_ijcostheta_ij) - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = V_isumlimits_j=1\n  ^n V_j(G_ijsintheta_ij-\n  B_ijcostheta_ij)-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"As the definition of reactive power is given by the equation:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    Q_i =V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"the Jacobian elements can be expressed in the following manner:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  -Q_i - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = Q_i-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The decoupled model is established through the following approximations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    sin(theta_ij) approx 0 \n    cos(theta_ij) approx 1 \n    Q_i  B_iiV_i^2\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Thus, when the approximations are made, the Jacobian elements are simplified, resulting in the decoupled model where the Jacobian elements are:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i = -V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_j = -V_iV_jB_ij\n  V_i cfracmathrm partialf_Q_i(mathbf x) mathrm partial V_i = -V_i^2B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrmpartial V_j =  -V_iV_jB_ij\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Thus, the initial system of equations becomes:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    f_P_2(mathbf x) = V_2^2B_22 Delta theta_2 + cdots + V_2V_nB_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_2V_nB_n2 Delta theta_2 + cdots + V_n^2B_nn Delta theta_n \n    f_Q_2(mathbf x) =  V_2^2B_22 cfracDelta V_2V_2 + cdots +\n     V_2V_mB_2m cfracDelta V_mV_m \n     vdots \n    f_Q_m(mathbf x) = V_2V_mB_m2 cfracDelta V_2V_2 + cdots +\n    V_m^2 B_mm cfracDelta V_mV_m\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Using V_j approx 1, wherein V_i^2 = V_iV_j j=i, the first part of the equations can be simplified to:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    f_P_2(mathbf x) = V_2B_22 Delta theta_2 + cdots + V_2B_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_nB_n2 Delta theta_2 + cdots + V_nB_nn Delta theta_n\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Similarly, the second part of the equations can be simplified to:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    f_Q_2(mathbf x) =  V_2B_22 Delta V_2 + cdots +\n     V_2 B_2m Delta V_m\n    \n     vdots \n    f_Q_m(mathbf x) = V_mB_m2 Delta V_2 + cdots +\n    V_m B_mm Delta V_m\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The fast Newton-Raphson method is ultimately based on the system of equations presented below:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    cfracf_P_2(mathbf x)V_2 = B_22 Delta theta_2 + cdots + B_2n Delta theta_n \n     vdots \n    cfracf_P_n(mathbf x)V_n = B_n2 Delta theta_2 + cdots + B_nn Delta theta_n \n    cfracf_Q_2(mathbf x)V_2 =  B_22 Delta V_2 + cdots + B_2m Delta V_m \n     vdots \n    cfracf_Q_m(mathbf x)V_m = B_m2 Delta V_2 + cdots +\n    B_mm Delta V_m\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"This system can be rewritten as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    mathbfh_P(mathbf x) = mathbfB_1 mathbfDelta bm theta \n    mathbfh_Q(mathbf x) = mathbfB_2 mathbfDelta V\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"One of the main advantages of this approach is that the Jacobian matrices mathbfB_1 and mathbfB_2 are constant and need only be formed once. Furthermore, this method can be used to define both the XB and BX versions of the fast Newton-Raphson algorithm.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#XB-Version","page":"In-depth Power Flow Analysis","title":"XB Version","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The matrix mathbfB_1 is formed by neglecting the resistance r_ij, shunt susceptance Im  y_textshi , charging susceptance Im  y_textsij , and transformer tap ratio magnitudetau_ij. The matrix mathbfB_2 is constructed by disregarding the transformer phase shift angle phi_ij. This approach corresponds to the standard fast Newton-Raphson method and is known to exhibit exceptional convergence properties in typical scenarios [3].","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To initialize the XB version of the fast Newton-Raphson method, one can utilize the following code snippet:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = fastNewtonRaphsonXB(system)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#BX-Version","page":"In-depth Power Flow Analysis","title":"BX Version","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The matrix mathbfB_1 ignores the shunt susceptanceIm  y_textshi , charging susceptance Im  y_textsij , and transformer tap ratio magnitude tau_ij. The matrix mathbfB_2 ignores the resistance r_ij and transformer phase shift angle phi_ij. In usual cases, the iteration count for the BX version is comparable to the XB scheme. However, for systems with high r_ijx_ij ratios, the BX scheme requires considerably fewer iterations than the XB scheme to solve the power flow [3].","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To initialize the BX version of the fast Newton-Raphson method, you can use the following code:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = fastNewtonRaphsonBX(system)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#Method-Implementation-2","page":"In-depth Power Flow Analysis","title":"Method Implementation","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To start, the JuliaGrid computes the Jacobian matrices mathbfB_1 and mathbfB_2 that correspond to the active and reactive power equations, respectively. These matrices can be accessed using the following commands:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.active.jacobian\njulia> result.algorithm.reactive.jacobian","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Next, JuliaGrid utilizes the LU factorization of matrices mathbfB_1 and mathbfB_2 to compute solutions through iterations. The lower and upper triangular matrices, as well as the right and left permutation matrices, and the diagonal scaling matrix can be accessed using the following commands:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.active.lower\njulia> result.algorithm.active.upper\njulia> result.algorithm.active.right\njulia> result.algorithm.active.left\njulia> result.algorithm.active.scaling","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.reactive.lower\njulia> result.algorithm.reactive.upper\njulia> result.algorithm.reactive.right\njulia> result.algorithm.reactive.left\njulia> result.algorithm.reactive.scaling","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To solve the AC power flow and obtain bus voltage magnitudes and angles, JuliaGrid provides the following function sequence:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"stopping = result.algorithm.iteration.stopping\nfor i = 1:100\n    fastNewtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The fast Newton-Raphson method first solves the equation:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  mathbfDelta bm theta^(nu) = mathbfB_1^-1 mathbfh_P(bm theta^(nu) mathbf V^(nu))","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The corresponding increment and mismatch can be accessed via:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.active.increment\njulia> result.algorithm.active.mismatch","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"After that, the solution is updated as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  bmtheta^(nu+1) = bmtheta^(nu) + mathbf Delta bm theta^(nu)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The final results are stored in the vector that contains all bus voltage angles:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.voltage.angle","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The fast Newton-Raphson method then solves the equation:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  mathbfDelta V^(nu) = mathbfB_2^-1 mathbfh_Q(bm theta^(nu + 1) mathbf V^(nu))","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The corresponding increment and mismatch can be accessed via:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.reactive.increment\njulia> result.algorithm.reactive.mismatch","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Finally, the solution is updated as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  mathbfV^(nu+1) = mathbfV^(nu) + mathbfDelta V^(nu)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The final results are stored in the vector that contains all bus voltage magnitudes:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.voltage.magnitude","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The functions mathbff_P(mathbf x) and mathbff_Q(mathbf x) remain free of approximations, with only the calculation of the state variable increments affected [2]. As a result, we still use the following equations to compute the mismatches:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalN_textpq cup mathcalN_textpv\n    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalN_textpq\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Therefore, we compute the mismatches in active power injection for PQ and PV buses as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  h_P_i(mathbf x^(nu+1)) =\n  sumlimits_j=1^n V_j^(nu+1)(G_ijcostheta_ij^(nu+1)+B_ijsintheta_ij^(nu+1)) - cfracP_iV_i^(nu+1)\n    i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"and in reactive power injection for PQ buses as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    h_Q_i(mathbf x^(nu+1)) =\n    sumlimits_j=1^n V_j^(nu+1) (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu+1)) - cfracQ_iV_i^(nu+1)\n     i in mathcalN_textpq","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The iteration loop is terminated when the following conditions are met:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    max h_P_i(mathbf x^(nu)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max h_Q_i(mathbf x^(nu)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Here, epsilon refers to the pre-defined stopping criteria. JuliaGrid stores these values to break the iteration loop in the following variables:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.iteration.stopping.active\njulia> result.algorithm.iteration.stopping.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#inDepthGaussSeidel","page":"In-depth Power Flow Analysis","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"By defining the complex current injection at bus i in mathcalN as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"\tbarI_i = fracP_i - jQ_ibarV_i^*","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"the power flow problem can be represented as a system of nonlinear equations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"This system of equations can be expanded to n complex equations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    Y_11  barV_1  + cdots+ Y_1nbarV_n = fracP_1 - jQ_1barV_1^* \n     vdots  \n    Y_n1  barV_1 + cdots+ Y_nnbarV_n = fracP_n - jQ_nbarV_n^*\n\tendaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"While the Gauss-Seidel method directly solves the system of equations, it suffers from very slow convergence, which increases almost linearly with the system size, necessitating numerous iterations to obtain the desired solution [4]. Moreover, the convergence time of the Gauss-Seidel method increases significantly for large-scale systems and can face convergence issues for systems with high active power transfers. Nevertheless, power flow programs utilize both the Gauss-Seidel and Newton-Raphson methods in a complementary manner. Specifically, the Gauss-Seidel method is employed to obtain a quick approximate solution from a \"flat start\", while the Newton-Raphson method is utilized to obtain the final accurate solution [5].","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The Gauss-Seidel method is typically based on the system of equations with n complex equations, one of which represents the slack bus. As a result, one equation can be eliminated, resulting in a power flow problem with n-1 equations.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#Method-Implementation-3","page":"In-depth Power Flow Analysis","title":"Method Implementation","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To solve the AC power flow and determine the bus voltage magnitudes and angles, the Gauss-Seidel method can be used with the help of JuliaGrid. The sequence of functions provided by JuliaGrid for this purpose is shown below:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:1000\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The Gauss-Seidel method starts by using initial complex bus voltages barV_i^(0), i in mathcalN. The method then computes bus complex voltages for PQ buses using the following iteration scheme:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    barV_i^(nu + 1) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_ibarV_i^*(nu) -\n    sumlimits_substackj = 1^i - 1 Y_ijbarV_j^(nu + 1) -\n    sumlimits_substackj = i + 1^n Y_ijbarV_j^(nu)Bigg)\n     i in mathcalN_textpq","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The next step is to determine the solution for PV buses in two stages: first, the reactive power injection is calculated, and then the bus complex voltage is updated using the following equations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  beginaligned\n    Q_i^(nu+1) =\n    -Im left barV_i^*(nu + 1) sumlimits_j=1^n Y_ijbarV_j^(nu+1)right  i in mathcalN_textpv \n    barV_i^(nu + 1) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_i^(nu + 1)barV_i^*(nu + 1)-\n    sumlimits_substackj = 1j neq i^n Y_ijbarV_j^(nu + 1) Bigg)  i in mathcalN_textpv\n  endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The obtained voltage magnitude may not be equal to the magnitude specified for the PV bus, so a voltage correction step is necessary:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"      barV_i^(nu+1) = V_i^(0) cfracbarV_i^(nu+1)V_i^(nu+1)  i in mathcalN_textpv","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"JuliaGrid stores the final results in vectors that contain all bus voltage magnitudes and angles:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.voltage.magnitude\njulia> result.bus.voltage.angle","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The iteration loop is executed repeatedly until the stopping condition is met. After each loop, we calculate the active power injection mismatch for PQ and PV buses as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    f_P_i(mathbf x^(nu+1)) = RebarV_i^(nu + 1) barI_i^*(nu + 1) - P_i  i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"and the reactive power injection mismatch for PQ buses as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  f_Q_i(mathbf x^(nu+1)) = ImbarV_i^(nu + 1) barI_i^*(nu + 1) - Q_i  i in mathcalN_textpq","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The iteration loop is terminated when the following conditions are satisfied:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    max f_P_i(mathbf x^(nu+1)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max f_Q_i(mathbf x^(nu+1)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where epsilon is a pre-determined stopping criterion. JuliaGrid stores these values in order to break the iteration loop:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.algorithm.iteration.stopping.active\njulia> result.algorithm.iteration.stopping.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#acPostprocessingAnalysis","page":"In-depth Power Flow Analysis","title":"AC Post-processing Analysis","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"After calculating the complex values of bus voltages, it becomes possible to determine various other electrical quantities of significance. For instance, JuliaGrid provides a set of functions to execute AC power flow analysis and compute powers and currents associated with buses and branches, as well as powers linked to generators:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nbus!(system, result)\nbranch!(system, result)\ngenerator!(system, result)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#acPostprocessingAnalysisBus","page":"In-depth Power Flow Analysis","title":"Bus","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To obtain the complex current injection at a particular bus, the following expression can be used:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    barI_i = sumlimits_j = 1^n Y_ij barV_j i in mathcalN","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"In JuliaGrid, the magnitude and angle of the complex current injection at each bus can be obtained using:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.current.injection.magnitude\njulia> result.bus.current.injection.angle","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active and reactive power injections at the bus can be computed as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    S_i =barV_ibarI_i^* i in mathcalN","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"You can retrieve the active and reactive power injections using:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.injection.active\njulia> result.bus.power.injection.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"For generators that supply bus i in mathcalN_textpv, the active power is equal to the sum of the given generator active powers in the input data, except for the slack bus, which can be determined as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_textsi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where P_textdi represents the active power demanded by consumers at the slack bus. You can retrieve the active powers using:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.supply.active","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The reactive power of the generators that supply the bus can be computed using the equation:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    Q_textsi = Q_i + Q_textdi i in mathcalN_textpv cup mathcalN_textsb","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where Q_textdi represents the reactive power demanded by consumers at the corresponding bus. You can retrieve the reactive powers using: ","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.supply.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To obtain the active and reactive powers related to the shunt element at the bus, use the equation:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  S_textshi =barV_ibarI_textshi^* = y_textshi^*barV_i^2 i in mathcalN","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"You can retrieve the active and reactive powers using:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.shunt.active\njulia> result.bus.power.shunt.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#acPostprocessingAnalysisBranch","page":"In-depth Power Flow Analysis","title":"Branch","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To obtain the complex current flow at from bus end i in mathcalN, the unified branch model can be used:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    barI_ij = cfrac1tau_ij^2(y_ij + y_textsij) barV_i - alpha_ij^*y_ij barV_j (ij) in mathcalE","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The magnitude and angle of the resulting complex current flows at the from bus end can be obtained using the following Julia code:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.current.from.magnitude\njulia> result.branch.current.from.angle","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Similarly, the complex current flow at to bus end j in mathcalN can be obtained using the same unified branch model:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    barI_ji = -alpha_ijy_ij barV_i + (y_ij + y_textsij) barV_j (ij) in mathcalE","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The magnitude and angle of the resulting complex current flows at to bus end can be obtained using the following Julia code:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.current.to.magnitude\njulia> result.branch.current.to.angle","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Finally, the complex current flow through the series impedance of the branch in the direction from bus i in mathcalN to bus j in mathcalN can be determined as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    barI_textbij =  y_ij (alpha_ijbarV_i - barV_j) (ij) in mathcalE","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The magnitude and angle of the resulting complex current flows through the series impedances can be obtained using the following Julia code:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.current.impedance.magnitude\njulia> result.branch.current.impedance.angle","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To obtain the active and reactive power flows at from bus end i in mathcalN, we use the following equations, based on the unified branch model:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    S_ij = barV_ibarI_ij^* (ij) in mathcalE","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"We can retrieve the active and reactive power flows using the following Julia commands:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.from.active\njulia> result.branch.power.from.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Similarly, to obtain the active and reactive power flows at to bus end j in mathcalN, we use the following equations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    S_ji = barV_jbarI_ji^* (ij) in mathcalE","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"We can retrieve the active and reactive power flows using the following Julia commands:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.to.active\njulia> result.branch.power.to.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The series impedance z_ij of the branch causes active and reactive power losses. We can obtain these losses using the following equations:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    beginaligned\n        P_textlossij = r_ijbarI_textbij^2 \n        Q_textlossij = x_ijbarI_textbij^2\n    endaligned","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where (ij) in mathcalE. We can retrieve the active and reactive power losses using the following Julia commands:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.loss.active\njulia> result.branch.power.loss.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The capacitive susceptances of the branch lead to reactive power injection. We can obtain the total reactive power injected by the branch using the following equation:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    Q_textchij = b_textsi (alpha_ijbarV_i^2 - barV_j^2) (ij) in mathcalE","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"We can retrieve the injected reactive powers using the following Julia command:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.shunt.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#acPostprocessingAnalysisGenerator","page":"In-depth Power Flow Analysis","title":"Generator","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To obtain the output active power of a generator located at bus i in mathcalN_textpv, the given active power in the input data is used. If there are multiple generators at the same bus, their output active powers are also equal to the active powers specified in the input data. The output active power of the generator at the slack bus is determined as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_textgi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"If there are several generators at the slack bus, the active power P_textgi assigned to the first generator in the list of input data is reduced by the output active power of the other generators.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The output reactive power of a generator at the bus is given by:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    Q_textgi = Q_i + Q_textdi i in mathcalN_textpv cup mathcalN_textsb","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"If multiple generators are present, the reactive power is distributed proportionally between the generators based on their capabilities. ","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"To retrieve the output active and reactive powers of the generators in the solved power flow, the following Julia code can be used:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.generator.power.active\njulia> result.generator.power.reactive","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#inDepthDCPowerFlowSolution","page":"In-depth Power Flow Analysis","title":"DC Power Flow Solution","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"As discussed in section In-depth DC Model, the DC power flow problem can be represented by a set of linear equations given by:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  mathbf P = mathbfB bm theta + mathbfP_textgs + mathbfP_textsh","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#Implementation","page":"In-depth Power Flow Analysis","title":"Implementation","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"JuliaGrid offers a set of functions to solve the DC power flow problem and obtain the bus voltage angles. Firstly, the power system is loaded and the DC model is built using the following code sequence:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")\ndcModel!(system)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Next, the DC power flow solution is obtained through a non-iterative approach by solving the linear equation:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    bm theta = mathbfB^-1(mathbf P - mathbfP_textgs - mathbfP_textsh)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"result = dcPowerFlow(system)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"It is worth noting that the slack bus voltage angle is excluded from the vector bmtheta. Therefore, the corresponding elements in the vectors mathbf P, mathbfP_textgs, mathbfP_textsh, and the corresponding column of the matrix mathbfB are removed during the calculation process.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Finally, the resulting bus voltage angles are saved in a vector as follows:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.voltage.angle","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#dcPostprocessingAnalysis","page":"In-depth Power Flow Analysis","title":"DC Post-processing Analysis","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Performing the DC power flow analysis involves computing active powers associated with buses, branches, and generators. JuliaGrid offers a sequence of functions to carry out this analysis:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\n\nbus!(system, result)\nbranch!(system, result)\ngenerator!(system, result)","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#dcPostprocessingAnalysisBus","page":"In-depth Power Flow Analysis","title":"Bus","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The expression for obtaining the active power injection at bus i in mathcalN is:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"   P_i = sum_j = 1^n B_ij theta_j + P_textgsi + P_textshi i in mathcalN","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"These values can be obtained using the following code:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.injection.active","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"For the generators that supply bus i in mathcalN_textpv, their output active power is equal to the given active power in the input data. However, for the slack bus, its output active power is determined as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_textsi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where P_textdi represents the active power demanded by consumers at the slack bus. The following code can be used to obtain the active power output of a generators that supplies buses:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.supply.active","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#dcPostprocessingAnalysisBranch","page":"In-depth Power Flow Analysis","title":"Branch","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active power flowing from bus i in mathcalN of the branch can be obtained using the following equation:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_ij = cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) (ij) in mathcalE","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The corresponding JuliaGrid function to obtain these values are:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.from.active","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Similarly, the active power flowing to bus j in mathcalN of the branch can be obtained as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_ji = - P_ij (ij) in mathcalE","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The corresponding JuliaGrid function to obtain these values are:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.to.active","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#dcPostprocessingAnalysisGenerator","page":"In-depth Power Flow Analysis","title":"Generator","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active power output of a generator located at bus i in mathcalN_textpv is equal to the active power specified in the input data. If there are multiple generators at bus i in mathcalN_textpv, their active power outputs are also equal to the active power specified in the input data. However, the active power output of a generator located at the slack bus is determined as:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_textgi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"If there are multiple generators at the slack bus, the active power output of the first generator in the input data is assigned to P_textgi, and the output active power of the remaining generators is subtracted from it. The following Julia command can be used to acquire these values:","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.generator.power.active","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"tutorials/powerFlowSolution/#inDepthPowerFlowSolutionReference","page":"In-depth Power Flow Analysis","title":"References","text":"","category":"section"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"[1] A. Wood and B. Wollenberg, Power Generation, Operation, and Control, ser. A Wiley-Interscience publication. Wiley, 1996.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"[2] G. Andersson, Modelling and analysis of electric power systems, EEH-Power Systems Laboratory, Swiss Federal Institute of Technology (ETH), Zürich, Switzerland (2008).","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"[3] R. A. M. van Amerongen, \"A general-purpose version of the fast decoupled load flow,\" IEEE Trans. Power Syst., vol. 4, no. 2, pp. 760-770, May 1989.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"[4] D. P. Chassin, P. R. Armstrong, D. G. Chavarria-Miranda, and R. T. Guttromson, \"Gauss-seidel accelerated: implementing flow solvers on field programmable gate arrays,\" in Proc. IEEE PES General Meeting, 2006, pp. 5.","category":"page"},{"location":"tutorials/powerFlowSolution/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"[5] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER User’s Manual, Version 7.0. 2019.","category":"page"},{"location":"tutorials/modelACDC/#ACandDCModel","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"section"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The power system analysis commonly utilizes the unified branch model that provides linear relationships between voltages and currents. However, as the focus is on power calculations rather than current calculations, the resulting equations become nonlinear, posing challenges in solving them. Hence, to accurately analyze power systems without any approximations, we use the AC model, which is a crucial component of our framework. In contrast, to obtain a linear system of equations for various DC analyses, we introduce approximations in the unified branch model, resulting in the DC model [1].","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"A common way to describe the power system network topology is through the bus/branch model, which employs the two-port pi-model, which results in the unified branch model. The bus/branch model can be represented by a graph denoted by mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n corresponds to buses, and the set of edges mathcalE subseteq mathcalN times mathcalN represents the branches of the power network.","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/modelACDC/#ACModel","page":"AC and DC Model","title":"AC Model","text":"","category":"section"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"JuliaGrid is based on common network elements and benefits from the unified branch model to perform various analyses based on the system of nonlinear equations. To generate matrices and vectors for AC or nonlinear analysis, JuliaGrid employs the acModel! function. For instance, to apply the acModel! function to a power system stored in the case14.h5 file, the following Julia code can be executed:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/modelACDC/#ACUnifiedBranchModel","page":"AC and DC Model","title":"Unified Branch Model","text":"","category":"section"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The equivalent unified pi-model for a branch (ij) in mathcalE incident to the buses ij in mathcalN is shown in Figure 1.","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"<img src=\"../../assets/pi_model.png\" class=\"center\"/>\n<figcaption>Figure 1: The equivalent branch model, where the transformer is located at \"from\" bus end of the branch.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The branch series admittance y_ij is inversely proportional to the branch series impedance z_ij:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"    y_ij = frac1z_ij =\n    frac1r_ij + textjx_ij =\n    fracr_ijr_ij^2 + x_ij^2 - textjfracx_ijr_ij^2 + x_ij^2 = g_ij + textjb_ij","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"where r_ij is a resistance, x_ij is a reactance, g_ij is a conductance and b_ij is a susceptance of the branch. In the composite type PowerSystem, the resistances and reactances are stored as vectors in the branch variable:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.branch.parameter.resistance\njulia> system.branch.parameter.reactance","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Moreover, the acModel stores the computed branch series admittances in the PowerSystem composite type. We can access them using:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.acModel.admittance","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The branch shunt capacitive admittance (i.e. charging admittance) y_textsij at buses ij is equal to:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"y_textsij = textj b_textsij","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Note that JuliaGrid stores the total branch shunt capacitive susceptance 2b_textsij:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.branch.parameter.susceptance","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The transformer complex ratio alpha_ij is defined:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"    alpha_ij = cfrac1tau_ije^-textjphi_ij","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"where tau_ij is the transformer turns ratio, while phi_ij is the transformer phase shift angle, always located \"from\" bus end of the branch. These transformer parameters are stored as vectors:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.branch.parameter.turnsRatio\njulia> system.branch.parameter.shiftAngle","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The acModel within the PowerSystem composite type contains the computed transformer complex ratios. These values can be accessed using the following code:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.acModel.transformerRatio","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Using Kirchhoff's circuit laws, the unified branch model can be described by complex expressions:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2(y_ij + y_textsij)  -alpha_ij^*y_ij\n    -alpha_ijy_ij  y_ij + y_textsij\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The values of the terms (y_ij + y_textsij)  tau_ij^2, -alpha_ij^*y_ij, -alpha_ijy_ij, and y_ij + y_textsij can be found stored in four separate vectors, respectively:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.acModel.nodalFromFrom\njulia> system.acModel.nodalFromTo\njulia> system.acModel.nodalToFrom\njulia> system.acModel.nodalToTo","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Note, if tau_ij = 1 and phi_ij = 0 the model describes the line. In-phase transformers are defined if phi_ij = 0 and y_textsij = 0, while phase-shifting transformers are obtained if y_textsij = 0.","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/modelACDC/#ACNodalMatrix","page":"AC and DC Model","title":"System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Let us consider an example, given in Figure 2, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with admittance y_textshk.","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"<img src=\"../../assets/pi_model_example.png\" class=\"center\"/>\n<figcaption>Figure 2: The example of the system with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"According to the unified branch model each branch is described using the system of equations as follows:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_pk  barI_kp\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_pk^*y_pk\n    -alpha_pky_pk  y_pk + y_textspk\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k\n  endbmatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_kq  barI_qk\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_kq^2(y_kq + y_textskq)  -alpha_kq^*y_kq\n    -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The complex current injections at buses are:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    barI_p = barI_pk = cfrac1tau_pk^2(y_pk + y_textspk) barV_p -alpha_kq^*y_kq barV_k \n    barI_k = barI_kp + barI_kq - barI_textshk =\n    -alpha_kqy_kq barV_p + (y_kq + y_textskq) barV_k +\n    cfrac1tau_kq^2(y_kq + y_textskq) barV_k -alpha_kq^*y_kq barV_q + y_textshk barV_k \n    barI_q = barI_qk = -alpha_kqy_kq barV_k + (y_kq + y_textskq) barV_q\n  endaligned","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_p  barI_k  barI_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_kq^*y_kq  0 \n   -alpha_kqy_kq  y_kq + y_textskq + cfrac1tau_kq^2(y_kq + y_textskq) + y_textshk   -alpha_kq^*y_kq \n    0  -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Next, the system of equations for buses i=1 dots n can be written in the matrix form:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"where mathbf bar V in mathbbC^n is the vector of bus complex voltages, and mathbf bar I in mathbbC^n is the vector of complex current injections at buses.","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The matrix mathbfY = mathbfG + textjmathbfB in mathbbC^n times n is the bus or nodal admittance matrix, with elements:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nY_ii = G_ii + textjB_ii = y_textshi +\nsumlimits_e in mathcalE  e(1) = i cfrac1tau_ij^2(y_ij + y_textsij) + sumlimits_e in mathcalE  e(2) = i (y_ij + y_textsij)\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nY_ij = G_ij + textjB_ij = -alpha_ij^*y_ij\nY_ji = G_ji + textjB_ji =  -alpha_ijy_ij","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix mathbfY is equal to zero. The nodal admittance matrix mathbfY is a sparse (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix mathbfY is symmetrical, it is not a general case, for example, in the presence of phase shifting transformers the matrix mathbfY is not symmetrical [2, Sec. 9.6]. JuliaGrid stores both the matrix mathbfY and its transpose mathbfY^T in the acModel variable of the PowerSystem composite type: ","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.acModel.nodalMatrix\njulia> system.acModel.nodalMatrixTranspose","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/modelACDC/#DCModel","page":"AC and DC Model","title":"DC Model","text":"","category":"section"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The DC model is obtained by linearisation of the nonlinear model, and it provides an approximate solution. In the typical operating conditions, the difference of bus voltage angles between adjacent buses (ij) in mathcalE is very small theta_i-theta_j approx 0, which implies cos theta_ijapprox 1 and sin theta_ij approx theta_ij. Further, all bus voltage magnitudes are V_i approx 1, i in mathcalN, and all shunt susceptance elements and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers. Therefore, the DC power flow takes only bus voltage angles bm theta as variables. To create vectors and matrices related to DC or linear analyses, JuliaGrid uses the function dcModel!, for example:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"system = powerSystem(\"case14.h5\")\ndcModel!(system)","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/modelACDC/#DCUnifiedBranchModel","page":"AC and DC Model","title":"Unified Branch Model","text":"","category":"section"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"According to the above assumptions, we start from the unified branch model:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"    beginbmatrix\n      barI_ij  barI_ji\n    endbmatrix = cfrac1textjx_ij\n    beginbmatrix\n      cfrac1tau_ij^2  -alpha_ij^*\n      -alpha_ij  1\n    endbmatrix\n    beginbmatrix\n      barV_i  barV_j\n    endbmatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"where barV_i = texte^textjtheta_i and barV_j = texte^textjtheta_j. Further, we have:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    barI_ij = cfrac1textjx_ij leftcfrac1tau_ij^2 texte^textjtheta_i -\n    cfrac1tau_ije^textj(phi_ij + theta_j) right \n    barI_ji = cfrac1textjx_ij left-cfrac1tau_ije^textj(theta_i - phi_ij) + texte^textjtheta_j right\n  endaligned","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The active power flows are derived as follows:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    P_ij = RebarV_ibarI_ij^* =\n    Re lefttextjcfrac1x_ij\n    leftcfrac1tau_ij^2 - cfrac1tau_ije^textj(theta_i - theta_j - phi_ij) right  right \n    P_ji = RebarV_jbarI_ji^* =\n    Re lefttextjcfrac1x_ij\n   left1-cfrac1tau_ije^textj(-theta_i +theta_j + phi_ij) right  right\n  endaligned","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The real components are:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    P_ij =cfrac1tau_ijx_ij sin(theta_i -theta_j-phi_ij) approx cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) \n    P_ji =cfrac1tau_ijx_ij sin(theta_j -theta_i+phi_ij) approx -cfrac1tau_ij x_ij (theta_i - theta_j-phi_ij)\n  endaligned","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"where 1(tau_ij x_ij) represents the branch admittance in the DC framework. To recall, the PowerSystem composite type stores the reactances as vectors in the branch variable: ","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.branch.parameter.reactance","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Furthermore, the computed branch admittances in the DC framework are stored in:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.dcModel.admittance","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"We can conclude that P_ij=-P_ji holds. With the DC model, the linear network equations relate active powers to bus voltage angles, versus complex currents to complex bus voltages in the AC model [3]. Consequently, analogous to the unified branch model we can write:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix = cfrac1tau_ijx_ij\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix + cfracphi_ijtau_ijx_ij\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/modelACDC/#DCNodalMatrix","page":"AC and DC Model","title":"System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"As before, let us consider an example of the DC framework, given in Figure 3, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with conductance g_textshk.","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"<img src=\"../../assets/dc_model.png\" class=\"center\"/>\n<figcaption>Figure 3: The example of the system with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Each branch in the DC framework is described with a system of equations as follows:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_pk  P_kp\n  endbmatrix = cfrac1tau_pkx_pk\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k\n  endbmatrix + cfracphi_pktau_pkx_pk\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_kq  P_qk\n  endbmatrix = cfrac1tau_kqx_kq\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_k  theta_q\n  endbmatrix + cfracphi_kqtau_kqx_kq\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The active power injections at buses are:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    P_p = P_pk =cfrac1tau_pkx_pk theta_p - cfrac1tau_pkx_pk theta_k - cfracphi_pktau_pkx_pk \n    P_k = P_kp + P_kq - P_textshk = -cfrac1tau_pkx_pk theta_p + cfrac1tau_pkx_pk theta_k + cfracphi_pktau_pkx_pk +\n    cfrac1tau_kqx_kq theta_k - cfrac1tau_kqx_kq theta_q - cfracphi_kqtau_kqx_kq + g_textshk \n    P_q = P_qk = -cfrac1tau_kqx_kq theta_k +cfrac1tau_kqx_kq theta_q + cfracphi_kqtau_kqx_kq\n  endaligned","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Note that the active power injected by the shunt element at the bus i in mathcalN is equal to:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  P_textshi = RebarV_ibarI_textshi^* = Re-barV_iy_textshi^*barV_i^* = - g_textshi","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_p  P_k  P_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pkx_pk  - cfrac1tau_pkx_pk  0 \n    -cfrac1tau_pkx_pk  cfrac1tau_pkx_pk + cfrac1tau_kqx_kq   -cfrac1tau_kqx_kq \n    0  -cfrac1tau_kqx_kq cfrac1tau_kqx_kq\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k  theta_q\n  endbmatrix +\n  beginbmatrix\n    - cfracphi_pktau_pkx_pk  cfracphi_pktau_pkx_pk - cfracphi_kqtau_kqx_kq  cfracphi_kqtau_kqx_kq\n  endbmatrix +\n  beginbmatrix\n    0  g_textshk  0\n  endbmatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"Next, the system of equations for i=1dotsn can be written in the matrix form:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"  mathbf P = mathbfB bm theta + mathbfP_textgs + mathbfP_textsh","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"where bm theta in mathbbR^n is the vector of bus voltage angles.","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The vector mathbf P in mathbbR^n contains active power injections at buses caused by generators and demands. In JuliaGrid, the vector can be recovered using a command:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.bus.supply.active - system.bus.demand.active","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The vector mathbfP_textgs in mathbbR^n represents active powers related to the non-zero shift angle of transformers. This vector is stored in the dcModel variable, and we can access it using:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.dcModel.shiftActivePower","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The vector mathbfP_textsh in mathbbR^n represents active powers consumed by shunt elements. We can access this vector using:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.bus.shunt.conductance","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The bus or nodal matrix in the DC framework is given as mathbfB in mathbbC^n times n, with elements:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nB_ii = sumlimits_e in mathcalE i in e cfrac1tau_ijx_ij\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nB_ij = -cfrac1tau_ijx_ij\nB_ji = -cfrac1tau_ijx_ij","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"The sparse nodal matrix mathbfB is stored in the dcModel variable, and we can access it using:","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"julia> system.dcModel.nodalMatrix","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/modelACDC/#ACandDCModelReference","page":"AC and DC Model","title":"References","text":"","category":"section"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"[1] G. Andersson, Power system analysis, EEH-Power Systems Laboratory, ETH Zurich, Lecture Notes 2012.","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"[2] J. Grainger and W. Stevenson, Power system analysis, ser. McGraw-Hill series in electrical and computer engineering: Power and energy. McGraw-Hill, 1994.","category":"page"},{"location":"tutorials/modelACDC/","page":"AC and DC Model","title":"AC and DC Model","text":"[3] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER User’s Manual, Version 7.0. 2019.","category":"page"},{"location":"#JuliaGrid","page":"Introduction","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver, and allows a variety of display and manipulation options.","category":"page"}]
}
