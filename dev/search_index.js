var documenterSearchIndex = {"docs":
[{"location":"man/estimation/#runse-1","page":"State Estimation","title":"State Estimation","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"To solve the state estimation problem three different modules are available:","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"non-linear state estimation,\nlinear DC state estimation,\nlinear state estimation with PMUs only.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"By default settings, the state estimation algorithms use the weighted least-squares estimation, but it is also possible to use the least absolute value estimation.  ","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The non-linear state estimation is implemented using the following features:","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"the state vector is given in the polar coordinate system,\nphasor measurements are given in the polar coordinate system,\nmeasurement errors are uncorrelated,\nthe slack bus is included in the state estimation formulation.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The linear state estimation with PMUs is implemented using the following features:","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"the state vector is given in the rectangular coordinate system,\nphasor measurements are transformed from polar to rectangular coordinates,\nthe covariance matrix is transformed from polar to rectangular coordinates,\nthe slack bus is not included in the state estimation formulation.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Besides state estimation algorithms, we have implemented the bad data processing using the largest normalized residual test. The routine proceeds with bad data analysis after the estimation process is finished, in the repetitive process of identifying and eliminating bad data measurements one after another.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The observability analysis with the identification of observable islands and observability restoration can be done using numerical or topological methods, where pseudo-measurements are chosen in place of measurements that are marked as out-of-service in the input DATA.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"man/estimation/#Run-Settings-1","page":"State Estimation","title":"Run Settings","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Input arguments of the function runse() describe the state estimation settings. The order of inputs and their appearance is arbitrary, with onlyÂ DATA input required. Still, for the methodological reasons, the syntax examples follow a certain order.","category":"page"},{"location":"man/estimation/#Syntax-1","page":"State Estimation","title":"Syntax","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"runse(DATA, METHOD)\nrunse(DATA, METHOD, ROUTINE)\nrunse(DATA, METHOD, ROUTINE, DISPLAY)\nrunse(DATA, METHOD, ROUTINE, DISPLAY; ATTACH)\nrunse(DATA, METHOD, ROUTINE, DISPLAY; ATTACH, SAVE)","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#Description-1","page":"State Estimation","title":"Description","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"runse(DATA, METHOD) solves the state estimation problem\nrunse(DATA, METHOD, ROUTINE) sets the least absolute values estimation, bad data and observability analysis\nrunse(DATA, METHOD, LAVBAD, DISPLAY) shows results in the terminal\nrunse(DATA, METHOD, LAVBAD, DISPLAY; ATTACH) sets various options mostly related with ROUTINE\nrunse(DATA, METHOD, LAVBAD, DISPLAY; ATTACH, SAVE) exports results data","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#Output-1","page":"State Estimation","title":"Output","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"results, measurements, system, info = runse() returns results, measurements, power system and summary data","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#Examples-1","page":"State Estimation","title":"Examples","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"julia> results, = runse(\"case14se.xlsx\", \"dc\", \"main\", \"estimate\", \"error\", \"flow\")","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"julia> results, = runse(\"case30se.h5\", \"dc\", \"estimate\"; bad = [\"pass\" 2])","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"julia> results, = runse(\"case14se.xlsx\", \"pmu\", \"estimate\", \"lav\")","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"julia> data = runmg(\"case14.h5\"; runflow = 1, pmuset = \"complete\", pmuvariance = [\"complete\" 1e-4])\njulia> results, = runse(data, \"pmu\", \"estimate\")","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"julia> data = runmg(\"case14.h5\"; runflow = 1, legacyset = [\"redundancy\" 1.4], legacyvariance = [\"complete\" 1e-4])\njulia> results = runse(data, \"dc\"; observe = [\"islandBP\" \"pivot\" 1e-6 \"Pi\" 1e4])","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"man/estimation/#Input-Arguments-1","page":"State Estimation","title":"Input Arguments","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The state estimation function runse() receives a group of variable number of arguments: DATA, METHOD, ROUTINE and DISPLAY, and group of arguments by keyword: ATTACH and SAVE.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#DATA-Variable-Argument-1","page":"State Estimation","title":"DATA - Variable Argument","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Example Description\n\"case30se.h5\" loads the state estimation data from the package\n\"case14se.xlsx\" loads the state estimation data from the package\n\"C:/case14.xlsx\" loads the state estimation data from a custom path\noutput from runmg() loads the state estimation data from the measurement generator function","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#METHOD-Variable-Argument-1","page":"State Estimation","title":"METHOD - Variable Argument","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Command Description\n\"nonlinear\" runs the non-linear state estimation based on the weighted least-squares, default setting\n\"pmu\" runs the linear weighted least-squares state estimation only with PMUs where measurement covariances are neglected\n\"dc\" runs the linear weighted least-squares DC state estimation","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#ROUTINE-Variable-Argument-1","page":"State Estimation","title":"ROUTINE - Variable Argument","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Command Description\n\"lav\" runs the non-linear or linear state estimation using the least absolute value estimation with \"GLPK\" solver as default settings (see ATTACH to change default settings)\n\"bad\" runs the bad data processing for the weighted least-squares method, where the bad data identification threshold is set to \"threshold\" = 3, with the maximum number of \"passes\" = 1, where the critical measurement criteria is equal to \"critical\" = 1e-10 (see ATTACH to change default settings)\n\"observe\" runs the observability analysis where identification of the observable islands is accomplished by the topological method, while the observability restoration is performed using numerical method with zero pivot threshold equal to \"pivot\" = 1e-10, where the restore routine takes only power injection measurements with variances in per-unit \"Pi\" = 1e5 (see ATTACH to change default settings)","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#DISPLAY-Variable-Argument-1","page":"State Estimation","title":"DISPLAY - Variable Argument","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Command Description\n\"main\" shows main bus data display\n\"flow\" shows power flow data display\n\"estimate\" shows estimation data display\n\"error\" shows evaluation data display","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#ATTACH-Keyword-Argument-1","page":"State Estimation","title":"ATTACH - Keyword Argument","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"ATTACH: Least Absolute Value Estimation Method\nCommand lav = solver\nDescription the least absolute value estimation can be run using \"GLPK\" or \"Ipopt\" optimization solver, default setting: lav = \"GLPK\"","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"ATTACH: Bad Data Processing\nCommand bad = [\"pass\" value \"threshold\" value \"critical\" value]\nDescription when using the weighted least-squares method bad data processing can be run using the bad data identification threshold, with the maximum number of passes, where critical measurements are marked according to value, default setting: bad = [\"pass\" 1 \"threshold\" 3 \"critical\" 1e-10]","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"ATTACH: Observability Analysis\nCommand observe = [... \"islandBP\" \"islandMax\" value \"islandBreak\" value \"islandStopping\" value \"islandTreshold\" value ...]\nDescription determination of the maximal observable islands is done using the Gaussian belief propagation method, where the maximal number of iterations of the Gaussian belief propagation algorithm is equal to \"islandMax\" value, while the algorithm begins to apply \"islandStopping\" value criterion after \"islandBreak\" value iterations; if the state variable marginal variance is below \"islandTreshold\" value, the state variable is observable, otherwise the state variable is unobservable, default setting: observe = [\"islandMax\" 2000 \"islandBreak\" 10 \"islandStopping\" 1.0 \"islandTreshold\" 1e5]","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"ATTACH: Observability Analysis\nCommand observe = [... \"flow\" ...]\nDescription the keyword \"flow\" allows the determination of the flow observable islands only","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"ATTACH: Observability Analysis\nCommand observe = [\"pivot\" value \"Pij\" value \"Pi\" value \"Ti\" value]\nDescription determination of the maximal observable islands is done using the topological method, while the observability restoration can be run using the zero pivot identification threshold, where active power flow \"Pij\" value, active power injection \"Pi\" value and/or bus voltage angle \"Ti\" value can be forced to restore observability, with measurement variances equal to values, default setting: observe = [\"pivot\" 1e-10 \"Pi\" 1e5]","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"ATTACH: Observability Analysis\nCommand observe = [... \"restoreBP\" \"restoreMax\" value \"Pi\" value ...]\nDescription the observability restoration is done using the Gaussian belief propagation method, where the maximal number of iterations of the Gaussian belief propagation algorithm is equal to \"restoreMax\" value, and active power injection \"Pi\" value can be forced to restore observability, with measurement variances equal to values, default setting: observe = [\"restoreBP\" \"restoreMax\" 100 \"Pi\" 1e5]","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"ATTACH: Linear System Solver\nCommand solve = solver\nDescription runs the linear system solver using built-in solve = \"builtin\" as default setting or LU linear system solver solve = \"lu\"","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"ATTACH: Covariance Matrix for the Linear State Estimation with PMUs\nCommand covarinace = 1\nDescription sets the covariance matrix model for the linear state estimation with PMUs where the matrix contains measurement variances and covariances","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#SAVE-Keyword-Argument-1","page":"State Estimation","title":"SAVE - Keyword Argument","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Command Description\nsave = \"path/name.h5\" saves results in the h5-file\nsave = \"path/name.xlsx\" saves results in the xlsx-file","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"man/estimation/#Input-Data-Structure-1","page":"State Estimation","title":"Input Data Structure","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The function supports two input types: .h5 or .xlsx file extensions. The measurement input data structure consists of variables pmuVoltage and pmuCurrent associated with phasor measurements, and legacyFlow, legacyCurrent, legacyInjection and legacyVoltage associated with legacy measurements. Further, the function requires knowledge about a power system using variables bus, branch, generator and basePower.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The minimum amount of information within an instance of the data structure required to run the module requires one variable associated with measurements, bus and branch variables.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"We advise the reader to read the sections Power System Data Structure and Measurement Data Structure which provides the structure of the input DATA, with numerous examples given in the section Use Cases.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"man/estimation/#Output-Data-Structure-1","page":"State Estimation","title":"Output Data Structure","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The state estimation function runse() returns a struct variable results with fields main, flow, estimate, error, baddata and observability containing state estimation analysis results. Further, the variables measurements and system contain the measurement and power system data, while the variable info contains a basic summary.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#DC-State-Estimation-1","page":"State Estimation","title":"DC State Estimation","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"We define the main electrical quantities generated by the JuliaGrid in the section DC Power Flow Analysis.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The main data structure contains results related to the bus.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Column Description Unit\n1 bus number defined as positive integer \n2 voltage angle deg\n3 active power injection MW","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The flow data structure contains results related to the branch.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Column Description Unit\n1 branch number defined as positive integer \n2 from bus number defined as positive integer \n3 to bus number defined as positive integer \n4 from bus active power flow MW\n5 to bus active power flow MW","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#Non-linear-and-Linear-State-Estimation-with-PMUs-1","page":"State Estimation","title":"Non-linear and Linear State Estimation with PMUs","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"We define main electrical quantities generated by the JuliaGrid in the section AC Power Flow Analysis.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The main data structure contains results related to the bus.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Column Description Unit\n1 bus number defined as positive integer \n2 voltage magnitude per-unit\n3 voltage angle deg\n4 active power injection MW\n5 reactive power injection MVAr\n6 active power consumed by the shunt conductance MW\n7 reactive power consumed by the shunt susceptance MVAr","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The flow data structure contains results related to the branch.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Column Description Unit\n1 branch number defined as positive integer \n2 from bus number defined as positive integer \n3 to bus number defined as positive integer \n4 from bus active power flow MW\n5 from bus reactive power flow MVAr\n6 to bus active power flow MW\n7 to bus reactive power flow MVAr\n8 total branch reactive power injection MVAr\n9 active power loss at the series impedance MW\n10 reactive power loss at the series impedance MVAr\n11 from bus current magnitude per-unit\n12 from bus current angle deg\n13 to bus current magnitude per-unit\n14 to bus current angle deg","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#State-Estimation-1","page":"State Estimation","title":"State Estimation","text":"","category":"section"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The estimate data structure contains summary of the state estimation analysis. The data is printed descriptively when displayed using a terminal, while the exported results are encoded with numeric values. Measurements that are marked as bad-measurement can only appear if the bad data analysis has been run, similarly pseudo-measurements occur if observability analysis is running.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Column Description\n1 row number defined as positive integer\n2 measurement status where in-service = 1, bad-measurement = 2, pseudo-measurement = 3\n3 measurement class where legacy = 1, PMU = 2\n4 measurement type where active power flow = 1, reactive power flow = 2, active power injection = 3, reactive power injection = 4, current magnitude = 5,  current angle = 6, voltage magnitude = 7, voltage angle = 8, current real component = 9, current imaginary component = 10, voltage real component = 11, voltage imaginary component = 12\n5 local index of the measurement given in the input DATA\n6 measurement value\n7 measurement variance value\n8 estimate value\n9 residual estimate to measurement values\n10 exact value (if exists in the input DATA)\n11 residual estimate to exact values (if exact values exist)","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The error data structure contains different error metrics which are calculated in the per-unit system. Note that only in-service and pseudo-measurement values are included, respectively bad-measurements are not included.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Column Description\n1 mean absolute error of the estimate and corresponding measurement values\n2 root mean square error of the estimate and corresponding measurement values\n3 weighted residual sum of squares error of the estimate and corresponding measurement values\n4 mean absolute error  of the estimate and corresponding exact values (if exact values exist)\n5 root mean square error of the estimate and corresponding exact values (if exact values exist)\n6 weighted residual sum of squares error of the estimate and corresponding exact values (if exact values exist)","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The baddata data structure contains information about bad data analysis. Note that if the bad data measurement corresponds with critical measurement, this measurement is skipped, and one of the next, with the highest normalized residual, is marked as the bad data in the same pass.","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Column Description\n1 pass of weighted least-squares method, where in each pass suspected bad data is eliminated\n2 bad measurement class where legacy = 1, PMU = 2\n3 measurement type where active power flow = 1, reactive power flow = 2, active power injection = 3, reactive power injection = 4, current magnitude = 5,  current angle = 6, voltage magnitude = 7, voltage angle = 8, current real component = 9, current imaginary component = 10, voltage real component = 11, voltage imaginary component = 12\n4 local index of the bad measurement given in the input DATA\n5 normalized residual value of the bad data measurement\n6 measurement status where bad-measurement = 2","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"The observability data structure contains information about flow islands and pseudo-measurements, where each flow island is formed by buses. Pseudo-measurements are also marked in the estimate variable.  ","category":"page"},{"location":"man/estimation/#","page":"State Estimation","title":"State Estimation","text":"Column Description\n1 flow island as positive integer\n2 bus number in the corresponding island\n3 pseudo-measurement class where legacy = 1, PMU = 2\n4 measurement type where active power flow = 1, reactive power flow = 2, active power injection = 3, reactive power injection = 4, current magnitude = 5,  current angle = 6, voltage magnitude = 7, voltage angle = 8, current real component = 9, current imaginary component = 10, voltage real component = 11, voltage imaginary component = 12\n5 local index of the pseudo-measurement given in the input DATA\n6 pseudo-measurement value\n7 pseudo-measurement variance","category":"page"},{"location":"man/input/#inputdata-1","page":"Input Data","title":"Input Data","text":"","category":"section"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"JuliaGrid supports two input types: .h5 or .xlsx file extensions, where to describe a power system using the same input data structure as Matpower, except for the first column in the branch data. Note that, in the case of large-scale systems, we strongly recommend to use the .h5 extension for the input as well as the output data.   ","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"To generate the power system input data in the .h5 format, we provide two scripts:","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"convert the Matpower input data file: MATLAB script;\nconvert a custom user input data: Julia script.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"","category":"page"},{"location":"man/input/#powersysteminputdata-1","page":"Input Data","title":"Power System Data Structure","text":"","category":"section"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The basic input data structure used to describe a power system consists of variables bus, branch, generator, generatorcost, and basePower. We define the system base power in MVA using basePower variable. Next, we describe the structure of other variables involved in the input data.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The bus input data is used for all analysis available in the JuliaGrid package. Each row in the bus data describes a corresponding bus, where bus numbers can take arbitrary positive integer values. However, for large-scale power systems, we strongly recommend using an ordered set of ascending positive integer values to label buses.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 bus number defined as positive integer \n2 bus type where PQ = 1, PV = 2, slack = 3 \n3 active power demand MW\n4 reactive power demand MVAr\n5 shunt conductance as active power demand at voltage magnitude equal to one per-unit MW\n6 shunt susceptance as reactive power demand at voltage magnitude equal to one per-unit MVAr\n7 area number defined as positive integer \n8 initial voltage magnitude per-unit\n9 initial voltage angle deg\n10 base voltage magnitude kV\n11 loss zone defined as positive integer \n12 minimum voltage magnitude per-unit\n13 maximum voltage magnitude per-unit","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"&nbsp;","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The branch input data is also used for all analysis available in the JuliaGrid package, where each row in the branch data describes a corresponding branch. The branch number can take arbitrary positive integer values, but we recommend to use an ordered set of ascending positive integer values. Note that, ''from bus'' and ''to bus'' positive integers must be harmonized with the bus numbers defined in the bus data.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 branch number defined as positive integer \n2 from bus number defined as positive integer \n3 to bus number defined as positive integer \n4 series resistance per-unit\n5 series reactance per-unit\n6 total line charging susceptance per-unit\n7 long term rating (equal to zero for unlimited) MVA\n8 short term rating (equal to zero for unlimited) MVA\n9 emergency rating (equal to zero for unlimited) MVA\n10 transformer off-nominal turns ratio, equal to zero for a line \n11 transformer phase shift angle where positive value defines delay deg\n12 status where in-service = 1, out-of-service = 0 \n13 minimum voltage angle difference between from and to buses deg\n14 maximum voltage angle difference between from and to buses deg","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"&nbsp;","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The generator input data is mandatory only for the optimal power flow routines, where each row in the generator data describes a corresponding generator. Also, bus numbers in the generator data must be harmonized with bus numbers in the bus data, where each bus can contain any number of generators.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 bus number defined as positive integer \n2 active power generation MW\n3 reactive power generation MVAr\n4 maximum reactive power generation MVAr\n5 minimum reactive power generation MVAr\n6 voltage magnitude setpoint per-unit\n7 base power MVA\n8 status where in-service = 1, out-of-service = 0 \n9 maximum active power generation MW\n10 minimum active power generation MW\n11 lower active power output of PQ capability curve MW\n12 upper active power output of PQ capability curve MW\n13 minimum reactive power output at PC1 MVAr\n14 maximum reactive power output at PC1 MVAr\n15 minimum reactive power output at PC2 MVAr\n16 maximum reactive power output at PC2 MVAr\n17 ramp rate for load following/AGC MW/min\n18 ramp rate for 10-minute reserves MW\n19 ramp rate for 30-minute reserves MW\n20 ramp rate for reactive power (two seconds timescale) MVAr/min\n21 area participation factor defined as positive integer ","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"&nbsp;","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The generatorcost input data is also mandatory only for the optimal power flow routines. The number of generatorcost rows n_texttextgc must be harmonized with number of generator rows n_textg, as follows:","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"if n_textgc = n_textg, then each row in the generatorcost contains active power costs produced by the corresponding generator in the generator data;\nif n_textgc = 2n_textg, then the first n_textg rows in the generatorcost contain active power costs produced by the corresponding generator in the generator data, and next n_textg rows (i.e., n_textg + 1 through 2n_textg) in the generatorcost contains reactive power costs produced by the corresponding generator in the generator data.  ","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"JuliaGrid supports piecewise linear and polynomial generator cost functions:","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"piecewise linear cost function is defined according to input-output points:\nactive power: (P_textmin f(P_textmin)), dots, (P_textmax f(P_textmax));\nreactive power: (Q_textmin f(Q_textmin)), dots, (Q_textmax f(Q_textmax));  \npolynomial cost functions is defined using the n-th degree polynomial:\nactive power: f(P) = a_nP^n + dots + a_1P + a_0;  \nreactive power: f(Q) = b_nQ^n + dots + b_1Q + b_0.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 active or reactive power cost model defined as piecewise linear = 1, polynomial = 2 \n2 active or reactive power startup cost currency\n3 active or reactive power shutdown cost currency\n4 number of data points for a piecewise linear cost function, or coefficients for a polynomial cost function ","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"If the piecewise linear cost function is selected, then:","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n5 active output power P_textmin or reactive output power Q_textmin MW or MVAr\n6 active input power  f(P_textmin) or reactive input power  f(Q_textmin) currency/hr\n...  \nn-1 active output power P_textmax or reactive output power Q_textmax MW or MVAr\nn active input power  f(P_textmax) or reactive input power  f(Q_textmax) currency/hr","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"If the polynomial cost function is selected, then:","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n5 active power cost function coefficient  a_n or reactive power cost function coefficient  b_n \n...  \nn-1 active power cost function coefficient  a_1 or reactive power cost function coefficient  b_1 \nn active power cost function coefficient  a_0 or reactive power cost function coefficient  b_0 ","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"","category":"page"},{"location":"man/input/#measurementinputdata-1","page":"Input Data","title":"Measurement Data Structure","text":"","category":"section"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The measurement input data structure consists of variables pmuVoltage and pmuCurrent associated with phasor measurements, and legacyFlow, legacyCurrent, legacyInjection and legacyVoltage associated with legacy measurements.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"In general, the measurement input data is used for the state estimation routines and measurement generator, where each measurement set needs not to be consistent with the total number of buses and branches. Also, JuliaGrid supports more than one measurement of the same type per bus or branch.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"When the corresponding measurement is defined, then a bus number or branch number must be harmonized with a bus number or branch number in the bus and branch input data. Next, we describe the structure of measurement variables included in the input data file.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The pmuVoltage data structure describes bus voltage phasor measurements, where voltage phasors are measured in the polar coordinate system. The optional column PMU number is used only by the measurement generator function runmg(), and it is useful if several PMUs exist on a single bus.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 bus number defined as positive integer \n2 voltage magnitude measurement value per-unit\n3 voltage magnitude measurement variance per-unit\n4 voltage magnitude measurement status where in-service = 1, out-of-service = 0 \n5 bus voltage angle measurement value radian\n6 bus voltage angle measurement variance radian\n7 voltage angle measurement status where in-service = 1, out-of-service = 0 \n8 voltage magnitude exact value, optional column for the state estimation per-unit\n9 voltage angle exact value, optional column for the state estimation radian\n10 PMU number defined as positive integer, optional column for the state estimation ","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"&nbsp;","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The pmuCurrent data structure describes branch current phasor measurements, where current phasors are measured in the polar coordinate system. Here, each PMU number should be harmonized with PMU numbers in the variable pmuVoltage.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 branch number defined as positive integer \n2 from bus number defined as positive integer \n3 to bus number defined as positive integer \n4 current magnitude measurement value per-unit\n5 current magnitude measurement variance per-unit\n6 current magnitude measurement status where in-service = 1, out-of-service = 0 \n7 current angle measurement value radian\n8 current angle measurement variance radian\n9 current angle measurement status where in-service = 1, out-of-service = 0 \n10 current magnitude exact value, optional column for the state estimation per-unit\n11 current angle exact value, optional column for the state estimation radian\n12 PMU number defined as positive integer, optional column for the state estimation ","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"&nbsp;","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The legacyFlow data structure describes active and reactive power flow measurements.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 branch number defined as positive integer \n2 from bus number defined as positive integer \n3 to bus number defined as positive integer \n4 active power flow measurement value per-unit\n5 active power flow measurement variance per-unit\n6 active power flow measurement status where in-service = 1, out-of-service = 0 \n7 reactive power flow measurement value per-unit\n8 reactive power flow measurement variance per-unit\n9 reactive power flow measurement status where in-service = 1, out-of-service = 0 \n10 active power flow exact value, optional column for the state estimation per-unit\n11 reactive power flow exact value, optional column for the state estimation per-unit","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"&nbsp;","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The legacyCurrent data structure describes branch current magnitude measurements.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 branch number defined as positive integer \n2 from bus number defined as positive integer \n3 to bus number defined as positive integer \n4 current magnitude measurement value per-unit\n5 current magnitude measurement variance per-unit\n6 current magnitude measurement status where in-service = 1, out-of-service = 0 \n7 current magnitude exact value, optional column for the state estimation per-unit","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"&nbsp;","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The legacyInjection data structure describes bus active and reactive injection measurements.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 bus number defined as positive integer \n2 active power injection measurement value per-unit\n3 active power injection measurement variance per-unit\n4 active power injection measurement status where in-service = 1, out-of-service = 0 \n5 reactive power injection measurement value per-unit\n6 reactive power injection measurement variance per-unit\n7 reactive power injection measurement status where in-service = 1, out-of-service = 0 \n8 active power injection exact value, optional column for the state estimation per-unit\n9 reactive power injection exact value, optional column for the state estimation per-unit","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"&nbsp;","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The pmuVoltage data structure describes bus voltage magnitude measurements.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Column Description Unit\n1 bus number defined as positive integer \n2 voltage magnitude measurement value per-unit\n3 voltage magnitude measurement variance per-unit\n4 voltage magnitude measurement status where in-service = 1, out-of-service = 0 \n5 voltage magnitude exact value, optional column for the state estimation per-unit","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"","category":"page"},{"location":"man/input/#usecases-1","page":"Input Data","title":"Use Cases","text":"","category":"section"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The pre-defined power system data are located in the src/data as the .h5 or .xlsx files.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Case Grid Bus Shunt Generator Branch\ncase3 transmission 3 0 1 3\ncase5 transmission 5 0 5 6\ncase5nptel transmission 5 0 1 7\ncase6 transmission 6 0 2 7\ncase6wood transmission 6 0 3 11\ncase9 transmission 9 0 3 9\ncase14 transmission 14 1 5 20\ncase_ieee30 transmission 30 2 6 41\ncase30 transmission 30 2 15 45\ncase47 distribution 47 4 5 46\ncase84 distribution 84 0 0 96\ncase118 transmission 118 14 54 186\ncase300 transmission 300 29 69 411\ncase1354pegase transmission 1354 1082 260 1991\ncase_ACTIVSg2000 transmission 2000 149 544 3206\ncase_ACTIVSg10k transmission 10000 281 2485 12706\ncase_ACTIVSg70k transmission 70000 3477 10390 88207","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"&nbsp;","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"The pre-defined power system and measurement data are located in the src/data as the .h5 or .xlsx files.","category":"page"},{"location":"man/input/#","page":"Input Data","title":"Input Data","text":"Case Grid Bus Shunt Generator Branch Phasor Measurement Legacy Measurement\ncase14se transmission 14 1 5 20 70 81\ncase30se transmission 30 2 15 45 72 206","category":"page"},{"location":"man/tbbranch/#networkequationpage-1","page":"Network Equations","title":"Network Equations","text":"","category":"section"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"Network equations obtained using the unified branch model and defined below represent the basic setup used for the power system analysis. The power system network topology is usually described by the bus/branch model, where branches of the network are defined using the two-port pi-model. The bus/branch model can be represented using a graph mathcalG =(mathcalHmathcalE), where the set of nodes mathcalH = 1dotsn   represents the set of buses, while the set of edges mathcalE subseteq mathcalH times mathcalH represents the set of branches of the power network, shown in Figure 1.","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"<img src=\"../../assets/bus_branch.png\" class=\"center\"/>\n<figcaption>Figure 1: An example of the power system bus/branch model.</figcaption>","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"","category":"page"},{"location":"man/tbbranch/#branchmodel-1","page":"Network Equations","title":"Branch Model","text":"","category":"section"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"The equivalent unified pi-model for a branch, shown in Figure 2, is sufficient to describe all main equations related to the power system.","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"<img src=\"../../assets/pi_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The equivalent branch model, where transformer is located at \"from bus end\" of the branch.</figcaption>\n&nbsp;","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"In Figure 2, ij in mathcalH denotes buses, where, in power networks the bus represents elements such as a generator, load, substation, etc. The branch series admittance y_ij is inversely proportional to the branch series impedance z_ij:  ","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"    y_ij = frac1z_ij =\n    frac1r_ij + textjx_ij =\n    fracr_ijr_ij^2 + x_ij^2 - textjfracx_ijr_ij^2 + x_ij^2 = g_ij + textjb_ij","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"where r_ij is a resistance, x_ij is a reactance, g_ij is a conductance and b_ij is a susceptance of the branch. We denote a half of the total branch shunt admittance (i.e., charging admittance) as y_textsij and y_textsji, where it can be written:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"y_textsij = y_textsji = textj b_textsi = textj b_textsj\n","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"The transformer complex ratio alpha_ij is defined:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"    alpha_ij = cfrac1tau_ije^-textjphi_ij","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"where tau_ij is the transformer tap ratio magnitude, while phi_ij is the transformer phase shift angle, always located \"from bus end\" of the branch.","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"Using Kirchhoff's circuit laws, the unified branch model can be described by complex expressions:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2(y_ij + y_textsij)  -alpha_ij^*y_ij\n    -alpha_ijy_ij  y_ij + y_textsij\n  endbmatrix  \n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix    ","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"Each branch (ij) in mathcalE can be described with four parameters C_ij, D_ij, E_ij and F_ij, where the unified branch model is:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    C_ij  D_ij\n    E_ij  F_ij\n  endbmatrix  \n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix    ","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"Consequently, if tau_ij = 1 and phi_ij = 0 the model describes the line. In-phase transformers are defined if phi_ij = 0 and y_textsij = 0, while phase-shifting transformers are obtained if y_textsij = 0.","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"","category":"page"},{"location":"man/tbbranch/#injectionnodal-1","page":"Network Equations","title":"Nodal Admittance Matrix","text":"","category":"section"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"Let us consider an example, given in Figure 3, that will allow us an easy transition to the general case. We observe system with three buses and two branches, where the bus k is incident to the shunt element.","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"<img src=\"../../assets/pi_model_example.png\" class=\"center\"/>\n<figcaption>Figure 3: The example with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"JuliaGrid uses the input data where the bus incident to the transformer is always located at \"from bus end\", and accordingly, we denote other elements related to branches, as given in Table.","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"From Bus To Bus Branch Admittance Branch Shunt Admittance Transformer Ratio\np k y_pk y_textspk alpha_pk\nk q y_kq y_textskq alpha_kq","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"Before we proceed further, it would be helpful to observe sets related to the system that we use in the rest of this part:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"set of buses: mathcalH = pkq;\nset of branches: mathcalE = (pk) (kq).","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"According to the unified branch model each branch is described using the system of equations as follows:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  beginbmatrix\n    barI_pk  barI_kp\n  endbmatrix =\n  beginbmatrix\n    C_pk  D_pk\n    E_pk  F_pk\n  endbmatrix  \n  beginbmatrix\n    barV_p  barV_k\n  endbmatrix   ","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  beginbmatrix\n    barI_kq  barI_qk\n  endbmatrix =\n  beginbmatrix\n    C_kq  D_kq\n    E_kq  F_kq\n  endbmatrix  \n  beginbmatrix\n    barV_k  barV_q\n  endbmatrix    ","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"The injection complex currents into buses are:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  beginaligned\n    barI_p = barI_pk = C_pk barV_p + D_pk barV_k \n    barI_k = barI_kp + barI_kq - barI_textshk = E_pk barV_p + F_pk barV_k + C_kq barV_k + D_kq barV_q + y_textshk barV_k \n    barI_q = barI_qk = E_kq barV_k + F_kq barV_q\n  endaligned","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  beginbmatrix\n    barI_p  barI_k  barI_q\n  endbmatrix =\n  beginbmatrix\n    C_pk  D_pk  0 \n    E_pk  C_kq + F_pk + y_textshk   D_kq \n    0  E_kq  F_kq\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"Next, the system of equations for buses i=1 dots n can be written in the matrix form:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"where:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"mathbf bar I in mathbbC^n is the vector of injection complex currents with elements barI_ii=1dotsn;\nmathbf bar V in mathbbC^n is the vector of bus complex voltages with elements barV_ii=1dotsn;\nmathbfY = mathbfG + textjmathbfB in mathbbC^n times n is the bus or nodal admittance matrix, where:\nthe diagonal elements are equal to:\nY_ii = G_ii + textjB_ii =\nsumlimits_e in mathcalE  e(1) = i C_e + sumlimits_e in mathcalE  e(2) = i F_e + y_textshi   i in mathcalH\nthe strictly upper triangular part contains elements equal to:\nY_ij = G_ij + textjB_ij = D_e   e in mathcalE  i = e(1)  j = e(2)\nthe strictly lower triangular part contains elements equal to:\nY_ij = G_ij + textjB_ij = E_e   e in mathcalE  i = e(2)  j = e(1)","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix mathbfY is equal to zero. The nodal admittance matrix mathbfY is a sparse matrix (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix mathbfY is symmetrical, it is not a general case, for example, in the presence of phase shifting transformers the matrix mathbfY is not symmetrical [1, Sec. 9.6].","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"","category":"page"},{"location":"man/tbbranch/#injectionpower-1","page":"Network Equations","title":"Injection Power","text":"","category":"section"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"The apparent power injection S_i into the bus i is a function of the complex voltage barV_i at the bus i and the conjugate value of the injection complex current barI_i into the bus i:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  S_i =barV_ibarI_i^* = P_i + textjQ_i","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"where P_i and Q_i represent active and reactive power injection into the bus i. Thus, apparent injection power S_i into the bus i is:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  S_i = barV_isumlimits_j in mathcalH_i Y_ij^* barV_j^*                  ","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"where mathcalH_i contains buses incident to the bus i, including bus i.","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"Without loss of generality, we can discard the observed set mathcalH_i and observe the entire bus set, where the corresponding elements of the nodal admittance matrix mathbfY  are equal to zero if the buses are not adjacent. Then, using the polar representation for bus voltages, apparent injection power S_i is defined:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  S_i =V_isumlimits_j = 1^n V_j texte^textjtheta_ij(G_ij - textjB_ij)   ","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"where theta_ij=theta_i-theta_j is the voltage angle difference between buses i and j. Thus, the active and reactive injection power into the bus i are equal to:","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"  beginaligned\n    P_i =V_isumlimits_j=1^n V_j(G_ijcostheta_ij + B_ijsintheta_ij)\n    Q_i =V_isumlimits_j=1^n V_j(G_ijsintheta_ij - B_ijcostheta_ij)     \n\tendaligned","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"These equations represent a hybrid form which is a common form for solving power flow problems [2].","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"","category":"page"},{"location":"man/tbbranch/#refsbranch-1","page":"Network Equations","title":"References","text":"","category":"section"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"[1] J. Grainger and W. Stevenson, Power system analysis, ser. McGraw-Hill series in electrical and computer engineering: Power and energy. McGraw-Hill, 1994.","category":"page"},{"location":"man/tbbranch/#","page":"Network Equations","title":"Network Equations","text":"[2] A. Wood and B. Wollenberg, Power Generation, Operation, and Control, ser. A Wiley-Interscience publication. Wiley, 1996.","category":"page"},{"location":"man/tbestimaterest/#baddata-1","page":"State Estimation Routines","title":"Bad Data Processing","text":"","category":"section"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"We refer the reader to section State Estimation which precedes the analysis given here. Besides the state estimation algorithm, one of the essential state estimation routines is the bad data processing, whose main task is to detect and identify measurement errors, and eliminate them if possible. State Estimation algorithms proceed with the bad data processing after the estimation process is finished. This is usually done by processing the measurement residuals [1, Ch. 5], and typically, the largest normalized residual test is used to identify bad data. The largest normalized residual test is performed after the algorithm converged in the repetitive process of identifying and eliminating bad data measurements one after another [2]. The bad data processing described below is associated with the commonly used weighted least-squares methods. More precisely, state estimation methods, such as the least absolute value estimation, incorporate bad data processing as part of the state estimation procedure [1, Ch. 5].","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"This section describes the largest normalized residual test based on the residual sensitivity analysis given in [1, Sec. 5.7]. Using weighted least-squares estimation methods (non-linear or linear), we obtained the state estimator hatmathbf x and elements of the measurement residual vector:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    r_i = z_i - h_i(hatmathbf x)  i in mathcalM","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Normalized residual is defined as:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    c_i = cfracr_isqrtC_ii  i in mathcalM","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"where C_ii is the diagonal entries of the residual covariance matrix mathbf C in mathbbR^k times k. Using a residual sensitivity matrix mathbf S, which represents the sensitivity of the measurement residuals to the measurement errors, the above equation becomes:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    c_i = cfracr_isqrtS_iiR_ii  i in mathcalM","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"where:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    mathbf C = mathbf S mathbf R = mathbf R - mathbf J mathbf J^T mathbf R^-1 mathbf J^-1 mathbf J^T","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Note that only the diagonal entries of mathbf C are needed. To obtain the inverse:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    mathbf J^T mathbf R^-1 mathbf J^-1","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"the JuliaGrid package uses a computationally efficient sparse inverse method to obtain only the necessary elements of the inverse. However, if the largest normalized residual:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    c_j ge epsilon  c_j = textmax c_i i in mathcalM ","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"then the j-th measurement will be suspected as the bad data and removed from the measurement set mathcalM if possible, where epsilon is a chosen the bad data identification threshold. State estimation can be repeated after the measurement is eliminated, in order to compute the new state estimate hatmathbf x.  Thus, we have the iterative process that sequentially identifies and eliminates bad data measurements one after another.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"The elimination of measurements is possible only for the redundant measurements. Namely, the removal of critical or non-redundant measurements from the measurement set will result in an unobservable system. Furthermore, the measurement residual of a critical measurement will be always approximately equal to zero [1, Sec. 5.2]. More precisely, if the measurement residual:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    r_i le gamma  i in mathcalM","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"JuliaGrid designates the corresponding measurement as critical, where gamma is a predetermined critical measurement criteria.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"","category":"page"},{"location":"man/tbestimaterest/#lav-1","page":"State Estimation Routines","title":"Least Absolute Value Method","text":"","category":"section"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"The least absolute value method represents an alternative estimation method which is more robust as compared to the weighted least-squares. The weighted least-squares state estimation problem is formulated based on certain assumptions about the measurement errors, while robust estimators are expected to remain unbiased despite the existence of different types of measurement errors and outliers, making the bad data processing unnecessary [1, Ch. 6]. Note that there is no free lunch, robustness is commonly achieved at the expense of computational complexity.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"In the case of least absolute value method, it can be shown that the problem can be formulated as a linear programming problem, and this section describes the method given in [1, Sec. 6.5]. Let us consider the system of linear equations:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  mathbfz=mathbfh(mathbfx)+mathbfu","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"where mathbf x=x_1dotsx_s^T is the vector of the state variables, mathbfh(mathbfx)= h_1(mathbfx), dots, h_k(mathbfx)^T is the vector of linear functions, mathbfz = z_1dotsz_k^mathrmT is the vector of measurement values, and mathbfu = u_1dotsu_k^mathrmT is the vector of uncorrelated measurement errors. Then, the least absolute value state estimator hatmathbf x is defined as the solution of the optimization problem:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  beginaligned\n    textminimize  mathbf a^T mathbf r(mathbf x)\n    textsubjectto  mathbfz - mathbfJmathbfx =mathbf r(mathbf x)\n  endaligned","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"where mathbf a in mathbb R^k is the vector with all entries equal to one, mathbf J in mathbb R^k times s is the Jacobian matrix of measurement functions mathbf h (mathbf x), and mathbf r (mathbf x) is the vector of measurement residuals. Further, we define bm eta:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  mathbf r(mathbf x) preceq bm eta","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"and replace the above inequality by two equalities via the introduction of two non-negative slack variables mathbf q in mathbb R_ge 0^k and mathbf w in mathbb R_ge 0^k:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  beginaligned\n    mathbf r(mathbf x) - mathbf q = -bm eta \n    mathbf r(mathbf x) + mathbf w = bm eta\n  endaligned","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Let us now define four additional non-negative variables:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  beginaligned\n    mathbf x_y in mathbb R_ge 0^s  mathbf x_v in mathbb R_ge 0^s    \n    mathbf y in mathbb R_ge 0^k  mathbf v in mathbb R_ge 0^k\n  endaligned","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"where:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  beginaligned\n    mathbf x = mathbf x_y - mathbf x_v \n    mathbf r(mathbf x) = mathbf y - mathbf v \n    mathbf y = cfrac12 mathbf q \n    mathbf v = cfrac12 mathbf w\n  endaligned","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Then, the above two equalities become:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  beginaligned\n    mathbf r(mathbf x) - 2mathbf y = -2bm eta \n    mathbf r(mathbf x) + 2mathbf v = 2bm eta\n  endaligned","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"that is:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  beginaligned\n    mathbf y + mathbf v = bm eta  mathbf r(mathbf x) = mathbf y - mathbf v\n  endaligned","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Hence, the optimization problem can be written:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  beginaligned\n    textminimize  mathbf a^T (mathbf y + mathbf v)\n    textsubjectto  mathbfJ(mathbf x_y - mathbf x_v) + mathbf y - mathbf v = mathbfz   \n                         mathbf x_y succeq mathbf 0  mathbf x_v succeq mathbf 0 \n                         mathbf y succeq mathbf 0  mathbf v succeq mathbf 0\n  endaligned","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"This can be written in compact form as a standard linear programming problem:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  beginaligned\n    textminimize  mathbf g^T mathbf t \n    textsubjectto  mathbfA mathbft = mathbf z \n                         mathbft succeq mathbf 0\n  endaligned","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"where:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  mathbf g =\n  beginbmatrix\n    mathbf 0_s  mathbf 0_s  mathbf 1_k  mathbf 1_k\n  endbmatrix \n  mathbf t =\n  beginbmatrix\n    mathbf x_y  mathbf x_v  mathbf y  mathbf v\n  endbmatrix \n  mathbf A =\n  beginbmatrix\n    mathbfJ  -mathbfJ  mathbfE  -mathbfE\n  endbmatrix","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Here, the all-zero vector mathbf 0_s is of dimension s, the all-one vector mathbf 1_k is of dimension k and mathbfE is the identity matrix of dimension k times k. After solving the above linear programming problem, we reveal the state estimator:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    hatmathbf x = mathbf x_y - mathbf x_v","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Note that the non-linear least absolute value state estimation is based on the successive set of linear programming problems, where we reveal state variables increments:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    mathbf mathbf Delta x = mathbf mathbf Delta x_y - mathbf mathbf Delta x_v","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"","category":"page"},{"location":"man/tbestimaterest/#observability-1","page":"State Estimation Routines","title":"Observability Analysis","text":"","category":"section"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Observability analysis in power systems is commonly performed on the linear decoupled measurement model [14, Ch. 7]. Its function is to decide if the given set of measurements mathcalM is sufficient to solve the system. When the given set of measurements mathcalM is not sufficient, it must identify all the possible observable islands that can be independently solved [4].","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"The JuliaGrid uses the observability analysis with the restore routine proposed in the papers [5] and [6], where pseudo-measurements are chosen in place of measurements that are marked as out-of-service in the input data.","category":"page"},{"location":"man/tbestimaterest/#Linear-DC-State-Estimation-1","page":"State Estimation Routines","title":"Linear DC State Estimation","text":"","category":"section"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"We observe the set of measurements mathcalM in the DC framework:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Legacy measurements:\nactive power flow M_P_ij M_P_ji  (ij) in mathcalE;\nactive power injection M_P_i  i in mathcalH;\nPhasor measurements provided by PMUs:\nbus voltage angle M_theta_i  i in mathcalH.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"To recall, the measurement model can be described as:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  mathbfz=mathbf J bm theta + mathbfc + mathbfu","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"where bm theta=theta_1dotstheta_s^T is the vector of the state variables, mathbf J in mathbbR^k times s is the measurement Jacobian matrix, mathbf c in mathbb R^k is the vector of constant terms, mathbfz = z_1dotsz_k^mathrmT is the vector of measurement values, and mathbfu = u_1dotsu_k^mathrmT is the vector of uncorrelated measurement errors.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"For observability purposes, we consider the Jacobian matrix mathbf J. The network is observable if:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  textrank(mathbf J) = s","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"where the slack bus is always included in the measurement model, as well as its equation. Note that the condition provides a necessary but not sufficient condition for observability. For most power systems under normal operating conditions, observability condition will guarantee a reliable state estimate [6]. More precisely, guaranteeing observability by the condition is not the same as guaranteeing a good estimation of the system state. This is so because numerical problems may deteriorate the estimation [7].","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"If the system is unobservable:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  textrank(mathbf J)  s","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"the observability analysis must identify all the possible observable islands that can be independently solved, where an observable island is defined as follows: An observable island is a part of the power system for which the flows across all branches of the observable island can be calculated from the set of available measurements, independent of the values adopted for angular reference [3, Sec. 7.1.1]. Once the islands are determined, the observability analysis merges these islands in a way to protect previously-determined observable states from being altered by the new set of equations defined by the additional measurements. In general, this can be achieved by ensuring that the set of new measurements is a non-redundant set [3, Sec. 7.3.2],  i.e., the set of equations must be linearly independent with regard to the global system. The aim of the observability restoration is to find this non-redundant set.","category":"page"},{"location":"man/tbestimaterest/#Determination-of-Observable-Islands-1","page":"State Estimation Routines","title":"Determination of Observable Islands","text":"","category":"section"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"The JuliaGrid uses several island detection algorithms:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"the topological method based on the multi-stage procedure [11],\nthe Gaussian belief propagation based method [12].","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"The observable islands are defined only according to the power flow and the power injection measurement functions, whereby bus voltage angle measurements are ignored. The algorithms allow the identification of two types of islands on the basis of which it will be executed observability restoration. The simplest structure of the observable islands is formed using all the active power flow measurements to identify the flow islands [6]. Then, these islands can be merged using the active power injection measurements to form maximal islands as the largest region in which an unobservable system is partitioned [5].","category":"page"},{"location":"man/tbestimaterest/#Observability-Restoration-1","page":"State Estimation Routines","title":"Observability Restoration","text":"","category":"section"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"As a result, we obtain the power system divided into n_texti flow islands. Next, we observe the set of measurements mathcalM_textb that includes:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"active power injection measurements at boundary buses,\nbus voltage angle measurements.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Let us introduce the matrix mathbf W_textb in mathbbR^n_textb times n_texti, where n_textb = mathcalM_textb is the total number of measurements from the set mathcalM_textb. This matrix can be viewed as the Jacobian of a reduced network having n_texti columns associated with flow islands, and n_textb rows related to the set mathcalM_textb. Measurement functions related to the set mathcalM_textb define the Jacobian matrix mathbf J_textb, where the matrix mathbf W_textb is formed by summing the columns of mathbf J_textb belonging to a particular flow island [6].","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Furthermore, we define the reduced Jacobian matrix mathbf W_textp in mathbbR^n_textp times n_texti associated with the set of candidate pseudo-measurements mathcalM_textp:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"active power flow measurements between boundary buses,\nactive power injection measurements at unmeasured boundary buses,\nbus voltage angle measurements at unmeasured boundary buses,","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"where n_textp = mathcalM_textp is the total number of candidate pseudo-measurements from the set mathcalM_textp. As before, measurement functions related to the set mathcalM_textp define the Jacobian matrix mathbf J_textp, where the matrix mathbf W_textp is formed by summing the columns of mathbf J_textp belonging to a particular flow island.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Thus, we form the reduced Jacobian matrix as:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  mathbf W_textbp = beginbmatrix mathbf W_textb  mathbf W_textp endbmatrix","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"and the corresponding Gram matrix:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  mathbf M_textbp = mathbf W_textbp mathbf W_textbp^T","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Let mathbf M_textbp be decomposed into its mathbf Q and mathbf R factors. Non-redundant measurements correspond to non-zero diagonal elements in mathbf R. More precisely, if the diagonal element:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"    R_ii  epsilon","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"JuliaGrid marks the corresponding measurement as redundant, where epsilon is a predetermined zero pivot threshold. The minimal set of pseudo-measurements for observability restoration corresponds to the non-zero diagonal elements at positions related to the candidate pseudo-measurements.   ","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Note that the incorrect choice of the zero pivot threshold may deteriorate observability restoration. Also, it can happen that the set of pseudo-measurements mathcalM_textp are not sufficient for observability restoration.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"","category":"page"},{"location":"man/tbestimaterest/#optimalpmu-1","page":"State Estimation Routines","title":"Optimal PMU Placement","text":"","category":"section"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"The JuliaGrid uses the optimal PMU placement algorithm proposed in [9]. The optimal placement of PMUs is formulated as a problem of integer linear programming, as follows:","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"  beginaligned\n    textminimize  sum_i=1^n x_i\n    textsubjectto  mathbf A mathbf x ge mathbf b\n  endaligned","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"Here, the vector mathbf x = x_1dotsx_n^T is the optimization variable, where x_i in mathbbF = 01 is the PMU placement or a binary decision variable related to the bus i in mathcalH. The all-one vector mathbf b is of dimension n. The binary connectivity matrix mathbf A in mathbbF^n times n can be directly obtained from the bus admittance matrix mathbf Y by transforming its entries into binary form [10].","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"As a result, we observe the binary vector mathbf x = x_1dotsx_n^T, where x_i = 1, i in mathcalH, suggests that we should place a PMU at bus i. Here, the objective of placing PMUs in the power system is to decide a minimal set of PMUs such that the whole system is observable without legacy measurements [9].","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"","category":"page"},{"location":"man/tbestimaterest/#refrestestimate-1","page":"State Estimation Routines","title":"References","text":"","category":"section"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[1] A. Abur and A. Exposito, Power System State Estimation: Theory and Implementation, ser. Power Engineering. Taylor & Francis, 2004.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[2] G. N. Korres, \"A distributed multiarea state estimation,\" IEEE Trans. Power Syst., vol. 26, no. 1, pp. 73â84, Feb. 2011.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[3] A. Monticelli, State Estimation in Electric Power Systems: A Generalized Approach, ser. Kluwer international series in engineering and computer science. Springer US, 1999.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[4] B. Gou, \"Jacobian matrix-based observability analysis for state estimation,\" IEEE Trans. Power Syst., vol. 21, no. 1, pp. 348â356, Feb. 2006.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[5] G. C. Contaxis and G. N. Korres, \"A Reduced Model for Power System Observability Analysis and Restoration,\" IEEE Trans. Power Syst., vol. 3, no. 4, pp. 1411-1417, Nov. 1988.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[6] N. M. Manousakis and G. N. Korres, \"Observability analysis for power systems including conventional and phasor measurements,\" in Proc. MedPower 2010, Agia Napa, 2010, pp. 1-8.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[7] G. N. Korres, \"Observability Analysis Based on Echelon Form of a Reduced Dimensional Jacobian Matrix,\" IEEE Trans. Power Syst., vol. 26, no. 4, pp. 2572-2573, Nov. 2011.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[8] M. C. de Almeida, E. N. Asada, and A. V. Garcia, \"Power system observability analysis based on gram matrix and minimum norm solution,\" IEEE Trans. Power Syst., vol. 23, no. 4, pp. 1611â1618, Nov. 2008.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[9] B. Gou, \"Optimal placement of PMUs by integer linear programming,\" IEEE Trans. Power Syst., vol. 23, no. 3, pp. 1525â1526, Aug. 2008.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[10] B. Xu and A. Abur, \"Observability analysis and measurement placement for systems with PMUs,\" in Proc. IEEE PES PSCE, New York, NY, 2004, pp. 943-946 vol.2.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[11] H. Horisberger, \"Observability analysis for power systems with measurement deficiencies,\" IFAC Proceedings Volumes, vol. 18, no. 7, pp.51â58, 1985.","category":"page"},{"location":"man/tbestimaterest/#","page":"State Estimation Routines","title":"State Estimation Routines","text":"[12] M. Cosovic and D. Vukobratovic, \"Observability analysis for large-scale power systems using factor graphs\", arXiv:1907.10338 (2019).","category":"page"},{"location":"man/tbflow/#Power-Flow-1","page":"Power Flow","title":"Power Flow","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"JuliaGrid is based on common network elements and benefits the unified branch model to perform the power flow analysis, which is used for defining load profiles, generator capabilities, voltage specification, contingency analysis, and planning. We advise the reader to read the section Network Equations which represents a requirement for the analysis given here.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"We start from the equation for the apparent power injection S_i into the bus i:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  \tS_i = barV_ibarI_i^*","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The apparent power S_i consists of the active power P_i and reactive power Q_i:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  \tP_i + jQ_i = barV_ibarI_i^*","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The energy or apparent power at the bus i is equal to zero according to Tellegen's theorem:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    S_i = S_textgi-S_textli\n    P_i + jQ_i = P_textgi + jQ_textgi - P_textli - jQ_textli\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where S_textgi = P_textgi + textjQ_textgi denotes a generator power, while S_textli = P_textli + textjQ_textli indicates a load power. Hence, the active and reactive power equations may be solved independently:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    P_i = P_textgi - P_textli\n    Q_i = Q_textgi - Q_textli\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"However, the power flow problem is described by the system of non-linear equations:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where it is necessary to compute complex voltages barV_1 dots barV_n. According to the system of equations, for a single bus there are four variables: active power injection P_i, reactive power injection Q_i, voltage magnitude V_i and voltage angle theta_i. Further, to solve the system of equations, two variables for each equation need to be specified. Mathematically, any two variables may be selected, but the choice is dictated by the devices connected to a particular bus. Standard options are summarized in Table below and these options define bus types [1].","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Bus Type Label JuliaGrid Known Unknown\nSlack generator V theta 3 V_itheta_i P_iQ_i\nGenerator PV 2 P_iV_i Q_itheta_i\nDemand PQ 1 P_iQ_i V_itheta_i","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Consequently, JuliaGrid operates with sets mathcalPV and mathcalPQ that contain PV and PQ buses, respectively, and exactly one slack bus. Note that JuliaGrid does not support systems with multiple slack buses.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/tbflow/#acpowerflow-1","page":"Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"To solve the AC power flow problem three different methods are available:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Gauss-Seidel,\nNewton-Raphson,\nFast Newton-Raphson with XB and BX schemes.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"By default, the AC power flow methods solve the system of non-linear equations and reveal complex bus voltages ignoring any limits. However, JuliaGrid integrates generator reactive power limits in all available methods. More precisely, after the algorithm converges, all generators that violated reactive power limits are placed at their limits, and corresponding PV buses are converted to PQ. This procedure is repeated until there are no more violations [2].","category":"page"},{"location":"man/tbflow/#acpfanalysis-1","page":"Power Flow","title":"Power Flow Analysis","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"JuliaGrid uses the above methods to compute complex bus voltages, and subsequently, calculates other electrical quantities related to the AC power flow analysis. In the rest of this part, we define electrical quantities evaluated by the JuliaGrid.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Electrical quantities related to the bus i in mathcalH:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Active and reactive power injection can be obtained using the expression for complex apparent power:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    S_i =barV_ibarI_i^* = barV_i sumlimits_j in mathcalH_i Y_ij^* barV_j^* \n    P_i = ReS_i \n    Q_i = ImS_i","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Total active and reactive generation are determined using Tellegen's theorem:  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    S_i = S_textgi-S_textli \n    P_textgi = ReS_i + ReS_textli \n    Q_textgi = ImS_i + ImS_textli","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Active and reactive power consumed by the shunt element are obtained using the complex apparent power:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  S_textshi =barV_ibarI_textshi^* = y_textshi^*barV_i^2 \n  P_textshi = ReS_textshi \n  Q_textshi = ImS_textshi","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Electrical quantities related to the branch (ij) in mathcalE:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Complex currents from/to buses can be obtained using the unified branch model:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"beginaligned\n    barI_ij = C_ij barV_i + D_ij barV_j\n    barI_ji = E_ij barV_i + F_ij barV_j\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Active and reactive power flows are determined using the complex apparent power flows:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    S_ij = barV_ibarI_ij^*  P_ij = ReS_ij  Q_ij = ImS_ij\n    S_ji = barV_jbarI_ji^*  P_ji = ReS_ji  Q_ji = ImS_ji\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Branch active and reactive power losses at the branch series impedance z_ij are obtained using the complex current through impedance z_ij:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  barI_textbij = y_ij (alpha_ijbarV_i - barV_j) \n  P_textlossij = r_ijbarI_textbij^2 \n  Q_textlossij = x_ijbarI_textbij^2","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Reactive power injected by the total branch susceptance can be obtained using:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    Q_textchij = b_textsi (alpha_ijbarV_i^2 - barV_j^2)","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/tbflow/#gaussseidel-1","page":"Power Flow","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Defining the injected current into the bus i in mathcalH as:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"\tbarI_i = fracP_i - jQ_ibarV_i^*","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"the power flow problem which is described by the system of non-linear equations:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"can be written in the expanded form:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    Y_11  barV_1  + cdots+ Y_1nbarV_n = fracP_1 - jQ_1barV_1^* \n     vdots  \n    Y_n1  barV_1 + cdots+ Y_nnbarV_n = fracP_n - jQ_nbarV_n^*\n\tendaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The Gauss-Seidel method directly solves the above system of equations, albeit with very slow convergence, almost linearly with the size of the system. Consequently, this method needs many iterations to achieve the desired solution [3]. In general, the Gauss-Seidel method is based on the above system of equations, where the set of non-linear equations has n complex equations, and one of these equations describes the slack bus. Consequently, one of these equations can be removed resulting in the power flow problem with n-1 equations.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"In the following, we observe a power system with sets mathcalPV and mathcalPQ that contain PV and PQ buses, respectively, and exactly one slack bus V theta:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathcalH = mathcalPV cup mathcalPQ cup V theta","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The method starts with initial complex bus voltages barV_i^(0) i in mathcalH. The iteration scheme first computes complex bus voltages for PQ buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    barV_i^(nu + 1) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_ibarV_i^*(nu) -\n    sumlimits_substackj = 1^i - 1 Y_ijbarV_j^(nu + 1) -\n    sumlimits_substackj = i + 1^n Y_ijbarV_j^(nu)Bigg)\n     i in mathcalPQ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where nu = 01dotsnu_max is the iteration index and nu_max is the number of iterations. Then, the solution for PV buses are obtained in two steps: we first determine the reactive power injection, then the complex bus voltage is updated:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    Q_i^(nu+1) =\n    -Im left barV_i^*(nu + 1) sumlimits_j=1^n Y_ijbarV_j^(nu+1)right  i in mathcalPV \n    barV_i^(nu + 1) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_i^(nu + 1)barV_i^*(nu + 1)-\n    sumlimits_substackj = 1j neq i^n Y_ijbarV_j^(nu + 1) Bigg)  i in mathcalPV\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Obtained voltage magnitude is not equal to the magnitude specified for the PV bus. Thus, it is necessary to perform the voltage correction:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"      barV_i^(nu+1) = V_i^(0) cfracbarV_i^(nu+1)V_i^(nu+1)  i in mathcalPV","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The iteration loop is repeated until the stopping criteria is met. Namely, after one iteration loop is done, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    Delta P_i^(nu + 1) = RebarV_i^(nu + 1) barI_i^*(nu + 1) - P_i  i in mathcalPQ cup mathcalPV","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  Delta Q_i^(nu + 1) = ImbarV_i^(nu + 1) barI_i^*(nu + 1) - Q_i  i in mathcalPQ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The iteration loop is stopped when conditions are met:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    Delta P_i^(nu + 1)  epsilon  i in mathcalPQ cup mathcalPV \n    Delta Q_i^(nu + 1)  epsilon  i in mathcalPQ\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where epsilon is a predetermined stopping criteria.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/tbflow/#newtonraphson-1","page":"Power Flow","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The Newton-Raphson method is generally preferred in power flow calculations because this method has quadratic rate of convergence. The method can have difficulties with initial conditions (\"flat start\"). The Gauss-Seidel method convergence time increases significantly for large-scale systems and can exhibit convergence problems for systems with high active power transfers. Often, the two algorithms are used complementary, meaning that power flow programs implement both. Gauss-Seidel method is used to rapidly determine an approximate solution from a \"flat start\", and then the Newton-Raphson method is used to obtain the final accurate solution [4].","category":"page"},{"location":"man/tbflow/#General-Properties-1","page":"Power Flow","title":"General Properties","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Before we apply the Newton-Raphson method to the power flow equations, we review some of its general properties [2]. First of all, let us consider a real-valued continuously differentiable function f(x). The Newton-Raphson method provides a good approximation for the root of the function f(x):","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  f(x)= 0","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The Newton-Raphson method or Newton's method is essentially based on the Taylor series expansion. Namely, at any point x_0 equiv x^(0), the function f(x) is:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  f(x) = f(x^(0)) + (x-x^(0))fracmathrm df(x^(0))mathrm d x +\n  frac(x-x^(0))^22fracmathrm d^2f(x^(0))mathrm dx^2 + dots","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Neglecting the quadratic and high order terms and taking:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  Deltax^(0)=x- x^(0)","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"we obtain a linear function (i.e., an affine function) f_texta(x) of the non-linear function f(x) at the point x^(0):","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  f_texta(x) = f(x^(0)) + Delta x^(0) fracmathrm df(x^(0))mathrm d x","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The expression represents a tangent line of the function f(x) at the point x^(0) f( x^(0)), as shown in Figure 1. Now, we are interested in determining the root of the equation:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    f(x^(0)) + Delta x^(0) fracmathrm df(x^(0))mathrm d x = 0  to   \n    Delta x^(0) = -cfracf(x^(0))cfracmathrm df(x^(0))mathrm d x","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Thus, we reveal the root x^(1) of the equation f_texta(x):","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  x^(1) = x^(0) + Delta x^(0)","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"<img src=\"../../assets/lin_fx.png\" class=\"center\"/>\n<figcaption>Figure 1: The linearized function of the non-linear function around a given point.</figcaption>\n&nbsp;","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"In order to find the root x^* of the function f(x), the process is repeated using the Taylor series expansion at the point x^(1), which reveals a new point x^(2), and so on, moving towards a global solution x^*. Therefore, the Newton-Raphson is an iterative method, where we iteratively compute the increments and update solutions:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    Delta x^(nu) = -cfracf(x^(nu))cfracmathrm df(x^(nu))mathrm d x\n    x^(nu+1) = x^(nu) + Delta x^(nu)\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where nu = 01dotsnu_max is the iteration index and nu_max is the maximum number of iterations.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"For a complete description of the problem we expand the above model to a function of two variables f(xy). The affine function f_texta(xy) at the point  (x^(0)y^(0)) is defined:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"\tf_texta(xy)=f(x^(0)y^(0))+(x-x^(0)) fracmathrm partialf(x^(0)y^(0))\n\tmathrm partial x +\n\t(y-y^(0)) fracmathrm partialf(x^(0)y^(0))mathrm partial y  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Using the matrix notation, the above equation can be written in the form:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  f_texta(xy)=f(x^(0)y^(0)) +\n  beginbmatrix\n    cfracmathrm partialf(x^(0)y^(0))mathrm partial x \n    cfracmathrmpartialf(x^(0)y^(0)) mathrm partial y\n  endbmatrix                                      \n    beginbmatrix Delta x^(0) Delta y^(0)\n  endbmatrix","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where the Jacobian matrix is:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbfJ(x^(0)y^(0)) =\n  beginbmatrix\n    cfracmathrm partialf(x^(0)y^(0))mathrm partial x \n    cfracmathrmpartialf(x^(0)y^(0)) mathrm partial y\n  endbmatrix    ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Although somewhat trivial, the above example gives us a good intuition and provides an easy transition to the n-dimensional case:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    mathbff(x) =leftf_1(mathbfx)dots f_n(mathbfx) right^T\n    mathbfx = leftx_1dots x_n right^T\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The linearization of the function mathbf f(mathbf x) at the point mathbf x^(nu) is defined by the Taylor expansion:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbf f_texta(mathbf x)=mathbf f(mathbf x^(nu))+mathbf J(mathbf x^(nu)) mathbf Delta mathbf x^(nu)                                        ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"By taking mathbf f_texta(mathbf x) = mathbf 0, the vector of increments can be obtained by solving:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"   mathbf Delta mathbf x^(nu) = -mathbf J(mathbf x^(nu))^-1 mathbf f(mathbf x^(nu))                                     ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"that is, written in the extended form:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginbmatrix Delta x_1^(nu)   vdots   Delta x_n^(nu) endbmatrix =                                 \n  -beginbmatrix\n    cfracmathrm partialf_1(mathbf x^(nu))mathrm partial x_1 \n    dots \n    cfracmathrm partialf_1(mathbf x^(nu))mathrm partial x_n\n    vdots\n    cfracmathrm partialf_n(mathbf x^(nu))mathrm partial x_1 \n     \n    cfracmathrm partialf_n(mathbf x^(nu))mathrm partial x_n\t\t\t\t\n  endbmatrix^-1\n  beginbmatrix f_1(mathbf x^(nu)) vdots f_n(mathbf x^(nu)) endbmatrix            ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Then, we obtain the solution:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbf x^(nu + 1)=   mathbf x^(nu) + mathbf Delta mathbf x^(nu)                                     ","category":"page"},{"location":"man/tbflow/#Newton-Raphson-Applied-to-the-Power-Flow-Equations-1","page":"Power Flow","title":"Newton-Raphson Applied to the Power Flow Equations","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"In the following, we observe a power system with the set of buses mathcalH = 1dotsn . Without loss of generality, we assume that the slack bus is the first bus, followed by the set of PQ buses and the set of PV buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathcalH =  V theta cup mathcalPQ cup mathcalPV","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    mathcalPQ = 2 dots m \n    mathcalPV = m + 1dots n  \n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where m = n_textpq + 1, and n_textpq = mathcalPQ is the number of PQ buses.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Let us observe the vector given in the polar coordinate system:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbf x_textsv = theta_1dotstheta_nV_1dotsV_n^T","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"In general, the vector mathbf x_textsv in mathbbR^2n contains elements whose values are known: (i) voltage angle theta_1 and magnitude V_1 at the slack bus; (ii) voltage magnitude at PV buses V_i i in mathcalPV. More precisely, the number of unknowns is n_textu = 2n-n_textpv - 2, where n_textpv = mathcalPV is the number of PV buses.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Thus, we observe the state vector mathbf x in mathbbR^n_textu and associated vector of increments mathbf Delta mathbf x in mathbbR^n_textu:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbf x =  \t\n  beginbmatrix\n    bm theta  mathbf V\n  endbmatrix \n  mathbf Delta mathbf x =  \t\n  beginbmatrix\n    mathbf Delta bm theta  mathbf Delta mathbf V\n  endbmatrix","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned  \t\n    bm theta = theta_2dotstheta_n^T  mathbf Delta bm theta = Delta theta_2dotsDelta theta_n^T \n    mathbf V = V_2dotsV_m^T  mathbf Delta mathbf V = Delta V_2dotsDelta V_m^T\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The apparent power at the bus i in mathcalH is a function of the complex bus voltage S_i=f(bar V_i). Hence, the real and imaginary components of the apparent power define the active and reactive power injection expressions:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    P_i =V_isumlimits_j=1^n V_j\n    (G_ijcostheta_ij+B_ijsintheta_ij)\n    Q_i =V_isumlimits_j=1^n V_j\n    (G_ijsintheta_ij-B_ijcostheta_ij)     \n\tendaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Based on the above equations, it is possible to define the active power injection functions for PV and PQ buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalPV cup mathcalPQ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"and reactive power injection functions for PQ buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalPQ    ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Functions f_P_i(mathbf x) and f_Q_i(mathbf x) are called active and reactive mismatch, respectively, and are often marked as Delta P_i(mathbf x) and Delta Q_i(mathbf x). The first terms on the right-hand side represents power injections into the bus i, while the second term is constant and represents active and reactive powers from generators and loads connected to the bus i. Thus, the power flow problem is described by the system of equations:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbff(x) =\n  beginbmatrix\n      f_P_2(mathbf x)  vdots  f_P_n(mathbf x)  f_Q_2(mathbf x)  vdots  f_Q_m(mathbf x)\n  endbmatrix =\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where the first n - 1 equations are defined for PV and PQ buses, while the last m-1 equations are defined only for PQ buses.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Applying the Newton-Raphson method over power flow equations we have:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"\tmathbfJ(x^(nu))mathbf Delta x^(nu)+mathbf f(x^(nu))=0  to \n  mathbf Delta x^(nu) = -mathbfJ(x^(nu))^-1mathbf f(x^(nu))","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbf x^(nu + 1) = mathbf x^(nu) + mathbf Delta mathbf x^(nu)","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where the Jacobian matrix mathbfJ(x^(nu)) in mathbbR^n_textu times n_textu is:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbfJ(x^(nu))=\n  left\n  beginarraycccccc\n  cfracmathrm partialf_P_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_P_n(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_m 10pt\n  hline \n  cfracmathrm partialf_Q_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_Q_m(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_m\n  endarray\n  right","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"As we can see, the Jacobian matrix can be written using four block matrices:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"\t  mathbfJ(x^(nu)) =\n  beginbmatrix\n    mathbfJ_11(x^(nu)) mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu)) \n\t   mathbfJ_22(x^(nu))\n  endbmatrix\t\t","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where diagonal elements of the Jacobian sub-matrices are defined according to:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu)) mathrm partial theta_i =\n  V_i^(nu)sumlimits_j=1^n V_j^(nu)(-G_ij\n  sintheta_ij^(nu)+B_ijcostheta_ij^(nu)) - (V_i^(nu))^2B_ii\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_i^(nu) = sumlimits_\n  j=1^n V_j^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))+V_i^(nu) G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_i=V_i^(nu)\n  sumlimits_j=1^n V_j^(nu)\n  (G_ijcostheta_ij^(nu)+B_ijsintheta_ij^(nu))- (V_i^(nu))^2G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial V_i=sumlimits_j=1\n  ^n V_j^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))-V_i^(nu) B_ii\t\t\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"while non-diagonal elements of the Jacobian sub-matrices are:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu))\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_j^(nu) = V_i^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (-G_ijcostheta_ij^(nu) -B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))mathrm\n  partial V_j=V_i^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))\t\t\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"To conclude, the Newton-Raphson method is based on the equations:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginbmatrix\n    mathbfJ_11(x^(nu)) mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu)) \n\t   mathbfJ_22(x^(nu))\n  endbmatrix\t\t\n  beginbmatrix\n    mathbfDelta theta^(nu)  mathbfDelta V^(nu)\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x^(nu))  mathbff_Q(mathbf x^(nu))\n  endbmatrix = mathbf 0","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"As for the Gauss-Sedel method, the iteration loop is repeated until the stopping criteria is met. Namely, after each iteration, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  f_P_i(mathbf x^(nu)) = V_i^(nu)sumlimits_j=1^n V_j^(nu)(G_ijcostheta_ij^(nu)+B_ijsintheta_ij^(nu)) - P_i\n   i in mathcalPV cup mathcalPQ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    f_Q_i(mathbf x^(nu)) = V_i^(nu)sumlimits_j=1^n V_j^(nu)(G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu)) - Q_i\n     i in mathcalPQ    ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The iteration loop is stopped when the following conditions are met:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    f_P_i(mathbf x^(nu))   epsilon  i in mathcalPQ cup mathcalPV \n    f_Q_i(mathbf x^(nu))   epsilon  i in mathcalPQ\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where epsilon is predetermined stopping criteria.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/tbflow/#fastnewtonraphson-1","page":"Power Flow","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The convergence of the fast Newton-Raphson method is in fact slower than the Newton-Raphson method, but often, shorter solution time for the updates compensates for slower convergence, resulting in overall shorter solution time. For not too heavily loaded systems a shorter overall solution time is almost always obtained. It should be noted that if the algorithm converges, it converges to a correct solution [2].","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The fast Newton-Raphson method is based on the decoupling of the power flow equations. Namely, in transmission grids a strong coupling can be found between active powers and voltage angles, and between reactive powers and voltage magnitudes. In order to obtain decoupling, two conditions are assumed to have been satisfied: first, the resistances r_ij of the branches are small with respect to their respective reactances x_ij and, second, the angle differences are small theta_ij approx 0 [5]. Respectively, we start from the equation:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginbmatrix\n    mathbfJ_11(x)  mathbf0  mathbf0  mathbfJ_22(x)\n  endbmatrix\t\t\n  beginbmatrix\n    mathbfDelta bm theta  mathbfDelta V\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where, for simplicity, we drop the iteration index. Thus, decoupled system can be written as:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    mathbff_P(mathbf x) = -mathbfJ_11(x) mathbfDelta bm  theta \n    mathbff_Q(mathbf x) = -mathbfJ_22(x) mathbfDelta V\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Here, it would be useful to observe the problem in the form:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = -Delta theta_2cfracmathrm partialf_P_2(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_2(mathbf x)mathrm partial theta_n \n     vdots \n    f_P_n(mathbf x) = -Delta theta_2cfracmathrm partialf_P_n(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_i(mathbf x)mathrm partial theta_n\n    f_Q_2(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_n_textpq  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n     vdots \n    f_Q_m(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_m  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"First of all, we expand the second part of the expressions as follows:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n  f_Q_2(mathbf x) =\n  -cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n   vdots \n  f_Q_m(mathbf x) =\n  - cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m  \n  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The next step is deriving the Jacobian elements. For this purpose, let us consider the expressions defined for the Newton-Raphson method, where we applied the above expansions for PQ buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  V_isumlimits_j=1^n V_j(-G_ij\n  sintheta_ij+B_ijcostheta_ij) - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = V_isumlimits_j=1\n  ^n V_j(G_ijsintheta_ij-\n  B_ijcostheta_ij)-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\t\t\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Since the reactive power is defined as:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    Q_i =V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij)    ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Jacobian elements can be written in the form:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  -Q_i - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = Q_i-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\t\t\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The decoupled model is based on the following approximations:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    sin(theta_ij) approx 0 \n    cos(theta_ij) approx 1 \n    Q_i  B_iiV_i^2\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Consequently, Jacobian elements become:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i = -V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_j = -V_iV_jB_ij\n  V_i cfracmathrm partialf_Q_i(mathbf x) mathrm partial V_i = -V_i^2B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrmpartial V_j =  -V_iV_jB_ij\t\t\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Then, the initial system of equations is:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = V_2^2B_22 Delta theta_2 + cdots + V_2V_nB_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_2V_nB_n2 Delta theta_2 + cdots + V_n^2B_nn Delta theta_n \n    f_Q_2(mathbf x) =  V_2^2B_22 cfracDelta V_2V_2 + cdots +\n     V_2V_mB_2m cfracDelta V_mV_m \n     vdots \n    f_Q_m(mathbf x) = V_2V_mB_m2 cfracDelta V_2V_2 + cdots +\n    V_m^2 B_mm cfracDelta V_mV_m\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Using V_j approx 1, wherein V_i^2 = V_iV_j j=i, the first part of the equations have a form:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = V_2B_22 Delta theta_2 + cdots + V_2B_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_nB_n2 Delta theta_2 + cdots + V_nB_nn Delta theta_n\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Simplifying the second part of the equations, we obtain:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    f_Q_2(mathbf x) =  V_2B_22 Delta V_2 + cdots +\n     V_2 B_2m Delta V_m\n    \n     vdots \n    f_Q_m(mathbf x) = V_mB_m2 Delta V_2 + cdots +\n    V_m B_mm Delta V_m\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Finally, the fast Newton-Raphson method is based on the following system of equations:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    cfracf_P_2(mathbf x)V_2 = B_22 Delta theta_2 + cdots + B_2n Delta theta_n \n     vdots \n    cfracf_P_n(mathbf x)V_n = B_n2 Delta theta_2 + cdots + B_nn Delta theta_n \n    cfracf_Q_2(mathbf x)V_2 =  B_22 Delta V_2 + cdots + B_2m Delta V_m \n     vdots \n    cfracf_Q_m(mathbf x)V_m = B_m2 Delta V_2 + cdots +\n    B_mm Delta V_m\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"which can be written as:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    mathbfh_P(mathbf x) = mathbfB_1 mathbfDelta bm theta \n    mathbfh_Q(mathbf x) = mathbfB_2 mathbfDelta V\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"True benefits from these equations is that Jacobian matrices mathbfB_1 and mathbfB_2 are constant and should be formed only once. Note that no approximations have been introduced to the functions mathbff_P(mathbf x) or mathbff_Q(mathbf x), only in the way we calculate the increments of the state variables [2]. Consequently, we still use:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalPV cup mathcalPQ\n    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalPQ    \n  endaligned    ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"It is now possible to define XB and BX schemes of the fast Newton-Raphson method:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"XB scheme: The resistance r_ij, shunt susceptance Im  y_textshi , charging susceptance Im  y_textsij  and transformer tap ratio magnitude tau_ij are ignored while forming the matrix mathbfB_1. The transformer phase shift angle phi_ij is ignored while building the matrix mathbfB_2. This version is the standard fast Newton-Raphson method and has excellent convergence properties for usual cases.  \nBX scheme: The shunt susceptance Im  y_textshi , charging susceptance Im  y_textsij  and transformer tap ratio magnitude tau_ij are ignored while forming the matrix mathbfB_1. The resistance r_ij and transformer phase shift angle phi_ij are ignored while building the matrix mathbfB_2. For usual cases, the iteration count will be similar to the XB scheme, but for systems with a few or with general high r_ijx_ij ratios the number of iterations needed to solve the power flow is considerably smaller than the number of the XB scheme [5].","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"In the following, we will describe the implementation aspects of the fast Newton-Rapshson method. In the beginning, we evaluate and invert matrices mathbfB_1 and mathbfB_2. More precisely, JuliaGrid uses the LU factorization of matrices mathbfB_1 and mathbfB_2 to reveal solutions through iterations.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The fast Newton-Raphson method first solves the equation:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbfDelta bm theta^(nu) = mathbfB_1^-1 mathbfh_P(bm theta^(nu) mathbf V^(nu))","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"and updates the solution:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  bmtheta^(nu+1) = bmtheta^(nu) + mathbf Delta bm theta^(nu)","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Then, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  h_P_i(bm theta^(nu+1) mathbf V^(nu)) = sumlimits_j=1^n V_j^(nu)(G_ijcostheta_ij^(nu+1)+B_ijsintheta_ij^(nu+1))\n  - cfracP_iV_i^(nu)  i in mathcalPV cup mathcalPQ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    h_Q_i(bm theta^(nu+1) mathbf V^(nu)) = sumlimits_j=1^n V_j^(nu+1)(G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu+1))\n    -cfracQ_iV_i^(nu)  i in mathcalPQ    ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The iteration loop is stopped if the following conditions are satisfied:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    lefth_P_i(bm theta^(nu+1) mathbf V^(nu)) right   epsilon  i in mathcalPQ cup mathcalPV \n    lefth_Q_i(bm theta^(nu+1) mathbf V^(nu)) right   epsilon  i in mathcalPQ\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where epsilon is predetermined stopping criteria.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The fast Newton-Raphson method further solves the equation:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbfDelta V^(nu) = mathbfB_2^-1 mathbfh_Q(bm theta^(nu + 1) mathbf V^(nu))","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"and updates the solution:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbfV^(nu+1) = mathbfV^(nu) + mathbfDelta V^(nu)","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Then, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  h_P_i(bm theta^(nu+1) mathbf V^(nu+1)) =\n  sumlimits_j=1^n V_j^(nu+1)(G_ijcostheta_ij^(nu+1)+B_ijsintheta_ij^(nu+1)) - cfracP_iV_i^(nu+1)\n   i in mathcalPV cup mathcalPQ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    h_Q_i(bm theta^(nu+1) mathbf V^(nu+1)) =\n    sumlimits_j=1^n V_j^(nu+1) (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu+1)) - cfracQ_iV_i^(nu+1)\n     i in mathcalPQ    ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The iteration loop is stopped if the following conditions are satisfied:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    lefth_P_i(bm theta^(nu+1) mathbf V^(nu+1)) right   epsilon  i in mathcalPQ cup mathcalPV \n    lefth_Q_i(bm theta^(nu+1) mathbf V^(nu+1)) right   epsilon  i in mathcalPQ\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/tbflow/#dcpowerflow-1","page":"Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The DC model is obtained by linearisation of the non-linear model. In the typical operating conditions, the difference of bus voltage angles between adjacent buses (ij) in mathcalE is very small theta_i-theta_j approx 0, which implies cos theta_ijapprox 1 and sin theta_ij approx theta_ij. Further, all bus voltage magnitudes are V_i approx 1, i in mathcalH, and all shunt susceptance elements and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers. Therefore, the DC power flow takes only bus voltage angles mathbf x equiv bm theta as state variables. Consequently, the number of state variables is n-1, where one voltage angle represents the slack bus.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"According to the above assumptions, we start from the unified branch model:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    beginbmatrix\n      barI_ij  barI_ji\n    endbmatrix = cfrac1textjx_ij\n    beginbmatrix\n      cfrac1tau_ij^2  -alpha_ij^*\n      -alpha_ij  1\n    endbmatrix  \n    beginbmatrix\n      barV_i  barV_j\n    endbmatrix      ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where barV_i = texte^textjtheta_i and barV_j = texte^textjtheta_j. Further, we have:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    barI_ij = cfrac1textjx_ij leftcfrac1tau_ij^2 texte^textjtheta_i -\n    cfrac1tau_ije^textj(phi_ij + theta_j) right \n    barI_ji = cfrac1textjx_ij left-cfrac1tau_ije^textj(theta_i - phi_ij) + texte^textjtheta_j right\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The active power flows are derived as follows:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    P_ij = RebarV_ibarI_ij^* =\n    Re lefttextjcfrac1x_ij\n    leftcfrac1tau_ij^2 - cfrac1tau_ije^textj(theta_i - theta_j - phi_ij) right  right \n    P_ji = RebarV_jbarI_ji^* =\n    Re lefttextjcfrac1x_ij\n   left1-cfrac1tau_ije^textj(-theta_i +theta_j + phi_ij) right  right\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The real components are:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    P_ij =cfrac1tau_ijx_ij sin(theta_i -theta_j-phi_ij) approx cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) \n    P_ji =cfrac1tau_ijx_ij sin(theta_j -theta_i+phi_ij) approx -cfrac1tau_ij x_ij (theta_i - theta_j-phi_ij)\n  endaligned  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"We can conclude that P_ij=-P_ji holds. With the DC model, the linear network equations relate active power to bus voltage angles, versus complex currents to complex bus voltages in the AC case [3]. Consequently, analogous to the unified branch model we can write:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix = cfrac1tau_ijx_ij\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix  \n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix + cfracphi_ijtau_ijx_ij\n  beginbmatrix\n    -1  1\n  endbmatrix    ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"that is:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix =\n  beginbmatrix\n    C_ij  -C_ij\n    -C_ij  C_ij\n  endbmatrix  \n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix+\n  beginbmatrix\n    -T_ij  T_ij\n  endbmatrix  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"As before, let us consider an example of the DC framework, given in Figure 2, that will allow us an easy transition to the general case, where we observe:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"set of buses: mathcalH = pkq;\nset of branches: mathcalE = (pk) (kq).","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"<img src=\"../../assets/dc_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The example with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Each branch in the DC framework is described with system of equations as follows:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginbmatrix\n    P_pk  P_kp\n  endbmatrix =\n  beginbmatrix\n    C_pk  -C_pk\n    -C_pk  C_pk\n  endbmatrix  \n  beginbmatrix\n    theta_p  theta_k\n  endbmatrix+\n  beginbmatrix\n    -T_pk  T_pk\n  endbmatrix  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginbmatrix\n    P_kq  P_qk\n  endbmatrix =\n  beginbmatrix\n    C_kq  -C_kq\n    -C_kq  C_kq\n  endbmatrix  \n  beginbmatrix\n    theta_k  theta_q\n  endbmatrix+\n  beginbmatrix\n    -T_kq  T_kq\n  endbmatrix  ","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The injection active powers into buses are:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    P_p = P_pk = C_pk theta_p - C_pk theta_k - T_pk \n    P_k = P_kp + P_kq - P_textshk = -C_pk theta_p + C_pk theta_k + T_pk + C_kq theta_k - C_kq theta_q - T_kq + g_textshk \n    P_q = P_qk = -C_kq theta_k + C_kq theta_q + T_kq\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Note that the active power injected by the shunt element into the bus i in mathcalH is equal to:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  P_textshi = RebarV_ibarI_textshi^* = Re-barV_iy_textshi^*barV_i^* = - g_textshi","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginbmatrix\n    P_p  P_k  P_q\n  endbmatrix =\n  beginbmatrix\n    C_pk  - C_pk  0 \n    -C_pk  C_pk + C_kq   -C_kq \n    0  -C_kq  C_kq\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k  theta_q\n  endbmatrix +\n  beginbmatrix\n    - T_pk  T_pk - T_kq  T_kq\n  endbmatrix +\n  beginbmatrix\n    0  g_textshk  0\n  endbmatrix","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Next, the system of equations for i=1dotsn can be written in the matrix form:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  mathbf P = mathbfB bm theta + mathbfP_textgs + mathbfG_textsh","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"where:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"mathbf P in mathbbR^n is the vector of active power injection with elements P_ii=1dotsn;\nbm theta in mathbbR^n is the vector of bus angle voltages with elements theta_ii=1dotsn;\nmathbfP_textgs in mathbbR^n is the vector of generation shift factors with elements P_textgsii=1dotsn, equal to:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  P_textgsi = sum_e in mathcalE e(2)=i T_e - sum_e in mathcalE e(1)=i T_e  \n   i in mathcalH","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"mathbfG_textsh in mathbbR^n is the vector of active power consumed by shunt element  g_textshii=1dotsn;\nmathbfB in mathbbC^n times n is the bus or nodal matrix in the DC framework, with diagonal and non-diagonal elements:\nthe diagonal elements are equal to:\nB_ii = sumlimits_e in mathcalE i in e C_e   i in mathcalH\nthe strictly upper triangular part contains elements equal to:\nB_ij = -C_e   e in mathcalE  i = e(1)  j = e(2)\nthe strictly lower triangular part contains elements equal to:\nB_ij = -C_e   e in mathcalE  i = e(2)  j = e(1)","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"The DC power flow solution is obtained through non-iterative procedure by solving the linear problem:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    bm theta = mathbfB^-1(mathbf P - mathbfP_textgs - mathbfG_textsh)","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Note that the slack bus voltage angle is excluded from bm theta. Respectively, corresponding elements in vectors mathbf P, mathbfP_textgs, mathbfG_textsh, and corresponding column of the matrix mathbfB will be removed.","category":"page"},{"location":"man/tbflow/#dcpfanalysis-1","page":"Power Flow","title":"Power Flow Analysis","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"JuliaGrid uses the above equation to compute bus voltage angles and then calculates other electrical quantities related to the DC power flow analysis. In the rest of this part, we define electrical quantities generated by the JuliaGrid.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Electrical quantities related to the bus i in mathcalH:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Active power injection can be simply obtained as:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"   P_i = sum_j in mathcalH_i B_ij theta_j + P_textgsi + g_textshi","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Total active power generation is determined using Tellegen's theorem:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"As for the AC model, for each bus i in mathcalH, Tellegen's theorem, holds:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"    P_i = P_textgi-P_textli  P_textgi = P_i + P_textli","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Active power consumed by the shunt element is obtained as:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  P_textshi =g_textshi","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Electrical quantities related to the branch (ij) in mathcalE:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"Active power flows from/to buses are:","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"  beginaligned\n    P_ij = cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij)\n    P_ji = - P_ij\n  endaligned","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/tbflow/#refs-1","page":"Power Flow","title":"References","text":"","category":"section"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"[1] A. Wood and B. Wollenberg, Power Generation, Operation, and Control, ser. A Wiley-Interscience publication. Wiley, 1996.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"[2] G. Andersson, Modelling and analysis of electric power systems, EEH-Power Systems Laboratory, Swiss Federal Institute of Technology (ETH), ZÃ¼rich, Switzerland (2008).","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"[3] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER Userâs Manual, Version 7.0. 2019.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"[4] D. P. Chassin, P. R. Armstrong, D. G. Chavarria-Miranda, and R. T. Guttromson, \"Gauss-seidel accelerated: implementing flow solvers on field programmable gate arrays,\" in Proc. IEEE PES General Meeting, 2006, pp. 5.","category":"page"},{"location":"man/tbflow/#","page":"Power Flow","title":"Power Flow","text":"[5] R. A. M. van Amerongen, \"A general-purpose version of the fast decoupled load flow,\" IEEE Trans. Power Syst., vol. 4, no. 2, pp. 760-770, May 1989.","category":"page"},{"location":"man/flow/#runpf-1","page":"Power Flow","title":"Power Flow","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"JuliaGrid is based on common network elements and benefits the unified branch model to perform the power flow analysis, which is used for defining load profiles, generator capabilities, voltage specification, contingency analysis, and planning.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"To solve the AC power flow problem three different methods are available:","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Gauss-Seidel,\nNewton-Raphson,\nfast Newton-Raphson with XB and BX schemes.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"By default, the AC power flow methods solve the system of non-linear equations and reveal complex bus voltages ignoring any limits. However, JuliaGrid integrates generator reactive power limits in all available methods.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Besides the AC power flow, JuliaGrid supports the DC power flow model, which is obtained by linearisation of the non-linear model.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/flow/#Run-Settings-1","page":"Power Flow","title":"Run Settings","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Input arguments of the function runpf() describe the power flow settings. The order of inputs and their appearance is arbitrary, with onlyÂ DATA input required. Still, for the methodological reasons, the syntax examples follow a certain order.","category":"page"},{"location":"man/flow/#Syntax-1","page":"Power Flow","title":"Syntax","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"runpf(DATA, METHOD)\nrunpf(DATA, METHOD, DISPLAY)\nrunpf(DATA, METHOD, DISPLAY; ACCONTROL)\nrunpf(DATA, METHOD, DISPLAY; ACCONTROL, SOLVE)\nrunpf(DATA, METHOD, DISPLAY; ACCONTROL, SOLVE, SAVE)","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#Description-1","page":"Power Flow","title":"Description","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"runpf(DATA, METHOD) solves the power flow problem\nrunpf(DATA, METHOD, DISPLAY) shows results in the terminal\nrunpf(DATA, METHOD, DISPLAY; ACCONTROL) sets variables for the AC power flow\nrunpf(DATA, METHOD, DISPLAY; ACCONTROL, SOLVE) sets the linear system solver\nrunpf(DATA, METHOD, DISPLAY; ACCONTROL, SOLVE, SAVE) exports results","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#Output-1","page":"Power Flow","title":"Output","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"results, system, info = runpf() returns results, power system and info data","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#Examples-1","page":"Power Flow","title":"Examples","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"julia> results, system, info = runpf(\"case14.h5\", \"nr\", \"main\", \"flow\", \"generation\")","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"julia> results, = runpf(\"case14.xlsx\", \"nr\", \"main\"; max = 10, stop = 1.0e-8)","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"julia> results, = runpf(\"case14.h5\", \"gs\", \"main\"; max = 500, stop = 1.0e-8, reactive = 1)","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"julia> results, = runpf(\"case14.h5\", \"dc\"; solve = \"lu\", save = \"D:/case14results.xlsx\")","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/flow/#Input-Arguments-1","page":"Power Flow","title":"Input Arguments","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The power flow function runpf() receives a group of variable number of arguments: DATA, METHOD, DISPLAY, and group of arguments by keyword: ACCONTROL, SOLVE, SAVE.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#DATA-Variable-Argument-1","page":"Power Flow","title":"DATA - Variable Argument","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Example Description\n\"case14.h5\" loads the power system data from the package\n\"case14.xlsx\" loads the power system data from the package\n\"C:/case14.xlsx\" loads the power system data from a custom path","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#METHOD-Variable-Argument-1","page":"Power Flow","title":"METHOD - Variable Argument","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Command Description\n\"nr\" runs the AC power flow analysis using Newton-Raphson method, default setting\n\"gs\" runs the AC power flow analysis using Gauss-Seidel method\n\"fnrxb\" runs the AC power flow analysis using XB fast Newton-Raphson method\n\"fnrbx\" runs the AC power flow analysis using BX fast Newton-Raphson method\n\"dc\" runs the DC power flow analysis","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#DISPLAY-Variable-Argument-1","page":"Power Flow","title":"DISPLAY - Variable Argument","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Command Description\n\"main\" shows main bus data display\n\"flow\" shows power flow data display\n\"generation\" shows generator data display","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#ACCONTROL-Keyword-Argument-1","page":"Power Flow","title":"ACCONTROL - Keyword Argument","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Command Description\nmax = value specifies the maximum number of iterations for the AC power flow, default setting: 100\nstop = value specifies the stopping criteria for the AC power flow, default setting: 1.0e-8\nreactive = 1 forces reactive power constraints, default setting: 0","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#SOLVE-Keyword-Argument-1","page":"Power Flow","title":"SOLVE - Keyword Argument","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Command Description\nsolve = \"builtin\" built-in linear system solver, default setting\nsolve = \"lu\" LU linear system solver","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#SAVE-Keyword-Argument-1","page":"Power Flow","title":"SAVE - Keyword Argument","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Command Description\nsave = \"path/name.h5\" saves results in the h5-file\nsave = \"path/name.xlsx\" saves results in the xlsx-file","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/flow/#Input-Data-Structure-1","page":"Power Flow","title":"Input Data Structure","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The function supports two input types: .h5 or .xlsx file extensions, where to describe a power system using the same input data structure as Matpower, except for the first column in the branch data. Note that, in the case of large-scale systems, we strongly recommend to use the .h5 extension for the input as well as the output data.  ","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The minimum amount of information within an instance of the data structure required to run the module requires bus and branch variables.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"We advise the reader to read the section Power System Data Structure which provides the structure of the input DATA, with numerous examples given in the section Use Cases.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/flow/#Output-Data-Structure-1","page":"Power Flow","title":"Output Data Structure","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The power flow function runpf() returns a struct variable results with fields main, flow, generation containing power flow analysis results, and the additional field iterations for the AC power flow. Further, the variable system contains the input data that describes the power system, while the variable info contains basic information about the power system.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#DC-Power-Flow-1","page":"Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"We define electrical quantities generated by the JuliaGrid in the section DC Power Flow Analysis.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The main data structure contains results related to the bus.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Column Description Unit\n1 bus number defined as positive integer \n2 voltage angle deg\n3 active power injection MW\n4 active power generation MW\n5 active power demand MW\n6 active power consumed by the shunt conductance MW","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The flow data structure contains results related to the branch.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Column Description Unit\n1 branch number defined as positive integer \n2 from bus number defined as positive integer \n3 to bus number defined as positive integer \n4 from bus active power flow MW\n5 to bus active power flow MW","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The generation data structure contains results related to the generator.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Column Description Unit\n1 bus number defined as positive integer \n2 active power generation MW","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#AC-Power-Flow-1","page":"Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"We define electrical quantities generated by the JuliaGrid in the section AC Power Flow Analysis.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The main data structure contains results related to the bus.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Column Description Unit\n1 bus number defined as positive integer \n2 voltage magnitude per-unit\n3 voltage angle deg\n4 active power injection MW\n5 reactive power injection MVAr\n6 active power generation MW\n7 reactive power generation MVAr\n8 active power demand MW\n9 reactive power demand MVAr\n10 active power consumed by the shunt conductance MW\n11 reactive power consumed by the shunt susceptance MVAr","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The flow data structure contains results related to the branch.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Column Description Unit\n1 branch number defined as positive integer \n2 from bus number defined as positive integer \n3 to bus number defined as positive integer \n4 from bus active power flow MW\n5 from bus reactive power flow MVAr\n6 to bus active power flow MW\n7 to bus reactive power flow MVAr\n8 total branch reactive power injection MVAr\n9 active power loss at the series impedance MW\n10 reactive power loss at the series impedance MVAr\n11 from bus current magnitude per-unit\n12 from bus current angle deg\n13 to bus current magnitude per-unit\n14 to bus current angle deg","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"&nbsp;","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The generation data structure contains results related to the generator.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"Column Description Unit\n1 bus number defined as positive integer \n2 active power generation MW\n3 reactive power generation MVAr","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"man/flow/#Flowchart-1","page":"Power Flow","title":"Flowchart","text":"","category":"section"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"The power flow flowchart depicts the algorithm process according to user settings.","category":"page"},{"location":"man/flow/#","page":"Power Flow","title":"Power Flow","text":"(Image: )","category":"page"},{"location":"man/tbestimate/#stateestimation-1","page":"State Estimation","title":"State Estimation","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The state estimation is used for describing the present state of the power system, unlike the power flow analysis which is used for defining load profiles, generator capabilities, voltage specification, contingency analysis, and planning.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"<img src=\"../../assets/ems.png\" class=\"center\"/>\n<figcaption>Figure 1: The energy management system configuration and state estimation routines.</figcaption>\n&nbsp;","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The state estimation is a part of the energy management systems and typically includes network topology processors, observability analysis, state estimation algorithm and bad data analysis, as shown in Figure 1. Data for the state estimation arrives from SCADA (Supervisory Control and Data Acquisition) and WAMS (Wide Area Measurement System) technology. SCADA provides legacy measurements with low sampling rates insufficient to capture system dynamics in real-time and provides a snapshot state estimation with order of seconds and minutes latency. In contrast, WAMS provides data from PMUs with high sampling rates (10 ms - 20 ms) enabling the real-time system monitoring.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"In a usual scenario, the state estimation model is described with the system of non-linear equations, where bus voltage magnitudes and bus voltage angles are state variables mathbfx. The core of the state estimation is the state estimation algorithm that provides an estimate of the system state mathbfx based on the network topology and available measurements. State estimation is performed on a bus/branch model and used to reconstruct the state of the system. Conventional state estimation algorithms use the Gauss-Newton method to solve the non-linear weighted least-squares problem [1, 2]. Besides the non-linear state estimation model, the DC model is obtained by linearization of the non-linear model, and it provides an approximate solution. The DC state estimate is obtained through non-iterative procedure by solving the linear weighted least-squares problem.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"man/tbestimate/#Measurement-Model-1","page":"State Estimation","title":"Measurement Model","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"We refer the reader to section Network Equations which precedes the analysis given here. The state estimation algorithm estimates the values of the state variables based on the knowledge of network topology and parameters, and measured values obtained from measurement devices spread across the power system. The knowledge of the network topology and parameters is provided by the network topology processor in the form of the bus/branch model, where branches of the grid are usually described using the two-port pi-model [3, Ch. 1,2].","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"As an input, the state estimation requires a set of measurements mathcalM of different electrical quantities spread across the power network. Using the bus/branch model and available measurements, the observability analysis defines observable and unobservable parts of the network, subsequently defining the additional set of pseudo-measurements needed to determine the solution [3, Ch. 4]. Finally, the measurement model can be described as the system of equations [1]:  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  mathbfz=mathbfh(mathbfx)+mathbfu","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where mathbf x=x_1dotsx_s^T is the vector of the state variables, mathbfh(mathbfx)= h_1(mathbfx), dots, h_k(mathbfx)^T is the vector of measurement functions, mathbfz = z_1dotsz_k^mathrmT is the vector of measurement values, and mathbfu = u_1dotsu_k^mathrmT is the vector of uncorrelated measurement errors. The state estimation problem in transmission grids is commonly an overdetermined system of equations (ks) [4, Sec. 2.1].","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Each measurement M_i in mathcalM is associated with measured value z_i, measurement error u_i, and measurement function h_i(mathbfx). Under the assumption that measurement errors u_i follow a zero-mean Gaussian distribution, the probability density function associated with the i-th measurement is proportional to:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  mathcalN(z_imathbfxv_i) propto expBiggcfracz_i-h_i(mathbfx)^22v_iBigg","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where v_i is the measurement variance defined by the measurement error u_i, and the measurement function h_i(mathbfx) connects the vector of state variables mathbfx to the value of the i-th measurement.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The state estimation in electric power systems deals with the problem of determining state variables mathbfx according to the noisy observed data mathbfz and a prior knowledge:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":" \t\tp(mathbfxmathbfz)= cfracp(mathbfzmathbfx)p(mathbfx)p(mathbfz)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Assuming that the prior probability distribution p(mathbfx) is uniform, and given that p(mathbfz) does not depend on mathbfx, the maximum a posteriori solution reduces to the maximum likelihood solution, as given below [5]:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\thatmathbfx = mathrmargmax_mathbfxp(mathbfxmathbfz) =\n\tmathrmargmax_mathbfxp(mathbfzmathbfx) = mathrmargmax_mathbfxmathcalL(mathbfzmathbfx)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"One can find the solution via maximization of the likelihood function mathcalL(mathbfzmathbfx), which is defined via likelihoods of k independent measurements:  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\thatmathbf x = mathrmarg max_mathbfxmathcalL(mathbfzmathbfx)=\n\tmathrmarg max_mathbfx prod_i=1^k mathcalN(z_imathbfxv_i)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"It can be shown that the solution of the maximum a posteriori problem can be obtained by solving the following optimization problem, known as the weighted least-squares problem [6, Sec. 9.3]:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\thatmathbf x = mathrmargmin_mathbfx sum_i=1^kcfracz_i-h_i(mathbf x)^2v_i","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The state estimate hatmathbf x representing the solution of the above optimization problem is known as the weighted least-squares estimator, the maximum likelihood and weighted least-squares estimator are equivalent to the maximum a posteriori solution [5, Sec. 8.6].","category":"page"},{"location":"man/tbestimate/#Measurement-Set-1","page":"State Estimation","title":"Measurement Set","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The typical set of measurements mathcalM is defined according to type of measurement devices and includes:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Legacy measurements:\nactive and reactive power flow M_P_ij  M_P_ji  M_Q_ij  M_Q_ji  (ij) in mathcalE;\nbranch current magnitude M_I_ij M_I_ji   (ij) in mathcalE;\nactive and reactive power injection M_P_i  M_Q_i  i in mathcalH;\nbus voltage magnitude M_V_i   i in mathcalH.\nPhasor measurements provide by PMUs:\nbranch current mathcalM_barI_ij = M_I_ij  M_beta_ij  mathcalM_barI_ji = M_I_ji  M_beta_ji   (ij) in mathcalE;\nbus voltage mathcalM_barV_i = M_V_i  M_theta_i  i in mathcalH,","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where each phasor measurement is represented by a pair of measurements in the polar coordinate system. More precisely, phasor measurement provided by PMU is formed by a magnitude, equal to the root mean square value of the signal, and phase angle [9, Sec. 5.6], where measurement errors are also related with magnitude and angle of the phasor. Thus, the PMU outputs phasor measurement in polar coordinates. In addition, PMU outputs can be observed in the rectangular coordinates with real and imaginary parts of the bus voltage and line current phasors, but in that case, the two measurements may be affected by correlated measurement errors [9, Sec. 7.3].","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Each legacy measurement is described by non-linear measurement function h_i(mathbfx), where the state vector mathbfx is given in polar coordinates. In contrast, phasor measurements can be described with both non-linear and linear measurement functions h_i(mathbfx), where the state vector mathbfx can be given in polar or rectangular coordinates.","category":"page"},{"location":"man/tbestimate/#State-Variables-1","page":"State Estimation","title":"State Variables","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"We observe complex bus voltages bar V_i, i in mathcalH as state variables:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    bar V_i = V_imathrme^mathrmjtheta_i = Re (bar V_i) + mathrmj Im(bar V_i)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where Re (bar V_i) and Im(bar V_i) represent the real and imaginary components of the complex bus voltage bar V_i, respectively.   ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Thus, the vector of state variables mathbfx can be given in polar coordinates mathbf x equivbm thetamathbf V, where we observe bus voltage angles and magnitudes as state variables respectively:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    bm theta=theta_1dotstheta_n^T\n    mathbf V=V_1dots V_n^T\n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The conventional state estimation model in the presence of legacy measurements usually implies above approach.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Furthermore, the vector of state variables mathbfx can be given in rectangular coordinates mathbf x equivmathbfV_mathrmremathbfV_mathrmim, where we can observe real and imaginary components of bus voltages as state variables:   ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    mathbfV_mathrmre=bigRe(barV_1)dotsRe(barV_n)big^T\n\t  mathbfV_mathrmim=bigIm(barV_1)dotsIm(barV_n)big^T\n  endaligned       ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"man/tbestimate/#nonlinearse-1","page":"State Estimation","title":"Non-linear State Estimation","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"In the presence of both, legacy and phasor measurements, the system of equations:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  mathbfz=mathbfh(mathbfx)+mathbfu","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"represents the system of non-linear equations. The Gauss-Newton method is typically used to solve the non-linear state estimation model defined using measurement functions mathbf h(x) that precisely follow the physical laws that connect the measured variables and the state variables.  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Based on the available set of measurements mathcalM, the weighted least-squares estimator hatmathbf x, i.e., the solution of the weighted least-squares problem, can be found using the Gauss-Newton method:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\t\tBigmathbf J (mathbf x^(nu))^T mathbf R^-1 mathbf J (mathbf x^(nu))Big mathbf Delta mathbf x^(nu) =\n\t\tmathbf J (mathbf x^(nu))^T mathbf R^-1 mathbf r (mathbf x^(nu))        ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\t\tmathbf x^(nu+1) = mathbf x^(nu) + mathbf Delta mathbf x^(nu)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where nu = 012dots is the iteration index, mathbf Delta mathbf x in mathbb R^s is the vector of increments of the state variables, mathbf J (mathbf x)in mathbb R^k times s is the Jacobian matrix of measurement functions mathbf h (mathbf x) at mathbf x=mathbf x^(nu), mathbfRin mathbb R^k times k is a measurement error covariance matrix, and mathbf r (mathbf x) = mathbfz - mathbf h (mathbf x) is the vector of residuals [4, Ch. 10]. Note that, assumption that measurement errors are uncorrelated leads to the diagonal covariance matrix mathbf R that corresponds to measurement variances.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The non-linear state estimation represents non-convex problem arising from the non-linear measurement functions [7]. Due the fact that the values of state variables usually fluctuate in narrow boundaries, the non-linear model represents the mildly non-linear problem, where solutions are in a reasonable-sized neighborhood which enables the use of the Gauss-Newton method. The Gauss-Newton method can produce different rates of convergence, which can be anywhere from linear to quadratic [8, Sec. 9.2]. The convergence rate in regards to power system state estimation depends of the topology and measurements, and if parameters are consistent (e.g., free bad data measurement set), the method shows near quadratic convergence rate [4, Sec. 11.2].","category":"page"},{"location":"man/tbestimate/#Legacy-Measurements-1","page":"State Estimation","title":"Legacy Measurements","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"In the following, we provide expressions for measurement functions mathbf h (mathbf x) and corresponding Jacobian elements of the matrix mathbf J (mathbf x) related to legacy measurements, where state variables (i.e., unknown variables) are given in polar coordinates mathbf x equiv bm theta mathbf V.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Active-and-Reactive-Power-Flow-Measurement-Functions-1","page":"State Estimation","title":"Active and Reactive Power Flow Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"We start from the unified branch model:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2(y_ij + y_textsij)  -alpha_ij^*y_ij\n    -alpha_ijy_ij  y_ij + y_textsij\n  endbmatrix  \n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The complex branch currents can be written in the form:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    barI_ij = cfrac1tau_ij^2 g_ij + textj(b_ij + b_textsi) V_imathrme^mathrmjtheta_i -\n    cfrac1tau_ij (g_ij + textjb_ij) V_j mathrme^mathrmj(theta_j + phi_ij)\n    barI_ji = - cfrac1tau_ij (g_ij + textjb_ij) V_i mathrme^mathrmj(theta_i - phi_ij) +\n    g_ij + textj(b_ij + b_textsi) V_j mathrme^mathrmjtheta_j\n  endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The complex apparent powers are:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    S_ij = barV_ibarI_ij^* =\n    cfrac1tau_ij^2 g_ij - textj(b_ij + b_textsi) V_i^2 -\n    cfrac1tau_ij (g_ij - textjb_ij) V_iV_j mathrme^mathrmj(theta_i - theta_j - phi_ij) \n    S_ji = barV_jbarI_ji^* = g_ij - textj(b_ij + b_textsi) V_j^2 -  \n    cfrac1tau_ij (g_ij - textjb_ij) V_i V_j mathrme^mathrmj(theta_j -theta_i + phi_ij)\n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The real components of the above complex expressions define active power flows:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    P_ij =\n    cfracg_ijtau_ij^2 V_i^2 -\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) + b_ijsin(theta_ij - phi_ij)rightV_iV_j \n    P_ji = g_ij V_j^2 -  \n    cfrac1tau_ij leftg_ij cos(theta_ij - phi_ij) - b_ij sin(theta_ij- phi_ij)right V_i V_j\n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where theta_ij=theta_i-theta_j is the voltage angle difference between buses i and j. The imaginary components define reactive power flows:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    Q_ij =\n    -cfracb_ij + b_textsitau_ij^2 V_i^2 -\n    cfrac1tau_ij  leftg_ijsin(theta_ij - phi_ij) - b_ijcos(theta_ij - phi_ij)right V_iV_j\n    Q_ji = -(b_ij + b_textsi) V_j^2 +  \n    cfrac1tau_ij leftg_ij sin(theta_ij - phi_ij) + b_ij cos(theta_ij - phi_ij)right V_iV_j\n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Hence, the real and imaginary components of the complex apparent powers define the active and reactive power flow measurement functions. Thus, measurements:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    M_P_ij  M_P_ji  M_Q_ij  M_Q_ji  (ij) in mathcalE","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"are associated with measurement functions:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    h_P_ij(cdot) triangleq P_ij  h_P_ji(cdot) triangleq P_ji  h_Q_ij(cdot) triangleq Q_ij \n    h_Q_ji(cdot) triangleq Q_ji","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_P_ij(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_ij(cdot)mathrm partial theta_i =-\n    cfracmathrm partialh_P_ij(cdot)mathrm partial theta_j =   \n    cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) - b_ijcos(theta_ij - phi_ij)right V_iV_j \n    cfracmathrm partialh_P_ij(cdot)mathrm partial V_i =\n    cfrac2g_ijtau_ij^2 V_i -\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) + b_ijsin(theta_ij - phi_ij)right V_j \n    cfracmathrm partialh_P_ij(cdot)mathrm partial V_j = -\n    cfrac1tau_ij leftg_ij cos(theta_ij - phi_ij) + b_ij sin(theta_ij - phi_ij)right V_i\n\tendaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_P_ji(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_ji(cdot)mathrm partial theta_i = -\n    cfracmathrm partialh_P_ji(cdot)mathrm partial theta_j =\n    cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) + b_ijcos(theta_ij - phi_ij)right V_iV_j \n    cfracmathrm partialh_P_ji(cdot)mathrm partial V_i =  -\n    cfrac1tau_ij leftg_ij cos(theta_ij - phi_ij) - b_ij sin(theta_ij - phi_ij)right V_j \n    cfracmathrm partialh_P_ji(cdot)mathrm partial V_j = 2g_ij V_j-\n    cfrac1tau_ij leftg_ij cos(theta_ij - phi_ij) - b_ij sin(theta_ij - phi_ij)right V_i\n\tendaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_Q_ij(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Q_ij(cdot)mathrm partial theta_i = -\n    cfracmathrm partialh_Q_ij(cdot)mathrm partial theta_j = -\n    cfrac1tau_ij  leftg_ijcos(theta_ij - phi_ij) + b_ijsin(theta_ij - phi_ij)right V_iV_j \n    cfracmathrm partialh_Q_ij(cdot)mathrm partial V_i = -\n    2cfracb_ij + b_textsitau_ij^2 V_i -\n    cfrac1tau_ij  leftg_ijsin(theta_ij - phi_ij) - b_ijcos(theta_ij - phi_ij)right V_j\n    cfracmathrm partialh_Q_ij(cdot)mathrm partial V_j = -\n    cfrac1tau_ij  leftg_ijsin(theta_ij - phi_ij) - b_ijcos(theta_ij - phi_ij)right V_i\n\tendaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_Q_ji(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Q_ji(cdot)mathrm partial theta_i = -\n    cfracmathrm partialh_Q_ji(cdot)mathrm partial theta_j =\n    cfrac1tau_ij  leftg_ijcos(theta_ij - phi_ij) - b_ijsin(theta_ij - phi_ij)right V_iV_j \n    cfracmathrm partialh_Q_ji(cdot)mathrm partial V_i =  \n    cfrac1tau_ij leftg_ij sin(theta_ij - phi_ij) + b_ij cos(theta_ij - phi_ij)right V_j\n    cfracmathrm partialh_Q_ji(cdot)mathrm partial V_j = -\n    2(b_ij + b_textsi) V_j +  \n    cfrac1tau_ij leftg_ij sin(theta_ij - phi_ij) + b_ij cos(theta_ij - phi_ij)right V_i\n\tendaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Branch-Current-Magnitude-Measurement-Functions-1","page":"State Estimation","title":"Branch Current Magnitude Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The current magnitudes at the branch (ij) in mathcalE that connects buses i and j can be obtained using:  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\t  I_ij = cfracsqrtP_ij^2 + Q_ij^2V_i","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    I_ji = cfracsqrtP_ji^2 + Q_ji^2V_j","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"It can be shown that current magnitudes are:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    I_ij =sqrt A_textm1V_i^2 + B_textm1V_j^2 - 2V_iV_jC_textm1 cos(theta_ij - phi_ij) - D_textm1sin(theta_ij - phi_ij)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    I_ji =sqrt A_textm2V_i^2 + B_textm2V_j^2 - 2V_iV_jC_textm2 cos(theta_ij - phi_ij) + D_textm2sin(theta_ij - phi_ij)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    A_textm1 = cfracg_ij^2+(b_ij+b_si)^2tau_ij^4  B_textm1 =  cfracg_ij^2+b_ij^2tau_ij^2     \n    C_textm1 = cfracg_ij^2+b_ij(b_ij+b_si)tau_ij^3  D_textm1 = cfracg_ijb_sitau_ij^3\n    A_textm2 = cfracg_ij^2+b_ij^2tau_ij^2  B_textm2 = g_ij^2+(b_ij+b_si)^2 \n    C_textm2 = cfracg_ij^2+b_ij(b_ij+b_si)tau_ij  D_textm2 = cfracg_ijb_sitau_ij\n  endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Hence, measurements:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    M_I_ij  M_I_ji  (ij) in mathcalE","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"are associated with measurement functions:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    h_I_ij(cdot) triangleq I_ij  h_I_ji(cdot) triangleq I_ji","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_I_ij(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_I_ij(cdot)mathrm partial theta_i =-\n    cfracmathrm partialh_I_ij(cdot)mathrm partial theta_j =   \n    cfracV_i V_j C_textm1sin(theta_ij - phi_ij) + D_textm1cos(theta_ij - phi_ij)h_I_ij(cdot) \n    cfracmathrm partialh_I_ij(cdot)mathrm partial V_i =\n    cfracA_textm1V_i - V_jC_textm1cos(theta_ij - phi_ij) - D_textm1sin(theta_ij - phi_ij)h_I_ij(cdot) \n    cfracmathrm partialh_I_ij(cdot)mathrm partial V_j =\n    cfracB_textm1V_i - V_iC_textm1cos(theta_ij - phi_ij) - D_textm1sin(theta_ij - phi_ij)h_I_ij(cdot) \n\tendaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_I_ji(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_I_ji(cdot)mathrm partial theta_i =-\n    cfracmathrm partialh_I_ji(cdot)mathrm partial theta_j =   \n    cfracV_i V_j C_textm2sin(theta_ij - phi_ij) - D_textm2cos(theta_ij- phi_ij)h_I_ji(cdot) \n    cfracmathrm partialh_I_ji(cdot)mathrm partial V_i =\n    cfracA_textm2V_i - V_jC_textm2cos(theta_ij - phi_ij) + D_textm2sin(theta_ij - phi_ij)h_I_ji(cdot) \n    cfracmathrm partialh_I_ji(cdot)mathrm partial V_j =\n    cfracB_textm2V_i - V_iC_textm2cos(theta_ij - phi_ij) + D_textm2sin(theta_ij - phi_ij)h_I_ji(cdot) \n\tendaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Note that, in deregulation environment current magnitude measurements can be found in significant numbers, especially in distribution grids. The use of line current magnitude measurements can lead to various problems (e.g., the \"flat start\" will cause undefined Jacobian elements), which in turn may seriously deteriorate the performance of the state estimators [3, Sec. 9.3].","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Active-and-Reactive-Injection-Measurement-Functions-1","page":"State Estimation","title":"Active and Reactive Injection Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The active and reactive power injection into the bus i in mathcalH can be obtained using:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  S_i =barV_ibarI_i^* = P_i + textjQ_i","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    P_i =V_isumlimits_j in mathcalH_i V_j(G_ijcostheta_ij + B_ijsintheta_ij)\n    Q_i =V_isumlimits_j in mathcalH_i V_j(G_ijsintheta_ij - B_ijcostheta_ij)     \n\tendaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Hence, measurements:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    M_P_i  M_Q_i  i in mathcalH","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"are associated with measurement functions:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    h_P_i(cdot) triangleq P_i  h_Q_i(cdot) triangleq Q_i","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_P_i(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_i(cdot)mathrm partial theta_i =\n    V_isum_j in mathcalH_i V_j (-G_ijsintheta_ij+B_ijcostheta_ij) - V_i^2B_ii\n    cfracmathrm partialh_P_i(cdot)mathrm partial theta_j =\n    V_iV_j(G_ijsintheta_ij-B_ijcostheta_ij) \n    cfracmathrm partialh_P_i(cdot)mathrm partial V_i =\n    sum_j in mathcalH_i V_j(G_ijcostheta_ij+B_ij sintheta_ij)+V_iG_ii\n    cfracmathrm partialh_P_i(cdot)mathrm partial V_j =\n    V_i(G_ijcostheta_ij+B_ijsintheta_ij)\n  endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_Q_i(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Q_i(cdot)mathrm partial theta_i =\n    V_isum_j in mathcalH_i V_j(G_ijcostheta_ij+B_ijsintheta_ij)-V_i^2G_ii\n    cfracmathrm partialh_Q_i(cdot)mathrm partial theta_j =\n    V_iV_j(-G_ijcostheta_ij-B_ijsintheta_ij) \n    cfracmathrm partialh_Q_i(cdot)mathrm partial V_i =\n    sum_j in mathcalH_i V_j(G_ijsintheta_ij-B_ijcostheta_ij)-V_iB_ii\n    cfracmathrm partialh_Q_i(cdot)mathrm partial V_j =\n    V_i(G_ijsintheta_ij-B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Bus-Voltage-Magnitude-Measurement-Functions-1","page":"State Estimation","title":"Bus Voltage Magnitude Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The bus voltage magnitude on the bus i in mathcalH simply defines corresponding measurement function. Hence, measurement:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    M_V_i  i in mathcalH","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"is associated with measurement function:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"   h_V_i(cdot) triangleq V_i","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_V_i(cdot) are defined:  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n   \tcfracmathrm partialh_V_i(cdot) mathrm partial theta_i=0 \n    cfracmathrm partialh_V_i(cdot) mathrm partial theta_j=0     \t\n   \tcfracmathrm partialh_V_i(cdot) mathrm partial V_i=1 \n    cfracmathrm partialh_V_i(cdot)mathrm partial V_j=0\n  endaligned","category":"page"},{"location":"man/tbestimate/#Phasor-Measurements-1","page":"State Estimation","title":"Phasor Measurements","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"In the majority of PMUs, the voltage and current phasors in polar coordinate system are regarded as \"direct\" measurements (i.e., output from the PMU). This representation delivers the more accurate state estimates in comparison to the rectangular measurement representation, but it requires larger computing time [10]. This representation is called simultaneous state estimation formulation, where measurements provided by PMUs are handled in the same manner as legacy measurements [11]. Measurement errors are uncorrelated, with measurement variances that correspond to each components of the phasor measurements (i.e., magnitude and angle).","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Bus-Voltage-Phasor-Measurement-Functions-1","page":"State Estimation","title":"Bus Voltage Phasor Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The bus voltage phasor on the bus i in mathcalH in the polar coordinate system is described:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    bar V_i = V_imathrme^mathrmjtheta_i","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"and due the fact that the state vector is given in the polar coordinate system mathbf x equivbm theta mathbf V, measurements:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    mathcalM_barV_i = M_V_i  M_theta_i  i in mathcalH","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"are associated with measurement functions:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"   h_V_i(cdot) triangleq V_i  h_theta_i(cdot) triangleq theta_i","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_V_i(cdot) are defined:  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n   \tcfracmathrm partialh_V_i(cdot)mathrm partial theta_i=0\n    cfracmathrm partialh_V_i(cdot)mathrm partial theta_j=0    \t\n   \tcfracmathrm partialh_V_i(cdot)mathrm partial V_i=1 \n    cfracmathrm partialh_V_i(cdot)mathrmpartial V_j=0\n    endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"while Jacobian expressions corresponding to the measurement function h_theta_i(cdot) are:  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n   \tcfracmathrm partialh_theta_i(cdot)mathrm partial theta_i=1  \n    cfracmathrm partialh_theta_i(cdot)mathrm partial theta_j=0    \t\n   \tcfracmathrm partialh_theta_i(cdot)mathrm partial V_i=0   \n    cfracmathrm partialh_theta_i(cdot)mathrmpartial V_j=0\n  endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Branch-Current-Phasor-Measurement-Functions-1","page":"State Estimation","title":"Branch Current Phasor Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The branch current phasors at the branch (ij) in mathcalE that connects buses i and j in polar coordinates are defined as:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n\t barI_ij=I_ijmathrme^mathrmjbeta_ij\n   barI_ji=I_jimathrme^mathrmjbeta_ji\n  endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where I_ij, I_ji and beta_ij, beta_ji are magnitudes and angles of the line current phasors, respectively. We defined branch current magnitudes, while current angles are:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    beta_ij = mathrmarctanBigg\n    cfrac(A_texta1 sintheta_i + B_texta1 costheta_i)V_i - C_texta1 sin(theta_j+phi_ij) + D_texta1cos(theta_j+phi_ij)V_j\n    (A_texta1 costheta_i - B_texta1 sintheta_i)V_i - C_texta1 cos(theta_j+phi_ij) - D_texta1 sin(theta_j+phi_ij)V_j Bigg   ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    beta_ji = mathrmarctanBigg\n    cfrac(A_texta2 sintheta_j + B_texta2 costheta_j)V_j - C_texta2 sin(theta_i-phi_ij) + D_texta2cos(theta_i-phi_ij)V_i\n    (A_texta2 costheta_j - B_texta2 sintheta_j)V_j - C_texta2 cos(theta_i-phi_ij) - D_texta2 sin(theta_i-phi_ij)V_i Bigg   ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where coefficients are as follows: \t\t","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    A_texta1 = cfracg_ijtau_ij^2  B_texta1 = cfracb_ij+b_textsitau_ij^2 \n    C_texta1 = cfracg_ijtau_ij  D_texta1 = cfracb_ijtau_ij \n    A_texta2 = g_ij  B_texta2 = b_ij + b_mathrmsi \n    C_texta2 = cfracg_ijtau_ij  D_texta2 = cfracb_ijtau_ij\n  endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Thus, measurements:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    mathcalM_barI_ij = M_I_ij  M_beta_ij  mathcalM_barI_ji = M_I_ji  M_beta_ji   (ij) in mathcalE","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"are associated with measurement functions:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    h_I_ij(cdot) triangleq I_ij  h_beta_ij(cdot) triangleq beta_ij  h_I_ji(cdot) triangleq I_ji  h_beta_ji(cdot) triangleq beta_ji","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_beta_ij(cdot) are defined:  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_beta_ij(cdot)mathrm partial theta_i =\n    cfracA_textm1 V_i^2- C_textm1 cos(theta_ij- phi_ij) - D_textm1 sin (theta_ij - phi_ij) V_iV_jh_I_ij^2(cdot) \n    cfracmathrm partialh_beta_ij(cdot)mathrm partial theta_j =\n    cfracB_textm1 V_j^2 - C_textm1 cos (theta_ij - phi_ij) - D_textm1 sin(theta_ij- phi_ij)V_iV_jh_I_ij^2(cdot) \n    cfracmathrm partialh_beta_ij(cdot)mathrm partial V_i = -\n    cfracC_textm1 sin (theta_ij - phi_ij) + D_textm1 cos(theta_ij- phi_ij)V_j h_I_ij^2(cdot)\n    cfracmathrm partialh_beta_ij(cdot)mathrm partial V_j =\n    cfracC_textm1 sin (theta_ij - phi_ij) + D_textm1 cos(theta_ij- phi_ij)V_i h_I_ij^2(cdot)\n  endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobian expressions corresponding to the measurement function h_beta_ji(cdot) are defined:  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_beta_ji(cdot)mathrm partial theta_i =\n    cfracA_textm2 V_i^2- C_textm2 cos(theta_ij- phi_ij) + D_textm2 sin (theta_ij - phi_ij) V_iV_jh_I_ji^2(cdot) \n    cfracmathrm partialh_beta_ji(cdot)mathrm partial theta_j =\n    cfracB_textm2 V_j^2 - C_textm2 cos (theta_ij - phi_ij) + D_textm2 sin(theta_ij- phi_ij)V_iV_jh_I_ji^2(cdot) \n    cfracmathrm partialh_beta_ji(cdot)mathrm partial V_i = -\n    cfracC_textm2 sin (theta_ij - phi_ij) - D_textm2 cos(theta_ij- phi_ij)V_j h_I_ji^2(cdot)\n    cfracmathrm partialh_beta_ji(cdot)mathrm partial V_j =\n    cfracC_textm2 sin (theta_ij - phi_ij) - D_textm2 cos(theta_ij- phi_ij)V_i h_I_ji^2(cdot)\n  endaligned","category":"page"},{"location":"man/tbestimate/#State-Estimation-Model-1","page":"State Estimation","title":"State Estimation Model","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The non-linear state estimation model, used by JuliaGrid, implies the state vector in polar coordinates mathbf x equivbm thetamathbf V, where the vector of measurement functions mathbf h (mathbf x) and corresponding Jacobian elements of the matrix mathbf J (mathbf x) are expressed in the same coordinate system. Here, the vector of measurement values mathbf z in mathbb R^k, the vector of measurement functions mathbf h(mathbf x) in mathbb R^k and corresponding Jacobian matrix mathbf J(mathbf x) in mathbb R^k times s are:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    mathbf z =\n    beginbmatrix    \t \n      mathbf z_P_ij3pt\n      mathbf z_P_ji3pt\n      mathbf z_Q_ij3pt\n      mathbf z_Q_ji3pt\n      mathbf z_I_ij3pt\n      mathbf z_I_ji3pt\n      mathbf z_P_i3pt\n      mathbf z_Q_i3pt\n      mathbf z_V_i3pt\n      mathbf z_theta_i3pt\n      mathbf z_beta_ij3pt      \n      mathbf z_beta_ji   \n    endbmatrix \n    mathbf h (mathbf x)\n    beginbmatrix    \t \n      mathbf h_P_ij(mathbf x)3pt\n      mathbf h_P_ji(mathbf x)3pt\n      mathbf h_Q_ij(mathbf x)3pt\n      mathbf h_Q_ji(mathbf x)3pt\n      mathbf h_I_ij(mathbf x)3pt\n      mathbf h_I_ji(mathbf x)3pt\n      mathbf h_P_i(mathbf x)3pt\n      mathbf h_Q_i(mathbf x)3pt\n      mathbf h_V_i(mathbf x)3pt\n      mathbf h_theta_i(mathbf x)3pt\n      mathbf h_beta_ij(mathbf x)3pt      \n      mathbf h_beta_ji(mathbf x)   \n    endbmatrix \n    mathbf J(mathbf x)=\n    beginbmatrix\n      mathbf J_P_ijtheta(mathbf x)  mathbf J_P_ijV(mathbf x) 3pt\n      mathbf J_P_jitheta(mathbf x)  mathbf J_P_jiV(mathbf x) 3pt\n      mathbf J_Q_ijtheta(mathbf x)  mathbf J_Q_ijV(mathbf x) 3pt\n      mathbf J_Q_jitheta(mathbf x)  mathbf J_Q_jiV(mathbf x) 3pt\n      mathbf J_I_ijtheta(mathbf x)  mathbf J_I_ijV(mathbf x) 3pt\n      mathbf J_I_jitheta(mathbf x)  mathbf J_I_jiV(mathbf x) 3pt\n      mathbf J_P_itheta(mathbf x)  mathbf J_P_iV(mathbf x) 3pt\n      mathbf J_Q_itheta(mathbf x)  mathbf J_Q_iV(mathbf x) 3pt\n      mathbf J_V_itheta(mathbf x)  mathbf J_V_iV(mathbf x) 3pt\n      mathbf J_theta_itheta(mathbf x)  mathbf J_theta_iV(mathbf x) 3pt\n      mathbf J_beta_ijtheta(mathbf x)  mathbf J_beta_ijV(mathbf x) 3pt\n      mathbf J_beta_jitheta(mathbf x)  mathbf J_beta_jiV(mathbf x) 3pt\n\tendbmatrix","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Due to assumption of uncorrelated measurement errors (i.e., usual assumption), the measurement error covariance matrix mathbfR in mathbb R^k times k has the diagonal structure:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\tmathbf R = textdiag\t(\n\tmathbf R_P_ij mathbf R_P_ji mathbf R_Q_ij mathbf R_Q_ji mathbf R_I_ij mathbf R_I_ji\n  mathbf R_P_i mathbf R_Q_i mathbf R_V_i mathbf R_theta_i mathbf R_beta_ij mathbf R_beta_ji)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"and each covariance sub-matrix of mathbfR is the diagonal matrix that contains measurement variances. The solution of the described state estimation model is obtained using the iterative Gauss-Newton method.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"JuliaGrid uses the above equation to compute bus voltage angles and magnitudes, where the slack bus is included in the formulation, where the angle of one reference bus is known. Consequently, the state vector mathbf x equivbm thetamathbf V has s = 2n-1 elements, while the corresponding column of the matrix mathbf J(mathbf x) is removed.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"man/tbestimate/#linearpmuse-1","page":"State Estimation","title":"Linear State Estimation with PMUs","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"To recall, phasor measurement provided by PMU is formed by a magnitude and phase angle, where measurement errors are also related with magnitude and angle of the phasor. Thus, the PMU outputs phasor measurement in polar coordinates. In addition, PMU outputs can be observed in the rectangular coordinates with real and imaginary parts of the bus voltage and line current phasors, where the vector of state variables is given in rectangular coordinates mathbf x equivmathbfV_textremathbfV_textim. Then, we obtain linear measurement functions with constant Jacobian elements. Unfortunately, direct inclusion in the conventional state estimation model is not possible due to different coordinate systems, however, this still represents the important advantage of phasor measurements. Thus, the JuliaGrid package provides linear state estimation with PMUs only.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Bus-Voltage-Phasor-Measurement-Functions-2","page":"State Estimation","title":"Bus Voltage Phasor Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The bus voltage phasor on the bus i in mathcalH in the rectangular coordinates is defined as:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\tbar V_i = Re(barV_i) +textjIm(barV_i) = V_textrei +textjV_textimi","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The state vector is given in the rectangular coordinate system mathbf x equivmathbfV_textremathbfV_textim and the real and imaginary components directly define measurement functions. Hence, phasor measurement:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    mathcalM_barV_i  i in mathcalH","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"is associated with measurement functions:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"   h_V_textrei(cdot) triangleq V_textrei  h_V_textimi(cdot) triangleq V_textimi","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobians expressions corresponding to the measurement function h_V_textrei(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n   \tcfracmathrm partialh_V_textrei(cdot)mathrm partial V_textrei=1   \n    cfracmathrm partialh_V_textrei(cdot)mathrm partial V_textrej=0 \n   \tcfracmathrm partialh_V_textrei(cdot)mathrm partial V_textimi=0  \n    cfracmathrm partialh_V_textrei(cdot)mathrm partial V_textimj=0    \n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"while Jacobians expressions corresponding to the measurement function h_V_textimi(cdot) are:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n   \tcfracmathrm partialh_V_textimi(cdot)mathrm partial V_textrei=0\n    cfracmathrm partialh_V_textimi(cdot)mathrm partial V_textrej=0 \n   \tcfracmathrm partialh_V_textimi(cdot)mathrm partial V_textimi=1\n    cfracmathrm partialh_V_textimi(cdot)mathrm partial V_textimj=0    \n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Branch-Current-Phasor-Measurement-Functions-2","page":"State Estimation","title":"Branch Current Phasor Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The branch current phasors at the branch (ij) in mathcalE that connects buses i and j in the rectangular coordinate system are given:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    barI_ij = Re(barI_ij) +mathrmjIm(barI_ij) = I_textreij +textjI_textimij \n    barI_ji = Re(barI_ji) +mathrmjIm(barI_ji) = I_textreji +textjI_textimji\n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Using the unified branch model, the real and imaginary components of the branch current phasors are:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"   I_textreij = cfracg_ijtau_ij^2 V_textrei - cfracb_ij+b_textsi tau_ij^2 V_textimi -\n  left(cfracg_ijtau_ij cosphi_ij - cfracb_ijtau_ij sin phi_ijright) V_textrej +    \n  left(cfracb_ijtau_ijcos phi_ij + cfracg_ijtau_ijsin phi_ijright)V_textimj","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"   I_textimij = cfracb_ij+b_textsitau_ij^2 V_textrei + cfracg_ij tau_ij^2 V_textimi -\n  left(cfracb_ijtau_ij cosphi_ij + cfracg_ijtau_ij sin phi_ijright) V_textrej -    \n  left(cfracg_ijtau_ijcos phi_ij - cfracb_ijtau_ijsin phi_ijright)V_textimj","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"   I_textreji = g_ij V_textrej - (b_ij+b_textsi) V_textimj -\n  left(cfracg_ijtau_ij cosphi_ij + cfracb_ijtau_ij sin phi_ijright) V_textrei +    \n  left(cfracb_ijtau_ijcos phi_ij - cfracg_ijtau_ijsin phi_ijright)V_textimi","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"   I_textimji = (b_ij+b_textsi) V_textrej + g_ij V_textimj -\n  left(cfracb_ijtau_ij cosphi_ij - cfracg_ijtau_ij sin phi_ijright) V_textrei -    \n  left(cfracg_ijtau_ijcos phi_ij + cfracb_ijtau_ijsin phi_ijright)V_textimi","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Hence, measurements:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    mathcalM_barI_ij  mathcalM_barI_ji   (ij) in mathcalE","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"are associated with measurement functions:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    h_I_textreij(cdot) triangleq I_textreij  h_I_textimij(cdot) triangleq I_textimij \n    h_I_textreji(cdot) triangleq I_textreji  h_I_textimji(cdot) triangleq I_textimji","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobians expressions corresponding to the measurement function h_I_textreij(cdot) and h_I_textimij(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n  cfracmathrm partialh_I_textreij(cdot)mathrm partial V_textrei =\n  cfracmathrm partialh_I_textimij(cdot)mathrm partial V_textimi = cfracg_ijtau_ij^2 \n  cfracmathrm partialh_I_textreij(cdot) mathrm partial V_textrej =\n  cfracmathrm partialh_I_textimij(cdot) mathrm partial V_textimj =\n  - left(cfracg_ijtau_ij cosphi_ij - cfracb_ijtau_ij sin phi_ijright)\n  cfracmathrm partialh_I_textreij(cdot)mathrm partial V_textimi =-\n  cfracmathrm partialh_I_textimij(cdot)mathrm partial V_textrei =\n  -cfracb_ij+b_textsi tau_ij^2 \n  cfracmathrm partialh_I_textreij(cdot)mathrm partial V_textimj = -\n  cfracmathrm partialh_I_textimij(cdot)mathrm partial V_textrej =\n  left(cfracb_ijtau_ijcos phi_ij + cfracg_ijtau_ijsin phi_ijright)\n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobians expressions corresponding to the measurement function h_I_textreji(cdot) and h_I_textimji(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n  cfracmathrm partialh_I_textreji(cdot)mathrm partial V_textrei =\n  cfracmathrm partialh_I_textimji(cdot)mathrm partial V_textimi =\n  - left(cfracg_ijtau_ij cosphi_ij + cfracb_ijtau_ij sin phi_ijright)\n  cfracmathrm partialh_I_textreji(cdot) mathrm partial V_textrej =\n  cfracmathrm partialh_I_textimji(cdot) mathrm partial V_textimj = g_ij\n  cfracmathrm partialh_I_textreji(cdot)mathrm partial V_textimi = -\n  cfracmathrm partialh_I_textimji(cdot)mathrm partial V_textrei =\n  left(cfracb_ijtau_ijcos phi_ij + cfracg_ijtau_ijsin phi_ijright) \n  cfracmathrm partialh_I_textreji(cdot)mathrm partial V_textimj = -\n  cfracmathrm partialh_I_textimji(cdot)mathrm partial V_textrej =\n  -(b_ij+b_textsi)\n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#State-Estimation-Model-2","page":"State Estimation","title":"State Estimation Model","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Presented model represents system of linear equations, where solution can be found by solving the linear weighted least-squares problem:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\t\tBigmathbf J^T mathbf R^-1 mathbf J Big mathbf x =\n\t\tmathbf J ^T mathbf R^-1 mathbf z       ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Here, the vector of measurement values mathbf z in mathbb R^k and Jacobian matrix mathbf J in mathbb R^k times s are:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    mathbf z =\n    beginbmatrix    \t \n      mathbf z_V_textrei3pt\n      mathbf z_V_textimi3pt\n      mathbf z_I_textreij3pt\n      mathbf z_I_textimij3pt\n      mathbf z_I_textreji3pt\n      mathbf z_I_textimji  \n    endbmatrix \n    mathbf J=\n    beginbmatrix\n      mathbf J_V_textrei V_textre  mathbf J_V_textrei V_textim 3pt\n      mathbf J_V_textimi V_textre  mathbf J_V_textimi V_textim 3pt\n      mathbf J_I_textreij V_textre  mathbf J_I_textreij V_textim 3pt\n      mathbf J_I_textimij V_textre  mathbf J_I_textimij V_textim 3pt\n      mathbf J_I_textreji V_textre  mathbf J_I_textreji V_textim 3pt\n      mathbf J_I_textimji V_textre  mathbf J_I_textimji V_textim\n\tendbmatrix","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where measurement values are:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    z_V_textrei = z_V_i cos z_theta_i  z_V_textimi = z_V_i sin z_theta_i \n    z_I_textreij = z_I_ij cos z_beta_ij  z_I_textimij = z_I_ij sin z_beta_ij \n    z_I_textreji = z_I_ji cos z_beta_ji  z_I_textimij = z_I_ji sin z_beta_ji\n  endaligned","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The main disadvantage of this approach is related to measurement errors, because measurement errors correspond to polar coordinates (i.e. magnitude and angle errors), and hence, the covariance matrix must be transformed from polar to rectangular coordinates. As a result, measurement errors of a single PMU are correlated and covariance matrix does not have diagonal form. Despite that, the measurement error covariance matrix is usually considered as diagonal matrix, which has the effect on the accuracy of the state estimation.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Using the classical theory of propagation of uncertainty [12], the variance in the rectangular coordinate system sigma_V_textrei^2 can be obtained using variances in the polar coordinate system sigma_V_i^2 and sigma_theta_i^2 as:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    sigma_V_textrei^2 =\n    sigma_V_i^2 left cfracmathrm partial mathrm partial z_V_i (z_V_i cos z_theta_i) right^2 +\n    sigma_theta_i^2 left cfracmathrm partial mathrm partial z_theta_i (z_V_i cos z_theta_i)right^2 =\n    sigma_V_i^2 (cos z_theta_i)^2 + sigma_theta_i^2 (z_V_i sin z_theta_i)^2","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Using analogy, we can write:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    sigma_V_textimi^2 =\n    sigma_V_i^2 (sin z_theta_i)^2 + sigma_theta_i^2 (z_V_i cos z_theta_i)^2 \n    sigma_I_textreij^2  =\n    sigma_I_ij^2 (cos z_beta_ij)^2 + sigma_beta_ij^2 (z_I_ij sin z_beta_ij)^2 \n    sigma_I_textimij^2 =\n    sigma_I_ij^2 (sin z_beta_ij)^2 + sigma_beta_ij^2 (z_I_ij cos z_beta_ij)^2 \n    sigma_I_textreji^2 =\n    sigma_I_ji^2 (cos z_beta_ji)^2 + sigma_beta_ji^2 (z_I_ji sin z_beta_ji)^2 \n    sigma_I_textimji^2 =\n    sigma_I_ji^2 (sin z_beta_ji)^2 + sigma_beta_ji^2 (z_I_ji cos z_beta_ji)^2\n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The covariance in the rectangular coordinate system is:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    sigma_V_textrei V_textimi^2 = sigma_V_textimi V_textrei^2 =\n    sigma_V_i^2 cfracmathrm partial mathrm partial z_V_i (z_V_i cos z_theta_i)\n    cfracmathrm partial mathrm partial z_V_i (z_V_i sin z_theta_i)  +\n    sigma_theta_i^2 cfracmathrm partial mathrm partial z_theta_i (z_V_i cos z_theta_i)\n    cfracmathrm partial mathrm partial z_theta_i (z_V_i sin z_theta_i)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"respectively:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    sigma_V_textrei V_textimi^2 = sigma_V_textimi V_textrei^2 =\n    cos z_theta_i sin z_theta_i(sigma_V_i^2  - sigma_theta_i^2 z_V_i^2)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Using analogy, we can write:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    sigma_I_textreij I_textimij^2 = sigma_I_textimij I_textreij^2  =\n    sin z_beta_ij cos z_beta_ij(sigma_I_ij^2  - sigma_beta_ij^2 z_I_ij^2) \n    sigma_I_textreji I_textimji^2 = sigma_I_textimji I_textreji^2  =\n    sin z_beta_ji cos z_beta_ji(sigma_I_ji^2  - sigma_beta_ij^2 z_I_ji^2)\n  endaligned    ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The measurement error covariance matrix mathbfR in mathbb R^k times k has the structure:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\tmathbf R = textdiag\t(\n    mathbf R_V_textrei  mathbf R_V_textimi  mathbf R_I_textreij \n    mathbf R_I_textimij  mathbf R_I_textreji  mathbf R_I_textimji)","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The diagonal elements of the each covariance sub-matrix contains variances, wile covariances defined non-diagonal elements.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"JuliaGrid supports two models related to the covariance matrix:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"covariance matrix mathbf R contains measurement variances and covariances;\nmeasurement covariances are neglected, and covariance matrix mathbf R has the diagonal structure.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Note that the inverse of the full covariance matrix mathbf R requires larger computing time and uses more memory compared to the case where measurement covariances are neglected.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Further, in the absence of any angle measurement the number of state variables is s = 2n. More precisely, linear state estimation with PMUs does not include the slack bus in the state estimation model.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"man/tbestimate/#lineardcse-1","page":"State Estimation","title":"Linear DC State Estimation","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"As for the DC Power Flow, the DC model is obtained by linearisation of the non-linear model, where all bus voltage magnitudes are V_i approx 1, i in mathcalH, and all shunt elements and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers. Therefore, the DC state estimation takes only bus voltage angles mathbf x equiv bm theta as state variables. Consequently, the number of state variables is s=n-1, where one voltage angle represents the slack bus.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The set of DC model measurements mathcalM involves:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Legacy measurements:\nactive power flow M_P_ij M_P_ji  (ij) in mathcalE;\nactive power injection M_P_i  i in mathcalH;\nPhasor measurements provide by PMUs:\nbus voltage angle M_theta_i  i in mathcalH.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  &nbsp;","category":"page"},{"location":"man/tbestimate/#Active-Power-Flow-Measurement-Functions-1","page":"State Estimation","title":"Active Power Flow Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"As for the DC Power Flow, the active power flow at the branch (ij) in mathcalE that connects buses i and j can be obtained using:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    P_ij = cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij)\n    P_ji = -cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij)\n  endaligned  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Hence, measurements:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    M_P_ij M_P_ji   (ij) in mathcalE","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"are associated with measurement functions:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    h_P_ij(cdot) triangleq P_ij  h_P_ji(cdot) triangleq P_ji","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobians expressions corresponding to the measurement function h_P_ij(cdot) and h_P_ji(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_ij(cdot)mathrm partial theta_i = cfrac1tau_ij x_ij \n    cfracmathrm partialh_P_ij(cdot)mathrm partial theta_j = -cfrac1tau_ij x_ij \n    cfracmathrm partialh_P_ji(cdot)mathrm partial theta_i = -cfrac1tau_ij x_ij \n  cfracmathrm partialh_P_ji(cdot)mathrm partial theta_j = cfrac1tau_ij x_ij\n  endaligned  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Active-Power-Injection-Measurement-Functions-1","page":"State Estimation","title":"Active Power Injection Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The active power injection into the bus i in mathcalH can be obtained using:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"   P_i = B_iitheta_i + sum_j in mathcalH_i setminus i B_ij theta_j + P_textgsi + g_textshi","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where mathcalH_i setminus i contains buses incident to the bus i, excluding bus i. Hence, the measurement:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    mathcalM_P_i   i in mathcalH","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"is associated with the measurement function:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    h_P_i(cdot) triangleq P_i","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Jacobians expressions corresponding to the measurement function h_P_i(cdot) are defined:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_i(cdot)mathrm partial theta_i = B_ii \n  cfracmathrm partialh_P_i(cdot)mathrm partial theta_j = B_ij\n  endaligned  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#Bus-Voltage-Angle-Measurement-Functions-1","page":"State Estimation","title":"Bus Voltage Angle Measurement Functions","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"The measurement:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    mathcalM_theta_i   i in mathcalH","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"is simply associated with the measurement function:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    h_theta_i(cdot) triangleq theta_i","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"with Jacobian expressions:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    cfracmathrm partialh_theta_i(cdot)mathrm partial theta_i = 1 \n    cfracmathrm partialh_theta_i(cdot)mathrm partial theta_j = 0\n  endaligned  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"&nbsp;","category":"page"},{"location":"man/tbestimate/#State-Estimation-Model-3","page":"State Estimation","title":"State Estimation Model","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"To recall, the measurement model is described as the system of equations:  ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  mathbfz=mathbfh(mathbfx)+mathbfu","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where in the DC model constant terms exist on the right-hand side of mathbfh(mathbfx). Consequently, we can write:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  mathbfz=mathbfh(mathbfx) + mathbfc +mathbfu","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Presented model represents the system of linear equations, where solution can be found by solving the linear weighted least-squares problem:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"\t\tBigmathbf J^T mathbf R^-1 mathbf JBig mathbf x =\n\t\tmathbf J^T mathbf R^-1 (mathbf z - mathbfc)       ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"Here, the vector of measurement values mathbf z in mathbb R^k, the vector of constant terms mathbf c in mathbb R^k, the Jacobian matrix mathbf J in mathbb R^k times s and measurement error covariance matrix mathbfR in mathbb R^k times k are:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"    mathbf z =\n    beginbmatrix    \t \n      mathbf z_P_ij3pt\n      mathbf z_P_ji3pt\n      mathbf z_P_i3pt\n      mathbf z_theta_i  \n    endbmatrix \n    mathbf c =\n    beginbmatrix    \t \n      mathbf c_P_ij3pt\n      mathbf c_P_ji3pt\n      mathbf c_P_i3pt\n      mathbf c_theta_i  \n    endbmatrix \n    mathbf J =\n    beginbmatrix\n      mathbf J_P_ij 3pt\n      mathbf J_P_ji 3pt\n      mathbf J_P_i 3pt\n      mathbf J_theta_i\n\tendbmatrix \n  mathbf R = \t\n    beginbmatrix\n\t   mathbf R_mathrmP_ij  mathbf0  mathbf0  mathbf0 \n     mathbf0  mathbf R_mathrmP_ji   mathbf0 mathbf0 \n\t   mathbf0  mathbf0  mathbf R_mathrmP_i  mathbf0  \n\t   mathbf0  mathbf0 mathbf0  mathbf R_mathrmtheta_i\n\tendbmatrix","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"where elements of the vector mathbf c are equal to:","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"  beginaligned\n    c_P_ij = -cfracphi_ijtau_ij  c_P_ji = cfracphi_ijtau_ij \n    c_P_i = P_textgsi + g_textshi  c_T_i = T_textref\n  endaligned      ","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"In the DC state estimation method, the slack bus voltage angle T_textref is formulated as T_textref = 0. If T_textref neq 0 then the bus voltage magnitude measurements must be shifted by T_textref value. Accordingly, the state estimator mathbf x shifts by the same value T_textref as well. Finally, each sub-matrix of mathbf R is the diagonal measurement error covariance matrix that contains measurement variances.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"man/tbestimate/#refestimate-1","page":"State Estimation","title":"References","text":"","category":"section"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[1] F. C. Schweppe and D. B. Rom, \"Power system static-state estimation, part II: Approximate model,\" IEEE Trans. Power Syst., vol. PAS-89, no. 1, pp. 125-130, Jan. 1970.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[2] A. Monticelli, \"Electric power system state estimation,\" in Proc. IEEE, vol. 88, no. 2, pp. 262-282, Feb. 2000.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[3] A. Abur and A. Exposito, Power System State Estimation: Theory and Implementation, ser. Power Engineering. Taylor & Francis, 2004.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[4] A. Monticelli, State Estimation in Electric Power Systems: A Generalized Approach, ser. Kluwer international series in engineering and computer science. Springer US, 1999.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[5] D. Barber, Bayesian Reasoning and Machine Learning, Cambridge University Press, 2012.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[6] A. Wood and B. Wollenberg, Power Generation, Operation, and Control, ser. A Wiley-Interscience publication. Wiley, 1996.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[7] Y. Weng, Q. Li, R. Negi, and M. Ilic, \"Semidefinite programming for power system state estimation,\" in Proc. IEEE PES General Meeting, July 2012, pp. 1-8.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[8] P. C. Hansen, V. Pereyra, and G. Scherer, Least squares data fitting with applications, JHU Press, 2013.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[9] A. G. Phadke and J. S. Thorp, Synchronized phasor measurements and their applications, Springer, 2008, vol. 1.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[10] G. N. Korres and N. M. Manousakis, \"State estimation and observability analysis for phasor measurement unit measured systems,\" IET Gener. Transm. Dis., vol. 6, no. 9, pp. 902-913, September 2012.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[11] A. Gomez-Exposito, A. Abur, P. Rousseaux, A. de la Villa Jaen, and C. Gomez-Quiles, \"On the use of PMUs in power system state estimation,\" in Proc. IEEE PSCC, 2011.","category":"page"},{"location":"man/tbestimate/#","page":"State Estimation","title":"State Estimation","text":"[12] ISO-IEC-OIML-BIPM: \"Guide to the expression of uncertainty in measurement,\" 1992.","category":"page"},{"location":"man/generator/#runmg-1","page":"Measurement Generator","title":"Measurement Generator","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"The function uses the AC Power Flow or predefined user data to generate measurements z_1 dots z_n by corrupting the exact solutions e_1 dots e_n using the additive white Gaussian noise with variances sigma_1^2 dots sigma_n^2:","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":" z_i = e_i + epsilon_i  5pt\n epsilon_i sim mathcalN(0sigma_i^2)","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"The standalone measurement generator produces measurement data in a form suitable for the state estimation function.","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"Also, to achieve global observability of the power system only with PMUs, we implemented the optimal placement algorithm.","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"","category":"page"},{"location":"man/generator/#Run-Settings-1","page":"Measurement Generator","title":"Run Settings","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"The standalone measurement generator receives inputs for measurement variances, and inputs for measurement sets, to produce measurement data. There are two export formats supported for the measurement data, .h5 or .xlsx file. The settings are provided as input arguments of the function runmg().","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"The order of inputs and their appearance is arbitrary, with onlyÂ DATA input required. Still, for the methodological reasons, the syntax examples follow a certain order.","category":"page"},{"location":"man/generator/#Syntax-1","page":"Measurement Generator","title":"Syntax","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"runmg(DATA)\nrunmg(DATA; RUNPF)\nrunmg(DATA; RUNPF, SET)\nrunmg(DATA; RUNPF, SET, VARIANCE)\nrunmg(DATA; RUNPF, SET, VARIANCE, ACCONTROL)\nrunmg(DATA; RUNPF, SET, VARIANCE, ACCONTROL, SAVE)","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#Description-1","page":"Measurement Generator","title":"Description","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"runmg(DATA) computes the AC power flow problem and generates measurements\nrunmg(DATA; RUNPF) sets AC power flow analysis\nrunmg(DATA; RUNPF, SET) defines the measurement set (in-service and out-service)\nrunmg(DATA; RUNPF, SET, VARIANCE) defines measurement values using predefined variances\nrunmg(DATA; RUNPF, SET, VARIANCE, ACCONTROL) sets variables for the AC power flow\nrunmg(DATA; RUNPF, SET, VARIANCE, ACCONTROL, SAVE) exports measurements and power system data","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#Output-1","page":"Measurement Generator","title":"Output","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"measurements, system, info = runmg() returns measurement and power system data with a summary","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#Examples-1","page":"Measurement Generator","title":"Examples","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"julia> measurements, system, info = runmg(\"case14.xlsx\"; pmuset = \"optimal\")","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"julia> measurements, = runmg(\"case14.xlsx\"; pmuset = [\"Iij\" 5 \"Vi\" 2])","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"julia> measurements, = runmg(\"case14.xlsx\"; pmuset = [\"Iij\" \"all\" \"Vi\" 2], legacyset = [\"Pij\" 4 \"Qi\" 8])","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"julia> measurements, = runmg(\"case14.h5\"; legacyset = [\"redundancy\" 3.1], legacyvariance = [\"complete\" 1e-4])","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"julia> measurements, = runmg(\"case14.h5\"; legacyset = \"complete\", legacyvariance = [\"Pij\" 1e-4])","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"","category":"page"},{"location":"man/generator/#Input-Arguments-1","page":"Measurement Generator","title":"Input Arguments","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"The measurement generator function runmg() receives the variable number of argument DATA, and group of arguments by keyword: RUNPF, SET, VARIANCE, ACCONTROL and SAVE.","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#DATA-Variable-Argument-1","page":"Measurement Generator","title":"DATA - Variable Argument","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"Example Description\n\"case14.h5\" loads the power system data from the package\n\"case14.xlsx\" loads the power system data from the package\n\"C:/case14.xlsx\" loads the power system data from a custom path","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#RUNPF-Keyword-Argument-1","page":"Measurement Generator","title":"RUNPF - Keyword Argument","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"Command Description\nrunflow = 1 forces the AC power flow analysis to generate measurements, default setting\nrunflow = 0 generates measurements directly from the input DATA","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#SET-Keyword-Argument-1","page":"Measurement Generator","title":"SET - Keyword Argument","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"SET: Complete Phasor Measurement Set\nCommand pmuset = \"complete\"\nDescription complete phasor measurement set in-service","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"SET: Optimal Phasor Measurement Set\nCommand pmuset = \"optimal\"\nDescription deploys phasor measurements according to the optimal PMU location using GLPK solver, where the system is completely observable only by phasor measurements","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"SET: Phasor Measurement Set Using Redundancy\nCommand pmuset = [\"redundancy\" value]\nDescription deploys random angle and magnitude measurements measured by PMUs according to the corresponding redundancy","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"SET: Phasor Measurement Set According to Devices\nCommand pmuset = [\"device\" value]\nDescription deploys voltage and current phasor measurements according to the random selection of PMUs placed on buses, to deploy all devices use \"all\" as value","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"SET: Phasor Measurement Set According to Types\nCommand pmuset = [\"Iij\" value \"Dij\" value \"Vi\" value \"Ti\" value \"complete\"]\nDescription deploys phasor measurements according to the random selection of measurement types[1], to deploy all selected measurements use \"all\" as value, to deploys all measurements in-service, except for those individually defined use \"complete\"","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"SET: Complete Legacy Measurement Set\nCommand legacyset = \"complete\"\nDescription complete legacy measurement set in-service","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"SET: Legacy Measurement Set Using Redundancy\nCommand legacyset = [\"redundancy \" value]\nDescription deploys random selection of legacy measurements according the corresponding redundancy","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"SET: Legacy Measurement Set According to Types\nCommand legacyset = [\"Pij\" value \"Qij\" value \"Iij\" value \"Pi\" value \"Qi\" value \"Vi\" value \"complete\"]\nDescription deploys legacy measurements according to the random selection of measurement types[2], to deploy all selected measurements use \"all\" as value, to deploys all measurements in-service, except for those individually defined use \"complete\"","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"note: Set\nIf runflow = 0, the function keeps sets as in the input DATA and changes only the sets that are called using keywords. For example, if the keywords pmuset and legacyset are omitted, the function will retain the measurement set as in the input DATA, which allows the same measurement set, while changing the measurement variances.If runflow = 1, the function starts with all the measurement sets marked as out-service.  Further, the function accept any subset of phasor[1] or legacy[2] measurements, and consequently, it is not necessary to define attributes for all measurements.  julia> runmg(\"case14.h5\"; pmuset = [\"Iij\" \"all\" \"Vi\" 2])Thus, the measurement set will consist of two randomly selected bus voltage magnitude measurements, and all branch current magnitude measurements, both of them related with PMUs.  ","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#VARIANCE-Keyword-Argument-1","page":"Measurement Generator","title":"VARIANCE - Keyword Argument","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"VARIANCE: Unique Phasor Measurement Variances\nCommand pmuvariance = [\"complete\" value]\nDescription applies fixed-value variance over all phasor measurements","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"VARIANCE: Random Phasor Measurement Variances within Limits\nCommand pmuvariance = [\"random\" min max]\nDescription selects variances uniformly at random within limits, applied over all phasor measurements","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"VARIANCE: Unique Phasor Measurement Variances According to Types\nCommand pmuvariance = [\"Iij\" value \"Dij\" value \"Vi\" value \"Ti\" value \"complete\" value]\nDescription predefines variances over a given subset of phasor measurements[1]; to apply fixed-value variance over all, except for those individually defined use \"complete\" value","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"VARIANCE: Unique Legacy Measurement Variances\nCommand legacyvariance = [\"complete\" value]\nDescription applies fixed-value variance over all legacy measurements","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"VARIANCE: Random Legacy Measurement Variances within Limits\nCommand legacyvariance = [\"random\" min max]\nDescription selects variances uniformly at random within limits, applied over all legacy measurements","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"VARIANCE: Unique Legacy Measurement Variances According to Types\nCommand legacyvariance = [\"Pij\" value \"Qij\" value \"Iij\" value \"Pi\" value \"Qi\" value \"Vi\" value \"complete\" value]\nDescription predefines variances over a given subset of legacy measurements[2], to apply fixed-value variance over all, except for those individually defined use \"complete\" value","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"note: Variance\nIf runflow = 0, the function keeps measurement values and measurement variances as in the input DATA, and changes only measurement values and variances that are called using keywords. For example, if the keywords pmuvariance and legacyvariance are omitted, the function will retain the measurement values and variances as in the input DATA, allowing the same measurement values and variances, while changing the measurement sets.If runflow = 1, the function starts with zero variances, meaning that measurement values are equal to zero values.Further, the function accepts any subset of phasor[1] or legacy[2] measurements, consequently, it is not necessary to define attributes for all measurements, where keyword \"complete\" generates measurement values according to defined variance for all measurements, except for those individually defined.   julia> runmg(\"case14.h5\"; legacyvariance = [\"Pij\" 1e-4 \"complete\" 1e-5])The function applies variance value of 1e-5 over all legacy measurements, except for active power flow measurements which have variance equal to 1e-4.","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#ACCONTROL-Keyword-Argument-1","page":"Measurement Generator","title":"ACCONTROL - Keyword Argument","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"Command Description\nmax = value specifies the maximum number of iterations for the AC power flow, default setting: 100\nstop = value specifies the stopping criteria for the AC power flow, default setting: 1.0e-8\nreactive = 1 forces reactive power constraints, default setting: 0\nsolve = \"builtin\" built-in linear system solver, default setting\nsolve = \"lu\" LU linear system solver","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"&nbsp;","category":"page"},{"location":"man/generator/#SAVE-Keyword-Argument-1","page":"Measurement Generator","title":"SAVE - Keyword Argument","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"Command Description\nsave = \"path/name.h5\" saves results in the h5-file\nsave = \"path/name.xlsx\" saves results in the xlsx-file","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"","category":"page"},{"location":"man/generator/#Data-Structure-1","page":"Measurement Generator","title":"Data Structure","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"The function supports two input types: .h5 or .xlsx file extensions. The measurement data structure consists of variables pmuVoltage and pmuCurrent associated with phasor measurements, and legacyFlow, legacyCurrent, legacyInjection and legacyVoltage associated with legacy measurements. Further, the function requires knowledge about a power system using variables bus, branch, generator and basePower.","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"The minimum amount of information within an instance of the data structure required to run the module requires one variable associated with measurements if runflow = 0, and bus and branch variables.","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"We advise the reader to read the sections Power System Data Structure and Measurement Data Structure which provides the structure of the DATA.","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"","category":"page"},{"location":"man/generator/#Flowchart-1","page":"Measurement Generator","title":"Flowchart","text":"","category":"section"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"The measurement generator flowchart depicts the algorithm process according to user settings.","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"(Image: )","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"[1]: Complete phasor measurement set contains branch current magnitude Iij, branch current angle Dij, bus voltage magnitude Vi and bus voltage angle Ti measurements.","category":"page"},{"location":"man/generator/#","page":"Measurement Generator","title":"Measurement Generator","text":"[2]: Complete legacy measurement set contains active power flow Pij, reactive power flow Qij, branch current magnitude Iij, active power injection Pi, reactive power injection Qi and bus voltage magnitude Vi measurements.","category":"page"},{"location":"#JuliaGrid-1","page":"Home","title":"JuliaGrid","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver,  and allows a variety of display and manipulation options.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The software package, among other things, includes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"AC power flow analysis,\nDC power flow analysis,\nnon-linear state estimation (work in progress),\nlinear DC state estimation,\nlinear state estimation with PMUs,\nleast absolute value state estimation,\nbad data processing,\nobservability analysis,\noptimal PMU placement.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Main-Features-1","page":"Home","title":"Main Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Features supported by JuliaGrid can be categorised into three main groups:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Power Flow - performs the AC and DC power flow analysis using the executive function runpf(),\nState Estimation - performs non-linear, DC and PMU state estimation using the executive function runse(),\nStandalone Measurement Generator - generates a set of measurements using the executive function runmg().","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"JuliaGrid requires Julia 1.2 and higher. To install JuliaGrid package, run the following command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add https://github.com/mcosovic/JuliaGrid.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To load the package, use the command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using JuliaGrid","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Quick-Start-Power-Flow-1","page":"Home","title":"Quick Start Power Flow","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> results, system, info = runpf(\"dc\", \"case14.h5\", \"main\", \"flow\", \"generation\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> results, = runpf(\"nr\", \"case14.xlsx\", \"main\"; max = 20, stop = 1.0e-8)","category":"page"},{"location":"#Quick-Start-State-Estimation-1","page":"Home","title":"Quick Start State Estimation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> results, = runse(\"case30se.h5\", \"dc\", \"estimate\"; bad = [\"pass\" 2 \"threshold\" 3.5])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> results, = runse(\"case14se.xlsx\", \"pmu\", \"main\", \"estimate\")","category":"page"},{"location":"#Quick-Start-Measurement-Generator-1","page":"Home","title":"Quick Start Measurement Generator","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> measurements, system, info = rungen(\"case14.h5\"; pmuset = \"optimal\", pmuvariance = [\"complete\" 1e-5])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> measurements, = rungen(\"case14.h5\"; legacyset = [\"redundancy\" 3.1], legacyvariance = [\"complete\" 1e-4])","category":"page"}]
}
