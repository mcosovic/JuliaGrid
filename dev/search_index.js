var documenterSearchIndex = {"docs":
[{"location":"api/configuration/#configurationSetupAPI","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"For further information on this topic, please see the Power System Model section of the Manual.","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#API-Index","page":"Configuration Setup","title":"API Index","text":"","category":"section"},{"location":"api/configuration/#Base-Unit-Prefixes","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#Input-Unit-System","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@parameter","category":"page"},{"location":"api/configuration/#Default-Settings","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Base-Unit-Prefixes-2","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#JuliaGrid.@base","page":"Configuration Setup","title":"JuliaGrid.@base","text":"@base(system::PowerSystem, power, voltage)\n\nBy default, the units for base power and base voltages are set to volt-ampere (VA) and volt (V), but you can modify the prefixes using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of power (VA) or unit of voltage (V). Keep in mind that the macro must be used after creating the composite type PowerSystem.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n@base(system, MVA, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Input-Unit-System-2","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@parameter","category":"page"},{"location":"api/configuration/#JuliaGrid.@power","page":"Configuration Setup","title":"JuliaGrid.@power","text":"@power(active, reactive, apparent)\n\nJuliaGrid stores all data related with powers in per-units, and these cannot be altered. However, the power units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of active power (W), reactive power (VAr), or apparent power (VA). Also it is a possible to combine SI units with/without prefixes with per-units (pu).\n\nChanging the unit of active power is reflected in the following quantities:\n\naddBus!: active, conductance,\nshuntBus!: conductance,\naddGenerator!: active, minActive, maxActive, lowActive, upActive, loadFollowing, reserve10min, reserve30min,\naddActiveCost!: piecewise, polynomial,\noutputGenerator!: active,\naddBranch!: longTerm, shortTerm, emergency if rating type = 2.\n\nChanging the unit of reactive power unit is reflected in the following quantities:\n\naddBus!: reactive, susceptance,\nshuntBus!: susceptance,\naddGenerator!: reactive, minReactive, maxReactive, minLowReactive, maxLowReactive, minUpReactive, maxUpReactive, reactiveTimescale,\naddReactiveCost!: piecewise, polynomial,\noutputGenerator!: reactive.\n\nChanging the unit of apparent power unit is reflected in the following quantities:\n\naddBranch!: longTerm, shortTerm, emergency if rating type = 1 or type = 3.\n\nExample\n\n@power(MW, kVAr, VA)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@voltage","page":"Configuration Setup","title":"JuliaGrid.@voltage","text":"@voltage(magnitude, angle, base)\n\nJuliaGrid stores all data related with voltages in per-units and radians, and these cannot be altered. However, the voltage magnitude and angle units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nThe prefixes must adhere to the SI prefixes and should be specified along with the unit of voltage, either magnitude (V) or base (V). Alternatively, the unit of voltage magnitude can be expressed in per-unit (pu). The unit of voltage angle should be in radians (rad) or degrees (deg).\n\nChanging the unit of voltage magnitude is reflected in the following quantities:\n\naddBus!: magnitude, minMagnitude, maxMagnitude,\naddGenerator!: magnitude.\n\nChanging the unit of voltage angle is reflected in the following quantities:\n\naddBus!: angle,\naddBranch!: shiftAngle, minDiffAngle, maxDiffAngle,\nparameterBranch!: shiftAngle.\n\nChanging the unit prefix of voltage base is reflected in the following quantity:\n\naddBus!: base.\n\nExample\n\n@voltage(pu, deg, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@parameter","page":"Configuration Setup","title":"JuliaGrid.@parameter","text":"@parameter(impedance, admittance)\n\nJuliaGrid stores all data related with impedances and admittancies in per-units, and these cannot be altered. However, units of impedance and admittance of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of impedance (Ω) or unit of admittance (S). The second option is to define the units in per-unit (pu).\n\nIn the case where impedance and admittance are being used in SI units (Ω and S) and these units are related to the transformer, the assignment must be based on the primary side of the transformer.\n\nChanging the units of impedance is reflected in the following quantities in specific functions:\n\naddBranch!: resistance, reactance,\nparameterBranch!: resistance, reactance.\n\nChanging the units of admittance is reflected in the following quantities:\n\naddBranch!: susceptance,\nparameterBranch!: susceptance.\n\nExample\n\n@parameter(Ω, pu)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Default-Settings-2","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/#JuliaGrid.@default","page":"Configuration Setup","title":"JuliaGrid.@default","text":"The macro is designed to reset various settings to their default values.\n\n@default(mode)\n\nThe mode argument can take on the following values:\n\nunit: resets all units to their default settings\npower: sets active, reactive, and apparent power to per-units\nvoltage: sets voltage magnitude to per-unit and voltage angle to radian\nparameter: sets impedance and admittance to per-units\ntemplate: resets bus, branch and generator templates to their default settings\nbus: resets the bus template to its default settings\nbranch: resets the branch template to its default settings\ngenerator: resets the generator template to its default settings.\n\nExample\n\n@default(unit)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerFlow/#PowerFlowAPI","page":"Power Flow","title":"Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"For further information on this topic, please see the AC Power Flow or DC Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for power flow analysis.","category":"page"},{"location":"api/powerFlow/#Build-Model","page":"Power Flow","title":"Build Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel\ndcPowerFlow","category":"page"},{"location":"api/powerFlow/#Solve-Power-Flow","page":"Power Flow","title":"Solve Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"mismatch!\nsolve!","category":"page"},{"location":"api/powerFlow/#Power-Analysis","page":"Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"power!\npowerInjection\npowerSupply\npowerShunt\npowerFrom\npowerTo\npowerCharging\npowerSeries\npowerGenerator","category":"page"},{"location":"api/powerFlow/#Current-Analysis","page":"Power Flow","title":"Current Analysis","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"current!\ncurrentInjection\ncurrentFrom\ncurrentTo\ncurrentSeries","category":"page"},{"location":"api/powerFlow/#Additional-Functions","page":"Power Flow","title":"Additional Functions","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"reactiveLimit!\nadjustAngle!","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-Model-2","page":"Power Flow","title":"Build Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel\ndcPowerFlow","category":"page"},{"location":"api/powerFlow/#JuliaGrid.newtonRaphson","page":"Power Flow","title":"JuliaGrid.newtonRaphson","text":"newtonRaphson(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Newton-Raphson method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the NewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\njacobian: the Jacobian matrix;\nmismatch: the active and reactive power injection mismatches;\nincrement: the bus voltage magnitude and angle increments;\npq: indices of demand buses;\npvpq: indices of demand and generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonBX","text":"fastNewtonRaphsonBX(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the fast Newton-Raphson method of version BX to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field  within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nactive:\njacobian: the Jacobian matrix associated with active power equations;\nmismatch: the active power injection mismatches;\nincrement: the bus voltage angle increments;\nfactorization: the factorized Jacobian matrix;\nreactive:\njacobian: the Jacobian matrix associated with reactive power equations;\nmismatch: the reative power injection mismatches;\nincrement: the bus voltage magnitude increments;\nfactorization: the factorized Jacobian matrix;\npq: indices of demand buses;\npvpq: indices of demand and generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonBX(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonXB","text":"fastNewtonRaphsonXB(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the fast Newton-Raphson method of version XB to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nactive:\njacobian: the Jacobian matrix associated with active power equations;\nmismatch: the active power injection mismatches;\nincrement: the bus voltage angle increments;\nfactorization: the factorized Jacobian matrix;\nreactive:\njacobian: the Jacobian matrix associated with reactive power equations;\nmismatch: the reative power injection mismatches;\nincrement: the bus voltage magnitude increments;\nfactorization: the factorized Jacobian matrix;\npq: indices of demand buses;\npvpq: indices of demand and generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonXB(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.gaussSeidel","page":"Power Flow","title":"JuliaGrid.gaussSeidel","text":"gaussSeidel(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Gauss-Seidel method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the GaussSeidel subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\ncomplex: the bus complex voltages;\npq: indices of demand buses;\npv: indices of generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = gaussSeidel(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.dcPowerFlow","page":"Power Flow","title":"JuliaGrid.dcPowerFlow","text":"dcPowerFlow(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input, which is utilized to establish the structure for solving the DC power flow.\n\nIf the DC model was not created, the function will automatically initiate an update of the dc field within the PowerSystem composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.\n\nReturns\n\nThe function returns an instance of the DCPowerFlow composite type, which includes the following fields:\n\nvoltage: the variable allocated to store the bus voltage angles;\npower: the variable allocated to store the active powers;\nfactorization: the factorized nodal matrix.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Solve-Power-Flow-2","page":"Power Flow","title":"Solve Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"mismatch!(::PowerSystem, ::NewtonRaphson)\nsolve!(::PowerSystem, ::NewtonRaphson)\nsolve!(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}","page":"Power Flow","title":"JuliaGrid.mismatch!","text":"mismatch!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function calculates both active and reactive power injection mismatches and returns their maximum absolute values, which can be utilized to terminate the iteration loop of methods employed to solve the AC power flow problem.\n\nUpdates\n\nThis function updates the mismatch variables in the Newton-Raphson and fast Newton-Raphson methods. It should be employed during the iteration loop before invoking the solve! function.\n\nIn contrast, the Gauss-Seidel method does not need mismatches to obtain bus voltages, but the maximum absolute values are commonly employed to stop the iteration loop. The function does not save any data and should be utilized during the iteration loop before invoking the solve! function.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the power mismatches within the Newton-Raphson method;\nFastNewtonRaphson: computes the power mismatches within the fast Newton-Raphson method;\nGaussSeidel: computes the power mismatches within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nmismatch!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function employs the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel method to solve the AC power flow problem and calculate bus voltage magnitudes and angles.\n\nAfter the mismatch! function is called, this function should be executed to perform a single iteration of the method.\n\nUpdates\n\nThe calculated voltages are stored in the voltage field of the respective struct type.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method;\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method;\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::DCPowerFlow)\n\nBy computing the bus voltage angles, the function solves the DC power flow problem.\n\nUpdates\n\nThe resulting bus voltage angles are stored in the voltage field of the DCPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Additional-Functions-2","page":"Power Flow","title":"Additional Functions","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"reactiveLimit!\nadjustAngle!","category":"page"},{"location":"api/powerFlow/#JuliaGrid.reactiveLimit!","page":"Power Flow","title":"JuliaGrid.reactiveLimit!","text":"reactiveLimit!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function verifies whether the generators in a power system exceed their reactive power limits. This is done by setting the reactive power of the generators to within the limits if they are violated, after determining the bus voltage magnitudes and angles. If the limits are violated, the corresponding generator buses or the slack bus are converted to demand buses.\n\nUpdates\n\nThe function assigns values to the generator.output.active and bus.supply.active variables of the PowerSystem type. Additionally, it examines the reactive powers of the generator and adjusts them to their maximum or minimum values if they exceed the specified threshold. Subsequently, the generator.output.reactive variable of the PowerSystem type is modified accordingly. As a result of this adjustment, the bus.supply.reactive variable of the PowerSystem type is also updated, and the bus types specified in bus.layout.type are modified. If the slack bus is converted, the bus.layout.slack field is correspondingly adjusted.\n\nReturns\n\nThe function returns the violate variable to indicate which buses violate the limits, with -1 indicating a violation of the minimum limits and 1 indicating a violation of the maximum limits.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method,\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method,\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nviolate = reactiveLimit!(system, analysis)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.adjustAngle!","page":"Power Flow","title":"JuliaGrid.adjustAngle!","text":"adjustAngle!(system::PowerSystem, analysis::ACPowerFlow; slack)\n\nThe function modifies the bus voltage angles based on a different slack bus than the one identified by the bus.layout.slack field.\n\nFor instance, if the reactive power of the generator exceeds the limit on the slack bus, the reactiveLimit! function will change that bus to the demand bus and designate the first generator bus in the sequence as the new slack bus. After obtaining the updated AC power flow solution based on the new slack bus, it is possible to adjust the voltage angles to align with the angle of the original slack bus. The slack keyword specifies the bus label of the original slack bus.\n\nUpdates\n\nThis function only updates the voltage.angle variable of the ACPowerFlow abstract type.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method;\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method;\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nreactiveLimit!(system, analysis)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nadjustAngle!(system, analysis; slack = 1)\n\n\n\n\n\n","category":"function"},{"location":"api/analysis/#PowerCurrentAnalysisAPI","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"In the following section, we have provided a list of functions that can be utilized for post-processing analysis. Once the voltage values are obtained through power flow analysis or optimal power flow analysis, these functions can be used to calculate power or current values. The specific procedures for computing these values depend on the chosen analysis, which are described in separate manuals for further information.","category":"page"},{"location":"api/analysis/#Power-Analysis","page":"Power and Current Analysis","title":"Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!\npowerInjection\npowerSupply\npowerShunt\npowerFrom\npowerTo\npowerCharging\npowerSeries\npowerGenerator","category":"page"},{"location":"api/analysis/#Current-Analysis","page":"Power and Current Analysis","title":"Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"current!\ncurrentInjection\ncurrentFrom\ncurrentTo\ncurrentSeries","category":"page"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#PowerAnalysisAPI","page":"Power and Current Analysis","title":"Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!(::PowerSystem, ::ACPowerFlow)\npower!(::PowerSystem, ::DCPowerFlow)\npowerInjection(::PowerSystem, ::AC)\npowerInjection(::PowerSystem, ::DCPowerFlow)\npowerSupply(::PowerSystem, ::ACPowerFlow)\npowerSupply(::PowerSystem, ::DCPowerFlow)\npowerShunt(::PowerSystem, ::AC)\npowerFrom(::PowerSystem, ::AC)\npowerFrom(::PowerSystem, ::DC)\npowerTo(::PowerSystem, ::AC)\npowerTo(::PowerSystem, ::DC)\npowerCharging(::PowerSystem, ::AC)\npowerSeries(::PowerSystem, ::AC)\npowerGenerator(::PowerSystem, ::ACPowerFlow)\npowerGenerator(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.power!","text":"power!(system::PowerSystem, analysis::AC)\n\nThe function computes the active and reactive powers associated with buses, branches, and generators in the AC framework.\n\nUpdates\n\nThis function updates the power field of the AC abstract type by computing the following electrical quantities:\n\ninjection: active and reactive power bus injections;\nsupply: active and reactive power bus injections from the generators;\nshunt: active and reactive power values associated with shunt element at each bus;\nfrom: active and reactive power flows at the \"from\" end of each branch;\nto: active and reactive power flows at the \"to\" end of each branch;\ncharging: active and reactive power values linked with branch charging admittances for each branch;\nseries active and reactive power losses through each branch series impedance;\ngenerator: produced active and reactive power outputs of each generator.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\npower!(system, analysis)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\npower!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.power!","text":"power!(system::PowerSystem, analysis::DC)\n\nThe function calculates the active power values related to buses, branches, and generators within the DC analysis framework. It modifies the power field of the abstract type DC.\n\nUpdates\n\nThis function computes the following electrical quantities:\n\ninjection: active power injections at each bus;\nsupply: active power injections from the generators at each bus;\nfrom: active power flows at each \"from\" bus end of the branch;\nto: active power flows at each \"to\" bus end of the branch;\ngenerator: output active powers of each generator.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the powers within the DC power flow;\nDCOptimalPowerFlow: computes the powers within the DC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\npower!(system, analysis)\n\nCompute powers after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\npower!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerInjection-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.powerInjection","text":"powerInjection(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power injections associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = powerInjection(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = powerInjection(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerInjection-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.powerInjection","text":"powerInjection(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power injection associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow;\n\nExamples\n\nCompute the active power of a specific bus after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\ninjection = powerInjection(system, analysis; label = 2)\n\nCompute the active power of a specific bus after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\ninjection = powerInjection(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerSupply-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.powerSupply","text":"powerSupply(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power injections from the generators associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = powerSupply(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = powerSupply(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerSupply-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.powerSupply","text":"powerSupply(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power injection from the generators associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow,\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific bus after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nsupply = powerSupply(system, analysis; label = 2)\n\nCompute the active power of a specific bus after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nsupply = powerSupply(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerShunt-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.powerShunt","text":"powerShunt(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power values of the shunt element associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = powerShunt(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = powerShunt(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerFrom-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.powerFrom","text":"powerFrom(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power flows at the \"from\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = powerFrom(system, analysis; label = 2)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = powerFrom(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerFrom-Tuple{PowerSystem, DC}","page":"Power and Current Analysis","title":"JuliaGrid.powerFrom","text":"powerFrom(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power flow at the \"from\" bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific branch after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nfrom = powerFrom(system, analysis; label = 2)\n\nCompute the active power of a specific branch after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nfrom = powerFrom(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerTo-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.powerTo","text":"powerTo(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power flows at the \"to\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = powerTo(system, analysis; label = 2)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = powerTo(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerTo-Tuple{PowerSystem, DC}","page":"Power and Current Analysis","title":"JuliaGrid.powerTo","text":"powerTo(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power flow at the \"to\" bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific branch after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nto = powerTo(system, analysis; label = 2)\n\nCompute the active power of a specific branch after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nto = powerTo(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerCharging-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.powerCharging","text":"powerCharging(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power values associated with the charging admittances of a specific branch in the AC framework. The label keyword argument must correspond to an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the power within the AC power flow;\nACOptimalPowerFlow: computes the power within the AC optimal power flow.\n\nExamples\n\nCompute the reactive power after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = powerCharging(system, analysis; label = 2)\n\nCompute the reactive power after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = powerCharging(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerSeries-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.powerSeries","text":"powerSeries(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power losses across the series impedance of a specific branch within the AC framework. The label keyword argument should correspond to an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the power within the AC power flow;\nACOptimalPowerFlow: computes the power within the AC optimal power flow.\n\nExamples\n\nCompute the reactive power after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = powerSeries(system, analysis; label = 2)\n\nCompute the reactive power after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = powerSeries(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerGenerator-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.powerGenerator","text":"powerGenerator(system::PowerSystem, analysis::AC)\n\nThe function returns the active and reactive powers associated with a specific generator in the AC framework. The label keyword argument must match an existing generator label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = powerGenerator(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = powerGenerator(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.powerGenerator-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.powerGenerator","text":"powerGenerator(system::PowerSystem, analysis::DC; label)\n\nThis function returns the output active power associated with a specific generator in the DC framework. The label keyword argument must match an existing generator label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific generator after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\ngenerator = powerGenerator(system, analysis; label = 1)\n\nCompute the active power of a specific generator after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\ngenerator = powerGenerator(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#CurrentAnalysisAPI","page":"Power and Current Analysis","title":"Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"current!(::PowerSystem, ::AC)\ncurrentInjection(::PowerSystem, ::AC)\ncurrentFrom(::PowerSystem, ::AC)\ncurrentTo(::PowerSystem, ::AC)\ncurrentSeries(::PowerSystem, ::AC)","category":"page"},{"location":"api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.current!","text":"current!(system::PowerSystem, analysis::AC)\n\nThe function computes the currents in the polar coordinate system associated with buses and branches in the AC framework.\n\nUpdates\n\nThis function calculates various electrical quantities in the polar coordinate system:\n\ninjection: current injections at each bus;\nfrom: current flows at each \"from\" bus end of the branch;\nto: current flows at each \"to\" bus end of the branch;\nseries: current flows through the series impedance of the branch in the direction from the \"from\" bus end to the \"to\" bus end of the branch.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the currents within the AC power flow;\nACOptimalPowerFlow: computes the currents within the AC optimal power flow.\n\nExamples\n\nCompute currents after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\ncurrent!(system, analysis)\n\nCompute currents after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\ncurrent!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.currentInjection-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.currentInjection","text":"currentInjection(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = currentInjection(system, analysis; label = 1)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = currentInjection(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.currentFrom-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.currentFrom","text":"currentFrom(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the \"from\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = currentFrom(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = currentFrom(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.currentTo-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.currentTo","text":"currentTo(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the \"to\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = currentTo(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = currentTo(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.currentSeries-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.currentSeries","text":"currentSeries(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system through series impedance associated with a specific branch in the direction from the \"from\" bus end to the \"to\" bus end of the branch within the AC framework. The label keyword argument must  match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = currentSeries(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = currentSeries(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/powerSystemModel/#powerSystemModelAPI","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For further information on this topic, please see the Power System Model section of the Manual. Below, we have provided a list of functions that can be used to create, save, and manipulate power system structures, as well as to build AC or DC models of power systems.","category":"page"},{"location":"api/powerSystemModel/#Power-System-Data","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nshuntBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nstatusGenerator!\noutputGenerator!\naddActiveCost!\naddReactiveCost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System-Data-2","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.powerSystem","page":"Power System Model","title":"JuliaGrid.powerSystem","text":"powerSystem(file::String)\n\nThe function builds the composite type PowerSystem and populates bus, branch, generator and base fields. In general, once the composite type PowerSystem has been created, it is possible to add new buses, branches, or generators, or modify the parameters of existing ones.\n\nArgument\n\npassing the path to the HDF5 file with the .h5 extension,\npassing the path to Matpower file with the .m extension.\n\nReturns\n\nThe PowerSystem composite type with the following fields:\n\nbus: data related to buses;\nbranch: data related to branches;\ngenerator: data related to generators;\nbase: base power and base voltages;\nmodel: data associated with AC (nonlinear) or DC (linear) analyses.\n\nUnits\n\nJuliaGrid stores all data in per-units and radians format which are fixed, the exceptions are base values in volt-amperes and volts. The prefixes for these base values can be changed using the @base macro.\n\nExamples\n\nLoad power system data:\n\nsystem = powerSystem(\"case14.h5\")\n\nLoad power system data and build AC and DC models:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\ndcModel!(system)\n\n\n\n\n\nAlternatively, the PowerSystem composite type can be initialized by calling the function without any arguments.\n\npowerSystem()\n\nThis allows the model to be built from scratch and modified as needed. This generates an empty PowerSystem type, with only the base power initialized to 1.0e8 volt-amperes (VA).\n\nExample\n\nsystem = powerSystem()\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.savePowerSystem","page":"Power System Model","title":"JuliaGrid.savePowerSystem","text":"savePowerSystem(system::PowerSystem; path::String, reference::String, note::String)\n\nThe function saves the power system's data in the HDF5 file using the fields bus, branch, generator, and base from the PowerSystem composite type.\n\nKeywords\n\nThe location and file name of the HDF5 file is specified by the mandatory keyword path in  the format of \"path/name.h5\". Additional information can be provided by the optional  keywords reference and note, which can be saved along with the power system data.\n\nView HDF5 File\n\nTo view the saved HDF5 file, you can use the HDFView software.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"D:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions-2","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nshuntBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBus!","page":"Power System Model","title":"JuliaGrid.addBus!","text":"addBus!(system::PowerSystem; label, type, active, reactive, conductance, susceptance,\n    magnitude, angle, minMagnitude, maxMagnitude, base, area, lossZone)\n\nThe function adds a new bus to the PowerSystem composite type, updating its bus field.\n\nKeywords\n\nThe bus is defined with the following keywords:\n\nlabel: unique label for the bus;\ntype: the bus type:\ntype = 1: demand bus (PQ);\ntype = 2: generator bus (PV);\ntype = 3: slack bus (Vθ);\nactive (pu or W): the active power demand at the bus;\nreactive (pu or VAr): the reactive power demand at the bus;\nconductance (pu or W): the active power demanded of the shunt element;\nsusceptance (pu or VAr): the reactive power injected of the shunt element;\nmagnitude (pu or V): the initial value of the voltage magnitude;\nangle (rad or deg): the initial value of the voltage angle;\nminMagnitude (pu or V): the minimum voltage magnitude value;\nmaxMagnitude (pu or V): the maximum voltage magnitude value;\nbase (V): the base value of the voltage magnitude;\narea: the area number;\nlossZone: the loss zone.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: type = 1, magnitude = 1.0 per-unit, and base = 138e3 volts. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @bus macro.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, angle = 0.1745, base = 132e3)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 25, reactive = -4, angle = 10, base = 132)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.shuntBus!","page":"Power System Model","title":"JuliaGrid.shuntBus!","text":"shuntBus!(system::PowerSystem; label, conductance, susceptance)\n\nThis function enables the modification of the conductance and susceptance parameters of a shunt element connected to a bus.\n\nKeywords\n\nThe keyword label must match an existing bus label. If either conductance or susceptance is left out, the corresponding value will remain unchanged.\n\nUpdates\n\nThis function modifies the bus.shunt field in the PowerSystem composite type. Moreover, it also automatically updates the ac field within the PowerSystem type, thereby removing the requirement to completely rebuild the vectors and matrices when adjustments are made to these parameters.\n\nUnits\n\nThe input units are in per-units by default, but they can be modified using the @power macro.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\nshuntBus!(system; label = 1, conductance = 0.04)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@bus","page":"Power System Model","title":"JuliaGrid.@bus","text":"@bus(kwargs...)\n\nThe macro generates a template for a bus, which can be utilized to define a bus using the addBus! function.\n\nKeywords\n\nTo define the bus template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBus! function, along with their corresponding values.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus template using the default unit system:\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 0.25, angle = 0.1745)\naddBus!(system; label = 1, reactive = -0.04, base = 132e3)\n\nCreating a bus template using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\n@bus(type = 2, active = 25, angle = 10, base = 132)\naddBus!(system; label = 1, reactive = -4)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions-2","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBranch!","page":"Power System Model","title":"JuliaGrid.addBranch!","text":"addBranch!(system::PowerSystem; label, from, to, status, resistance, reactance,\n    conductance, susceptance, turnsRatio, shiftAngle, minDiffAngle, maxDiffAngle,\n    longTerm, shortTerm, emergency, type)\n\nThe function adds a new branch to the PowerSystem type and updates its branch field. A branch can be added between already defined buses.\n\nKeywords\n\nThe branch is defined with the following keywords:\n\nlabel: unique label for the branch;\nfrom: from bus label, corresponds to the bus label;\nto: to bus label, corresponds to the bus label;\nstatus: operating status of the branch:\nstatus = 1: in-service;\nstatus = 0: out-of-service;\nresistance (pu or Ω): series resistance;\nreactance (pu or Ω): series reactance;\nconductance (pu or S): total shunt conductance;\nsusceptance (pu or S): total shunt susceptance;\nturnsRatio: transformer off-nominal turns ratio, equal to one for a line;\nshiftAngle (rad or deg): transformer phase shift angle, where positive value defines delay;\nminDiffAngle (rad or deg): minimum voltage angle difference value between from and to bus;\nmaxDiffAngle (rad or deg): maximum voltage angle difference value between from and to bus;\nlongTerm (pu or VA, W): long-term rating (equal to zero for unlimited);\nshortTerm (pu or VA, W): short-term rating (equal to zero for unlimited);\nemergency (pu or VA, W): emergency rating (equal to zero for unlimited);\ntype: types of longTerm, shortTerm, and emergency ratings:\ntype = 1: apparent power flow (pu or VA);\ntype = 2: active power flow (pu or W);\ntype = 3: current magnitude (pu or VA at 1 pu voltage).\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1, turnsRatio = 1.0, and type = 1. The  rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @branch macro.\n\nUnits\n\nThe default units for the keyword parameters are per-units (pu) and radians (rad). However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)\n\nCreating a branch using a custom unit system:\n\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1,  active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 10)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.statusBranch!","page":"Power System Model","title":"JuliaGrid.statusBranch!","text":"statusBranch!(system::PowerSystem; label, status)\n\nThe function alters the operational status of a branch within the PowerSystem composite type, toggling between in-service and out-of-service.\n\nKeywords\n\nThe label keyword should correspond to the existing branch label, while the status keyword modifies the operational status of the branch.\n\nUpdates\n\nThis function modifies the branch.layout.status variable in the PowerSystem composite type. Moreover, it also automatically updates the ac and dc fields within the PowerSystem type, thereby removing the requirement to completely rebuild the vectors and matrices when the operational status of a branch changes.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nstatusBranch!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.parameterBranch!","page":"Power System Model","title":"JuliaGrid.parameterBranch!","text":"parameterBranch!(system::PowerSystem; label, resistance, reactance, conductance,\n    susceptance, turnsRatio, shiftAngle)\n\nThe function allows for the modification of branch parameters within the PowerSystem composite type.\n\nKeywords\n\nThe function modifies the resistance, reactance, conductance, susceptance, turnsRatio, and shiftAngle parameters of a branch, which is identified by its label. If any of these parameters are left out, their existing values will remain unchanged.\n\nUpdates\n\nIt updates the branch.parameter field of the PowerSystem composite type. Additionally, this function automatically updates the ac and dc fields within the PowerSystem type, thereby removing the requirement to completely rebuild the vectors and matrices when adjustments are made to these parameters.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units. However, users have the option to use other units instead of per-units and radians using the @voltage and @parameter macros.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nparameterBranch!(system; label = 1, susceptance = 0.062)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@branch","page":"Power System Model","title":"JuliaGrid.@branch","text":"@branch(kwargs...)\n\nThe macro generates a template for a branch, which can be utilized to define a branch using the addBranch! function.\n\nKeywords\n\nTo define the branch template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBranch! function, along with their corresponding values.\n\nUnits\n\nThe default units for the keyword parameters are per-units and radians. However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch template using the default unit system:\n\nsystem = powerSystem()\n\n@branch(reactance = 0.12, shiftAngle = 0.1745)\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2)\n\nCreating a branch template using a custom unit system:\n\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\n@branch(shiftAngle = 10)\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1,  active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions-2","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nstatusGenerator!\noutputGenerator!\naddActiveCost!\naddReactiveCost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addGenerator!","page":"Power System Model","title":"JuliaGrid.addGenerator!","text":"addGenerator!(system::PowerSystem; label, bus, status, active, reactive, magnitude,\n    minActive, maxActive, minReactive, maxReactive, lowActive, minLowReactive,\n    maxLowReactive, upActive, minUpReactive, maxUpReactive,\n    loadFollowing, reactiveTimescale, reserve10min, reserve30min, area)\n\nThe function is used to add a new generator to the PowerSystem composite type and update its generator field. The generator can be added to an already defined bus.\n\nKeywords\n\nThe generator is defined with the following keywords:\n\nlabel: a unique label for the generator;\nbus: the label of the bus to which the generator is connected;\nstatus: the operating status of the generator:\nstatus = 1: in-service;\nstatus = 0: out-of-service;\nactive (pu or W): output active power;\nreactive (pu or VAr): output reactive power;\nmagnitude (pu or V): voltage magnitude setpoint;\nminActive (pu or W): minimum allowed output active power value;\nmaxActive (pu or W): maximum allowed output active power value;\nminReactive (pu or VAr): minimum allowed output reactive power value;\nmaxReactive (pu or VAr): maximum allowed output reactive power value;\nlowActive (pu or W): lower allowed active power output value of PQ capability curve;\nminLowReactive (pu or VAr): minimum allowed reactive power output value at lowActive value;\nmaxLowReactive (pu or VAr): maximum allowed reactive power output value at lowActive value;\nupActive (pu or W): upper allowed active power output value of PQ capability curve;\nminUpReactive (pu or VAr): minimum allowed reactive power output value at upActive value;\nmaxUpReactive (pu or VAr): maximum allowed reactive power output value at upActive value;\nloadFollowing (pu/min or W/min): ramp rate for load following/AG;\nreserve10min (pu or W): ramp rate for 10-minute reserves;\nreserve30min (pu or W): ramp rate for 30-minute reserves;\nreactiveTimescale (pu/min or VAr/min): ramp rate for reactive power, two seconds timescale;\narea: area participation factor.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1 and magnitude = 1.0 per-unit. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @generator macro.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 2, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1, magnitude = 1.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 2, active = 25, reactive = -4, base = 132)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10, magnitude = 145.2)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.statusGenerator!","page":"Power System Model","title":"JuliaGrid.statusGenerator!","text":"statusGenerator!(system::PowerSystem; label, status)\n\nThe function changes the operating status of a generator by switching it from in-service to out-of-service, or vice versa.\n\nKeywords\n\nIt has two parameters, label and status, where the label corresponds to the generator label that has already been defined.\n\nUpdates\n\nThe main purpose of the function is to update the bus.supply field within the PowerSystem type. Additionally, the function alters the generator.layout.status variable.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\nstatusGenerator!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.outputGenerator!","page":"Power System Model","title":"JuliaGrid.outputGenerator!","text":"outputGenerator!(system::PowerSystem; label, active, reactive)\n\nThe function modifies the active and reactive output powers of a generator.\n\nKeywords\n\nIt has three parameters, label, active, and reactive, where the label corresponds to the generator label that has already been defined. The active and reactive parameters can be left, in which case their values will remain unchanged.\n\nUpdates\n\nThe main purpose of the function is to update the bus.supply field within the PowerSystem type. Additionally, the function alters the generator.output field.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\noutputGenerator!(system; label = 1, active = 0.85)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.addActiveCost!","page":"Power System Model","title":"JuliaGrid.addActiveCost!","text":"addActiveCost!(system::PowerSystem; label, model, piecewise, polynomial)\n\nThe function updates the generator.cost field of the PowerSystem type by adding costs for the active power produced by the corresponding generator. It can add a cost to an already defined generator.\n\nKeywords\n\nThe function accepts four keywords:\n\nlabel: corresponds to the already defined generator label;\nmodel: cost model:\nmodel = 1: piecewise linear is being used;\nmodel = 2: polynomial is being used;\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or W): active power output of the generator;\nsecond column (currency/hr): cost for the specified active power output;\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/Wⁿhr): coefficient of the n-th degree term, ...;\npenultimate element (currency/puhr or currency/Whr): coefficient of the first degree term;\nlast element (currency/hr): constant coefficient.\n\nUnits\n\nBy default, the input units related with active powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\naddActiveCost!(system; label = 1, model = 1, polynomial = [1100.0; 500.0; 150.0])\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 25, reactive = -4, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\naddActiveCost!(system; label = 1, model = 1, polynomial = [0.11; 5.0; 150.0])\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.addReactiveCost!","page":"Power System Model","title":"JuliaGrid.addReactiveCost!","text":"addReactiveCost!(system::PowerSystem; label, model, piecewise, polynomial)\n\nThe function updates the generator field of the PowerSystem type by adding costs for the reactive power produced by the corresponding generator. It can add a cost to an already defined generator.\n\nKeywords\n\nThe function accepts four keywords:\n\nlabel: corresponds to the already defined generator label;\nmodel: cost model:\nmodel = 1: piecewise linear is being used;\nmodel = 2: polynomial is being used;\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or VAr): reactive power output of the generator;\nsecond column (currency/hr): cost for the specified reactive power output;\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/VArⁿhr): coefficient of the n-th degree term, ...;\npenultimate element (currency/puhr or currency/VArhr): coefficient of the first degree term;\nlast element (currency/hr): constant coefficient.\n\nUnits\n\nBy default, the input units related with reactive powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\naddReactiveCost!(system; label = 1, model = 2, piecewise = [0.1085 12; 0.1477 16])\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 25, reactive = -4, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\naddReactiveCost!(system; label = 1, model = 2, piecewise = [10.85 12; 14.77 16])\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@generator","page":"Power System Model","title":"JuliaGrid.@generator","text":"@generator(kwargs...)\n\nThe macro generates a template for a generator, which can be utilized to define a generator using the addGenerator! function.\n\nKeywords\n\nTo define the generator template, the kwargs input arguments must be provided in accordance with the keywords specified within the addGenerator! function, along with their corresponding values.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\n@generator(magnitude = 1.1)\naddBus!(system; label = 1, type = 2, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\nsystem = powerSystem()\n\n@generator(magnitude = 145.2)\naddBus!(system; label = 1, type = 2, active = 25, reactive = -4, base = 132)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model-2","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.acModel!","page":"Power System Model","title":"JuliaGrid.acModel!","text":"acModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with AC analyses.\n\nUpdates\n\nThe function modifies the model.ac field within the PowerSystem composite type, populating the following variables:\n\nnodalMatrix: the nodal matrix;\nnodalMatrixTranspose: the transpose of the nodal matrix;\nnodalFromFrom: the Y-parameters of the two-port branches;\nnodalFromTo: the Y-parameters of the two-port branches;\nnodalToTo: the Y-parameters of the two-port branches;\nnodalToFrom: the Y-parameters of the two-port branches;\nadmittance: the branch admittances.\n\nOnce these variables are established, they will be automatically adjusted upon using the following functions:\n\nshuntBus!,\naddBranch!,\nstatusBranch!,\nparameterBranch!.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.dcModel!","page":"Power System Model","title":"JuliaGrid.dcModel!","text":"dcModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with DC analyses.\n\nUpdates\n\nThe function modifies the model.dc field within the PowerSystem composite type, populating the following variables:\n\nnodalMatrix: the nodal matrix;\nadmittance: the branch admittances;\nshiftActivePower: the active powers related to phase-shifting transformers.\n\nOnce these variables are established, they will be automatically adjusted upon using the following functions:\n\naddBranch!,\nstatusBranch!,\nparameterBranch!.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"manual/powerSystemModel/#PowerSystemModelManual","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid supports the composite type PowerSystem to preserve power system data, with the following fields: bus, branch, generator, base, and model. The fields bus, branch, and generator hold data related to buses, branches, and generators, respectively. The base field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes for the base power and line-to-line voltages measured in volts for base voltages. The model stores vectors and matrices that are related to the topology and parameters of the power system.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The composite type PowerSystem can be created using a function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid supports three modes for populating the PowerSystem type: using built-in functions, using HDF5 file format, and using Matpower case files.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type is created, you can add buses, branches, and generators using the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!,\naddBranch!,\naddGenerator!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, JuliaGrid provides macros @bus, @branch, and @generator to define templates that aid in creating buses, branches, and generators. These templates help avoid entering the same parameters repeatedly.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To create vectors and matrices based on the power system topology and parameters, you can use the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!,\ndcModel!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In addition, it is possible to manipulate the parameters of buses, branches, and generators using the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"shuntBus!,\nstatusBranch!,\nparameterBranch!,\nstatusGenerator!,\noutputGenerator!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Executing these functions will automatically update all fields affected by them within PowerSystem composite type. You can also change other parameters of the power system by accessing and modifying the values in the bus, branch, generator, and base fields of the PowerSystem type.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, after adding the generator, JualiGrid provides the following functions to incorporate costs for the active and reactive power generated by the generator:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!,\naddReactiveCost!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#BuildModelManual","page":"Power System Model","title":"Build Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The powerSystem function generates the PowerSystem composite type and requires a string-formatted path to either Matpower case or HDF5 files as input. Alternatively, the PowerSystem can be created without any initial data by initializing it as empty, allowing the user to construct the power system from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Matpower-or-HDF5-File","page":"Power System Model","title":"Matpower or HDF5 File","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, to create the PowerSystem type using the Matpower case file for the IEEE 14-bus test case, which is named case14.m and located in the folder C:\\matpower, the following Julia code can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/matpower/case14.m\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In order to use the HDF5 file as input to create the PowerSystem object, it is necessary to have saved the data using the savePowerSystem function beforehand. As an example, let us say we saved the power system as case14.h5 in the directory C:\\hdf5. In this case, the following Julia code can be used to construct the PowerSystem composite type:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/hdf5/case14.h5\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIt is recommended to load the power system from the HDF5 file to reduce the loading time.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Model-from-Scratch","page":"Power System Model","title":"Model from Scratch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Alternatively, the model can be build from the scratch using built-in functions, for example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, base = 345e3)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Internal-Unit-System","page":"Power System Model","title":"Internal Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The PowerSystem composite type stores all electrical quantities in per-units and radians, except for the base values of power and voltages. The base power value is expressed in volt-amperes, while the base voltages are given in volts.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Base-Unit-Prefixes","page":"Power System Model","title":"Change Base Unit Prefixes","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As an example, if you execute the previous code snippet, you can retrieve the base power and base voltage values and units as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"By using the @base macro, users can change the prefixes of the base units. For instance, if the user wishes to convert base power and base voltage values to megavolt-amperes (MVA) and kilovolts (kV) respectively, they can execute the following macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, MVA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon execution of the macro, the base power and voltage values and units will be modified accordingly:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, by using the @base macro to modify the prefixes of the base units, users can convert the output data from various analyses to specific units with the desired prefixes.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#SaveModelManual","page":"Power System Model","title":"Save Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type has been created using one of the methods outlined in Build Model, the current data can be stored in the HDF5 file by using  savePowerSystem function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem(system; path = \"C:/matpower/case14.h5\", reference = \"IEEE 14-bus test case\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"All electrical quantities saved in the HDF5 file are in per-units and radians, except for base values for power and voltages, which are given in volt-amperes and volts. It is important to note that even if the user modifies the base units using the @base macro, the units will still be saved in the default settings.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBusManual","page":"Power System Model","title":"Add Bus","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We have the option to add buses to a loaded power system or to one created from scratch. As an illustration, we can initiate the PowerSystem type and then incorporate two buses by utilizing the addBus! function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.034907, base = 345e3)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this case, we have created two buses where the active power demanded by the consumer at Bus 1 is specified in per-units, which are the same units used to store electrical quantities:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In addition, it is worth noting that the base keyword is used to specify the base voltages, and its default input unit is in volts (V).","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, we set the bus voltage angle in radians for the Bus 2 to its initial value:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.voltage.angle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nWe recommend reading the documentation for the addBus! function, where all the keywords used in the function are explained in detail.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Input-Unit-System","page":"Power System Model","title":"Change Input Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Typically, all keywords associated with electrical quantities are expected to be provided in per-units (pu) and radians (rad) by default, with the exception of base voltages, which should be specified in volts (V). However, users can choose to use different units than the default per-units and radians or modify the prefix of the base voltage unit by using macros such as the following:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can create identical two buses as before using new system of units as follows:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 10.0, base = 345.0)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -2.0, base = 345.0)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As can be observed, electrical quantities will continue to be stored in per-units and radians format:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active\nsystem.bus.voltage.angle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The base voltage values will still be stored in volts (V) since we only changed the input unit prefix, and did not modify the internal unit prefix, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To modify the internal unit prefix, the following macro can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, VA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After executing this macro, the base voltage values will be stored in kilovolts (kV):","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBranchManual","page":"Power System Model","title":"Add Branch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After adding buses with unique labels, we can define branches between them. The branch cannot be added unless the buses are already defined, and the from and to keywords should correspond to the already defined bus labels. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit)  # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.2)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Here, we created branch from Bus 1 to Bus 2 with following parameter:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to consult the documentation for the addBranch! function, which provides an explanation of all the keywords used in the function.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Input-Unit-System-2","page":"Power System Model","title":"Change Input Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To use units other than per-units (pu) and radians (rad), macros can be employed to change the input units. For example, if the need arises to use ohms (Ω), the macros below can be employed:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@parameter(Ω, pu)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.2)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\",  reactance = 22.8528)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Still, all electrical quantities are stored in per-units and radians, and the same branch as before is created, as shown in the following output:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is important to note that, when working with impedance and admittance values in ohms (Ω) and siemens (S) that are related to a transformer, the assignment must be based on the primary side of the transformer.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddGeneratorManual","page":"Power System Model","title":"Add Generator","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After defining the buses, generators can be added to the power system. Each generator must have a unique label, and the bus keyword should correspond to the unique label of the bus it is connected to. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\", active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the above code, we add the generator to the Bus 2, with active and reactive power outputs set to:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.output.active\nsystem.generator.output.reactive","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similar to buses and branches, the input units can be changed to units other than per-units using different macros.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to refer to the documentation for the addGenerator! function, which explains all the keywords used in the function.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#LabelsManual","page":"Power System Model","title":"Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As we shown above, JuliaGrid mandates a distinctive label for every bus, branch, or generator. These labels are stored in dictionaries, functioning as pairs of strings and integers. The string signifies the exclusive label for the specific component, whereas the integer maintains an internal numbering of buses, branches, or generators.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In contrast to the simple labeling approach, JuliaGrid offers two additional methods for labeling. The choice of method depends on the specific needs and can potentially be more straightforward.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Integer-Based-Labeling","page":"Power System Model","title":"Integer-Based Labeling","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"If users prefer to utilize integers as labels in various functions, this is acceptable. However, it is important to note that despite using integers, these labels are still stored as strings. Let us take a look at the following illustration:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1)\naddBus!(system; label = 2, type = 1, angle = -0.2)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)\n\naddGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we create two buses labelled as 1 and 2. The branch is established between these two buses with a unique branch label of 1. Finally, the generator is connected to the bus labelled 2 and has its distinct label set to 1.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Automated-Labeling","page":"Power System Model","title":"Automated Labeling","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Users also possess the option to omit the label keyword, allowing JuliaGrid to independently allocate unique labels for buses, branches, or generators. In such instances, JuliaGrid employs an ordered set of incremental integers for labeling components. To illustrate, consider the subsequent example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; type = 3, active = 0.1)\naddBus!(system; type = 1, angle = -0.2)\n\naddBranch!(system; from = 1, to = 2, reactance = 0.12)\n\naddGenerator!(system; bus = 2, active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This example presents the same power system as the previous one. In the previous example, we used an ordered set of increasing integers for labels, which aligns with JuliaGrid's automatic labeling behaviour when the label keyword is omitted.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Retrieving-Labels","page":"Power System Model","title":"Retrieving Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, we will outline how users can retrieve stored labels. Let us consider the following power system creation:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 30)\naddBus!(system; label = 20)\naddBus!(system; label = 40)\n\naddBranch!(system; label = 100, from = 30, to = 20, reactance = 0.8)\naddBranch!(system; label = 200, from = 20, to = 40, reactance = 0.5)\n\naddGenerator!(system; label = 200, bus = 40)\naddGenerator!(system; label = 100, bus = 30)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For instance, the bus labels can be accessed using the variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid employs a non-ordered dictionary structure for label storage to optimize performance. If you need to retrieve labels in the order corresponding to the sequence of bus definitions, you can use the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"labelBus = collect(keys(sort(system.bus.label; byvalue = true)))","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"A similar approach can be employed for branches and generators using system.branch.label and system.generator.label respectively.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Moreover, the from and to keywords are stored based on internally assigned numerical values linked to bus labels. These values are stored in the variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.branch.layout.from system.branch.layout.to]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To recover the original from and to labels, you can utilize the following method:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[labelBus[system.branch.layout.from] labelBus[system.branch.layout.to]]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, the bus keyword is saved based on internally assigned numerical values corresponding to bus labels and can be accessed using:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.layout.bus","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To obtain the original labels of the bus keyword, you can use the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"labelBus[system.generator.layout.bus]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddTemplatesManual","page":"Power System Model","title":"Add Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The functions addBus!, addBranch!, and addGenerator! are used to add bus, branch, and generator to the power system, respectively. If certain keywords are not specified, default values are assigned to some parameters.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Default-Keyword-Values","page":"Power System Model","title":"Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Concerning the addBus! function, in case the type keyword is not supplied, the bus type is automatically configured as a demand bus, with type = 1 as its value. The initial bus voltage is standardized to magnitude = 1 per unit, while the base voltage is set to base = 138e3 volts. These predefined values hold significant importance to avert potential issues during algorithm execution, such as encountering a singular Jacobian when magnitude = 0.0.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Transitioning to the addBranch! function, the default status is set to status = 1, indicating the branch's operational status as in-service. Moreover, the transformer's off-nominal turns ratio assumes a value of turnsRatio = 1.0, accompanied by a shiftAngle = 0.0, which collectively establish the line configuration using these standard settings. Additionally, the type keyword defaults to type = 1, aligning with a specific rating category.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, the addGenerator! function designates an operational generator by employing status = 1, and it setsmagnitude = 1.0 per unit, denoting the desired voltage magnitude setpoint.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The remaining parameters are initialized with default values of zero.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Default-Keyword-Values","page":"Power System Model","title":"Change Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In JuliaGrid, users are allowed to modify default values and assign non-zero values to other keywords using the @bus, @branch, and @generator macros. These macros create bus, branch, and generator templates that are used every time the addBus!, addBranch!, and addGenerator! functions are called. For instance, the code block shows an example of creating bus, branch, and generator templates with customized default values:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 0.1)\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.5)\n\n@branch(reactance = 0.12)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\")\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.06)\n\n@generator(magnitude = 1.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 50)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 1\", active = 20)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This code example involves two uses of the addBus! and addBranch! functions. In the first use, the functions rely on the default values set by the templates created with the @bus and @branch macros. In contrast, the second use passes specific values that match the keywords used in the templates. As a result, the templates are overridden:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.layout.type\nsystem.bus.demand.active\nsystem.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the given example, the @generator macro is utilized instead of repeatedly specifying the magnitude keyword in the addGenerator! function. This macro creates a generator template with a default value for magnitude, which is automatically applied every time the addGenerator! function is called. Therefore, it eliminates the requirement to set the magnitude value for each individual generator:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.voltage.magnitude","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Input-Unit-System-3","page":"Power System Model","title":"Change Input Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid requires users to specify electrical quantity-related keywords in per-units (pu) and radians (rad) by default. However, it provides macros, such as @power, that allow users to specify other units:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\n@power(MW, MVAr, MVA)\n\n@bus(active = 100, reactive = 200)\naddBus!(system; label = \"Bus 1\")\n\n@power(pu, pu, pu)\n\naddBus!(system; label = \"Bus 2\", active = 0.5)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we create the bus template and one bus using SI power units, and then we switch to per-units and add the second bus. It is important to note that once the template is defined in any unit system, it remains valid regardless of subsequent unit system changes. The resulting power values are:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active\nsystem.bus.demand.reactive","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Thus, JuliaGrid automatically tracks the unit system used to create templates and provides the appropriate conversion to per-units and radians. Even if the user switches to a different unit system later on, the previously defined template will still be valid.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Multiple-Templates","page":"Power System Model","title":"Multiple Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the case of calling the @bus, @branch, or @generator macros multiple times, the provided keywords and values will be combined into a single template for the corresponding component (bus, branch, or generator), which will be used for generating the component.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Reset-Templates","page":"Power System Model","title":"Reset Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To reset the bus, branch, and generator templates to their default settings, users can utilize the following macros:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(bus)\n@default(branch)\n@default(generator)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, users can reset all templates for the bus, branch, and generator components using the macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(template)\nnothing # hide","category":"page"},{"location":"#JuliaGrid","page":"Introduction","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver, and allows a variety of display and manipulation options.","category":"page"},{"location":"api/optimalPowerFlow/#OptimalPowerFlowAPI","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"For further information on this topic, please see the AC Optimal Power Flow or DC Optimal Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for optimal power flow analysis.","category":"page"},{"location":"api/optimalPowerFlow/#Build-Model","page":"Optimal Power Flow","title":"Build Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"acOptimalPowerFlow\ndcOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#Solve-Optimal-Power-Flow","page":"Optimal Power Flow","title":"Solve Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!","category":"page"},{"location":"api/optimalPowerFlow/#Power-Analysis","page":"Optimal Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"power!\npowerInjection\npowerSupply\npowerShunt\npowerFrom\npowerTo\npowerCharging\npowerSeries","category":"page"},{"location":"api/optimalPowerFlow/#Current-Analysis","page":"Optimal Power Flow","title":"Current Analysis","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"current!\ncurrentInjection\ncurrentFrom\ncurrentTo\ncurrentSeries","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Build-Model-2","page":"Optimal Power Flow","title":"Build Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"acOptimalPowerFlow\ndcOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.acOptimalPowerFlow","text":"acOptimalPowerFlow(system::PowerSystem, optimizer; bridge, name, balance, limit,\n    rating, capability)\n\nThe function takes the PowerSystem composite type as input to establish the structure for solving the AC optimal power flow. The optimizer argument is also required to create and solve the optimization problem. If the ac field within the PowerSystem composite type has not been created, the function will initiate an update automatically.\n\nKeywords\n\nJuliaGrid offers the ability to manipulate the jump model based on the guidelines provided in the JuMP documentation. However, certain configurations may require different method calls, such as:\n\nbridge: used to manage the bridging mechanism;\nname: used to manage the creation of string names.\n\nMoreover, we have included keywords that regulate the usage of different types of constraints:\n\nbalance: controls the equality constraints that relate to the active and reactive power balance equations;\nlimit: controls the inequality constraints that relate to the voltage magnitude and angle differences between buses;\nrating: controls the inequality constraints that relate to the long-term rating of branches;\ncapability: controls the inequality constraints that relate to the active and reactive power generator outputs.\n\nBy default, all of these keywords are set to true and are of the Bool type.\n\nJuMP\n\nThe JuliaGrid builds the AC optimal power flow around the JuMP package and supports commonly used solvers. For more information, refer to the JuMP documenatation.\n\nReturns\n\nThe function returns an instance of the ACOptimalPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\njump: the JuMP model;\nconstraint: holds the constraint references to the JuMP model.\n\nExamples\n\nCreate the complete AC optimal power flow model:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\n\nCreate the AC optimal power flow model without rating constraints:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer; rating = false)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.dcOptimalPowerFlow","text":"dcOptimalPowerFlow(system::PowerSystem, optimizer; bridge, name, balance, limit,\n    rating, capability)\n\nThe function takes the PowerSystem composite type as input to establish the structure for solving the DC optimal power flow. The optimizer argument is also required to create and solve the optimization problem. If the dc field within the PowerSystem composite type has not been created, the function will initiate an update automatically.\n\nKeywords\n\nJuliaGrid offers the ability to manipulate the jump model based on the guidelines provided in the JuMP documentation. However, certain configurations may require different method calls, such as:\n\nbridge: used to manage the bridging mechanism;\nname: used to manage the creation of string names.\n\nMoreover, we have included keywords that regulate the usage of different types of constraints:\n\nbalance: controls the equality constraints that relate to the active power balance equations;\nlimit: controls the inequality constraints that relate to the voltage angle differences between buses;\nrating: controls the inequality constraints that relate to the long-term rating of branches;\ncapability: controls the inequality constraints that relate to the active power generator outputs.\n\nBy default, all of these keywords are set to true and are of the Bool type.\n\nJuMP\n\nThe JuliaGrid builds the DC optimal power flow around the JuMP package and supports commonly used solvers. For more information, refer to the JuMP documenatation.\n\nReturns\n\nThe function returns an instance of the DCOptimalPowerFlow type, which includes the following fields:\n\nvoltage: the variable allocated to store the bus voltage angle,\npower: the variable allocated to store the active powers,\njump: the JuMP model,\nconstraint: holds the constraint references to the JuMP model.\n\nExamples\n\nCreate the complete DC optimal power flow model:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\n\nCreate the DC optimal power flow model without rating constraints:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer; rating = false)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Solve-Optimal-Power-Flow-2","page":"Optimal Power Flow","title":"Solve Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!(::PowerSystem, ::ACOptimalPowerFlow)\nsolve!(::PowerSystem, ::DCOptimalPowerFlow)","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::ACOptimalPowerFlow)\n\nThe function finds the AC optimal power flow solution and calculate the bus voltage magnitudes and angles, and output active and reactive powers of each generators.\n\nThe calculated voltage magnitudes and angles and active and reactive powers are then stored in the variables of the voltage and power fields of the ACOptimalPowerFlow composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::DCOptimalPowerFlow)\n\nThe function finds the DC optimal power flow solution and calculate the bus voltage angles and output active powers of the generators.\n\nThe calculated voltage angles and active powers are then stored in the angle variable of the voltage field and the generator variable of the power field.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"}]
}
