var documenterSearchIndex = {"docs":
[{"location":"manual/powerSystemModel/#PowerSystemModelManual","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid supports the composite type PowerSystem to preserve power system data, with the following fields: bus, branch, generator, base, acModel, and dcModel. The fields bus, branch, and generator hold data related to buses, branches, and generators, respectively. The base field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes for the base power and line-to-line voltages measured in volts for base voltages. The acModel and dcModel store vectors and matrices that are related to the topology and parameters of the power system.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The composite type PowerSystem can be created using a function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid supports three modes for populating the PowerSystem type: using built-in functions, using HDF5 file format, and using Matpower case files.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type is created, you can add buses, branches, and generators using the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\naddBranch!\naddGenerator!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, JuliaGrid provides macros @bus, @branch, and @generator to define templates that aid in creating buses, branches, and generators. These templates help avoid entering the same parameters repeatedly.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To create vectors and matrices based on the power system topology and parameters, you can use the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In addition, it is possible to manipulate the parameters of buses, branches, and generators using the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"shuntBus!\nstatusBranch!\nparameterBranch!\nstatusGenerator!\noutputGenerator!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Executing these functions will automatically update all fields affected by them within PowerSystem composite type. You can also change other parameters of the power system by accessing and modifying the values in the bus, branch, generator, and base fields of the PowerSystem type.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, after adding the generator, JualiGrid provides the following functions to incorporate costs for the active and reactive power generated by the generator:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!\naddReactiveCost!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#BuildModelManual","page":"Power System Model","title":"Build Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The powerSystem function generates the PowerSystem composite type and requires a string-formatted path to either Matpower case or HDF5 files as input. Alternatively, the PowerSystem can be created without any initial data by initializing it as empty, allowing the user to construct the power system from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Matpower-or-HDF5-File","page":"Power System Model","title":"Matpower or HDF5 File","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, to create the PowerSystem type using the Matpower case file for the IEEE 14-bus test case, which is named case14.m and located in the folder C:\\matpower, the following Julia code can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/matpower/case14.m\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In order to use the HDF5 file as input to create the PowerSystem object, it is necessary to have saved the data using the savePowerSystem function beforehand. As an example, let us say we saved the power system as case14.h5 in the directory C:\\hdf5. In this case, the following Julia code can be used to construct the PowerSystem composite type:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/hdf5/case14.h5\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIt is recommended to load the power system from the HDF5 file to reduce the loading time.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Model-from-Scratch","page":"Power System Model","title":"Model from Scratch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Alternatively, the model can be build from the scratch using built-in functions, for example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = 2, type = 1, reactive = 0.05, base = 345e3)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.008, reactance = 0.05)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Internal-Unit-System","page":"Power System Model","title":"Internal Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The PowerSystem composite type stores all electrical quantities in per-units and radians, except for the base values of power and voltages. The base power value is expressed in volt-amperes, while the base voltages are given in volts.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Internal-Base-Unit-Prefixes","page":"Power System Model","title":"Change Internal Base Unit Prefixes","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As an example, if you execute the previous code snippet, you can retrieve the base power and base voltage values and units as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"By using the @base macro, users can change the prefixes of the base units. For instance, if the user wishes to convert base power and base voltage values to megavolt-amperes (MVA) and kilovolts (kV) respectively, they can execute the following macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, MVA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon execution of the macro, the base power and voltage values and units will be modified accordingly:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, by using the @base macro to modify the prefixes of the base units, users can convert the output data from various analyses to specific units with the desired prefixes.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#SaveModelManual","page":"Power System Model","title":"Save Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type has been created using one of the methods outlined in Build Model, the current data can be stored in the HDF5 file by using  savePowerSystem function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem(system; path = \"C:/matpower/case14.h5\", reference = \"IEEE 14-bus test case\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"All electrical quantities saved in the HDF5 file are in per-units and radians, except for base values for power and voltages, which are given in volt-amperes and volts. It is important to note that even if the user modifies the base units using the @base macro, the units will still be saved in the default settings.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBusManual","page":"Power System Model","title":"Add Bus","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We have the option to add buses to a loaded power system or to one created from scratch. As an illustration, we can initiate the PowerSystem type and then incorporate two buses by utilizing the addBus! function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = 2, type = 1, angle = -0.034907, base = 345e3)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this case, we have created two buses where the active power demanded by the consumer at buses labelled with 1 is specified in per-units, which are the same units used to store electrical quantities:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In addition, it is worth noting that the base keyword is used to specify the base voltages, and its default input unit is in volts (V).","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, we set the bus voltage angle in radians for the bus with label 2 to its initial value:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.voltage.angle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nWe recommend reading the documentation for the addBus! function, where all the keywords used in the function are explained in detail.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Input-Unit-System","page":"Power System Model","title":"Change Input Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Typically, all keywords associated with electrical quantities are expected to be provided in per-units (pu) and radians (rad) by default, with the exception of base voltages, which should be specified in volts (V). However, users can choose to use different units than the default per-units and radians or modify the prefix of the base voltage unit by using macros such as the following:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can create identical two buses as before using new system of units as follows:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 10.0, base = 345.0)\naddBus!(system; label = 2, type = 1, angle = -2.0, base = 345.0)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As can be observed, electrical quantities will continue to be stored in per-units and radians format:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active\nsystem.bus.voltage.angle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The base voltage values will still be stored in volts (V) since we only changed the input unit prefix, and did not modify the internal unit prefix, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To modify the internal unit prefix, the following macro can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, VA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After executing this macro, the base voltage values will be stored in kilovolts (kV):","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#BusLabelsManual","page":"Power System Model","title":"Bus Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In JuliaGrid, the set of bus labels is always internally assigned and stored in a dictionary, even if the labels assigned to the buses are in an increasing ordered set of integers. In this case, each bus label value corresponds to the same internally assigned value.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"However, if the labels assigned to the buses are not in an increasing ordered set of integers, the system will always internally renumber all labels to satisfy the requirement of an increasing ordered set of integers. For example, suppose we have a power system with buses labelled as:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 30)\naddBus!(system; label = 20)\naddBus!(system; label = 40)\naddBus!(system; label = 10)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"These labels, along with their internally assigned labels, are stored in the variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"If a user needs to retrieve the original labels and match them with other parameters related to the buses, they can do so using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"label = collect(keys(sort(system.bus.label; byvalue = true)))","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBranchManual","page":"Power System Model","title":"Add Branch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After adding buses with unique labels, we can define branches between them. The branch cannot be added unless the buses are already defined, and the from and to keywords should correspond to the already defined bus labels. Additionally, each branch should be labelled with its own unique label. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit)  # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1)\naddBus!(system; label = 2, type = 1, angle = -0.034907)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Here, we created branch from bus 1 to bus 2 with following parameters:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance\nsystem.branch.parameter.shiftAngle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to consult the documentation for the addBranch! function, which provides an explanation of all the keywords used in the function.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Input-Unit-System-2","page":"Power System Model","title":"Change Input Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To use units other than per-units (pu) and radians (rad), macros can be employed to change the input units. For example, if the need arises to use ohms (Ω) and degrees (deg), the macros below can be employed:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@parameter(Ω, pu)\n@voltage(pu, deg, V)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1)\naddBus!(system; label = 2, type = 1, angle = -2.0)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 22.8528, shiftAngle = 10.0)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Still, all electrical quantities are stored in per-units and radians, and the same branch as before is created, as shown in the following output:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance\nsystem.branch.parameter.shiftAngle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is important to note that, when working with impedance and admittance values in ohms (Ω) and siemens (S) that are related to a transformer, the assignment must be based on the primary side of the transformer.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#BranchLabelsManual","page":"Power System Model","title":"Branch Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"If the branch labels are not in an ordered set of increasing integers, the system will internally renumber all labels, similar to how bus lables are handled. For example, consider a power system with non-ordered bus and branch labels as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 30)\naddBus!(system; label = 20)\naddBus!(system; label = 40)\n\naddBranch!(system; label = 100, from = 30, to = 20, reactance = 0.8)\naddBranch!(system; label = 200, from = 20, to = 40, reactance = 0.5)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The system stores the original branch labels along with their internally assigned labels:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To retrieve the original labels and match them with other branch parameters, users can use the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"label = collect(keys(sort(system.branch.label; byvalue = true)))","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Furthermore, the from and to keywords are saved based on the internally assigned numerical values, which are derived from the increasing ordered set of integers based on bus labels:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label\n[system.branch.layout.from system.branch.layout.to]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To retrieve the original from and to labels, the following approach can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"labelBus = collect(keys(sort(system.bus.label; byvalue = true)))\n[labelBus[system.branch.layout.from] labelBus[system.branch.layout.to]]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddGeneratorManual","page":"Power System Model","title":"Add Generator","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After defining the buses, generators can be added to the power system. Each generator must have a unique label assigned to it, and the bus keyword should correspond to the unique label of the bus it is connected to. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\n\naddGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the above code, we add the generator to the bus labelled 2, with active and reactive power outputs set to:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.output.active\nsystem.generator.output.reactive","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similar to buses and branches, the input units can be changed to units other than per-units using different macros.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to refer to the documentation for the addGenerator! function, which explains all the keywords used in the function.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#GeneratorLabelsManual","page":"Power System Model","title":"Generator Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similar to how the system handles bus labels and branch labels, the system will internally renumber all generator labels if they are not in an ordered set of increasing integers. As an example, let us take the power system with non-ordered bus and generator labels, as illustrated below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 30)\naddBus!(system; label = 20)\naddBus!(system; label = 40)\n\naddGenerator!(system; label = 200, bus = 40)\naddGenerator!(system; label = 100, bus = 30)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid stores both the original generator labels and their corresponding internally assigned labels.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To retrieve the original labels and match them with other generator parameters, users can utilize the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"label = collect(keys(sort(system.generator.label; byvalue = true)))","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, the bus keyword is saved based on the internally assigned numerical values, which are derived from the ordered set of integers based on bus labels:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label\nsystem.generator.layout.bus","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To obtain the original labels of the bus keyword, you can use the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"labelBus = collect(keys(sort(system.bus.label; byvalue = true)))\nlabel = labelBus[system.generator.layout.bus]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddTemplatesManual","page":"Power System Model","title":"Add Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The functions addBus!, addBranch!, and addGenerator! are used to add bus, branch, and generator to the power system, respectively. If certain keywords are not specified, default values are assigned to some parameters.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Default-Keyword-Values","page":"Power System Model","title":"Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For the addBus! function, if the type keyword is not provided, the bus type is automatically set to a demand bus with a value of 1 for type. The initial bus voltage magnitude is set to 1.0 per-unit, and the base voltage is set to 138e3 volts. These default values are important to prevent issues with algorithm execution, such as a singular Jacobian when magnitude = 0.0.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The addBranch! function assigns default values of 1 for status, indicating that the branch is in-service, and 1 for type, representing the type of ratings.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, the addGenerator! function assigns default values of 1 for status, indicating that the generator is in-service, and 1.0 per-unit for magnitude, which represents the voltage magnitude setpoint.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The remaining parameters are initialized with default values of zero.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Default-Keyword-Values","page":"Power System Model","title":"Change Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In JuliaGrid, users are allowed to modify default values and assign non-zero values to other keywords using the @bus, @branch, and @generator macros. These macros create bus, branch, and generator templates that are used every time the addBus!, addBranch!, and addGenerator! functions are called. For instance, the code block shows an example of creating bus, branch, and generator templates with customized default values:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 0.1)\naddBus!(system; label = 1)\naddBus!(system; label = 2, type = 1, active = 0.5)\n\n@branch(reactance = 0.12)\naddBranch!(system; label = 1, from = 1, to = 2)\naddBranch!(system; label = 2, from = 1, to = 2, reactance = 0.06)\n\n@generator(magnitude = 1.1)\naddGenerator!(system; label = 1, bus = 1, active = 50)\naddGenerator!(system; label = 2, bus = 1, active = 20)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This code example involves two uses of the addBus! and addBranch! functions. In the first use, the functions rely on the default values set by the templates created with the @bus and @branch macros. In contrast, the second use passes specific values that match the keywords used in the templates. As a result, the templates are overridden:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.layout.type\nsystem.bus.demand.active\nsystem.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the given example, the @generator macro is utilized instead of repeatedly specifying the magnitude keyword in the addGenerator! function. This macro creates a generator template with a default value for magnitude, which is automatically applied every time the addGenerator! function is called. Therefore, it eliminates the requirement to set the magnitude value for each individual generator:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.voltage.magnitude","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Input-Unit-System-3","page":"Power System Model","title":"Change Input Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid requires users to specify electrical quantity-related keywords in per-units (pu) and radians (rad) by default. However, it provides macros, such as @power, that allow users to specify other units:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\n@power(MW, MVAr, MVA)\n\n@bus(active = 100, reactive = 200)\naddBus!(system; label = 1)\n\n@power(pu, pu, pu)\n\naddBus!(system; label = 2, active = 1.0, reactive = 2.0)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we create the bus template and one bus using SI power units, and then we switch to per-units and add the second bus. It is important to note that once the template is defined in any unit system, it remains valid regardless of subsequent unit system changes. The resulting power values are:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active\nsystem.bus.demand.reactive","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Thus, JuliaGrid automatically tracks the unit system used to create templates and provides the appropriate conversion to per-units and radians. Even if the user switches to a different unit system later on, the previously defined template will still be valid.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Multiple-Templates","page":"Power System Model","title":"Multiple Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the case of calling the @bus, @branch, or @generator macros multiple times, the provided keywords and values will be combined into a single template for the corresponding component (bus, branch, or generator), which will be used for generating the component.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Reset-Templates","page":"Power System Model","title":"Reset Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To reset the bus, branch, and generator templates to their default settings, users can utilize the following macros:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(bus)\n@default(branch)\n@default(generator)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, users can reset all templates for the bus, branch, and generator components using the macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(template)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ACDCModelManual","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"When we constructed the power system, we can create an AC and/or DC model, which include vectors and matrices related to the power system's topology and parameters. The following code snippet demonstrates this:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1)\naddBus!(system; label = 2, type = 1, reactive = 0.05)\naddBus!(system; label = 3, type = 1, susceptance = 0.05)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; label = 2, from = 2, to = 3, resistance = 0.008, reactance = 0.05)\n\nacModel!(system)\ndcModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The nodal matrices are one of the components of both the AC and DC models and are stored in the variables:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.dcModel.nodalMatrix\nsystem.acModel.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nThe AC model is used for performing AC power flow, AC optimal power flow, nonlinear state estimation, or state estimation with PMUs, whereas the DC model is essential for various DC or linear analyses. Consequently, once these models are developed, they can be applied to various types of simulations. We recommend that the reader refer to the tutorial on AC and DC models.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#New-Branch-Triggers-Model-Update","page":"Power System Model","title":"New Branch Triggers Model Update","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can execute the acModel! and dcModel! functions after defining the final number of buses, and each new branch added will trigger an update of the AC and DC vectors and matrices. Here is an example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1)\naddBus!(system; label = 2, type = 1, reactive = 0.05)\naddBus!(system; label = 3, type = 1, susceptance = 0.05)\n\nacModel!(system)\ndcModel!(system)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; label = 2, from = 2, to = 3, resistance = 0.008, reactance = 0.05)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, the nodal matrix in the DC framework has the same values as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.dcModel.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIt is not fully recommended to create AC and DC models before adding a large number of branches if the execution time of functions is important. Instead, triggering updates to the AC and DC models using the addBranch! function is useful for power systems that require the addition of several branches. This update avoids the need to recreate vectors and matrices from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#New-Bus-Triggers-Model-Erasure","page":"Power System Model","title":"New Bus Triggers Model Erasure","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The AC and DC models must be defined when a finite number of buses are defined, otherwise, adding a new bus will delete them. For example, if we attempt to add a new bus to the PowerSystem type that was previously created, the current AC and DC models will be completely erased:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!(system; label = 4, type = 2)\nsystem.dcModel.nodalMatrix\nsystem.acModel.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AlterShuntElementsManual","page":"Power System Model","title":"Alter Shunt Elements","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To modify or add new shunt element at bus, you can use the shuntBus! function. If the AC and DC models have not yet been created, you can directly modify the bus.shunt field of the PowerSystem type to change their values. However, if AC and DC models have been created, using the shuntBus! function will automatically update all relevant fields in these models. This avoids the need to recreate the AC and DC models from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, it is recommended to use this function after executing the acModel! and dcModel! functions. For example, let us start by creating the AC model:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, susceptance = 2.1)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Then, the nodal matrix is given as:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.acModel.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, to add a shunt element at bus 1 with a specified conductance value and modify the susceptance value of the shunt element at bus 2, we can execute the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"shuntBus!(system; label = 1, conductance = 0.04)\nshuntBus!(system; label = 2, susceptance = 0.25)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon examining the nodal matrix, it can be inferred that the shuntBus! function automatically updates this matrix:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.acModel.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeBranchStatusManual","page":"Power System Model","title":"Change Branch Status","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can use the statusBranch! function to switch the branch's status between in-service and out-of-service. If the AC and DC models are not created, the function will perform the same operation as accessing the status variable of the branch.layout field and changing the value from 1 to 0 or vice versa. However, if the AC and DC models are created, the function will trigger updates to all affected vectors and matrices.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, it is recommended to use this function after executing the acModel! and dcModel! functions. The following code demonstrates the usage of the statusBranch! function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\naddBus!(system; label = 3)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; label = 2, from = 2, to = 3, resistance = 0.008, reactance = 0.05)\n\nacModel!(system)\ndcModel!(system)\n\nstatusBranch!(system; label = 1, status = 0)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This code sets the branch labelled with 1 to out-of-service. For example, the nodal matrix in the DC framework has the following form:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.dcModel.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Drop-Zeros","page":"Power System Model","title":"Drop Zeros","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After the execution of the statusBranch! function, the nodal matrices will contain zeros, as demonstrated in the code example. If needed, the user can remove these zeros by using the dropzeros! function, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using SparseArrays\ndropzeros!(system.dcModel.nodalMatrix)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt should be noted that in simulations conducted with the JuliaGrid package, the accuracy of the results will not be affected by leaving zeros.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeBranchParametersManual","page":"Power System Model","title":"Change Branch Parameters","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The parameterBranch! function is used to modify the parameters of a branch, which include resistance, reactance, susceptance, turns ratio, and shift angle. Although one can modify these parameters by accessing the corresponding variables within the branch.parameter field, using the parameterBranch! function will update all affected vectors and matrices, provided that the AC and DC models have been created.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, this function is useful after executing the acModel! and dcModel! functions. For example, let us start by creating the AC model:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Then the nodal matrix is:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.acModel.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can modify the reactance value of the branch and add resistance to it while keeping the shift angle constant, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"parameterBranch!(system; label = 1, reactance = 0.10, resistance = 0.02)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Next, we can observe that the nodal matrix is updated automatically by the function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.acModel.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeGeneratorStatusManual","page":"Power System Model","title":"Change Generator Status","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The statusGenerator! function can be used to change the status of a generator between in-service and out-of-service. It is important to always use this function when changing the status of a previously defined generator. Directly accessing the corresponding variable to change the status can result in incorrect results because it will not affect the variable that holds the active and reactive powers generated by the generators that supply buses.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, using the function is the safe way to put a generator in or out of service. Let us create the power system with two generators connected to the same bus:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\n\naddGenerator!(system; label = 1, bus = 2, active = 0.4)\naddGenerator!(system; label = 2, bus = 2, active = 0.6)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To check the the powers being generated by the generators that supply the buses and outputs of the generators, you can use:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.supply.active\nsystem.generator.output.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To put the second generator out-of-service, you can use the function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"statusGenerator!(system; label = 2, status = 0)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Here, we can see the updated variables, where the second generator has been taken out of the system:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.supply.active\nsystem.generator.output.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is worth noting that even if the generator is out-of-service, the output.active variable still reflects its production. This is because it allows the same generator to be put back in-service with the same output power as before.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ChangeGeneratorOutputsManual","page":"Power System Model","title":"Change Generator Outputs","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The function outputGenerator! can be utilized to change the output of a generator. Similar to the Change Generator Status, this function provides the safe way to modify the active and reactive powers produced by the previously defined generator.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To demonstrate how to use this function, we can use the example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\n\naddGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)\naddGenerator!(system; label = 2, bus = 2, active = 0.5, reactive = 0.1)\n\noutputGenerator!(system; label = 1, active = 1.0)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we increase the output active power of the first generator, and the results can be observed below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.output.active\nsystem.bus.supply.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is worth noting that the output reactive power of the generators remains the same:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.output.reactive\nsystem.bus.supply.reactive","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddActiveReactiveCostsManual","page":"Power System Model","title":"Add Active and Reactive Costs","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The addActiveCost! and addReactiveCost! functions are responsible for adding costs for the active and reactive power produced by the corresponding generator. These costs are added only if the corresponding generator is defined.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The addActiveCost! function will be used consistently throughout this manual. The same steps can be applied for the addReactiveCost! function. To begin, let us create an example of the power system using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\n\naddGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Polynomial-Cost","page":"Power System Model","title":"Polynomial Cost","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Let us define a quadratic polynomial cost function f(P_g) = 1100P^2_g + 500P_g + 150 for the active power produced by the generator labelled with 1 using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!(system; label = 1, model = 2, polynomial = [1100.0; 500.0; 150.0])","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As previously, the default input units are related with per-units (pu), and the coefficients of the cost function have units of currency/pu²hr for 1100, currency/puhr for 500, and currency/hr for 150. Hence, the coefficients are stored exactly as entered:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.polynomial","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"By setting model = 2 in the function, we specify that the quadratic polynomial cost is being used for the corresponding generator. This can be particularly useful if we have also defined a piecewise linear cost function for the same generator. In such cases, we can choose between these two cost functions depending on our simulation requirements.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Piecewise-Linear-Cost","page":"Power System Model","title":"Piecewise Linear Cost","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can also create a piecewise linear cost function for the active power of the same generator by using:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!(system; label = 1, piecewise =  [0.1085 12.3; 0.1477 16.8; 0.18 18.1])\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this case, the first column specifies the output active powers of the generator in per-units, while the second column specifies the corresponding costs for the specified active power in currency/hr. Thus, the data is stored exactly as entered:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.piecewise","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"If we want to use this piecewise linear cost function instead of the polynomial cost function that was defined earlier, we need to set model = 1.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Input-Unit-System-4","page":"Power System Model","title":"Change Input Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Changing input units from per-units (pu) can be particularly useful since cost functions are usually related to SI units of powers. To demonstrate this, let us set active powers in megawatts (MW) while keeping the rest of the units in per-units:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@power(MW, pu, pu)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\n\naddGenerator!(system; label = 1, bus = 2, active = 50, reactive = 0.1)\n\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Now, we can add the quadratic polynomial function using megawatts:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!(system; label = 1, model = 2, polynomial = [0.11; 5.0; 150.0])","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After inspecting the resulting cost data, we can see that it is the same as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.polynomial","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, we can define the linear piecewise cost:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addActiveCost!(system; label = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon inspection, we can see that the stored data is the same as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.piecewise","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/configuration/#configurationSetupAPI","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"For further information on this topic, please see the Power System Model section of the Manual.","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#API-Index","page":"Configuration Setup","title":"API Index","text":"","category":"section"},{"location":"api/configuration/#Base-Unit-Prefixes","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#Input-Unit-System","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@parameter","category":"page"},{"location":"api/configuration/#Default-Settings","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Base-Unit-Prefixes-2","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#JuliaGrid.@base","page":"Configuration Setup","title":"JuliaGrid.@base","text":"By default, the units for base power and base voltages are set to volt-ampere (VA) and volt (V), but you can modify the prefixes using the macro:\n\n@base(system::PowerSystem, power, voltage)\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of power (VA) or unit of voltage (V). Keep in mind that the macro must be used after creating the composite type PowerSystem.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n@base(system, MVA, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Input-Unit-System-2","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@parameter","category":"page"},{"location":"api/configuration/#JuliaGrid.@power","page":"Configuration Setup","title":"JuliaGrid.@power","text":"JuliaGrid stores all data related with powers in per-units, and these cannot be altered. However, the power units of the built-in functions used to add or modified power system elements can be modified using the macro:\n\n@power(active, reactive, apparent)\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of active power (W), reactive power (VAr), or apparent power (VA). Also it is a possible to combine SI units with/without prefixes with per-units (pu).\n\nChanging the unit of active power is reflected in the following quantities:\n\naddBus!: active, conductance\nshuntBus!: conductance\naddGenerator!: active, minActive, maxActive, lowActive, upActive, loadFollowing, reserve10min, reserve30min\naddActiveCost!: piecewise, polynomial\noutputGenerator!: active\naddBranch!: longTerm, shortTerm, emergency if rating type = 2.\n\nChanging the unit of reactive power unit is reflected in the following quantities:\n\naddBus!: reactive, susceptance\nshuntBus!: susceptance\naddGenerator!: reactive, minReactive, maxReactive, minLowReactive, maxLowReactive, minUpReactive, maxUpReactive, reactiveTimescale\naddReactiveCost!: piecewise, polynomial\noutputGenerator!: reactive.\n\nChanging the unit of apparent power unit is reflected in the following quantities:\n\naddBranch!: longTerm, shortTerm, emergency if rating type = 1 or type = 3.\n\nExample\n\n@power(MW, kVAr, VA)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@voltage","page":"Configuration Setup","title":"JuliaGrid.@voltage","text":"JuliaGrid stores all data related with voltages in per-units and radians, and these cannot be altered. However, the voltage magnitude and angle units of the built-in functions used to add or modified power system elements can be modified using the macro:\n\n@voltage(magnitude, angle, base)\n\nThe prefixes must adhere to the SI prefixes and should be specified along with the unit of voltage, either magnitude (V) or base (V). Alternatively, the unit of voltage magnitude can be expressed in per-unit (pu). The unit of voltage angle should be in radians (rad) or degrees (deg).\n\nChanging the unit of voltage magnitude is reflected in the following quantities:\n\naddBus!: magnitude, minMagnitude, maxMagnitude\naddGenerator!: magnitude.\n\nChanging the unit of voltage angle is reflected in the following quantities:\n\naddBus!: angle\naddBranch!: shiftAngle, minDiffAngle, maxDiffAngle\nparameterBranch!: shiftAngle.\n\nChanging the unit prefix of voltage base is reflected in the following quantity:\n\naddBus!: base.\n\nExample\n\n@voltage(pu, deg, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@parameter","page":"Configuration Setup","title":"JuliaGrid.@parameter","text":"JuliaGrid stores all data related with impedances and admittancies in per-units, and these cannot be altered. However, units of impedance and admittance of the built-in functions used to add or modified power system elements can be modified using the macro:\n\n@parameter(impedance, admittance)\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of impedance (Ω) or unit of admittance (S). The second option is to define the units in per-unit (pu).\n\nIn the case where impedance and admittance are being used in SI units (Ω and S) and these units are related to the transformer, the assignment must be based on the primary side of the transformer.\n\nChanging the units of impedance is reflected in the following quantities in specific functions:\n\naddBranch!: resistance, reactance\nparameterBranch!: resistance, reactance.\n\nChanging the units of admittance is reflected in the following quantities:\n\naddBranch!: susceptance\nparameterBranch!: susceptance.\n\nExample\n\n@parameter(Ω, pu)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Default-Settings-2","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/#JuliaGrid.@default","page":"Configuration Setup","title":"JuliaGrid.@default","text":"The macro is designed to reset various settings to their default values.\n\n@default(mode)\n\nThe mode argument can take on the following values:\n\nunit: resets all units to their default settings\npower: sets active, reactive, and apparent power to per-units\nvoltage: sets voltage magnitude to per-unit and voltage angle to radian\nparameter: sets impedance and admittance to per-units\ntemplate: resets bus, branch and generator templates to their default settings\nbus: resets the bus template to its default settings\nbranch: resets the branch template to its default settings\ngenerator: resets the generator template to its default settings.\n\nExample\n\n@default(unit)\n\n\n\n\n\n","category":"macro"},{"location":"api/postprocessing/#postprocessingAnalysisAPI","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"","category":"section"},{"location":"api/postprocessing/","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"For further information on this topic, please see the Power System Model section of the Manual.","category":"page"},{"location":"api/postprocessing/","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"","category":"page"},{"location":"api/postprocessing/#API-Index","page":"Postprocessing Analysis","title":"API Index","text":"","category":"section"},{"location":"api/postprocessing/","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"analysisBus\nanalysisBranch\nanalysisGenerator","category":"page"},{"location":"api/postprocessing/","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"","category":"page"},{"location":"api/postprocessing/#Bus-Function","page":"Postprocessing Analysis","title":"Bus Function","text":"","category":"section"},{"location":"api/postprocessing/","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"analysisBus","category":"page"},{"location":"api/postprocessing/#JuliaGrid.analysisBus","page":"Postprocessing Analysis","title":"JuliaGrid.analysisBus","text":"analysisBus(system::PowerSystem, model::ACPowerFlow)\n\nThe function computes the powers and currents associated with buses in the AC power flow framework.\n\nReturns\n\nThe function returns two instances of types.\n\nThe PowerBus type contains the following fields:\n\ninjection: the active and reactive power injections\nsupply: the active and reactive power injected by the generators\nshunt: the active and reactive power associated with shunt elements.\n\nThe CurrentBus type contains the following field:\n\ninjection: the magnitude and angle of current injections.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\npower, current = analysisBus(system, model)\n\n\n\n\n\nanalysisBus(system::PowerSystem, model::DCPowerFlow)\n\nThe function returns the active powers associated with buses in the DC power flow framework.\n\nReturns\n\nThe DCPowerBus type contains the following fields:\n\ninjection: the active power injections\nsupply: the active power injected by the generators.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nmodel = dcPowerFlow(system)\nsolve!(system, model)\n\npower = analysisBus(system, model)\n\n\n\n\n\n","category":"function"},{"location":"api/postprocessing/","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"","category":"page"},{"location":"api/postprocessing/#Branch-Function","page":"Postprocessing Analysis","title":"Branch Function","text":"","category":"section"},{"location":"api/postprocessing/","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"analysisBranch","category":"page"},{"location":"api/postprocessing/#JuliaGrid.analysisBranch","page":"Postprocessing Analysis","title":"JuliaGrid.analysisBranch","text":"analysisBranch(system::PowerSystem, model::ACPowerFlow)\n\nThe function returns the powers and currents associated with branches in the AC power flow framework.\n\nReturns\n\nThe function returns two instances of types.\n\nThe PowerBranch type contains the following fields:\n\nfrom: the active and reactive power flows at the from ends\nto: the active and reactive power flows at the to ends\nshunt: the reactive power injections\nloss: the active and reactive power losses.\n\nThe CurrentBranch type contains the following field:\n\nfrom: the magnitude and angle of current flows at from bus ends\nto: the magnitude and angle of current flows at to bus ends\nimpedance: the magnitude and angle of current flows through series impedances.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\npower, current = analysisBranch(system, model)\n\n\n\n\n\nanalysisBranch(system::PowerSystem, model::DCPowerFlow)\n\nThe function returns the active powers associated with branches in the DC power flow framework.\n\nReturns\n\nThe DCPowerBranch type contains the following fields:\n\nfrom: the active power flows at the from ends\nto: the active power flows at the to ends\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nmodel = dcPowerFlow(system)\nsolve!(system, model)\n\npower = analysisBranch(system, model)\n\n\n\n\n\n","category":"function"},{"location":"api/postprocessing/","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"","category":"page"},{"location":"api/postprocessing/#Generator-Function","page":"Postprocessing Analysis","title":"Generator Function","text":"","category":"section"},{"location":"api/postprocessing/","page":"Postprocessing Analysis","title":"Postprocessing Analysis","text":"analysisGenerator","category":"page"},{"location":"api/postprocessing/#JuliaGrid.analysisGenerator","page":"Postprocessing Analysis","title":"JuliaGrid.analysisGenerator","text":"analysisGenerator(system::PowerSystem, model::ACPowerFlow)\n\nThe function return powers related to generators for the AC power flow analysis.\n\nReturns\n\nThe PowerGenerator type contains the following variables:\n\nactive: the active power output of the generators\nreactive: the reactive power output of the generators.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\npower = analysisGenerator(system, model)\n\n\n\n\n\nanalysisGenerator(system::PowerSystem, model::DCPowerFlow)\n\nThe function returns powers related to generators in the DC power flow framework.\n\nReturns\n\nThe DCPowerGenerator type contains the following field:\n\nactive: the active power output of the generators.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nmodel = dcPowerFlow(system)\nsolve!(system, model)\n\npower = analysisGenerator(system, model)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#powerSystemModelAPI","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For further information on this topic, please see the Power System Model section of the Manual.","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#API-Index","page":"Power System Model","title":"API Index","text":"","category":"section"},{"location":"api/powerSystemModel/#Power-System-Data","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nshuntBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nstatusGenerator!\noutputGenerator!\naddActiveCost!\naddReactiveCost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System-Data-2","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.powerSystem","page":"Power System Model","title":"JuliaGrid.powerSystem","text":"powerSystem(file::String)\n\nThe function builds the composite type PowerSystem and populates bus, branch, generator and base fields. In general, once the composite type PowerSystem has been created, it is possible to add new buses, branches, or generators, or modify the parameters of existing ones.\n\nArgument\n\npassing the path to the HDF5 file with the .h5 extension\npassing the path to Matpower file with the .m extension\n\nReturns\n\nThe PowerSystem composite type with the following fields:\n\nbus: data related to buses\nbranch: data related to branches\ngenerator: data related to generators\nbase: base power and base voltages\nacModel: variables associated with AC or nonlinear analyses\ndcModel: variables associated with DC or linear analyses.\n\nUnits\n\nJuliaGrid stores all data in per-units and radians format which are fixed, the exceptions are base values in volt-amperes and volts. The prefixes for these base values can be changed using the @base macro.\n\nExamples\n\nLoad power system data:\n\nsystem = powerSystem(\"case14.h5\")\n\nLoad power system data and build AC and DC models:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\ndcModel!(system)\n\n\n\n\n\nAlternatively, the PowerSystem composite type can be initialized by calling the function without any arguments.\n\npowerSystem()\n\nThis allows the model to be built from scratch and modified as needed. This generates an empty PowerSystem type, with only the base power initialized to 1.0e8 volt-amperes (VA).\n\nExample\n\nsystem = powerSystem()\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.savePowerSystem","page":"Power System Model","title":"JuliaGrid.savePowerSystem","text":"savePowerSystem(system::PowerSystem; path::String, reference::String, note::String)\n\nThe function saves the power system's data in the HDF5 file using the fields bus, branch, generator, and base from the PowerSystem composite type.\n\nKeywords\n\nThe location and file name of the HDF5 file is specified by the mandatory keyword path in the format of \"path/name.h5\". Additional information can be provided by the optional keywords reference and note, which can be saved along with the power system data.\n\nView HDF5 File\n\nTo view the saved HDF5 file, you can use the HDFView software.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"D:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions-2","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nshuntBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBus!","page":"Power System Model","title":"JuliaGrid.addBus!","text":"addBus!(system::PowerSystem; label, type, active, reactive, conductance, susceptance,\n    magnitude, angle, minMagnitude, maxMagnitude, base, area, lossZone)\n\nThe function adds a new bus to the PowerSystem type, updating its bus field.\n\nKeywords\n\nThe bus is defined with the following keywords:\n\nlabel: unique label for the bus\ntype: the bus type:\ntype = 1: demand bus (PQ)\ntype = 2: generator bus (PV)\ntype = 3: slack bus (Vθ)\nactive (pu or W): the active power demand at the bus\nreactive (pu or VAr): the reactive power demand at the bus\nconductance (pu or W): the active power demanded of the shunt element\nsusceptance (pu or VAr): the reactive power injected of the shunt element\nmagnitude (pu or V): the initial value of the voltage magnitude\nangle (rad or deg): the initial value of the voltage angle\nminMagnitude (pu or V): the minimum voltage magnitude value\nmaxMagnitude (pu or V): the maximum voltage magnitude value\nbase (V): the base value of the voltage magnitude\narea: the area number\nlossZone: the loss zone.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: type = 1, magnitude = 1.0 per-unit, and base = 138e3 volts. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @bus macro.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, angle = 0.1745, base = 132e3)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 25, reactive = -4, angle = 10, base = 132)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.shuntBus!","page":"Power System Model","title":"JuliaGrid.shuntBus!","text":"shuntBus!(system::PowerSystem; label, conductance, susceptance)\n\nThis function enables the modification of the conductance and susceptance parameters of a shunt element connected to a bus.\n\nThe keyword label must match an existing bus label. If either conductance or susceptance is left out, the corresponding value will remain unchanged. It updates the bus.shunt field of the PowerSystem composite type.\n\nAdditionally, this function automatically updates the acModel field of the PowerSystem type, eliminating the need to rebuild the model from scratch when making changes to these parameters.\n\nUnits\n\nThe input units are in per-units by default, but they can be modified using the @power macro.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\nshuntBus!(system; label = 1, conductance = 0.04)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@bus","page":"Power System Model","title":"JuliaGrid.@bus","text":"@bus(kwargs...)\n\nThe macro generates a template for a bus, which can be utilized to define a bus using the addBus! function.\n\nTo define the bus template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBus! function, along with their corresponding values.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus template using the default unit system:\n\nsystem = powerSystem()\n@bus(type = 2, active = 0.25, angle = 0.1745)\naddBus!(system; label = 1, reactive = -0.04, base = 132e3)\n\nCreating a bus template using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 25, angle = 10, base = 132)\naddBus!(system; label = 1, reactive = -4)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions-2","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBranch!","page":"Power System Model","title":"JuliaGrid.addBranch!","text":"addBranch!(system::PowerSystem; label, from, to, status, resistance, reactance,\n    susceptance, turnsRatio, shiftAngle, minDiffAngle, maxDiffAngle,\n    longTerm, shortTerm, emergency, type)\n\nThe function adds a new branch to the PowerSystem type and updates its branch field. A branch can be added between already defined buses.\n\nKeywords\n\nThe branch is defined with the following keywords:\n\nlabel: unique label for the branch\nfrom: from bus label, corresponds to the bus label\nto: to bus label, corresponds to the bus label\nstatus: operating status of the branch:\nstatus = 1: in-service\nstatus = 0: out-of-service\nresistance (pu or Ω): branch resistance\nreactance (pu or Ω): branch reactance\nsusceptance (pu or S): total line charging susceptance\nturnsRatio: transformer off-nominal turns ratio, equal to zero for a line\nshiftAngle (rad or deg): transformer phase shift angle, where positive value defines delay\nminDiffAngle (rad or deg): minimum voltage angle difference value between from and to bus\nmaxDiffAngle (rad or deg): maximum voltage angle difference value between from and to bus.\nlongTerm (pu or VA, W): long-term rating (equal to zero for unlimited)\nshortTerm (pu or VA, W): short-term rating (equal to zero for unlimited)\nemergency (pu or VA, W): emergency rating (equal to zero for unlimited)\ntype: types of longTerm, shortTerm, and emergency ratings:\ntype = 1: apparent power flow (pu or VA)\ntype = 2: active power flow (pu or W)\ntype = 3: current magnitude (pu or VA at 1 pu voltage).\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1 and type = 1. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @branch macro.\n\nUnits\n\nThe default units for the keyword parameters are per-units (pu) and radians (rad). However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)\n\nCreating a branch using a custom unit system:\n\n@voltage(pu, deg, kV)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1,  active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 10)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.statusBranch!","page":"Power System Model","title":"JuliaGrid.statusBranch!","text":"statusBranch!(system::PowerSystem; label, status)\n\nThe function enables the switching of the operational status of a branch, identified by its label, within the PowerSystem system between in-service and out-of-service.\n\nThis function updates the acModel and dcModel fields automatically when the operating status of a branch is changed, thus eliminating the need to rebuild the model from scratch.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nstatusBranch!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.parameterBranch!","page":"Power System Model","title":"JuliaGrid.parameterBranch!","text":"parameterBranch!(system::PowerSystem; label, resistance, reactance, susceptance,\n    turnsRatio, shiftAngle)\n\nThis function enables the alteration of the resistance, reactance, susceptance, turnsRatio and shiftAngle parameters of a branch, identified by its label.\n\nIf any of these parameters are omitted, their current values will be retained. It updates the branch.parameter field of the PowerSystem composite type.\n\nAdditionally, this function updates the acModel and dcModel fields automatically, removing the need to rebuild the model from scratch.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units. However, users have the option to use other units instead of per-units and radians using the @voltage and @parameter macros.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nparameterBranch!(system; label = 1, susceptance = 0.062)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@branch","page":"Power System Model","title":"JuliaGrid.@branch","text":"@branch(kwargs...)\n\nThe macro generates a template for a branch, which can be utilized to define a branch using the addBranch! function.\n\nTo define the branch template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBranch! function, along with their corresponding values.\n\nUnits\n\nThe default units for the keyword parameters are per-units and radians. However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch template using the default unit system:\n\nsystem = powerSystem()\n\n@branch(reactance = 0.12, shiftAngle = 0.1745)\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1, active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2)\n\nCreating a branch template using a custom unit system:\n\n@voltage(pu, deg, kV)\n\nsystem = powerSystem()\n\n@branch(shiftAngle = 10)\naddBus!(system; label = 1, type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, type = 1,  active = 0.15, reactive = 0.08)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions-2","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nstatusGenerator!\noutputGenerator!\naddActiveCost!\naddReactiveCost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addGenerator!","page":"Power System Model","title":"JuliaGrid.addGenerator!","text":"addGenerator!(system::PowerSystem; label, bus, status, active, reactive, magnitude,\n    minActive, maxActive, minReactive, maxReactive, lowActive, minLowReactive,\n    maxLowReactive, upActive, minUpReactive, maxUpReactive,\n    loadFollowing, reactiveTimescale, reserve10min, reserve30min, area)\n\nThe function is used to add a new generator to the PowerSystem type and update its generator field. The generator can be added to an already defined bus.\n\nKeywords\n\nThe generator is defined with the following keywords:\n\nlabel: a unique label for the generator\nbus: the label of the bus to which the generator is connected\nstatus: the operating status of the generator:\nstatus = 1: in-service\nstatus = 0: out-of-service\nactive (pu or W): output active power\nreactive (pu or VAr): output reactive power\nmagnitude (pu or V): voltage magnitude setpoint\nminActive (pu or W): minimum allowed output active power value\nmaxActive (pu or W): maximum allowed output active power value\nminReactive (pu or VAr): minimum allowed output reactive power value\nmaxReactive (pu or VAr): maximum allowed output reactive power value\nlowActive (pu or W): lower allowed active power output value of PQ capability curve\nminLowReactive (pu or VAr): minimum allowed reactive power output value at lowActive value\nmaxLowReactive (pu or VAr): maximum allowed reactive power output value at lowActive value\nupActive (pu or W): upper allowed active power output value of PQ capability curve\nminUpReactive (pu or VAr): minimum allowed reactive power output value at upActive value\nmaxUpReactive (pu or VAr): maximum allowed reactive power output value at upActive value\nloadFollowing (pu/min or W/min): ramp rate for load following/AG\nreserve10min (pu or W): ramp rate for 10-minute reserves\nreserve30min (pu or W): ramp rate for 30-minute reserves\nreactiveTimescale (pu/min or VAr/min): ramp rate for reactive power, two seconds timescale\narea: area participation factor.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1 and magnitude = 1.0 per-unit. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @generator macro.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 2, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1, magnitude = 1.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 2, active = 25, reactive = -4, base = 132)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10, magnitude = 145.2)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.statusGenerator!","page":"Power System Model","title":"JuliaGrid.statusGenerator!","text":"statusGenerator!(system::PowerSystem; label, status)\n\nThe function changes the operating status of a generator by switching it from in-service to out-of-service, or vice versa.\n\nIt has two parameters, label and status, where the label corresponds to the generator label that has already been defined. It updates the bus.layout.type field of the PowerSystem type.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\nstatusGenerator!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.outputGenerator!","page":"Power System Model","title":"JuliaGrid.outputGenerator!","text":"outputGenerator!(system::PowerSystem; label, active, reactive)\n\nThe function modifies the active and reactive output powers of a generator.\n\nIt has three parameters, label, active, and reactive, where the label corresponds to the generator label that has already been defined. The active and reactive parameters can be left, in which case their values will remain unchanged. The function also updates the bus.supply field of the PowerSystem type.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\noutputGenerator!(system; label = 1, active = 0.85)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.addActiveCost!","page":"Power System Model","title":"JuliaGrid.addActiveCost!","text":"addActiveCost!(system::PowerSystem; label, model, piecewise, polynomial)\n\nThe function updates the generator.cost field of the PowerSystem type by adding costs for the active power produced by the corresponding generator. It can add a cost to an already defined generator.\n\nKeywords\n\nThe function takes in four keywords as arguments:\n\nlabel: corresponds to the already defined generator label\nmodel: cost model:\nmodel = 1: piecewise linear is being used\nmodel = 2: polynomial is being used\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or W): active power output of the generator\nsecond column (currency/hr): cost for the specified active power output\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/Wⁿhr): coefficient of the n-th degree term, ...\npenultimate element (currency/puhr or currency/Whr): coefficient of the first degree term\nlast element (currency/hr): constant coefficient.\n\nUnits\n\nBy default, the input units related with active powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\naddActiveCost!(system; label = 1, model = 1, polynomial = [1100.0; 500.0; 150.0])\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 25, reactive = -4, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\naddActiveCost!(system; label = 1, model = 1, polynomial = [0.11; 5.0; 150.0])\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.addReactiveCost!","page":"Power System Model","title":"JuliaGrid.addReactiveCost!","text":"addReactiveCost!(system::PowerSystem; label, model, piecewise, polynomial)\n\nThe function updates the generator field of the PowerSystem type by adding costs for the reactive power produced by the corresponding generator. It can add a cost to an already defined generator.\n\nKeywords\n\nThe function takes in four keywords as arguments:\n\nlabel: corresponds to the already defined generator label\nmodel: cost model:\nmodel = 1: piecewise linear is being used\nmodel = 2: polynomial is being used\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or VAr): reactive power output of the generator\nsecond column (currency/hr): cost for the specified reactive power output\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/VArⁿhr): coefficient of the n-th degree term, ...\npenultimate element (currency/puhr or currency/VArhr): coefficient of the first degree term\nlast element (currency/hr): constant coefficient.\n\nUnits\n\nBy default, the input units related with reactive powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\naddReactiveCost!(system; label = 1, model = 2, piecewise = [0.1085 12; 0.1477 16])\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 25, reactive = -4, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\naddReactiveCost!(system; label = 1, model = 2, piecewise = [10.85 12; 14.77 16])\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@generator","page":"Power System Model","title":"JuliaGrid.@generator","text":"@generator(kwargs...)\n\nThe macro generates a template for a generator, which can be utilized to define a generator using the addGenerator! function.\n\nTo define the generator template, the kwargs input arguments must be provided in accordance with the keywords specified within the addGenerator! function, along with their corresponding values.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\n@generator(magnitude = 1.1)\naddBus!(system; label = 1, type = 2, active = 0.25, reactive = -0.04, base = 132e3)\naddGenerator!(system; label = 1, bus = 1, active = 0.5, reactive = 0.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\n\nsystem = powerSystem()\n\n@generator(magnitude = 145.2)\naddBus!(system; label = 1, type = 2, active = 25, reactive = -4, base = 132)\naddGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model-2","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.acModel!","page":"Power System Model","title":"JuliaGrid.acModel!","text":"acModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with AC analysis.\n\nThe function updates the field acModel. Once formed, the field will be automatically updated when using functions shuntBus!, addBranch!, statusBranch!, and parameterBranch!.\n\nVariables\n\nThe following variables are formed once the function is executed:\n\nnodalMatrix: the nodal matrix\nnodalMatrixTranspose: the transpose of the nodal matrix\nnodalFromFrom: the Y-parameters of the two-port branches\nnodalFromTo: the Y-parameters of the two-port branches\nnodalToTo: the Y-parameters of the two-port branches\nnodalToFrom: the Y-parameters of the two-port branches\nadmittance: the branch admittances\ntransformerRatio: the complex ratios of transformers.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.dcModel!","page":"Power System Model","title":"JuliaGrid.dcModel!","text":"dcModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with DC analysis.\n\nThe function updates the field dcModel. Once formed, the field will be automatically updated when using functions addBranch!, statusBranch!, and parameterBranch!.\n\nVariables\n\nThe following variables are formed once the function is executed:\n\nnodalMatrix: the nodal matrix\nadmittance: the branch admittances\nshiftActivePower: the active powers related to phase-shifting transformers.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"tutorials/dcPowerFlow/#DCPowerFlowTutorials","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid employs standard network components and the unified branch model to obtain the DC power flow solution. To begin, the PowerSystem composite type must be provided to JuliaGrid through the use of the powerSystem function, as illustrated by the following example:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, V)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 21.7)\naddBus!(system; label = 3, type = 2, conductance = 0.07)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.26)\naddBranch!(system; label = 2, from = 1, to = 3, reactance = 0.38)\naddBranch!(system; label = 3, from = 2, to = 3, reactance = 0.17, turnsRatio = 0.97)\n\naddGenerator!(system; label = 1, bus = 1, active = 2.0)\naddGenerator!(system; label = 2, bus = 1, active = 4.0)\naddGenerator!(system; label = 3, bus = 3, active = 5.0)\nnothing #hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝒩 = collect(keys(sort(system.bus.label)))\nℰ = [system.branch.layout.from system.branch.layout.to]","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"ukw: Notation\nIn this section, when referring to a vector mathbfa, we use the notation mathbfa = a_i or mathbfa = a_ij, where a_i denotes the generic element associated with bus i in mathcalN, and a_ij denotes the generic element associated with branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#DCPowerFlowSolutionTutorials","page":"DC Power Flow","title":"DC Power Flow Solution","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"As discussed in section DC Model, the DC power flow problem can be represented by a set of linear equations given by:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"  mathbf P = mathbfB bm theta + mathbfP_texttr + mathbfP_textsh","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Implementation","page":"DC Power Flow","title":"Implementation","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid offers a set of functions to solve the DC power flow problem and obtain the bus voltage angles. Firstly, the power system is loaded and the DC model is built using the following code sequence:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The DC power flow solution is obtained through a non-iterative approach by solving the system of linear equations:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    bm theta = mathbfB^-1(mathbf P - mathbfP_texttr - mathbfP_textsh)","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The initial step taken by JuliaGrid is to factorize the nodal matrix mathbfB using the function:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"model = dcPowerFlow(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The factorization of the nodal matrix can be accessed using:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"model.factorization\nusing SparseArrays\nsparse(model.factorization.L)","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"This enables the user to modify any of the vectors mathbf P, mathbfP_texttr, and mathbfP_textsh and reuse the factorization. This approach is more efficient compared to solving the system of equations from the beginning, as it saves computation time.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To acquire the bus voltage angles, the user must invoke the function:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"solve!(system, model)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"It is important to note that the slack bus voltage angle is excluded from the vector bmtheta only during the computation step. As a analysis, the corresponding elements in the vectors mathbf P, mathbfP_texttr, mathbfP_textsh, and the corresponding row and column of the matrix mathbfB are removed. It is worth mentioning that this process is handled internally, and the stored elements remain unchanged.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, the resulting bus voltage angles are saved in the vector as follows:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝛉 = model.voltage.angle","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#DCBusPowersTutorials","page":"DC Power Flow","title":"Bus Powers","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid's analysisBus function can be used to compute powers associated with buses. Here is an example code snippet:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power = analysisBus(system, model)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To obtain the active power injection at bus i in mathcalN, we can refer to section DC Model, which provides the following expression:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"   P_i = sum_j = 1^n B_ij theta_j + P_texttri + P_textshi i in mathcalN","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Active power injections are stored as the vector mathbfP = P_i, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏 = power.injection.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The active power supplied by generators to the buses can be calculated by summing the given generator active powers in the input data, except for the slack bus, which can be determined as:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_textsi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"where P_textdi represents the active power demanded by consumers at the slack bus. The vector of active power injected by generators to the buses, denoted by mathbfP_texts = P_textsi, can be obtained using the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ₛ = power.supply.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#DCBranchPowersTutorials","page":"DC Power Flow","title":"Branch Powers","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To compute powers associated with branches, JuliaGrid provides the analysisBranch function. Here is an example code snippet:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power = analysisBranch(system, model)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The active power flows at from bus end i in mathcalN can be obtained using the following equations:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_ij = cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) (ij) in mathcalE","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The resulting active power flows at from bus end are stored as the vector mathbfP_texti = P_ij, which can be retrieved using the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ᵢ = power.from.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Similarly, the active power flows at to bus end j in mathcalN can be obtained as:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_ji = - P_ij (ij) in mathcalE","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The resulting active power flows at to bus end are stored as the vector mathbfP_textj = P_ji, which can be retrieved using the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ⱼ = power.to.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#DCGeneratorPowersTutorials","page":"DC Power Flow","title":"Generator Powers","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To compute powers associated with generators, JuliaGrid provides the analysisGenerator function. Here is an example code snippet:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power = analysisGenerator(system, model)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The active power output of a generator located at bus i in mathcalN_textpv cup mathcalN_textpq is equal to the active power specified in the input data. If there are multiple generators, their active power outputs are also equal to the active power specified in the input data. However, the active power output of a generator located at the slack bus is determined as:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_textgi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"In the case of multiple generators connected to the slack bus, the first generator in the input data is assigned the obtained value of P_textgi. Then, this amount of power is reduced by the output active power of the other generators. Therefore, to get the vector of output active power of generators, i.e., mathbfP_textg = P_textgi, you can use the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ₒ = power.active","category":"page"},{"location":"manual/optimalPowerFlow/#OptimalPowerFlowManual","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"section"},{"location":"tutorials/acPowerFlow/#ACPowerFlowTutorials","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid utilizes standard network components and leverages the unified branch model to perform power flow analysis, enabling the definition of load profiles, generator capacities, voltage specifications, contingency analysis, and planning.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To begin, the PowerSystem composite type must be provided to JuliaGrid through the use of the powerSystem function, as illustrated by the following example:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, V)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 21.7, reactive = 12.7)\naddBus!(system; label = 3, type = 1, active = 11.2, reactive = -3.0)\naddBus!(system; label = 4, type = 2, conductance = 2.1, susceptance = 1.2)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.02, reactance = 0.06)\naddBranch!(system; label = 2, from = 1, to = 3, resistance = 0.05, reactance = 0.21)\naddBranch!(system; label = 3, from = 2, to = 3, resistance = 0.13, reactance = 0.26)\naddBranch!(system; label = 4, from = 3, to = 4, reactance = 0.17, susceptance = 0.2)\n\naddGenerator!(system; label = 1, bus = 3, active = 40.0, reactive = 42.4)\nnothing #hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝒩 = collect(keys(sort(system.bus.label)))\nℰ = [system.branch.layout.from system.branch.layout.to]","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"ukw: Notation\nIn this section, when referring to a vector mathbfa, we use the notation mathbfa = a_i or mathbfa = a_ij, where a_i denotes the generic element associated with bus i in mathcalN, and a_ij denotes the generic element associated with branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#BusTypesPowerInjectionsTutorials","page":"AC Power Flow","title":"Bus Types and Power Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As previously demonstrated in the section on the AC Model, we can express the network as the system of equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    mathbfbar I = mathbfY mathbfbar V","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The complex current injection at the bus i in mathcalN is defined as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  \tbarI_i = cfracS_i^*barV_i^*","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where barV_i = V_i texte^textjtheta_i. Thus, for any given bus i in mathcalN, we can express it as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  \tcfracS_i^*barV_i^* = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The complex power injection denoted by S_i comprises of both the active power P_i and reactive power Q_i. This relationship can be represented as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  \tcfracP_i - textjQ_ibarV_i = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As demonstrated by the above equation, the bus i in mathcalN contains four unknown variables, namely the active power injection P_i, reactive power injection Q_i, bus voltage magnitude V_i, and bus voltage angle theta_i. To solve the system of equations, two variables must be specified for each equation. Although any two variables can be selected mathematically, the choice is determined by the devices that are connected to a particular bus. The standard options are listed in the table below, and these options are used to define the bus types [1].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Bus Type Label JuliaGrid Known Unknown\nDemand PQ 1 P_i, Q_i V_i, theta_i\nGenerator PV 2 P_i, V_i Q_i, theta_i\nSlack V theta 3 V_i, theta_i P_i, Q_i","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Consequently, JuliaGrid operates with sets mathcalN_textpq and mathcalN_textpv that contain demand and generator buses, respectively, and exactly one slack bus in the set mathcalN_textsb. The bus types are stored in the variable:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"system.bus.layout.type","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"It should be noted that JuliaGrid cannot handle systems with multiple slack buses. Additionally, when using functions such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, and gaussSeidel, the bus type can be modified in the following manner: If a bus was originally classified as the generator bus, but does not have any in-service generators, it will be converted to the demand bus, as discussed in the section on Bus Type Modification.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Furthermore, the active power injections P_i and reactive power injections Q_i can be expressed as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  \tP_i = P_textsi - P_textdi \n    Q_i = Q_textsi - Q_textdi\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where P_textsi and Q_textsi correspond to the active and reactive power injected by the generators at the bus i in mathcalN, while P_textdi and Q_textdi denote the active and reactive power demanded at the bus i in mathcalN. We can calculate the vectors mathbfP = P_i and mathbfQ = Q_i using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏 = system.bus.supply.active - system.bus.demand.active\n𝐐 = system.bus.supply.reactive - system.bus.demand.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#NewtonRaphsonMethodTutorials","page":"AC Power Flow","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Newton-Raphson method is commonly used in AC power flow calculations due to its quadratic rate of convergence. It provides an accurate approximation of the roots of the system of nonlinear equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbff(mathbfx) = mathbf0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This, in turn, allows for the determination of the unknown voltage magnitudes and angles of buses, represented by the state vector mathbf x = mathbf x_a mathbf x_m^T. The state vector comprises two components:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"mathbf x_a in mathbbR^n-1, which holds the bus voltage angles of demand and generator buses, represented by mathbf x_a = theta_i, where i in mathcalN_textpq cup mathcalN_textpv;\nmathbf x_m in mathbbR^n_textpq, which holds the bus voltage magnitudes of demand buses, represented by mathbf x_m = V_i, where i in mathcalN_textpq, and n_textpq = mathcalN_textpq.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Knowing the voltage magnitudes and angles for certain types of buses is a consequence of the structure of the state vector mathbf x. Specifically, the voltage magnitude and angle at the slack bus are known, as well as the voltage magnitude at generator buses.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The complex power injection S_i at a bus i in mathcalN is a function of the complex bus voltages. Therefore, the active and reactive power injection expressions can be defined based on the real and imaginary components of the complex power as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    P_i =V_isumlimits_j=1^n V_j (G_ijcostheta_ij+B_ijsintheta_ij)\n    Q_i =V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij)\n\tendaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Using the above equations, we can define the active power injection function for demand and generator buses as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"and the reactive power injection function for demand buses as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active and reactive mismatches, often denoted as Delta P_i(mathbf x) and Delta Q_i(mathbf x), respectively, are defined as the functions f_P_i(mathbf x) and f_Q_i(mathbf x). The first terms on the right-hand side represent power injections at a bus, while the second term is constant and is obtained based on the active and reactive powers of the generators that supply a bus and active and reactive powers demanded by consumers at the same bus. Therefore, the Newton-Raphson method solves the system of nonlinear equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbff(x) =\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where the first n - 1 equations correspond to demand and generator buses, and the last n_textpq equations correspond to demand buses.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Initialization","page":"AC Power Flow","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To compute the voltage magnitudes and angles of buses using the Newton-Raphson method in JuliaGrid, you must first execute the acModel! function to set up the system, followed by initializing the Newton-Raphson method using the newtonRaphson function. The following code snippet demonstrates this process:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nmodel = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This results in the creation of the starting vectors of bus voltage magnitudes mathbfV^(0) and angles bmtheta^(0), as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕⁽⁰⁾ = model.voltage.magnitude\n𝛉⁽⁰⁾ = model.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Here, we utilize a \"flat start\" approach in our method. It is important to keep in mind that when dealing with initial conditions in this manner, the Newton-Raphson method may encounter difficulties.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Iterative-Process","page":"AC Power Flow","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To implement the Newton-Raphson method, the iterative approach based on the Taylor series expansion, JuliaGrid provides the mismatch! and solve! functions. These functions are utilized to carry out the Newton-Raphson method iteratively until a stopping criterion is reached, as demonstrated in the following code snippet:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The mismatch! function calculates the mismatch in active power injection for demand and generator buses and the mismatch in reactive power injection for demand buses at each iteration nu = 1 2 dots. The equations used for these computations are:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_P_i(mathbf x^(nu-1)) = V_i^(nu-1)sumlimits_j=1^n V_j^(nu-1)(G_ijcostheta_ij^(nu-1)+B_ijsintheta_ij^(nu-1)) - P_i\n   i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"as well as the reactive power injection mismatch for demand buses:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    f_Q_i(mathbf x^(nu-1)) = V_i^(nu)sumlimits_j=1^n V_j^(nu-1)(G_ijsintheta_ij^(nu-1)-B_ijcostheta_ij^(nu-1)) - Q_i\n     i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The resulting vector from these calculations is stored in the mismatch variable of the Model composite type and can be accessed through the following line of code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐟 = model.mismatch","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In addition to computing the mismatches in active and reactive power injection, the mismatch! function also returns the maximum absolute values of these mismatches. These maximum values are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion epsilon:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    max f_P_i(mathbf x^(nu-1)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max f_Q_i(mathbf x^(nu-1)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the function solve! computes the increments of bus voltage angle and magnitude at each iteration using the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbfDelta mathbfx^(nu-1) = -mathbfJ(mathbfx^(nu-1))^-1 mathbff(mathbfx^(nu-1))","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where mathbfDelta mathbfx = mathbf Delta mathbf x_a mathbf Delta mathbf x_m^T consists of the vector of bus voltage angle increments mathbf Delta mathbf x_a in mathbbR^n-1 and bus voltage magnitude increments mathbf Delta mathbf x_m in mathbbR^n_textpq, and mathbfJ(mathbfx) in mathbbR^n_textu times n_textu is the Jacobian matrix, n_textu = n + n_textpq - 1.  These values are stored in the Model composite type and can be accessed after each iteration using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚫𝐱 = model.increment\n𝐉 = model.jacobian","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The JuliaGrid implementation of the AC power flow follows a specific order to store the increment and mismatch vectors. The first n-1 elements of both vectors correspond to the demand and generator buses in the same order as they appear in the input data. This order is not obtained by first extracting the demand and then generator buses but by excluding the slack bus in the input data. The first n-1 elements of the increment vector correspond to the voltage angle increments, while the first n-1 elements of the mismatch vector correspond to the mismatch in active power injections. The last n_textpq elements of the increment and mismatch vectors correspond to the demand buses in the order they appear in the input data. For the increment vector, it matches the bus voltage magnitude increments, while for the mismatch vector, it matches the mismatch in reactive power injections. As a analysis, this order defines the row and column order of the Jacobian matrix mathbfJ(mathbfx).","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Finally, the function solve! adds the computed increment term to the previous solution to obtain a new solution:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf x^(nu) = mathbf x^(nu-1) + mathbf Delta mathbf x^(nu-1)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The bus voltage magnitudes mathbfV = V_i and angles bmtheta = theta_i are then updated based on the obtained solution mathbf x. It is important to note that only the voltage magnitudes related to demand buses and angles related to demand and generator buses are updated; not all values are updated. Therefore, the final solution obtained by JuliaGrid is stored in the following vectors:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕 = model.voltage.magnitude\n𝛉 = model.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Jacobian-Matrix","page":"AC Power Flow","title":"Jacobian Matrix","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To complete the tutorial on the Newton-Raphson method, we will now describe the Jacobian matrix and provide the equations involved in its evolution. Without loss of generality, we assume that the slack bus is the first bus, followed by the set of demand buses and the set of generator buses:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathcalN_textsb =  1  \n    mathcalN_textpq = 2 dots m \n    mathcalN_textpv = m + 1dots n\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where mathcalN = mathcalN_textsb cup mathcalN_textpq cup mathcalN_textpv. Therefore, we can express:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathbf x_a = theta_2dotstheta_n^T  mathbf Delta mathbf x_a = Delta theta_2dotsDelta theta_n^T \n    mathbf x_m = V_2dotsV_m^T  mathbf Delta mathbf x_m = Delta V_2dotsDelta V_m^T\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Jacobian matrix mathbfJ(x^(nu)) in mathbbR^n_textu times n_textu is:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbfJ(x^(nu))=\n  left\n  beginarraycccccc\n  cfracmathrm partialf_P_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_P_n(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_m 10pt\n  hline \n  cfracmathrm partialf_Q_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_Q_m(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_m\n  endarray\n  right","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Jacobian matrix can be expressed using four block matrices:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"\t  mathbfJ(x^(nu)) =\n  beginbmatrix\n    mathbfJ_11(x^(nu)) mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu)) \n\t   mathbfJ_22(x^(nu))\n  endbmatrix","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where diagonal elements of the Jacobian sub-matrices are defined as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu)) mathrm partial theta_i =\n  V_i^(nu)sumlimits_j=1^n V_j^(nu)(-G_ij\n  sintheta_ij^(nu)+B_ijcostheta_ij^(nu)) - (V_i^(nu))^2B_ii\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_i^(nu) = sumlimits_\n  j=1^n V_j^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))+V_i^(nu) G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_i=V_i^(nu)\n  sumlimits_j=1^n V_j^(nu)\n  (G_ijcostheta_ij^(nu)+B_ijsintheta_ij^(nu))- (V_i^(nu))^2G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial V_i=sumlimits_j=1\n  ^n V_j^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))-V_i^(nu) B_ii\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"while non-diagonal elements of the Jacobian sub-matrices are:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu))\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_j^(nu) = V_i^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (-G_ijcostheta_ij^(nu) -B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))mathrm\n  partial V_j=V_i^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#FastNewtonRaphsonMethodTutorials","page":"AC Power Flow","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Although the fast Newton-Raphson method may converge more slowly than the traditional Newton-Raphson method, the shorter solution time for the updates often compensates for this slower convergence, resulting in a shorter overall solution time. This is particularly true for systems that are not heavily loaded, where a shorter overall solution time is almost always achieved. It is important to note that if the algorithm converges, it will converge to a correct solution [2].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The fast Newton-Raphson method involves decoupling the power flow equations. Namely, the Newton-Raphson method is based on the equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginbmatrix\n    mathbfJ_11(x) mathbfJ_12(x)  mathbfJ_21(x) \n\t   mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbf Delta mathbf x_a  mathbf Delta mathbf x_m\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where the iteration index has been omitted for simplicity. However, in transmission grids, there exists a strong coupling between active powers and voltage angles, as well as between reactive powers and voltage magnitudes. To achieve decoupling, two conditions must be satisfied: first, the resistance values r_ij of the branches must be small compared to their reactance values x_ij, and second, the angle differences must be small, i.e., theta_ij approx 0 [3]. Therefore, starting from the above equation, we have:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginbmatrix\n    mathbfJ_11(x)  mathbf0  mathbf0  mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbf Delta mathbf x_a  mathbf Delta mathbf x_m\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"which gives the decoupled system as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathbff_P(mathbf x) = -mathbfJ_11(x) mathbf Delta mathbf x_a \n    mathbff_Q(mathbf x) = -mathbfJ_22(x) mathbf Delta mathbf x_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To examine the problem, it is helpful to express it as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = -Delta theta_2cfracmathrm partialf_P_2(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_2(mathbf x)mathrm partial theta_n \n     vdots \n    f_P_n(mathbf x) = -Delta theta_2cfracmathrm partialf_P_n(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_i(mathbf x)mathrm partial theta_n\n    f_Q_2(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_n_textpq  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n     vdots \n    f_Q_m(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_m  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Firstly, the second part of the expressions is expanded as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  f_Q_2(mathbf x) =\n  -cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n   vdots \n  f_Q_m(mathbf x) =\n  - cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the Jacobian elements are derived. To achieve this, we can use the expressions defined for the Newton-Raphson method. For PQ buses, the above expansions are applied as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  V_isumlimits_j=1^n V_j(-G_ij\n  sintheta_ij+B_ijcostheta_ij) - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = V_isumlimits_j=1\n  ^n V_j(G_ijsintheta_ij-\n  B_ijcostheta_ij)-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As the definition of reactive power is given by the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    Q_i =V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"the Jacobian elements can be expressed in the following manner:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  -Q_i - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = Q_i-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The decoupled model is established through the following approximations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    sin(theta_ij) approx 0 \n    cos(theta_ij) approx 1 \n    Q_i  B_iiV_i^2\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Thus, when the approximations are made, the Jacobian elements are simplified, resulting in the decoupled model where the Jacobian elements are:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i = -V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_j = -V_iV_jB_ij\n  V_i cfracmathrm partialf_Q_i(mathbf x) mathrm partial V_i = -V_i^2B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrmpartial V_j =  -V_iV_jB_ij\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Thus, the initial system of equations becomes:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = V_2^2B_22 Delta theta_2 + cdots + V_2V_nB_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_2V_nB_n2 Delta theta_2 + cdots + V_n^2B_nn Delta theta_n \n    f_Q_2(mathbf x) =  V_2^2B_22 cfracDelta V_2V_2 + cdots +\n     V_2V_mB_2m cfracDelta V_mV_m \n     vdots \n    f_Q_m(mathbf x) = V_2V_mB_m2 cfracDelta V_2V_2 + cdots +\n    V_m^2 B_mm cfracDelta V_mV_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Using V_j approx 1, wherein V_i^2 = V_iV_j j=i, the first part of the equations can be simplified to:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = V_2B_22 Delta theta_2 + cdots + V_2B_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_nB_n2 Delta theta_2 + cdots + V_nB_nn Delta theta_n\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, the second part of the equations can be simplified to:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_Q_2(mathbf x) =  V_2B_22 Delta V_2 + cdots +\n     V_2 B_2m Delta V_m\n    \n     vdots \n    f_Q_m(mathbf x) = V_mB_m2 Delta V_2 + cdots +\n    V_m B_mm Delta V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The fast Newton-Raphson method is ultimately based on the system of equations presented below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    cfracf_P_2(mathbf x)V_2 = B_22 Delta theta_2 + cdots + B_2n Delta theta_n \n     vdots \n    cfracf_P_n(mathbf x)V_n = B_n2 Delta theta_2 + cdots + B_nn Delta theta_n \n    cfracf_Q_2(mathbf x)V_2 =  B_22 Delta V_2 + cdots + B_2m Delta V_m \n     vdots \n    cfracf_Q_m(mathbf x)V_m = B_m2 Delta V_2 + cdots +\n    B_mm Delta V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This system can be rewritten as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathbfh_P(mathbf x) = mathbfB_1 mathbf Delta mathbf x_a \n    mathbfh_Q(mathbf x) = mathbfB_2 mathbf Delta mathbf x_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"One of the main advantages of this approach is that the Jacobian matrices mathbfB_1 and mathbfB_2 are constant and need only be formed once. Furthermore, this method can be used to define both the XB and BX versions of the fast Newton-Raphson method.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#XB-Version","page":"AC Power Flow","title":"XB Version","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The matrix mathbfB_1 is formed by neglecting the resistance r_ij, shunt susceptance Im  y_textshi , charging susceptance Im  y_textsij , and transformer tap ratio magnitudetau_ij. The matrix mathbfB_2 is constructed by disregarding the transformer phase shift angle phi_ij. This approach corresponds to the standard fast Newton-Raphson method and is known to exhibit exceptional convergence properties in typical scenarios [3].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To initialize the XB version of the fast Newton-Raphson method, one can utilize the following code snippet:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nmodel = fastNewtonRaphsonXB(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#BX-Version","page":"AC Power Flow","title":"BX Version","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The matrix mathbfB_1 ignores the shunt susceptanceIm  y_textshi , charging susceptance Im  y_textsij , and transformer tap ratio magnitude tau_ij. The matrix mathbfB_2 ignores the resistance r_ij and transformer phase shift angle phi_ij. In usual cases, the iteration count for the BX version is comparable to the XB scheme. However, for systems with high r_ijx_ij ratios, the BX scheme requires considerably fewer iterations than the XB scheme to solve the power flow [3].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To initialize the BX version of the fast Newton-Raphson method, you can use the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nmodel = fastNewtonRaphsonBX(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Initialization-2","page":"AC Power Flow","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"One of the versions of the algorithm mentioned earlier is used to initialize the fast Newton-Raphson method. This means that the algorithm computes the Jacobian matrices mathbfB_1 and mathbfB_2 that correspond to the active and reactive power equations, respectively. These matrices can be accessed using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐁₁ = model.active.jacobian\n𝐁₂ = model.reactive.jacobian","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, JuliaGrid utilizes the LU factorization of matrices mathbfB_1 and mathbfB_2 to compute solutions through iterations, which can be accessed using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"model.active.factorization\nmodel.reactive.factorization","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Additionally, during this stage, JuliaGrid generates the starting vectors for bus voltage magnitudes mathbfV^(0) and angles bmtheta^(0) as demonstrated below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕⁽⁰⁾ = model.voltage.magnitude\n𝛉⁽⁰⁾ = model.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Iterative-Process-2","page":"AC Power Flow","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid offers the mismatch! and solve! functions to implement the fast Newton-Raphson method iterations. These functions are used iteratively until a stopping criterion is met, as shown in the code snippet below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The functions mathbff_P(mathbf x) and mathbff_Q(mathbf x) remain free of approximations, with only the calculation of the state variable increments affected [2]. As a result, we still use the following equations to compute the mismatches:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalN_textpq cup mathcalN_textpv\n    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalN_textpq\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Therefore, the mismatch! function calculates the mismatch in active power injection for demand and generator buses and the mismatch in reactive power injection for demand buses at each iteration nu = 1 2 dots:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  h_P_i(mathbf x^(nu-1)) =\n  sumlimits_j=1^n V_j^(nu-1)(G_ijcostheta_ij^(nu-1)+B_ijsintheta_ij^(nu-1)) - cfracP_iV_i^(nu-1)\n    i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"and in reactive power injection for PQ buses as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    h_Q_i(mathbf x^(nu-1)) =\n    sumlimits_j=1^n V_j^(nu-1) (G_ijsintheta_ij^(nu-1)-B_ijcostheta_ij^(nu-1)) - cfracQ_iV_i^(nu-1)\n     i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The resulting vectors from these calculations are stored in the Model composite type and can be accessed through the following:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐡ₚ = model.active.increment\n𝐡ₒ = model.reactive.increment","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In addition to computing the mismatches in active and reactive power injection, the mismatch! function also returns the maximum absolute values of these mismatches. These maximum values are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion epsilon:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    max h_P_i(mathbf x^(nu)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max h_Q_i(mathbf x^(nu)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the function solve! computes the bus voltage angle increments:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf Delta mathbf x_a^(nu-1) = mathbfB_1^-1 mathbfh_P(mathbf x_a^(nu-1) mathbf x_m^(nu-1))","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vector of increments that corresponds to the active power equations can be accessed using the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚫𝐱ₐ = model.active.increment","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The solution is then updated as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf x_a^(nu) = mathbf x_a^(nu-1) + mathbf Delta mathbf x_a^(nu-1)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"It is important to note that only the voltage angles related to demand and generator buses are updated, while the vector of bus voltage angles of all buses is stored:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝛉 = model.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The fast Newton-Raphson method then solves the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"   mathbf Delta mathbf x_m^(nu-1) = mathbfB_2^-1 mathbfh_Q(mathbf x_a^(nu) mathbf x_m^(nu-1))","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vector of increments that corresponds to the reactive power equations can be accessed using the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚫𝐱ₘ = model.active.increment","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Finally, the solution is updated as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf x_m^(nu) = mathbf x_m^(nu-1) + mathbf Delta mathbf x_m^(nu-1)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Again, it is important to note that only the the voltage magnitudes of demand buses are updated, while the vector of bus voltage magnitude for all buses is stored:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕 = model.voltage.magnitude","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#gaussSeidel","page":"AC Power Flow","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"By defining the complex current injection at bus i in mathcalN as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"\tbarI_i = fracP_i - jQ_ibarV_i^*","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"the power flow problem can be represented as the system of equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This system of equations can be expanded to n complex equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    Y_11  barV_1  + cdots+ Y_1nbarV_n = fracP_1 - jQ_1barV_1^* \n     vdots  \n    Y_n1  barV_1 + cdots+ Y_nnbarV_n = fracP_n - jQ_nbarV_n^*\n\tendaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"While the Gauss-Seidel method directly solves the system of equations, it suffers from very slow convergence, which increases almost linearly with the system size, necessitating numerous iterations to obtain the desired solution [4]. Moreover, the convergence time of the Gauss-Seidel method increases significantly for large-scale systems and can face convergence issues for systems with high active power transfers. Nevertheless, power flow programs utilize both the Gauss-Seidel and Newton-Raphson methods in a complementary manner. Specifically, the Gauss-Seidel method is employed to obtain a quick approximate solution from a \"flat start\", while the Newton-Raphson method is utilized to obtain the final accurate solution [5].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Gauss-Seidel method is typically based on the system of equations with n complex equations, one of which represents the slack bus. As a analysis, one equation can be eliminated, resulting in a power flow problem with n-1 equations.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Initialization-3","page":"AC Power Flow","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid provides a way to utilize the Gauss-Seidel method for solving the AC power flow problem and determining the magnitudes and angles of bus voltages. To use this method, we need to execute the  acModel! function first to set up the system and then initialize the Gauss-Seidel method using the gaussSeidel function. The code snippet below demonstrates this process:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nmodel = gaussSeidel(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This results in the creation of the starting vectors of bus voltage magnitudes mathbfV^(0) and angles bmtheta^(0), as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕⁽⁰⁾ = model.voltage.magnitude\n𝛉⁽⁰⁾ = model.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Iterative-Process-3","page":"AC Power Flow","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid offers the mismatch! and solve! functions to implement the Gauss-Seidel method iterations. These functions are used iteratively until a stopping criterion is met, as shown in the code snippet below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:300\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In contrast to the Newton-Raphson and Fast Newton-Raphson methods, the Gauss-Seidel method does not require the calculation of the mismatch in active and reactive power injection at each iteration. Instead, the mismatch! function is used solely to verify the convergence criteria. At each iteration nu = 1 2 dots, we calculate the active power injection mismatch for demand and generator buses, as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    f_P_i(mathbf x^(nu-1)) = RebarV_i^(nu - 1) barI_i^*(nu - 1) - P_i  i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We also compute the reactive power injection mismatch for demand buses, given by:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_Q_i(mathbf x^(nu-1)) = ImbarV_i^(nu - 1) barI_i^*(nu - 1) - Q_i  i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"However, these mismatches are not stored as they are only used to obtain the maximum absolute values of these mismatches. The maximum values of these mismatches are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion epsilon, as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    max f_P_i(mathbf x^(nu-1)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max f_Q_i(mathbf x^(nu-1)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After initializing complex bus voltages barV_i^(0) for all buses in the power system, the function solve! proceeds to compute the voltages for demand buses using the Gauss-Seidel method:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    barV_i^(nu) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_ibarV_i^*(nu-1) -\n    sumlimits_substackj = 1^i - 1 Y_ijbarV_j^(nu) -\n    sumlimits_substackj = i + 1^n Y_ijbarV_j^(nu-1)Bigg)\n     i in mathcalN_textpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The next step is to determine the solution for generator buses in two stages: first, the reactive power injection is calculated, and then the bus complex voltage is updated using the following equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    Q_i^(nu) =\n    -Im left barV_i^*(nu) sumlimits_j=1^n Y_ijbarV_j^(nu)right  i in mathcalN_textpv \n    barV_i^(nu ) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_i^(nu)barV_i^*(nu )-\n    sumlimits_substackj = 1j neq i^n Y_ijbarV_j^(nu) Bigg)  i in mathcalN_textpv\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The obtained voltage magnitude may not be equal to the magnitude specified for the generator bus, so a voltage correction step is necessary:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"      barV_i^(nu) = V_i^(0) cfracbarV_i^(nu)V_i^(nu)  i in mathcalN_textpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid stores the final results in vectors that contain all bus voltage magnitudes and angles:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕 = model.voltage.magnitude\n𝛉 = model.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#BusPowersCurrentsTutorials","page":"AC Power Flow","title":"Bus Powers and Currents","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After the computation of voltage magnitudes and angles at each bus, various electrical quantities can be determined. JuliaGrid provides the analysisBus function to compute powers and currents linked to buses. Here is an example code snippet:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power, current = analysisBus(system, model)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This function stores the computed currents in the polar coordinate system, while the powers are stored in the rectangular coordinate system. It calculates the following quantities:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"current injections: mathbfI = I_i, bmpsi = psi_i\npower injections: mathbfP = P_i, mathbfQ = Q_i\npower injected by the generators:  mathbfP_texts = P_textsi, mathbfQ_texts = Q_textsi\npower associated with shunt elements: mathbfP_textsh = P_textshi, mathbfQ_textsh = Q_textshi.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-Injections","page":"AC Power Flow","title":"Current Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the complex current injection at the specific bus, we use the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    barI_i = I_i texte^textjpsi_i = sumlimits_j = 1^n Y_ij barV_j i in mathcalN","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In JuliaGrid, these complex current injections are stored in the vector of magnitudes denoted as mathbfI = I_i and the vector of angles represented as bmpsi = psi_i. You can retrieve them using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈 = current.injection.magnitude\n𝛙 = current.injection.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-Injections","page":"AC Power Flow","title":"Power Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The computation of active and reactive power injections at the bus is expressed by the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    S_i = P_i + textjQ_i = barV_ibarI_i^* i in mathcalN","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Active and reactive power injections are stored as the vectors mathbfP = P_i and mathbfQ = Q_i, respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏 = power.injection.active\n𝐐 = power.injection.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-Injected-by-the-Generators","page":"AC Power Flow","title":"Power Injected by the Generators","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The analysisBus function in JuliaGrid also computes the active and reactive powers that generators inject to the buses. The active power supplied by the generators to the buses can be calculated by summing the given generator active powers in the input data, except for the slack bus, which can be determined as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    P_textsi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where P_textdi represents the active power demanded by consumers at the slack bus. The vector of active power injected by generators to the buses, denoted by mathbfP_texts = P_textsi, can be obtained using the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₛ = power.supply.active","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, the reactive power injected by the generators to the buses can be obtained using the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    Q_textsi = Q_i + Q_textdi i in mathcalN_textpv cup mathcalN_textsb","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where Q_textdi represents the reactive power demanded by consumers at the corresponding bus. Further, the reactive power injected by the generators at buses from mathcalN_textpq can be calculated by summing the given generator reactive powers in the input data. The vector of these reactive power injections by the generators to the buses, denoted by mathbfQ_texts = Q_textsi, can be retrieved using the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐐ₛ = power.supply.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-Associated-with-Shunt-Elements","page":"AC Power Flow","title":"Power Associated with Shunt Elements","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the active and reactive powers associated with the shunt element at each bus, you can use the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  S_textshi = P_textshi + textjQ_textshi = barV_ibarI_textshi^* = y_textshi^*barV_i^2 i in mathcalN","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active power demanded by the shunt element at each bus is represented by the vector mathbfP_textsh = P_textshi, while the reactive power injected or demanded by the shunt element at each bus is represented by the vector mathbfQ_textsh = Q_textshi. To retrieve these powers in JuliaGrid, use the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₛₕ = power.shunt.active\n𝐐ₛₕ = power.shunt.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#BranchPowersCurrentsTutorials","page":"AC Power Flow","title":"Branch Powers and Currents","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid provides the analysisBranch function to compute powers and currents linked to branches. Here is an example code snippet:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power, current = analysisBranch(system, model)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The function stores the currents in the polar coordinate system and the powers in the rectangular coordinate system. It calculates the following quantities:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"current flow at from bus ends: mathbfI_texti = I_ij, bmpsi_texti = psi_ij\ncurrent flow at to bus ends: mathbfI_textj = I_ji, bmpsi_textj = psi_ji\ncurrent flow through series impedances: mathbfI_texts = I_textsij, bmpsi_texts = psi_textsij\npower flow at from bus ends: mathbfP_texti = P_ij, mathbfQ_texti = Q_ij\npower flow at to bus ends: mathbfP_textj = P_ji, mathbfQ_textj = Q_ji\npower losses: mathbfP_textl = P_textlij, mathbfQ_textl = Q_textlij\nreactive power injections: mathbfQ_textr =  Q_textrij.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-Flow-at-From-Bus-Ends","page":"AC Power Flow","title":"Current Flow at From Bus Ends","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the complex current flow at from bus end i in mathcalN, the unified branch model can be utilized:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    barI_ij = I_ij texte^textjpsi_ij = cfrac1tau_ij^2(y_ij + y_textsij) barV_i - alpha_ij^*y_ij barV_j (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the vectors of magnitudes mathbfI_texti = I_ij and angles bmpsi_texti = psi_ij for the resulting complex current flows at the from bus end, you can use the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈ᵢ = current.from.magnitude\n𝛙ᵢ = current.from.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-Flow-at-To-Bus-Ends","page":"AC Power Flow","title":"Current Flow at To Bus Ends","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, we can obtain the complex current flow at the to bus end j in mathcalN using the unified branch model, given by:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    barI_ji = I_ji texte^textjpsi_ji = -alpha_ijy_ij barV_i + (y_ij + y_textsij) barV_j (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can obtain the vectors of magnitudes mathbfI_textj = I_ji and angles bmpsi_textj = psi_ji of the resulting complex current flows at the to bus end using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈ⱼ = current.to.magnitude\n𝛙ⱼ = current.to.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-Flow-Through-Series-Impedances","page":"AC Power Flow","title":"Current Flow Through Series Impedances","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the complex current flow through the series impedance of a branch in the direction from bus i in mathcalN to bus j in mathcalN, one can use the expression:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    barI_textsij = I_textsij texte^psi_textsij =  y_ij (alpha_ijbarV_i - barV_j)  (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the vectors of magnitudes mathbfI_texts = I_textsij and angles bmpsi_texts = psi_textsij of the resulting complex current flow through the series impedance, one can use the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈ₛ = current.impedance.magnitude\n𝛙ₛ = current.impedance.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-Flow-at-From-Bus-Ends","page":"AC Power Flow","title":"Power Flow at From Bus Ends","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active and reactive power flows at from bus end i in mathcalN can be obtained using the following equations based on the unified branch model:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    S_ij = P_ij + textjQ_ij = barV_ibarI_ij^* (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The resulting active and reactive power flows at from bus end are stored as the vectors mathbfP_texti = P_ij and mathbfQ_texti = Q_ij, respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ᵢ = power.from.active\n𝐐ᵢ = power.from.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-Flow-at-To-Bus-Ends","page":"AC Power Flow","title":"Power Flow at To Bus Ends","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, we can determine the active and reactive power flows at the to bus end j in mathcalN using the equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    S_ji = P_ji + textjQ_ji = barV_jbarI_ji^* (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vectors of active and reactive power flows at the to bus end are stored as mathbfP_textj = P_ji and mathbfQ_textj = Q_ji, respectively, and can be retrieved using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ⱼ = power.to.active\n𝐐ⱼ = power.to.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-Losses","page":"AC Power Flow","title":"Power Losses","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active and reactive power losses in the branch are caused by its series impedance z_ij. These losses can be obtained using the following equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    beginaligned\n        P_textlij = r_ijbarI_textbij^2 \n        Q_textlij = x_ijbarI_textbij^2\n    endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where (ij) in mathcalE. We can retrieve the vectors of active and reactive power losses, mathbfP_textl = P_textlij and mathbfQ_textl = Q_textlij, respectively, using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₗ = power.loss.active\n𝐐ₗ = power.loss.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Reactive-Power-Injections","page":"AC Power Flow","title":"Reactive Power Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The branch's capacitive susceptances cause reactive power injection. We can calculate the total reactive power injected by the branch using the following equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    Q_textrij = b_textsij (alpha_ijbarV_i^2 - barV_j^2) (ij) in mathcalE","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To retrieve the vector of injected reactive powers mathbfQ_textr = Q_textrij, use the following Julia command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐐ᵣ = power.shunt.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#GeneratorPowersTutorials","page":"AC Power Flow","title":"Generator Powers","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The analysisGenerator function provided by JuliaGrid can be used to compute powers associated with generators. Here is an example code snippet:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power = analysisGenerator(system, model)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The powers are stored in the rectangular coordinate system, and only the output power of the generators is calculated. The output powers are stored in vectors as mathbfP_textg = P_textgi and mathbfQ_textg = Q_textgi.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the output active power of generators connected to bus i in mathcalN_textpq cup mathcalN_textpv, the given active power in the input data is utilized. For the generator connected to the slack bus, the output active power is determined using the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    P_textgi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In the case of multiple generators connected to the slack bus, the first generator in the input data is assigned the obtained value of P_textgi. Then, this amount of power is reduced by the output active power of the other generators. Therefore, to get the vector of output active power of generators, i.e., mathbfP_textg = P_textgi, you can use the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₒ = power.active","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The output reactive power of the generator located at the bus is obtained as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"    Q_textgi = Q_i + Q_textdi i in mathcalN","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"If there are multiple generators at the same bus, the reactive power is allocated proportionally among the generators based on their reactive power capabilities. To obtain the vector of output reactive power of generatorsmathbfQ_textg = Q_textgi, the following command can be used:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐐ₒ = power.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#PowerFlowSolutionReferenceTutorials","page":"AC Power Flow","title":"References","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[1] A. Wood and B. Wollenberg, Power Generation, Operation, and Control, ser. A Wiley-Interscience publication. Wiley, 1996.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[2] G. Andersson, Modelling and analysis of electric power systems, EEH-Power Systems Laboratory, Swiss Federal Institute of Technology (ETH), Zürich, Switzerland (2008).","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[3] R. A. M. van Amerongen, \"A general-purpose version of the fast decoupled load flow,\" IEEE Trans. Power Syst., vol. 4, no. 2, pp. 760-770, May 1989.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[4] D. P. Chassin, P. R. Armstrong, D. G. Chavarria-Miranda, and R. T. Guttromson, \"Gauss-seidel accelerated: implementing flow solvers on field programmable gate arrays,\" in Proc. IEEE PES General Meeting, 2006, pp. 5.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[5] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER User’s Manual, Version 7.0. 2019.","category":"page"},{"location":"manual/powerFlow/#PowerFlowManual","page":"Power Flow","title":"Power Flow","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"In order to conduct an AC or DC power flow, you will need the PowerSystem composite type that has been created with either the acModel or dcModel. Following this, you will need to create the Model composite type to establish the AC or DC power flow framework.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"To create the Model composite type and set up a framework for solving AC or DC power flow, utilize one of the functions listed below:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel\ndcPowerFlow.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"To solve the power flow problem and obtain bus voltages, the following functions can be employed:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"mismatch!\nsolve!.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"JuliaGrid offers a set of postprocessing analysis functions for calculating powers, losses, and currents associated with buses, branches, or generators after obtaining AC or DC power flow solutions:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"analysisBus\nanalysisBranch\nanalysisGenerator.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Finally, the package provides two additional functions. One function validates the reactive power limits of generators once the AC power flow solution has been computed. The other function adjusts the voltage angles to match the angle of an arbitrary bus:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"reactiveLimit!\nadjustAngle!.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#BusTypeModificationManual","page":"Power Flow","title":"Bus Type Modification","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Depending on how the system is constructed, the types of buses that are initially set are checked and can be changed during the initialization process, using one of the available functions such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel. Assuming the Newton-Raphson method has been chosen, to explain the details, we can observe a power system with only buses and generators. The following code snippet can be used:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 2)\naddBus!(system; label = 3, type = 2)\n\naddGenerator!(system; label = 1, bus = 2)\n\nacModel!(system)\n\nmodel = newtonRaphson(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Initially, the bus labelled with 1 is set as the slack bus (type = 3), and the buses with labels 2 and 3 are generator buses (type = 2). However, the bus labelled with 3 does not have a generator, and JuliaGrid considers this a mistake and changes the corresponding bus to a demand bus (type = 1):","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"system.bus.layout.type","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"In contrast, if a bus is initially defined as the demand bus (type = 1) and later a generator is added to it, the bus type will not be changed to the generator bus (type = 2). Instead, it will remain as a demand bus:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1)\naddBus!(system; label = 3, type = 2)\n\naddGenerator!(system; label = 1, bus = 2)\n\nacModel!(system)\n\nmodel = newtonRaphson(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"In this example, the bus labelled with 2 remains the demand bus (type = 1) even though it has the generator:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"system.bus.layout.type","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"note: Info\nThe type of only those buses that are defined as generator buses (type = 2) but do not have a connected in-service generator will be changed to demand buses (type = 1).","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#SetupStartingVoltagesManual","page":"Power Flow","title":"Setup Starting Voltages","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"To begin analysing the AC power flow in JuliaGrid, we must first establish the PowerSystem composite type and define the AC model by calling the acModel! function. Once the power system is set up, we can select one of the available methods for solving the AC power flow problem, such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel. Assuming we have selected the Newton-Raphson method, we can use the following code snippet:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, magnitude = 1.0, angle = 0.0)\naddBus!(system; label = 2, type = 1, magnitude = 0.9, angle = -0.1)\naddBus!(system; label = 3, type = 2, magnitude = 0.8, angle = -0.2)\n\naddGenerator!(system; label = 1, bus = 2, magnitude = 1.1)\naddGenerator!(system; label = 2, bus = 3, magnitude = 1.2)\n\nacModel!(system)\n\nmodel = newtonRaphson(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Here, in this code snippet, the function newtonRaphson generates starting voltage vectors in polar coordinates, where the magnitudes and angles are constructed as:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model.voltage.magnitude\nmodel.voltage.angle","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The starting values for the voltage angles are defined based on the initial values given within the buses:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"system.bus.voltage.angle","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"On the other hand, the starting voltage magnitudes are determined by a combination of the initial values specified within the buses and the setpoints provided within the generators:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"system.bus.voltage.magnitude\nsystem.generator.voltage.magnitude","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"note: Info\nThe rule governing the specification of starting voltage magnitudes is simple. If a bus has an in-service generator and is declared the generator bus (type = 2), then the starting voltage magnitudes are specified using the setpoint provided within the generator. This is because the generator bus has known values of voltage magnitude that are specified within the generator.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Finally, we can add a generator to the slack bus of the previously created power system and then reinitialize the Newton-Raphson method:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"addGenerator!(system; label = 3, bus = 1, magnitude = 1.3)\n\nmodel = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The starting voltages are now as follows:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model.voltage.magnitude","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"note: Info\nThus, if an in-service generator exists on the slack bus, the starting value of the voltage magnitude is specified using the setpoints provided within the generators. This is a consequence of the fact that the slack bus has a known voltage magnitude. If a generator exists on the slack bus, its value is used, otherwise, the value is defined based on the initial voltage magnitude specified within the bus.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#Custom-Starting-Voltages","page":"Power Flow","title":"Custom Starting Voltages","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"This method of specifying starting values has a significant advantage in that it allows the user to easily change the starting voltage magnitudes and angles, which play a crucial role in iterative methods. For instance, suppose we define our power system as follows:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, magnitude = 1.0, angle = 0.0)\naddBus!(system; label = 2, type = 1, magnitude = 0.9, angle = -0.1)\naddBus!(system; label = 3, type = 2, magnitude = 0.8, angle = -0.2)\n\naddGenerator!(system; label = 2, bus = 3, magnitude = 1.2)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Now, the user can initiate a \"flat start\" without interfering with the input data. This can be easily done as follows:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"for i = 1:system.bus.number\n    system.bus.voltage.magnitude[i] = 1.0\n    system.bus.voltage.angle[i] = 0.0\nend\n\nmodel = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The starting voltage values are:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model.voltage.magnitude\nmodel.voltage.angle","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Thus, we start with the set of voltage magnitude values that are constant throughout iteration, and the rest of the values correspond to the \"flat start\".","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#ACPowerFlowSolutionManual","page":"Power Flow","title":"AC Power Flow Solution","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"To solve the AC power flow problem using JuliaGrid, we first need to create the PowerSystem composite type and define the AC model by calling the acModel! function. Here is an example:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)\naddBus!(system; label = 2, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)\naddBus!(system; label = 3, type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)\naddBranch!(system; label = 2, from = 1, to = 3, resistance = 0.02, reactance = 0.01)\naddBranch!(system; label = 3, from = 2, to = 3, resistance = 0.01, reactance = 0.20)\n\naddGenerator!(system; label = 1, bus = 2, active = 3.2, magnitude = 1.2)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Once the AC model is defined, we can choose the method to solve the power flow problem. JuliaGrid provides four methods: newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, and gaussSeidel. For example, to use the Newton-Raphson method to solve the power flow problem, we can call the newtonRaphson function as follows:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"This function sets up the desired method for an iterative process based on two functions: mismatch! and solve!. The mismatch! function calculates the active and reactive power injection mismatches using the given voltage magnitudes and angles, while solve! computes the new voltage magnitudes and angles.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"To perform an iterative process with the Newton-Raphson or Fast Newton-Raphson methods in JuliaGrid, the mismatch! function must be included inside the iteration loop. For instance:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"for iteration = 1:100\n    mismatch!(system, model)\n    solve!(system, model)\nend\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"After the process is completed, the solution to the AC power flow problem can be accessed as follows:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model.voltage.magnitude\nmodel.voltage.angle","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"In contrast, the iterative loop of the Gauss-Seidel method does not require the mismatch! function:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model = gaussSeidel(system)\nfor iteration = 1:100\n    solve!(system, model)\nend\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"In these examples, the algorithms run until the specified number of iterations is reached.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"note: Info\nWe recommend that the reader refer to the tutorial on AC power flow analysis, where we explain the implementation of the methods and algorithm structures in detail.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#Breaking-the-Iterative-Process","page":"Power Flow","title":"Breaking the Iterative Process","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"You can terminate the iterative process using the mismatch! function, which is why mismatches are computed separately. The following code shows an example of how to use the mismatch! function to break out of the iteration loop:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The mismatch! function returns the maximum absolute values of active and reactive power injection mismatches, which are commonly used as a convergence criterion in iterative AC power flow algorithms. Note that the mismatch! function can also be used to terminate the loop when using the Gauss-Seidel method, even though it is not required.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"tip: Tip\nTo ensure an accurate count of iterations, it is important for the user to place the iteration counter after the condition expressions within the if construct. Counting the iterations before this point can result in an incorrect number of iterations, as it leads to an additional iteration being performed.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#ReusableTypesACPowerFlowModel","page":"Power Flow","title":"Reusable Types for AC Power Flow","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The PowerSystem composite type with its acModel field can be used without limitations, and can be modified automatically using functions like shuntBus!, statusBranch!, parameterBranch!, statusGenerator!, and outputGenerator! functions. This allows the PowerSystem type to be shared across different analyses.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Additionally, the Model composite type can also be reused within the same method that solves the AC power flow problem.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Let us create the power system with its existing model once again:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)\naddBus!(system; label = 2, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)\naddBus!(system; label = 3, type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)\naddBranch!(system; label = 2, from = 1, to = 3, resistance = 0.02, reactance = 0.01)\naddBranch!(system; label = 3, from = 2, to = 3, resistance = 0.01, reactance = 0.20)\n\naddGenerator!(system; label = 1, bus = 2, active = 3.2, magnitude = 1.2)\n\nacModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#Reusable-PowerSystem-Type","page":"Power Flow","title":"Reusable PowerSystem Type","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The initial application of the reusable PowerSystem type is simple: it can be shared among various methods, which can yield benefits. For example, the Gauss-Seidel method is commonly used for a speedy approximate solution, whereas the Newton-Raphson method is typically utilized for the precise final solution. Thus, we can execute the Gauss-Seidel method for a limited number of iterations, as exemplified below:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"gsModel = gaussSeidel(system)\nfor iteration = 1:3\n    solve!(system, gsModel)\nend","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Next, we can initialize the Newton-Raphson method with the voltages obtained from the Gauss-Seidel method and start the algorithm from that point:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"nrModel = newtonRaphson(system)\n\nfor i = 1:system.bus.number\n    nrModel.voltage.magnitude[i] = gsModel.voltage.magnitude[i]\n    nrModel.voltage.angle[i] = gsModel.voltage.angle[i]\nend\n\nfor iteration = 1:100\n    stopping = mismatch!(system, nrModel)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, nrModel)\nend","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Another way to utilize the reusable PowerSystem type is to make modifications to the power system parameters using built-in functions. For instance, we can alter the resistance of the branch labelled as 3, while still using the PowerSystem that was created earlier:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"parameterBranch!(system; label = 1, resistance = 0.06)\n\nmodel = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"note: Info\nThe functions newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel only modify the PowerSystem type to eliminate mistakes in the bus types as explained in the section Bus Type Modification. Further, the functions mismatch! and solve! do not modify the PowerSystem type at all. Therefore, it is safe to use the same PowerSystem type for multiple analyses once it has been created.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#Reusable-Model-Type","page":"Power Flow","title":"Reusable Model Type","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"As we have seen, the PowerSystem type can be reused and modified using various functions, and the question now is whether we can do the same with the Model composite type. In fact, in the previous code snippet, we did not need to recreate the Model type after changing the resistance of the branch labelled 3. Thus, once the Model type is created, users can modify the power system's structure using functions shuntBus!, statusBranch!, parameterBranch!, and outputGenerator!, without having to recreate the Model type from scratch.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"For instance, if the branch labelled 3 needs to be put out-of-service in the previously mentioned example, the AC power flow can be executed again by running the following code snippet:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"statusBranch!(system; label = 3, status = 0)\n\nfor iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Here, the previously created PowerSystem and Model types are reused. This approach ensures that the algorithm has the \"warm start\" since the Newton-Raphson method starts with voltages obtained from the step where the branch was in-service.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"warning: Warning\nIt is important to note that this approach is only possible with the Newton-Raphson and Gauss-Seidel methods since these methods involve the power system structure inside the iteration loop. On the other hand, the fast Newton-Raphson algorithm has constant Jacobian matrices created when the Model type is created, which means that any modifications to the power system require creating the Model type again.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#DCPowerFlowSolutionManual","page":"Power Flow","title":"DC Power Flow Solution","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"To solve the DC power flow problem using JuliaGrid, we start by creating the PowerSystem composite type and defining the DC model with the dcModel! function. Here is an example:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 0.1)\naddBus!(system; label = 3, type = 1, active = 0.05)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05)\naddBranch!(system; label = 2, from = 1, to = 3, reactance = 0.01)\naddBranch!(system; label = 3, from = 2, to = 3, reactance = 0.01)\n\naddGenerator!(system; label = 1, bus = 2, active = 3.2)\n\ndcModel!(system)\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The dcPowerFlow function can be used to establish the DC power flow problem. It factorizes the nodal matrix to prepare for determining the bus voltage angles:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model = dcPowerFlow(system)\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"To obtain the bus voltage angles, we can call the solve! function as follows:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"solve!(system, model)\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Once the solution is obtained, the bus voltage angles can be accessed using:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model.voltage.angle\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"note: Info\nWe recommend that readers refer to the tutorial on DC power flow for insights into the implementation.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#ReusableTypesDCPowerFlowModel","page":"Power Flow","title":"Reusable Types for DC Power Flow","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The PowerSystem composite type with its dcModel field can be utilized without restrictions and can be modified automatically using functions such as shuntBus!, statusBranch!, parameterBranch!, statusGenerator!, and outputGenerator!. This facilitates sharing the PowerSystem type across various DC power flow analyses.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Furthermore, the Model composite type can be reused within the same method used to solve the DC power flow problem.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#Reusable-PowerSystem-Type-2","page":"Power Flow","title":"Reusable PowerSystem Type","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Once you have created the power system and DC model, you can reuse them for multiple DC power flow analyses. Specifically, you can modify the structure of the power system using the statusBranch! and parameterBranch! functions without having to recreate the system from scratch. As an example, let us say we wish to take the branch labelled 3 out-of-service from the previous example and conduct the DC power flow again:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"statusBranch!(system; label = 3, status = 0)\n\nmodel = dcPowerFlow(system)\nsolve!(system, model)\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#Reusable-Model-Type-2","page":"Power Flow","title":"Reusable Model Type","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The Model composite type contains a factorized nodal matrix, which means that users can reuse it when only modifying shunt or generator parameters and keeping the power system's branch parameters the same. This allows for more efficient computations as the factorization step is not repeated.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Therefore, by using only the functions shuntBus!, statusGenerator! and outputGenerator!, the Model composite type can be reused. For example, to change the output of the generator and compute the bus voltage angles again, one can use the following code:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"outputGenerator!(system; label = 1, active = 0.5)\n\nsolve!(system, model)\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Here, the previously factorized nodal matrix is utilized to obtain the new solution, which is more efficient than repeating the factorization step.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#PowerCurrentAnalysisManual","page":"Power Flow","title":"Power and Current Analysis","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"After obtaining the solution from the AC or DC power flow, we can calculate various electrical quantities related to buses, branches, and generators using the analysisBus, analysisBranch, and analysisGenerator functions. For instance, let us consider the power system for which we obtained the AC power flow solution:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.5)\naddBus!(system; label = 2, type = 1, reactive = 0.05)\naddBus!(system; label = 3, type = 1, active = 0.5)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)\naddBranch!(system; label = 2, from = 1, to = 2, resistance = 0.02, reactance = 0.01)\naddBranch!(system; label = 3, from = 2, to = 3, resistance = 0.03, reactance = 0.04)\n\naddGenerator!(system; label = 1, bus = 2, active = 3.2)\n\nacModel!(system)\n\nmodel = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Next, we can use the above-mentioned functions to compute the relevant data for buses, branches, and generators. Here is an example code snippet that demonstrates this process:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"busPower, busCurrent = analysisBus(system, model)\nbranchPower, branchCurrent = analysisBranch(system, model)\ngeneratorPower = analysisGenerator(system, model)\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"For instance, we can now observe the active and reactive power injections in megawatts (MW) and megavolt-ampere reactive (MVAr) using the code snippet below:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"@base(system, MVA, V);\nsystem.base.power.value * busPower.injection.active\nsystem.base.power.value * busPower.injection.reactive","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"note: Info\nWe recommend that readers refer to the tutorials on AC power flow and DC power flow for a detailed explanation of all the electrical quantities related to buses, branches, and generators that are computed by the functions analysisBus, analysisBranch, and analysisGenerator in the context of power flow analysis.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#GeneratorReactivePowerLimitsManual","page":"Power Flow","title":"Generator Reactive Power Limits","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The function reactiveLimit! can be used by the user to check if the generators' output of reactive power is within the defined limits after obtaining the solution from the AC power flow analysis. This can be done by using the example code provided:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.5, reactive = 0.05)\naddBus!(system; label = 2, type = 1, active = 0.5)\naddBus!(system; label = 3, type = 2)\naddBus!(system; label = 4, type = 2)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)\naddBranch!(system; label = 2, from = 1, to = 3, resistance = 0.02, reactance = 0.01)\naddBranch!(system; label = 3, from = 2, to = 3, resistance = 0.03, reactance = 0.04)\naddBranch!(system; label = 4, from = 2, to = 4, resistance = 0.03, reactance = 0.004)\n\n@generator(minReactive = 0.0, maxReactive = 0.2)\naddGenerator!(system; label = 1, bus = 3, active = 0.8, reactive = 0.1)\naddGenerator!(system; label = 2, bus = 4, reactive = 0.3)\n\nacModel!(system)\n\nmodel = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\npower = analysisGenerator(system, model)\nviolate = reactiveLimit!(system, model, power)\n\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The output reactive power of the observed generators is subject to limits which are defined as follows:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"[system.generator.capability.minReactive system.generator.capability.maxReactive]","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Once the solution of the AC power flow analysis is obtained, the analysisGenerator function can be called to compute the reactive power output of generators:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"power.reactive","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"The variable violate indicates the violation of limits, where the first generator violates the minimum limit and the second generator violates the maximum limit, as shown below:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"violate","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"As a result of these limit violations, the PowerSystem type is changed, and the output reactive powers at the violated limits are set as follows:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"system.generator.output.reactive","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"To ensure that these values stay within the limits, the bus type must be changed from the generator bus (type = 2) to the demand bus (type = 1), as shown below:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"system.bus.layout.type","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"After modifying the PowerSystem type as described earlier, we can run the simulation again with the following code:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\npower = analysisGenerator(system, model)\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Once the simulation is complete, we can verify that all generator reactive power outputs now satisfy the limits by checking the violate variable again:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"violate = reactiveLimit!(system, model, power)","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"note: Info\nThe reactiveLimit! function changes the PowerSystem composite type deliberately because it is intended to help users create the power system where all reactive power outputs of the generators are within limits.","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"manual/powerFlow/#New-Slack-Bus","page":"Power Flow","title":"New Slack Bus","text":"","category":"section"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Looking at the following code example, we can see that the output limits of the generator are set only for the first generator that is connected to the slack bus:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.5, reactive = 0.05)\naddBus!(system; label = 2, type = 1, active = 0.5)\naddBus!(system; label = 3, type = 2)\naddBus!(system; label = 4, type = 2)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)\naddBranch!(system; label = 2, from = 1, to = 3, resistance = 0.02, reactance = 0.01)\naddBranch!(system; label = 3, from = 2, to = 3, resistance = 0.03, reactance = 0.04)\naddBranch!(system; label = 4, from = 2, to = 4, resistance = 0.03, reactance = 0.004)\n\naddGenerator!(system; label = 1, bus = 1, minReactive = 0.0, maxReactive = 0.2)\naddGenerator!(system; label = 2, bus = 4, reactive = 0.3)\n\nacModel!(system)\n\nmodel = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\npower = analysisGenerator(system, model)\nnothing # hide","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Upon checking the limits, we can observe that the slack bus has been transformed by executing the following code:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"violate = reactiveLimit!(system, model, power)","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Here, the generator connected to the slack bus is violating the minimum reactive power limit, which indicates the need to convert the slack bus. It is important to note that the new slack bus can be created only from the generator bus (type = 2). We will now perform another AC power flow analysis on the modified system using the following code:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"After examining the bus voltages, we will focus on the angles:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model.voltage.angle","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"We can observe that the angles have been calculated based on the new slack bus. JuliaGrid offers the function to adjust these angles to match the original slack bus as follows:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"adjustAngle!(system, model; slack = 1)","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"Here, the slack keyword should correspond to the label of the slack bus. After executing the above code, the updated results can be viewed:","category":"page"},{"location":"manual/powerFlow/","page":"Power Flow","title":"Power Flow","text":"model.voltage.angle","category":"page"},{"location":"api/powerFlowSolution/#powerFlowSolutionAPI","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"section"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"For further information on this topic, please see the Power System Analysis section of the Manual.","category":"page"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"api/powerFlowSolution/#API-Index","page":"Power Flow Solution","title":"API Index","text":"","category":"section"},{"location":"api/powerFlowSolution/#Build-Model","page":"Power Flow Solution","title":"Build Model","text":"","category":"section"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel\ndcPowerFlow","category":"page"},{"location":"api/powerFlowSolution/#Solve-Power-Flow","page":"Power Flow Solution","title":"Solve Power Flow","text":"","category":"section"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"mismatch!\nsolve!","category":"page"},{"location":"api/powerFlowSolution/#Additional-Functions","page":"Power Flow Solution","title":"Additional Functions","text":"","category":"section"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"reactiveLimit!\nadjustAngle!","category":"page"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"api/powerFlowSolution/#Build-Model-2","page":"Power Flow Solution","title":"Build Model","text":"","category":"section"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson(::PowerSystem)\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel\ndcPowerFlow","category":"page"},{"location":"api/powerFlowSolution/#JuliaGrid.newtonRaphson-Tuple{PowerSystem}","page":"Power Flow Solution","title":"JuliaGrid.newtonRaphson","text":"newtonRaphson(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Newton-Raphson method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the acModel field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the NewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the magnitudes and angles of bus voltages\njacobian: the Jacobian matrix\nmismatch: the active and reactive power injection mismatches\nincrement: the magnitudes and angles of bus voltage increments\npq: indices of demand buses\npvpq: indices of demand and generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = newtonRaphson(system)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphsonBX","text":"fastNewtonRaphsonBX(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Fast Newton-Raphson method of version BX to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the acModel field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the magnitudes and angles of bus voltages\nactive:\njacobian: the Jacobian matrix associated with active power equations\nmismatch: the active power injection mismatches\nincrement: the angles of bus voltage increments\nfactorization: the factorized Jacobian matrix\nreactive:\njacobian: the Jacobian matrix associated with reactive power equations\nmismatch: the reative power injection mismatches\nincrement: the magnitudes of bus voltage increments\nfactorization: the factorized Jacobian matrix\npq: indices of demand buses\npvpq: indices of demand and generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = fastNewtonRaphsonBX(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphsonXB","text":"fastNewtonRaphsonXB(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Fast Newton-Raphson method of version XB to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the acModel field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the magnitudes and angles of bus voltages\nactive:\njacobian: the Jacobian matrix associated with active power equations\nmismatch: the active power injection mismatches\nincrement: the angles of bus voltage increments\nfactorization: the factorized Jacobian matrix\nreactive:\njacobian: the Jacobian matrix associated with reactive power equations\nmismatch: the reative power injection mismatches\nincrement: the magnitudes of bus voltage increments\nfactorization: the factorized Jacobian matrix\npq: indices of demand buses\npvpq: indices of demand and generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = fastNewtonRaphsonXB(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlowSolution/#JuliaGrid.gaussSeidel","page":"Power Flow Solution","title":"JuliaGrid.gaussSeidel","text":"gaussSeidel(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Gauss-Seidel method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the acModel field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the GaussSeidel subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the magnitudes and angles of bus voltages\ncomplex: the complex voltages\nmagnitude: the bus voltage magnitudes for corrections\npq: indices of demand buses\npv: indices of generator buses.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = gaussSeidel(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlowSolution/#JuliaGrid.dcPowerFlow","page":"Power Flow Solution","title":"JuliaGrid.dcPowerFlow","text":"dcPowerFlow(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input, which is utilized to establish the structure for solving the DC power flow. Additionally, if the DC model was not created, the function will automatically initiate an update of the dcModel field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the DCPowerFlow type, which includes the following filled fields:\n\nvoltage: the angles of bus voltages\nfactorization: the factorized nodal matrix.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nmodel = dcPowerFlow(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"api/powerFlowSolution/#Solve-Power-Flow-2","page":"Power Flow Solution","title":"Solve Power Flow","text":"","category":"section"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"mismatch!\nsolve!","category":"page"},{"location":"api/powerFlowSolution/#JuliaGrid.mismatch!","page":"Power Flow Solution","title":"JuliaGrid.mismatch!","text":"mismatch!(system::PowerSystem, model::Method) where Method <: ACPowerFlow\n\nThe function calculates both active and reactive power injection mismatches and returns their maximum absolute values, which can be utilized to terminate the iteration loop of methods employed to solve the AC power flow problem.\n\nThis function updates the mismatch variables in the Newton-Raphson and fast Newton-Raphson methods. It should be employed during the iteration loop before invoking the solve! function.\n\nIn contrast, the Gauss-Seidel method does not need mismatches to obtain bus voltages, but the maximum absolute values are commonly employed to stop the iteration loop. The function does not save any data and should be utilized during the iteration loop before invoking the solve! function.\n\nSubtypes\n\nThe ACPowerFlow abstract type can take the following subtypes:\n\nNewtonRaphson: computes the power mismatches within the Newton-Raphson method\nFastNewtonRaphson: computes the power mismatches within the fast Newton-Raphson method\nGaussSeidel: computes the power mismatches within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = newtonRaphson(system)\nmismatch!(system, model)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlowSolution/#JuliaGrid.solve!","page":"Power Flow Solution","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, model::Method) where Method <: ACPowerFlow\n\nThe function employs the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel method to solve the AC power flow problem and calculate the magnitudes and angles of bus voltages.\n\nAfter the mismatch! function is called, solve! should be executed to perform a single iteration of the method. The calculated voltages are stored in the voltage field of the respective struct type.\n\nSubtypes\n\nThe ACPowerFlow abstract type can take the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\n\n\n\n\nsolve!(system::PowerSystem, model::DCPowerFlow)\n\nBy computing the voltage angles for each bus, the function solves the DC power flow problem. The resulting voltage angles are stored in the voltage field of the DCPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nmodel = dcPowerFlow(system)\nsolve!(system, model)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"api/powerFlowSolution/#Additional-Functions-2","page":"Power Flow Solution","title":"Additional Functions","text":"","category":"section"},{"location":"api/powerFlowSolution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"reactiveLimit!\nadjustAngle!","category":"page"},{"location":"api/powerFlowSolution/#JuliaGrid.reactiveLimit!","page":"Power Flow Solution","title":"JuliaGrid.reactiveLimit!","text":"reactiveLimit!(system::PowerSystem, model::ACPowerFlow, power::PowerGenerator)\n\nThe function verifies whether the generators in a power system exceed their reactive power limits. This is done by setting the reactive power of the generators to within the limits if they are violated, after determining the bus voltage magnitudes and angles. If the limits are violated, the corresponding generator buses or the slack bus are converted to demand buses.\n\nArguments\n\nInitially, the analysisGenerator function must be executed. Afterward, the function uses the results from this function to assign values to the generator.output.active and bus.supply.active fields of the PowerSystem type.\n\nAt the end of the process, the function inspects the reactive powers of the generator and adjusts them to their maximum or minimum values if they violate the threshold. The generator.output.reactive field of the PowerSystem type is then modified accordingly. In light of this modification, the bus.supply.reactive field of the PowerSystem type is also updated, and the bus types in bus.layout.type are adjusted. If the slack bus is converted, the bus.layout.slack field is modified accordingly.\n\nReturns\n\nThe function returns the violate variable to indicate which buses violate the limits, with -1 indicating a violation of the minimum limits and 1 indicating a violation of the maximum limits.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\npower = analysisGenerator(system, model)\n\nviolate = reactiveLimit!(system, model, power)\n\nmodel = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlowSolution/#JuliaGrid.adjustAngle!","page":"Power Flow Solution","title":"JuliaGrid.adjustAngle!","text":"adjustAngle!(system::PowerSystem, model::ACPowerFlow; slack)\n\nThe function modifies the bus voltage angles based on a different slack bus than the one identified by the bus.layout.slack field. This function only updates the voltage.angle variable of the Model composite type.\n\nFor instance, if the reactive power of the generator exceeds the limit on the slack bus, the reactiveLimit! function will change that bus to the demand bus and designate the first generator bus in the sequence as the new slack bus. After obtaining the updated AC power flow solution based on the new slack bus, it is possible to adjust the voltage angles to align with the angle of the original slack bus. The slack keyword specifies the bus label of the original slack bus.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nmodel = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\npower = analysisGenerator(system, model)\n\nreactiveLimit!(system, model, power)\n\nmodel = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, model)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, model)\nend\n\nadjustAngle!(system, model; slack = 1)\n\n\n\n\n\n","category":"function"},{"location":"tutorials/acdcModel/#ACDCModelTutorials","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The power system analyses commonly utilize the unified branch model that provides linear relationships between voltages and currents. However, as the focus is on power calculations rather than current calculations, the resulting equations become nonlinear, posing challenges in solving them. Hence, to accurately analyze power systems without any approximations, we use the AC model, which is a crucial component of our framework. In contrast, to obtain a linear system of equations for various DC analyses, we introduce approximations in the unified branch model, resulting in the DC model [1].","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"A common way to describe the power system network topology is through the bus/branch model, which employs the two-port pi-model, which results in the unified branch model. The bus/branch model can be represented by a graph denoted by mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n corresponds to buses, and the set of edges mathcalE subseteq mathcalN times mathcalN represents the branches of the power network.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Let us now construct the power system:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, V)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 21.7, reactive = 12.7)\naddBus!(system; label = 3, type = 2, conductance = 2.1, susceptance = 1.2)\n\naddBranch!(system; label = 1, from = 1, to = 2,\n    resistance = 0.02, reactance = 0.06, susceptance = 0.05)\naddBranch!(system; label = 2, from = 1, to = 3,\n    reactance = 0.21, turnsRatio = 0.98, shiftAngle = 1.2)\naddBranch!(system; label = 3, from = 2, to = 3,\n    resistance = 0.13, reactance = 0.26)\n\naddGenerator!(system; label = 1, bus = 3, active = 40.0, reactive = 42.4)\nnothing #hide","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The given example provides the set of buses and branches:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝒩 = collect(keys(sort(system.bus.label)))\nℰ = [system.branch.layout.from system.branch.layout.to]","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"ukw: Notation\nIn this section, when referring to a vector mathbfa, we use the notation mathbfa = a_ij, where a_ij represents the generic element associated with the branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#ACModelTutorials","page":"AC and DC Model","title":"AC Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"JuliaGrid is based on common network elements and benefits from the unified branch model to perform various analyses based on the system of nonlinear equations. To generate matrices and vectors for AC or nonlinear analysis, JuliaGrid employs the acModel! function. To demonstrate the usage of this function, consider the power system defined in the previous example. In order to apply the acModel! function to this power system, the following code can be executed:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"acModel!(system)\nnothing #hide","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#UnifiedBranchModelTutorials","page":"AC and DC Model","title":"Unified Branch Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The equivalent unified pi-model for a branch (ij) in mathcalE incident to the buses ij in mathcalN is shown in Figure 1.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"<img src=\"../../assets/pi_model.png\" class=\"center\"/>\n<figcaption>Figure 1: The equivalent branch model, where the transformer is located at \"from\" bus end of the branch.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The branch series admittance y_ij is inversely proportional to the branch series impedance z_ij:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"    y_ij = frac1z_ij =\n    frac1r_ij + textjx_ij =\n    fracr_ijr_ij^2 + x_ij^2 - textjfracx_ijr_ij^2 + x_ij^2 = g_ij + textjb_ij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where r_ij is a resistance, x_ij is a reactance, g_ij is a conductance and b_ij is a susceptance of the branch.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The vectors of resistances, denoted by mathbfr = r_ij, and reactances, denoted by mathbfx = x_ij, are stored in the variables:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐫 = system.branch.parameter.resistance\n𝐱 = system.branch.parameter.reactance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Moreover, the acModel stores the computed vector of branch series admittances mathbfy = y_ij:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐲 = system.acModel.admittance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The branch shunt capacitive admittance (i.e. charging admittance) y_textsij is equal to:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"y_textsij = textj b_textsij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"JuliaGrid stores the total branch shunt capacitive susceptances, so to obtain the vector mathbfb_s = b_textsij, the susceptances must be split according to the ends of branches:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐛ₛ = system.branch.parameter.susceptance / 2","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The transformer complex ratio alpha_ij is defined:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"    alpha_ij = cfrac1tau_ije^-textjphi_ij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where tau_ij is a transformer turns ratio, while phi_ij is a transformer phase shift angle, always located \"from\" bus end of the branch. These transformer parameters are stored in the vectors bmtau = tau_ij and bmphi = phi_ij, respectively:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝛕 = system.branch.parameter.turnsRatio\n𝚽 = system.branch.parameter.shiftAngle","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The acModel within the PowerSystem composite type contains the computed transformer complex ratios bmalpha = alpha_ij. These values can be accessed using the following command:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝛂 = system.acModel.transformerRatio","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Using Kirchhoff's circuit laws, the unified branch model can be described by complex expressions:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2(y_ij + y_textsij)  -alpha_ij^*y_ij\n    -alpha_ijy_ij  y_ij + y_textsij\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The values of the vectors mathbfy_textii = (y_ij + y_textsij)  tau_ij^2, mathbfy_textij = -alpha_ij^*y_ij, mathbfy_textji = -alpha_ijy_ij, and mathbfy_textjj = y_ij + y_textsij can be found stored in the variables:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐲ᵢᵢ = system.acModel.nodalFromFrom\n𝐲ᵢⱼ = system.acModel.nodalFromTo\n𝐲ⱼᵢ = system.acModel.nodalToFrom\n𝐲ⱼⱼ = system.acModel.nodalToTo","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Note, if tau_ij = 1 and phi_ij = 0 the model describes the line. In-phase transformers are defined if phi_ij = 0 and y_textsij = 0, while phase-shifting transformers are obtained if y_textsij = 0.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#SystemEquationsNodalMatrixTutorials","page":"AC and DC Model","title":"System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Let us consider an example, given in Figure 2, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with admittance y_textshk.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"<img src=\"../../assets/pi_model_example.png\" class=\"center\"/>\n<figcaption>Figure 2: The example of the system with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"According to the unified branch model each branch is described using the system of equations as follows:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_pk  barI_kp\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_pk^*y_pk\n    -alpha_pky_pk  y_pk + y_textspk\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_kq  barI_qk\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_kq^2(y_kq + y_textskq)  -alpha_kq^*y_kq\n    -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The complex current injections at buses are:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    barI_p = barI_pk = cfrac1tau_pk^2(y_pk + y_textspk) barV_p -alpha_kq^*y_kq barV_k \n    barI_k = barI_kp + barI_kq - barI_textshk =\n    -alpha_kqy_kq barV_p + (y_kq + y_textskq) barV_k +\n    cfrac1tau_kq^2(y_kq + y_textskq) barV_k -alpha_kq^*y_kq barV_q + y_textshk barV_k \n    barI_q = barI_qk = -alpha_kqy_kq barV_k + (y_kq + y_textskq) barV_q\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    barI_p  barI_k  barI_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_kq^*y_kq  0 \n   -alpha_kqy_kq  y_kq + y_textskq + cfrac1tau_kq^2(y_kq + y_textskq) + y_textshk   -alpha_kq^*y_kq \n    0  -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Next, the system of equations for buses i=1 dots n can be written in the matrix form:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where mathbf bar V in mathbbC^n is the vector of bus complex voltages, and mathbf bar I in mathbbC^n is the vector of complex current injections at buses.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The matrix mathbfY = mathbfG + textjmathbfB in mathbbC^n times n is the bus or nodal admittance matrix, with elements:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nY_ii = G_ii + textjB_ii = y_textshi +\nsumlimits_e in mathcalE  e(1) = i cfrac1tau_ij^2(y_ij + y_textsij) + sumlimits_e in mathcalE  e(2) = i (y_ij + y_textsij)\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nY_ij = G_ij + textjB_ij = -alpha_ij^*y_ij\nY_ji = G_ji + textjB_ji =  -alpha_ijy_ij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix mathbfY is equal to zero. The nodal admittance matrix mathbfY is a sparse (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix mathbfY is symmetrical, it is not a general case, for example, in the presence of phase shifting transformers the matrix mathbfY is not symmetrical [2, Sec. 9.6]. JuliaGrid stores both the matrix mathbfY and its transpose mathbfY^T in the acModel variable of the PowerSystem composite type:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐘 = system.acModel.nodalMatrix\n𝐘ᵀ = system.acModel.nodalMatrixTranspose","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#DCModelTutorials","page":"AC and DC Model","title":"DC Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The DC model is obtained by linearisation of the nonlinear model, and it provides an approximate solution. In the typical operating conditions, the difference of bus voltage angles between adjacent buses (ij) in mathcalE is very small theta_i-theta_j approx 0, which implies cos theta_ijapprox 1 and sin theta_ij approx theta_ij. Further, all bus voltage magnitudes are V_i approx 1, i in mathcalN, and all shunt susceptance elements and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers. Therefore, the DC power flow takes only bus voltage angles bm theta as variables. To create vectors and matrices related to DC or linear analyses, JuliaGrid uses the function dcModel!. Therefore, we can continue with the previous example:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#DCUnifiedBranchModelTutorials","page":"AC and DC Model","title":"Unified Branch Model","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"According to the above assumptions, we start from the unified branch model:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"    beginbmatrix\n      barI_ij  barI_ji\n    endbmatrix = cfrac1textjx_ij\n    beginbmatrix\n      cfrac1tau_ij^2  -alpha_ij^*\n      -alpha_ij  1\n    endbmatrix\n    beginbmatrix\n      barV_i  barV_j\n    endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where barV_i = texte^textjtheta_i and barV_j = texte^textjtheta_j. Further, we have:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    barI_ij = cfrac1textjx_ij leftcfrac1tau_ij^2 texte^textjtheta_i -\n    cfrac1tau_ije^textj(phi_ij + theta_j) right \n    barI_ji = cfrac1textjx_ij left-cfrac1tau_ije^textj(theta_i - phi_ij) + texte^textjtheta_j right\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The active power flows are derived as follows:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    P_ij = RebarV_ibarI_ij^* =\n    Re lefttextjcfrac1x_ij\n    leftcfrac1tau_ij^2 - cfrac1tau_ije^textj(theta_i - theta_j - phi_ij) right  right \n    P_ji = RebarV_jbarI_ji^* =\n    Re lefttextjcfrac1x_ij\n   left1-cfrac1tau_ije^textj(-theta_i +theta_j + phi_ij) right  right\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The real components are:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    P_ij =cfrac1tau_ijx_ij sin(theta_i -theta_j-phi_ij) approx cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) \n    P_ji =cfrac1tau_ijx_ij sin(theta_j -theta_i+phi_ij) approx -cfrac1tau_ij x_ij (theta_i - theta_j-phi_ij)\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where 1(tau_ij x_ij) represents the branch admittance in the DC framework. To recall, the PowerSystem composite type stores the reactances as vector mathbfx = x_ij in the variable:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐱 = system.branch.parameter.reactance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Furthermore, the computed branch admittances in the DC framework are stored in the vector mathbfy = 1(tau_ij x_ij):","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐲 = system.dcModel.admittance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"We can conclude that P_ij=-P_ji holds. With the DC model, the linear network equations relate active powers to bus voltage angles, versus complex currents to complex bus voltages in the AC model [3]. Consequently, analogous to the unified branch model we can write:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix = cfrac1tau_ijx_ij\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix + cfracphi_ijtau_ijx_ij\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#SystemEquationsNodalMatrixTutorials-2","page":"AC and DC Model","title":"System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"As before, let us consider an example of the DC framework, given in Figure 3, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with conductance g_textshk.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"<img src=\"../../assets/dc_model.png\" class=\"center\"/>\n<figcaption>Figure 3: The example of the system with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Each branch in the DC framework is described with a system of equations as follows:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_pk  P_kp\n  endbmatrix = cfrac1tau_pkx_pk\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k\n  endbmatrix + cfracphi_pktau_pkx_pk\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_kq  P_qk\n  endbmatrix = cfrac1tau_kqx_kq\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_k  theta_q\n  endbmatrix + cfracphi_kqtau_kqx_kq\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The active power injections at buses are:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginaligned\n    P_p = P_pk =cfrac1tau_pkx_pk theta_p - cfrac1tau_pkx_pk theta_k - cfracphi_pktau_pkx_pk \n    P_k = P_kp + P_kq - P_textshk = -cfrac1tau_pkx_pk theta_p + cfrac1tau_pkx_pk theta_k + cfracphi_pktau_pkx_pk +\n    cfrac1tau_kqx_kq theta_k - cfrac1tau_kqx_kq theta_q - cfracphi_kqtau_kqx_kq + g_textshk \n    P_q = P_qk = -cfrac1tau_kqx_kq theta_k +cfrac1tau_kqx_kq theta_q + cfracphi_kqtau_kqx_kq\n  endaligned","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where the active power injected by the shunt element at the bus k is equal to:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  P_textshk = RebarV_kbarI_textshk^* = Re-barV_ky_textshk^*barV_k^* = - g_textshk","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  beginbmatrix\n    P_p  P_k  P_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pkx_pk  - cfrac1tau_pkx_pk  0 \n    -cfrac1tau_pkx_pk  cfrac1tau_pkx_pk + cfrac1tau_kqx_kq   -cfrac1tau_kqx_kq \n    0  -cfrac1tau_kqx_kq cfrac1tau_kqx_kq\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k  theta_q\n  endbmatrix +\n  beginbmatrix\n    - cfracphi_pktau_pkx_pk  cfracphi_pktau_pkx_pk - cfracphi_kqtau_kqx_kq  cfracphi_kqtau_kqx_kq\n  endbmatrix +\n  beginbmatrix\n    0  g_textshk  0\n  endbmatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"Next, the system of equations for i=1dotsn can be written in the matrix form:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"  mathbf P = mathbfB bm theta + mathbfP_texttr + mathbfP_textsh","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"where bm theta in mathbbR^n is the vector of bus voltage angles.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The vector mathbf P in mathbbR^n contains active power injections at buses caused by generators and demands. In JuliaGrid, the vector can be recovered using a command:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐏 = system.bus.supply.active - system.bus.demand.active","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The vector mathbfP_texttr in mathbbR^n represents active powers related to the non-zero shift angle of transformers. This vector is stored in the dcModel variable, and we can access it using:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐏ₜᵣ = system.dcModel.shiftActivePower","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The vector mathbfP_textsh in mathbbR^n represents active powers consumed by shunt elements. We can access this vector using:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐏ₛₕ = system.bus.shunt.conductance","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The bus or nodal matrix in the DC framework is given as mathbfB in mathbbC^n times n, with elements:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nB_ii = sumlimits_e in mathcalE i in e cfrac1tau_ijx_ij\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nB_ij = -cfrac1tau_ijx_ij\nB_ji = -cfrac1tau_ijx_ij","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"The sparse nodal matrix mathbfB is stored in the dcModel variable, and we can access it using:","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"𝐁 = system.dcModel.nodalMatrix","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"","category":"page"},{"location":"tutorials/acdcModel/#ACDCModelReferenceTutorials","page":"AC and DC Model","title":"References","text":"","category":"section"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"[1] G. Andersson, Power system analysis, EEH-Power Systems Laboratory, ETH Zurich, Lecture Notes 2012.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"[2] J. Grainger and W. Stevenson, Power system analysis, ser. McGraw-Hill series in electrical and computer engineering: Power and energy. McGraw-Hill, 1994.","category":"page"},{"location":"tutorials/acdcModel/","page":"AC and DC Model","title":"AC and DC Model","text":"[3] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER User’s Manual, Version 7.0. 2019.","category":"page"},{"location":"api/optimaPowerFlowSolution/#OptimalPowerFlowSolutionAPI","page":"Optimal Power Flow Solution","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"api/optimaPowerFlowSolution/","page":"Optimal Power Flow Solution","title":"Optimal Power Flow Solution","text":"For further information on this topic, please see the Power System Analysis section of the Manual.","category":"page"},{"location":"api/optimaPowerFlowSolution/","page":"Optimal Power Flow Solution","title":"Optimal Power Flow Solution","text":"","category":"page"},{"location":"api/optimaPowerFlowSolution/#API-Index","page":"Optimal Power Flow Solution","title":"API Index","text":"","category":"section"},{"location":"api/optimaPowerFlowSolution/#Build-Model","page":"Optimal Power Flow Solution","title":"Build Model","text":"","category":"section"},{"location":"api/optimaPowerFlowSolution/","page":"Optimal Power Flow Solution","title":"Optimal Power Flow Solution","text":"dcOptimalPowerFlow","category":"page"},{"location":"api/optimaPowerFlowSolution/#Solve-Optimal-Power-Flow","page":"Optimal Power Flow Solution","title":"Solve Optimal Power Flow","text":"","category":"section"},{"location":"api/optimaPowerFlowSolution/","page":"Optimal Power Flow Solution","title":"Optimal Power Flow Solution","text":"optimize!","category":"page"},{"location":"api/optimaPowerFlowSolution/","page":"Optimal Power Flow Solution","title":"Optimal Power Flow Solution","text":"","category":"page"},{"location":"api/optimaPowerFlowSolution/#Build-Model-2","page":"Optimal Power Flow Solution","title":"Build Model","text":"","category":"section"},{"location":"api/optimaPowerFlowSolution/","page":"Optimal Power Flow Solution","title":"Optimal Power Flow Solution","text":"dcOptimalPowerFlow","category":"page"},{"location":"api/optimaPowerFlowSolution/#JuliaGrid.dcOptimalPowerFlow","page":"Optimal Power Flow Solution","title":"JuliaGrid.dcOptimalPowerFlow","text":"dcOptimalPowerFlow(system::PowerSystem, optimizer; bridges, names, balance, limit,\n    rating, capability)\n\nThe function takes the PowerSystem composite type as input to establish the structure for solving the DC optimal power flow. The optimizer argument is also required to create and solve the optimization problem. If the dcModel field within the PowerSystem composite type has not been created, the function will initiate an update automatically.\n\nKeywords\n\nJuliaGrid offers the ability to manipulate the jump model based on the guidelines provided in the JuMP documentation. However, certain configurations may require different method calls, such as:\n\nbridges: used to manage the bridging mechanism\nnames: used to manage the creation of string names.\n\nMoreover, we have included keywords that regulate the usage of different types of constraints:\n\nbalance: controls the equality constraints that relate to the active power balance equations\nlimit: controls the inequality constraints that relate to the voltage angle differences between buses\nrating: controls the inequality constraints that relate to the long-term rating of branches\ncapability: controls the inequality constraints that relate to the active power generator outputs.\n\nBy default, all of these keywords are set to true and are of the Bool type.\n\nJuMP\n\nThe JuliaGrid builds the DC optimal power flow around the JuMP package and supports commonly used solvers. For more information, refer to the JuMP documenatation.\n\nReturns\n\nThe function returns an instance of the DCOptimalPowerFlow type, which includes the following fields:\n\nvoltage: the angles of bus voltages\noutput: the active power output of the generators\njump: the JuMP model\nconstraint: holds the constraint references to the JuMP model.\n\nExamples\n\nCreate the complete DC optimal power flow model:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nmodel = dcOptimalPowerFlow(system, HiGHS.Optimizer)\n\nCreate the DC optimal power flow model without rating constraints:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nmodel = dcOptimalPowerFlow(system, HiGHS.Optimizer; rating = false)\n\n\n\n\n\n","category":"function"},{"location":"api/optimaPowerFlowSolution/","page":"Optimal Power Flow Solution","title":"Optimal Power Flow Solution","text":"","category":"page"},{"location":"api/optimaPowerFlowSolution/#Solve-Optimal-Power-Flow-2","page":"Optimal Power Flow Solution","title":"Solve Optimal Power Flow","text":"","category":"section"},{"location":"api/optimaPowerFlowSolution/","page":"Optimal Power Flow Solution","title":"Optimal Power Flow Solution","text":"optimize!","category":"page"},{"location":"api/optimaPowerFlowSolution/#JuliaGrid.optimize!","page":"Optimal Power Flow Solution","title":"JuliaGrid.optimize!","text":"optimize!(system::PowerSystem, model::DCOptimalPowerFlow)\n\nThe function finds the DC optimal power flow solution and calculate the angles of bus voltages and active power output of the generators.\n\nThe calculated voltage angles and active powers are then stored in the angle variable of the voltage field and the active variable of the power field.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nmodel = dcOptimalPowerFlow(system, HiGHS.Optimizer)\noptimize!(system, model)\n\n\n\n\n\n","category":"function"},{"location":"#JuliaGrid","page":"Introduction","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver, and allows a variety of display and manipulation options.","category":"page"}]
}
