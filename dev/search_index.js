var documenterSearchIndex = {"docs":
[{"location":"api/configuration/#configurationSetupAPI","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"For further information on this topic, please see the Power System Model section of the Manual.","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Base-Unit-Prefixes","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#Input-Unit-System","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@current\n@parameter","category":"page"},{"location":"api/configuration/#Default-Settings","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Base-Unit-Prefixes-2","page":"Configuration Setup","title":"Base Unit Prefixes","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@base","category":"page"},{"location":"api/configuration/#JuliaGrid.@base","page":"Configuration Setup","title":"JuliaGrid.@base","text":"@base(system::PowerSystem, power, voltage)\n\nBy default, the units for base power and base voltages are set to volt-ampere (VA) and volt (V), but you can modify the prefixes using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of power (VA) or unit of voltage (V). Keep in mind that the macro must be used after creating the composite type PowerSystem.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n@base(system, MVA, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Input-Unit-System-2","page":"Configuration Setup","title":"Input Unit System","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@power\n@voltage\n@current\n@parameter","category":"page"},{"location":"api/configuration/#JuliaGrid.@power","page":"Configuration Setup","title":"JuliaGrid.@power","text":"@power(active, reactive, apparent)\n\nJuliaGrid stores all data related with powers in per-units, and these cannot be altered. However, the power units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of active power (W), reactive power (VAr), or apparent power (VA). Also it is a possible to combine SI units with/without prefixes with per-units (pu).\n\nChanging the unit of active power is reflected in the following quantities:\n\naddBus!: active, conductance,\nshuntBus!: conductance,\naddGenerator!: active, minActive, maxActive, lowActive, upActive, loadFollowing, reserve10min, reserve30min,\naddActiveCost!: piecewise, polynomial,\noutputGenerator!: active,\naddBranch!: longTerm, shortTerm, emergency if rating type = 2.\n\nChanging the unit of reactive power unit is reflected in the following quantities:\n\naddBus!: reactive, susceptance,\nshuntBus!: susceptance,\naddGenerator!: reactive, minReactive, maxReactive, minLowReactive, maxLowReactive, minUpReactive, maxUpReactive, reactiveTimescale,\naddReactiveCost!: piecewise, polynomial,\noutputGenerator!: reactive.\n\nChanging the unit of apparent power unit is reflected in the following quantities:\n\naddBranch!: longTerm, shortTerm, emergency if rating type = 1 or type = 3.\n\nExample\n\n@power(MW, kVAr, VA)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@voltage","page":"Configuration Setup","title":"JuliaGrid.@voltage","text":"@voltage(magnitude, angle, base)\n\nJuliaGrid stores all data related with voltages in per-units and radians, and these cannot be altered. However, the voltage magnitude and angle units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nThe prefixes must adhere to the SI prefixes and should be specified along with the unit of voltage, either magnitude (V) or base (V). Alternatively, the unit of voltage magnitude can be expressed in per-unit (pu). The unit of voltage angle should be in radians (rad) or degrees (deg).\n\nChanging the unit of voltage magnitude is reflected in the following quantities:\n\naddBus!: magnitude, minMagnitude, maxMagnitude,\naddGenerator!: magnitude.\n\nChanging the unit of voltage angle is reflected in the following quantities:\n\naddBus!: angle,\naddBranch!: shiftAngle, minDiffAngle, maxDiffAngle,\nparameterBranch!: shiftAngle.\n\nChanging the unit prefix of voltage base is reflected in the following quantity:\n\naddBus!: base.\n\nExample\n\n@voltage(pu, deg, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@current","page":"Configuration Setup","title":"JuliaGrid.@current","text":"@current(magnitude, angle)\n\nJuliaGrid stores all data related with currents in per-units and radians, and these cannot be altered. However, the current magnitude and angle units of the built-in functions used to add or modified measurement devices can be modified using the macro.\n\nThe prefixes must adhere to the SI prefixes and should be specified along with the unit of current magnitude (V). Alternatively, the unit of current magnitude can be expressed in per-unit (pu). The unit of current angle should be in radians (rad) or degrees (deg).\n\nChanging the unit of current magnitude is reflected in the following quantities:\n\naddAmmeter!: mean, exact, variance.\n\nExample\n\n@current(pu, deg)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/#JuliaGrid.@parameter","page":"Configuration Setup","title":"JuliaGrid.@parameter","text":"@parameter(impedance, admittance)\n\nJuliaGrid stores all data related with impedances and admittancies in per-units, and these cannot be altered. However, units of impedance and admittance of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of impedance (Ω) or unit of admittance (S). The second option is to define the units in per-unit (pu).\n\nIn the case where impedance and admittance are being used in SI units (Ω and S) and these units are related to the transformer, the assignment must be based on the primary side of the transformer.\n\nChanging the units of impedance is reflected in the following quantities in specific functions:\n\naddBranch!: resistance, reactance,\nparameterBranch!: resistance, reactance.\n\nChanging the units of admittance is reflected in the following quantities:\n\naddBranch!: susceptance,\nparameterBranch!: susceptance.\n\nExample\n\n@parameter(Ω, pu)\n\n\n\n\n\n","category":"macro"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"","category":"page"},{"location":"api/configuration/#Default-Settings-2","page":"Configuration Setup","title":"Default Settings","text":"","category":"section"},{"location":"api/configuration/","page":"Configuration Setup","title":"Configuration Setup","text":"@default","category":"page"},{"location":"api/configuration/#JuliaGrid.@default","page":"Configuration Setup","title":"JuliaGrid.@default","text":"The macro is designed to reset various settings to their default values.\n\n@default(mode)\n\nThe mode argument can take on the following values:\n\nunit: resets all units to their default settings\npower: sets active, reactive, and apparent power to per-units\nvoltage: sets voltage magnitude to per-unit and voltage angle to radian\nparameter: sets impedance and admittance to per-units\ntemplate: resets bus, branch and generator templates to their default settings\nbus: resets the bus template to its default settings\nbranch: resets the branch template to its default settings\ngenerator: resets the generator template to its default settings.\n\nExample\n\n@default(unit)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerFlow/#PowerFlowAPI","page":"Power Flow","title":"Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"For further information on this topic, please see the AC Power Flow or DC Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for power flow analysis.","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-AC-Power-Flow-Model","page":"Power Flow","title":"Build AC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel","category":"page"},{"location":"api/powerFlow/#Solve-AC-Power-Flow","page":"Power Flow","title":"Solve AC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"mismatch!\nsolve!","category":"page"},{"location":"api/powerFlow/#Additional-AC-Functions","page":"Power Flow","title":"Additional AC Functions","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"reactiveLimit!\nadjustAngle! ","category":"page"},{"location":"api/powerFlow/#Build-DC-Power-Flow-Model","page":"Power Flow","title":"Build DC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"dcPowerFlow","category":"page"},{"location":"api/powerFlow/#Solve-DC-Power-Flow","page":"Power Flow","title":"Solve DC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"solve!","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-AC-Power-Flow-Model-2","page":"Power Flow","title":"Build AC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel","category":"page"},{"location":"api/powerFlow/#JuliaGrid.newtonRaphson","page":"Power Flow","title":"JuliaGrid.newtonRaphson","text":"newtonRaphson(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Newton-Raphson method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the NewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nmethod: contains the Jacobian matrix, power injection mismatches, bus voltage increments, and indices;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonBX","text":"fastNewtonRaphsonBX(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the fast Newton-Raphson method of version BX to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field  within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nmethod: contains Jacobian matrices, power injection mismatches, bus voltage increments, and indices;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonBX(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonXB","text":"fastNewtonRaphsonXB(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the fast Newton-Raphson method of version XB to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the FastNewtonRaphson subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nmethod: contains Jacobian matrices, power injection mismatches, bus voltage increments, and indices;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonXB(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.gaussSeidel","page":"Power Flow","title":"JuliaGrid.gaussSeidel","text":"gaussSeidel(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input and uses it to set up the Gauss-Seidel method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the GaussSeidel subtype of the abstract ACPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\nmethod: contains the bus complex voltages and indices;\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = gaussSeidel(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Solve-AC-Power-Flow-2","page":"Power Flow","title":"Solve AC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"mismatch!(::PowerSystem, ::NewtonRaphson)\nsolve!(::PowerSystem, ::NewtonRaphson)","category":"page"},{"location":"api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}","page":"Power Flow","title":"JuliaGrid.mismatch!","text":"mismatch!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function calculates both active and reactive power injection mismatches and returns their maximum absolute values, which can be utilized to terminate the iteration loop of methods employed to solve the AC power flow problem.\n\nUpdates\n\nThis function updates the mismatch variables in the Newton-Raphson and fast Newton-Raphson methods. It should be employed during the iteration loop before invoking the solve! function.\n\nIn contrast, the Gauss-Seidel method does not need mismatches to obtain bus voltages, but the maximum absolute values are commonly employed to stop the iteration loop. The function does not save any data and should be utilized during the iteration loop before invoking the solve! function.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the power mismatches within the Newton-Raphson method;\nFastNewtonRaphson: computes the power mismatches within the fast Newton-Raphson method;\nGaussSeidel: computes the power mismatches within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nmismatch!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function employs the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel method to solve the AC power flow problem and calculate bus voltage magnitudes and angles.\n\nAfter the mismatch! function is called, this function should be executed to perform a single iteration of the method.\n\nUpdates\n\nThe calculated voltages are stored in the voltage field of the respective struct type.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method;\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method;\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Additional-AC-Functions-2","page":"Power Flow","title":"Additional AC Functions","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"reactiveLimit!\nadjustAngle!","category":"page"},{"location":"api/powerFlow/#JuliaGrid.reactiveLimit!","page":"Power Flow","title":"JuliaGrid.reactiveLimit!","text":"reactiveLimit!(system::PowerSystem, analysis::ACPowerFlow)\n\nThe function verifies whether the generators in a power system exceed their reactive power limits. This is done by setting the reactive power of the generators to within the limits if they are violated, after determining the bus voltage magnitudes and angles. If the limits are violated, the corresponding generator buses or the slack bus are converted to demand buses.\n\nUpdates\n\nThe function assigns values to the generator.output.active and bus.supply.active variables of the PowerSystem type. Additionally, it examines the reactive powers of the generator and adjusts them to their maximum or minimum values if they exceed the specified threshold. Subsequently, the generator.output.reactive variable of the PowerSystem type is modified accordingly. As a result of this adjustment, the bus.supply.reactive variable of the PowerSystem type is also updated, and the bus types specified in bus.layout.type are modified. If the slack bus is converted, the bus.layout.slack field is correspondingly adjusted.\n\nReturns\n\nThe function returns the violate variable to indicate which buses violate the limits, with -1 indicating a violation of the minimum limits and 1 indicating a violation of the maximum limits.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method,\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method,\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nviolate = reactiveLimit!(system, analysis)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.adjustAngle!","page":"Power Flow","title":"JuliaGrid.adjustAngle!","text":"adjustAngle!(system::PowerSystem, analysis::ACPowerFlow; slack)\n\nThe function modifies the bus voltage angles based on a different slack bus than the one identified by the bus.layout.slack field.\n\nFor instance, if the reactive power of the generator exceeds the limit on the slack bus, the reactiveLimit! function will change that bus to the demand bus and designate the first generator bus in the sequence as the new slack bus. After obtaining the updated AC power flow solution based on the new slack bus, it is possible to adjust the voltage angles to align with the angle of the original slack bus. The slack keyword specifies the bus label of the original slack bus.\n\nUpdates\n\nThis function only updates the voltage.angle variable of the ACPowerFlow abstract type.\n\nAbstract type\n\nThe abstract type ACPowerFlow can have the following subtypes:\n\nNewtonRaphson: computes the bus voltages within the Newton-Raphson method;\nFastNewtonRaphson: computes the bus voltages within the fast Newton-Raphson method;\nGaussSeidel: computes the bus voltages within the Gauss-Seidel method.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nreactiveLimit!(system, analysis)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\n\nadjustAngle!(system, analysis; slack = 1)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Build-DC-Power-Flow-Model-2","page":"Power Flow","title":"Build DC Power Flow Model","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"dcPowerFlow","category":"page"},{"location":"api/powerFlow/#JuliaGrid.dcPowerFlow","page":"Power Flow","title":"JuliaGrid.dcPowerFlow","text":"dcPowerFlow(system::PowerSystem)\n\nThe function accepts the PowerSystem composite type as input, which is utilized to establish the structure for solving the DC power flow.\n\nIf the DC model was not created, the function will automatically initiate an update of the dc field within the PowerSystem composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.\n\nReturns\n\nThe function returns an instance of the DCPowerFlow composite type, which includes the following fields:\n\nvoltage: the variable allocated to store the bus voltage angles;\npower: the variable allocated to store the active powers;\nfactorization: the factorized nodal matrix.\nuuid: a universally unique identifier associated with the PowerSystem composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#Solve-DC-Power-Flow-2","page":"Power Flow","title":"Solve DC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"solve!(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::DCPowerFlow)\n\nBy computing the bus voltage angles, the function solves the DC power flow problem.\n\nUpdates\n\nThe resulting bus voltage angles are stored in the voltage field of the DCPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#PowerCurrentAnalysisAPI","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"In the following section, we have provided a list of functions that can be utilized for post-processing analysis. Once the voltage values are obtained through power flow analysis or optimal power flow analysis, these functions can be used to calculate power or current values. The specific procedures for computing these values depend on the chosen analysis, which are described in separate manuals for further information.","category":"page"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#AC-Power-Analysis","page":"Power and Current Analysis","title":"AC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!","category":"page"},{"location":"api/analysis/#AC-Power-Breakdown-Analysis","page":"Power and Current Analysis","title":"AC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower\nsupplyPower\nshuntPower\nfromPower\ntoPower\nseriesPower\nchargingPower\ngeneratorPower","category":"page"},{"location":"api/analysis/#AC-Current-Analysis","page":"Power and Current Analysis","title":"AC Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"current!","category":"page"},{"location":"api/analysis/#AC-Current-Breakdown-Analysis","page":"Power and Current Analysis","title":"AC Current Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionCurrent\nfromCurrent\ntoCurrent\nseriesCurrent","category":"page"},{"location":"api/analysis/#DC-Power-Analysis","page":"Power and Current Analysis","title":"DC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!","category":"page"},{"location":"api/analysis/#DC-Power-Breakdown-Analysis","page":"Power and Current Analysis","title":"DC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower\nsupplyPower\nfromPower\ntoPower\ngeneratorPower","category":"page"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACPowerAnalysisAPI","page":"Power and Current Analysis","title":"AC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!(::PowerSystem, ::ACPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.power!","text":"power!(system::PowerSystem, analysis::AC)\n\nThe function computes the active and reactive powers associated with buses, branches, and generators in the AC framework.\n\nUpdates\n\nThis function updates the power field of the AC abstract type by computing the following electrical quantities:\n\ninjection: active and reactive power bus injections;\nsupply: active and reactive power bus injections from the generators;\nshunt: active and reactive power values associated with shunt element at each bus;\nfrom: active and reactive power flows at the \"from\" end of each branch;\nto: active and reactive power flows at the \"to\" end of each branch;\ncharging: active and reactive power values linked with branch charging admittances for each branch;\nseries active and reactive power losses through each branch series impedance;\ngenerator: produced active and reactive power outputs of each generator.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\npower!(system, analysis)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\npower!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACPowerBreakdownAnalysisAPI","page":"Power and Current Analysis","title":"AC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower(::PowerSystem, ::AC)\nsupplyPower(::PowerSystem, ::ACPowerFlow)\nshuntPower(::PowerSystem, ::AC)\nfromPower(::PowerSystem, ::AC)\ntoPower(::PowerSystem, ::AC)\nseriesPower(::PowerSystem, ::AC)\nchargingPower(::PowerSystem, ::AC)\ngeneratorPower(::PowerSystem, ::ACPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.injectionPower","text":"injectionPower(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power injections associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = injectionPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = injectionPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.supplyPower","text":"supplyPower(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power injections from the generators associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = supplyPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = supplyPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.shuntPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.shuntPower","text":"shuntPower(system::PowerSystem, analysis::AC, label)\n\nThe function returns the active and reactive power values of the shunt element associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = shuntPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = shuntPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.fromPower","text":"fromPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power flows at the \"from\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = fromPower(system, analysis; label = 2)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = fromPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.toPower","text":"toPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power flows at the \"to\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = toPower(system, analysis; label = 2)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = toPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.seriesPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.seriesPower","text":"seriesPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power losses across the series impedance of a specific branch within the AC framework. The label keyword argument should correspond to an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the power within the AC power flow;\nACOptimalPowerFlow: computes the power within the AC optimal power flow.\n\nExamples\n\nCompute the reactive power after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = seriesPower(system, analysis; label = 2)\n\nCompute the reactive power after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = seriesPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.chargingPower-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.chargingPower","text":"chargingPower(system::PowerSystem, analysis::AC; label)\n\nThe function returns the active and reactive power values associated with the charging admittances of a specific branch in the AC framework. The label keyword argument must correspond to an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the power within the AC power flow;\nACOptimalPowerFlow: computes the power within the AC optimal power flow.\n\nExamples\n\nCompute the reactive power after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = chargingPower(system, analysis; label = 2)\n\nCompute the reactive power after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = chargingPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.generatorPower-Tuple{PowerSystem, ACPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.generatorPower","text":"generatorPower(system::PowerSystem, analysis::AC)\n\nThe function returns the active and reactive powers associated with a specific generator in the AC framework. The label keyword argument must match an existing generator label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the powers within the AC power flow;\nACOptimalPowerFlow: computes the powers within the AC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the AC power flow solution\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nactive, reactive = generatorPower(system, analysis; label = 1)\n\nCompute powers after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nactive, reactive = generatorPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACCurrentAnalysisAPI","page":"Power and Current Analysis","title":"AC Current Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"current!(::PowerSystem, ::AC)","category":"page"},{"location":"api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.current!","text":"current!(system::PowerSystem, analysis::AC)\n\nThe function computes the currents in the polar coordinate system associated with buses and branches in the AC framework.\n\nUpdates\n\nThis function calculates various electrical quantities in the polar coordinate system:\n\ninjection: current injections at each bus;\nfrom: current flows at each \"from\" bus end of the branch;\nto: current flows at each \"to\" bus end of the branch;\nseries: current flows through the series impedance of the branch in the direction from the \"from\" bus end to the \"to\" bus end of the branch.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the currents within the AC power flow;\nACOptimalPowerFlow: computes the currents within the AC optimal power flow.\n\nExamples\n\nCompute currents after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\ncurrent!(system, analysis)\n\nCompute currents after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\ncurrent!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#ACCurrentBreakdownAnalysisAPI","page":"Power and Current Analysis","title":"AC Current Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionCurrent(::PowerSystem, ::AC)\nfromCurrent(::PowerSystem, ::AC)\ntoCurrent(::PowerSystem, ::AC)\nseriesCurrent(::PowerSystem, ::AC)","category":"page"},{"location":"api/analysis/#JuliaGrid.injectionCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.injectionCurrent","text":"injectionCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = injectionCurrent(system, analysis; label = 1)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = injectionCurrent(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.fromCurrent","text":"fromCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the \"from\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = fromCurrent(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = fromCurrent(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.toCurrent","text":"toCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the \"to\" bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = toCurrent(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = toCurrent(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.seriesCurrent-Tuple{PowerSystem, AC}","page":"Power and Current Analysis","title":"JuliaGrid.seriesCurrent","text":"seriesCurrent(system::PowerSystem, analysis::AC; label)\n\nThe function returns the current in the polar coordinate system through series impedance associated with a specific branch in the direction from the \"from\" bus end to the \"to\" bus end of the branch within the AC framework. The label keyword argument must  match an existing branch label.\n\nAbstract type\n\nThe abstract type AC can have the following subtypes:\n\nACPowerFlow: computes the current within the AC power flow;\nACOptimalPowerFlow: computes the current within the AC optimal power flow.\n\nExamples\n\nCompute the current after obtaining the AC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(system, analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(system, analysis)\nend\nmagnitude, angle = seriesCurrent(system, analysis; label = 2)\n\nCompute the current after obtaining the AC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\nmagnitude, angle = seriesCurrent(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#DCPowerAnalysisAPI","page":"Power and Current Analysis","title":"DC Power Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"power!(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.power!","text":"power!(system::PowerSystem, analysis::DC)\n\nThe function calculates the active power values related to buses, branches, and generators within the DC analysis framework. It modifies the power field of the abstract type DC.\n\nUpdates\n\nThis function computes the following electrical quantities:\n\ninjection: active power injections at each bus;\nsupply: active power injections from the generators at each bus;\nfrom: active power flows at each \"from\" bus end of the branch;\nto: active power flows at each \"to\" bus end of the branch;\ngenerator: output active powers of each generator.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the powers within the DC power flow;\nDCOptimalPowerFlow: computes the powers within the DC optimal power flow.\n\nExamples\n\nCompute powers after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\npower!(system, analysis)\n\nCompute powers after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\npower!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"","category":"page"},{"location":"api/analysis/#DCPowerBreakdownAnalysisAPI","page":"Power and Current Analysis","title":"DC Power Breakdown Analysis","text":"","category":"section"},{"location":"api/analysis/","page":"Power and Current Analysis","title":"Power and Current Analysis","text":"injectionPower(::PowerSystem, ::DCPowerFlow)\nsupplyPower(::PowerSystem, ::DCPowerFlow)\nfromPower(::PowerSystem, ::DC)\ntoPower(::PowerSystem, ::DC)\ngeneratorPower(::PowerSystem, ::DCPowerFlow)","category":"page"},{"location":"api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.injectionPower","text":"injectionPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power injection associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow;\n\nExamples\n\nCompute the active power of a specific bus after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\ninjection = injectionPower(system, analysis; label = 2)\n\nCompute the active power of a specific bus after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\ninjection = injectionPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.supplyPower","text":"supplyPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power injection from the generators associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow,\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific bus after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nsupply = supplyPower(system, analysis; label = 2)\n\nCompute the active power of a specific bus after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nsupply = supplyPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, DC}","page":"Power and Current Analysis","title":"JuliaGrid.fromPower","text":"fromPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power flow at the \"from\" bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific branch after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nfrom = fromPower(system, analysis; label = 2)\n\nCompute the active power of a specific branch after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nfrom = fromPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, DC}","page":"Power and Current Analysis","title":"JuliaGrid.toPower","text":"toPower(system::PowerSystem, analysis::DC; label)\n\nThe function returns the active power flow at the \"to\" bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific branch after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\nto = toPower(system, analysis; label = 2)\n\nCompute the active power of a specific branch after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\nto = toPower(system, analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.generatorPower-Tuple{PowerSystem, DCPowerFlow}","page":"Power and Current Analysis","title":"JuliaGrid.generatorPower","text":"generatorPower(system::PowerSystem, analysis::DC; label)\n\nThis function returns the output active power associated with a specific generator in the DC framework. The label keyword argument must match an existing generator label.\n\nAbstract type\n\nThe abstract type DC can have the following subtypes:\n\nDCPowerFlow: computes the power within the DC power flow;\nDCOptimalPowerFlow: computes the power within the DC optimal power flow.\n\nExamples\n\nCompute the active power of a specific generator after obtaining the DC power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(system, analysis)\ngenerator = generatorPower(system, analysis; label = 1)\n\nCompute the active power of a specific generator after obtaining the DC optimal power flow solution:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\ngenerator = generatorPower(system, analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/powerSystemModel/#powerSystemModelAPI","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For further information on this topic, please see the Power System Model section of the Manual. Below, we have provided a list of functions that can be used to create, save, and manipulate power system structures, as well as to build AC or DC models of power systems.","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System-Data","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nupdateBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nupdateBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nupdateGenerator!\ncost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System-Data-2","page":"Power System Model","title":"Power System Data","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.powerSystem","page":"Power System Model","title":"JuliaGrid.powerSystem","text":"powerSystem(file::String)\n\nThe function builds the composite type PowerSystem and populates bus, branch, generator and base fields. In general, once the composite type PowerSystem has been created, it is possible to add new buses, branches, or generators, or modify the parameters of existing ones.\n\nArgument\n\npassing the path to the HDF5 file with the .h5 extension,\npassing the path to Matpower file with the .m extension.\n\nReturns\n\nThe PowerSystem composite type with the following fields:\n\nbus: data related to buses;\nbranch: data related to branches;\ngenerator: data related to generators;\nbase: base power and base voltages;\nmodel: data associated with AC (nonlinear) or DC (linear) analyses;\nuuid: universally unique identifier for the power system.\n\nUnits\n\nJuliaGrid stores all data in per-units and radians format which are fixed, the exceptions are base values in volt-amperes and volts. The prefixes for these base values can be changed using the @base macro.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\n\n\n\n\nAlternatively, the PowerSystem composite type can be initialized by calling the function without any arguments.\n\npowerSystem()\n\nThis allows the model to be built from scratch and modified as needed. This generates an empty PowerSystem type, with only the base power initialized to 1.0e8 volt-amperes (VA).\n\nExample\n\nsystem = powerSystem()\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.savePowerSystem","page":"Power System Model","title":"JuliaGrid.savePowerSystem","text":"savePowerSystem(system::PowerSystem; path::String, reference::String, note::String)\n\nThe function saves the power system's data in the HDF5 file using the fields bus, branch, generator, and base from the PowerSystem composite type.\n\nKeywords\n\nThe location and file name of the HDF5 file is specified by the mandatory keyword path in  the format of \"path/name.h5\". Additional information can be provided by the optional  keywords reference and note, which can be saved along with the power system data.\n\nView HDF5 File\n\nTo view the saved HDF5 file, you can use the HDFView software.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"D:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Bus-Functions-2","page":"Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nupdateBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBus!","page":"Power System Model","title":"JuliaGrid.addBus!","text":"addBus!(system::PowerSystem; label, type, active, reactive, conductance, susceptance,\n    magnitude, angle, minMagnitude, maxMagnitude, base, area, lossZone)\n\nThe function adds a new bus to the PowerSystem composite type.\n\nKeywords\n\nThe bus is defined with the following keywords:\n\nlabel: unique label for the bus;\ntype: the bus type:\ntype = 1: demand bus (PQ);\ntype = 2: generator bus (PV);\ntype = 3: slack bus (Vθ);\nactive (pu or W): the active power demand at the bus;\nreactive (pu or VAr): the reactive power demand at the bus;\nconductance (pu or W): the active power demanded of the shunt element;\nsusceptance (pu or VAr): the reactive power injected of the shunt element;\nmagnitude (pu or V): the initial value of the voltage magnitude;\nangle (rad or deg): the initial value of the voltage angle;\nminMagnitude (pu or V): the minimum voltage magnitude value;\nmaxMagnitude (pu or V): the maximum voltage magnitude value;\nbase (V): the base value of the voltage magnitude;\narea: the area number;\nlossZone: the loss zone.\n\nUpdates\n\nThe function updates the bus field of the PowerSystem composite type.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: type = 1, magnitude = 1.0 per-unit, and base = 138e3 volts. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @bus macro.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 0.25, angle = 0.175, base = 132e3)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 25.0, angle = 10.026, base = 132.0)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.updateBus!","page":"Power System Model","title":"JuliaGrid.updateBus!","text":"updateBus!(system::PowerSystem, analysis::Analysis; kwargs...)\n\nThe function allows for the alteration of parameters for an existing bus.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined process avoids the need to completely rebuild vectors and matrices when adjusting these parameters.\n\nKeywords\n\nTo update a specific bus, provide the necessary kwargs input arguments in accordance with the keywords specified in the addBus! function, along with their respective values. Ensure that the label keyword matches the label of the existing bus you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the bus field within the PowerSystem composite type, and in cases where parameters impact variables in the ac field, it automatically adjusts the field. Furthermore, it guarantees that any modifications to the parameters are transmitted to the Analysis type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addBus! function.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\nupdateBus!(system; label = \"Bus 1\", active = 0.15, susceptance = 0.15)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@bus","page":"Power System Model","title":"JuliaGrid.@bus","text":"@bus(kwargs...)\n\nThe macro generates a template for a bus, which can be utilized to define a bus using the addBus! function.\n\nKeywords\n\nTo define the bus template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBus! function, along with their corresponding values.\n\nUnits\n\nBy default, the keyword parameters use per-units (pu) and radians (rad) as units, with the exception of the base keyword argument, which is in volts (V). However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nCreating a bus template using the default unit system:\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 0.25, angle = 0.1745)\naddBus!(system; label = \"Bus 1\", reactive = -0.04, base = 132e3)\n\nCreating a bus template using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\n@bus(type = 2, active = 25.0, angle = 10.0, base = 132.0)\naddBus!(system; \"Bus 1\", reactive = -4.0)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Branch-Functions-2","page":"Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nupdateBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addBranch!","page":"Power System Model","title":"JuliaGrid.addBranch!","text":"addBranch!(system::PowerSystem, analysis::Analysis; label, from, to, status,\n    resistance, reactance, conductance, susceptance, turnsRatio, shiftAngle,\n    minDiffAngle, maxDiffAngle, longTerm, shortTerm, emergency, type)\n\nThe function adds a new branch to the PowerSystem composite type. A branch can be added between already defined buses.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined approach circumvents the necessity for completely reconstructing vectors and matrices when adding a new branch.\n\nKeywords\n\nThe branch is defined with the following keywords:\n\nlabel: unique label for the branch;\nfrom: from bus label, corresponds to the bus label;\nto: to bus label, corresponds to the bus label;\nstatus: operating status of the branch:\nstatus = 1: in-service;\nstatus = 0: out-of-service;\nresistance (pu or Ω): series resistance;\nreactance (pu or Ω): series reactance;\nconductance (pu or S): total shunt conductance;\nsusceptance (pu or S): total shunt susceptance;\nturnsRatio: transformer off-nominal turns ratio, equal to one for a line;\nshiftAngle (rad or deg): transformer phase shift angle, where positive value defines delay;\nminDiffAngle (rad or deg): minimum voltage angle difference value between from and to bus;\nmaxDiffAngle (rad or deg): maximum voltage angle difference value between from and to bus;\nlongTerm (pu or VA, W): long-term rating (equal to zero for unlimited);\nshortTerm (pu or VA, W): short-term rating (equal to zero for unlimited);\nemergency (pu or VA, W): emergency rating (equal to zero for unlimited);\ntype: types of longTerm, shortTerm, and emergency ratings:\ntype = 1: apparent power flow (pu or VA);\ntype = 2: active power flow (pu or W);\ntype = 3: current magnitude (pu or VA at 1 pu voltage).\n\nUpdates\n\nThe function updates the branch field within the PowerSystem composite type, and in  cases where parameters impact variables in the ac and dc fields, it automatically  adjusts the fields. Furthermore, it guarantees that any modifications to the parameters  are transmitted to the  Analysis type.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1, turnsRatio = 1.0, and type = 1. The  rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @branch macro.\n\nUnits\n\nThe default units for the keyword parameters are per-units (pu) and radians (rad). However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 0.1745)\n\nCreating a branch using a custom unit system:\n\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 10)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.updateBranch!","page":"Power System Model","title":"JuliaGrid.updateBranch!","text":"updateBranch!(system::PowerSystem, analysis::Analysis; kwargs...)\n\nThe function allows for the alteration of parameters for an existing branch.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined process avoids the need to completely rebuild vectors and matrices when adjusting these parameter\n\nKeywords\n\nTo update a specific branch, provide the necessary kwargs input arguments in accordance with the keywords specified in the addBranch! function, along with their respective values. Ensure that the label keyword matches the label of the existing branch you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the branch field within the PowerSystem composite type, and in  cases where parameters impact variables in the ac and dc fields, it automatically  adjusts the fields. Furthermore, it guarantees that any modifications to the parameters  are transmitted to the Analysis type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addBranch! function.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\nupdateBranch!(system; label = \"Branch 1\", reactance = 0.02, susceptance = 0.062)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@branch","page":"Power System Model","title":"JuliaGrid.@branch","text":"@branch(kwargs...)\n\nThe macro generates a template for a branch, which can be utilized to define a branch using the addBranch! function.\n\nKeywords\n\nTo define the branch template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBranch! function, along with their corresponding values.\n\nUnits\n\nThe default units for the keyword parameters are per-units and radians. However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nCreating a branch template using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\n@branch(reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\")\n\nCreating a branch template using a custom unit system:\n\n@voltage(pu, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1,  active = 0.15, reactive = 0.08)\n\n@branch(shiftAngle = 10)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Generator-Functions-2","page":"Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nupdateGenerator!\ncost!\n@generator","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.addGenerator!","page":"Power System Model","title":"JuliaGrid.addGenerator!","text":"addGenerator!(system::PowerSystem, analysis::Analysis; label, bus, status,\n    active, reactive, magnitude, minActive, maxActive, minReactive, maxReactive,\n    lowActive, minLowReactive, maxLowReactive, upActive, minUpReactive, maxUpReactive,\n    loadFollowing, reactiveTimescale, reserve10min, reserve30min, area)\n\nThe function adds a new generator to the PowerSystem composite type. The generator can be added to an already defined bus.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined approach circumvents the necessity for completely reconstructing vectors and matrices when adding a new generator.\n\nKeywords\n\nThe generator is defined with the following keywords:\n\nlabel: a unique label for the generator;\nbus: the label of the bus to which the generator is connected;\nstatus: the operating status of the generator:\nstatus = 1: in-service;\nstatus = 0: out-of-service;\nactive (pu or W): output active power;\nreactive (pu or VAr): output reactive power;\nmagnitude (pu or V): voltage magnitude setpoint;\nminActive (pu or W): minimum allowed output active power value;\nmaxActive (pu or W): maximum allowed output active power value;\nminReactive (pu or VAr): minimum allowed output reactive power value;\nmaxReactive (pu or VAr): maximum allowed output reactive power value;\nlowActive (pu or W): lower allowed active power output value of PQ capability curve;\nminLowReactive (pu or VAr): minimum allowed reactive power output value at lowActive value;\nmaxLowReactive (pu or VAr): maximum allowed reactive power output value at lowActive value;\nupActive (pu or W): upper allowed active power output value of PQ capability curve;\nminUpReactive (pu or VAr): minimum allowed reactive power output value at upActive value;\nmaxUpReactive (pu or VAr): maximum allowed reactive power output value at upActive value;\nloadFollowing (pu/min or W/min): ramp rate for load following/AG;\nreserve10min (pu or W): ramp rate for 10-minute reserves;\nreserve30min (pu or W): ramp rate for 30-minute reserves;\nreactiveTimescale (pu/min or VAr/min): ramp rate for reactive power, two seconds timescale;\narea: area participation factor.\n\nUpdates\n\nThe function updates the generator field within the PowerSystem composite type, and in  cases where parameters impact variables in the bus field, it automatically adjusts the  field. Furthermore, it guarantees that any modifications to the parameters are transmitted  to the Analysis type.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1 and magnitude = 1.0 per-unit. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @generator macro.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 0.2, base = 132e3)\n\naddGenerator!(system; bus = \"Bus 1\", active = 0.5, magnitude = 1.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 20, base = 132)\n\naddGenerator!(system; bus = \"Bus 1\", active = 50, magnitude = 145.2)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.updateGenerator!","page":"Power System Model","title":"JuliaGrid.updateGenerator!","text":"updateGenerator!(system::PowerSystem, analysis::Analysis; kwargs...)\n\nThe function allows for the alteration of parameters for an existing generator.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined process avoids the need to completely rebuild vectors and matrices when adjusting these parameter\n\nKeywords\n\nTo update a specific generator, provide the necessary kwargs input arguments in accordance with the keywords specified in the addGenerator! function, along with their respective values. Ensure that the label keyword matches the label of the existing generator you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the generator field within the PowerSystem composite type, and in  cases where parameters impact variables in the bus field, it automatically adjusts the  field. Furthermore, it guarantees that any modifications to the parameters are transmitted  to the Analysis type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addBranch! function.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 0.2, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5)\nupdateGenerator!(system; label = \"Generator 1\", active = 0.6, reactive = 0.2)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.cost!","page":"Power System Model","title":"JuliaGrid.cost!","text":"cost!(system::PowerSystem, analysis::Analysis; label, cost, \n    model, piecewise, polynomial)\n\nThe function either adds a new cost or modifies an existing one for the active or reactive  power generated by the corresponding generator within the PowerSystem composite type.  It has the capability to append a cost to an already defined generator.\n\nArguments\n\nIf the Analysis type is omitted, the function applies changes to the PowerSystem composite type only. However, when including the Analysis type, it updates both the PowerSystem and Analysis types. This streamlined approach circumvents the necessity for completely reconstructing vectors and matrices when adding a new branch.\n\nKeywords\n\nThe function accepts four keywords:\n\nlabel: corresponds to the already defined generator label;\ncost: cost type:\ncost = :active: adding cost for the active power;\ncost = :reactive: adding cost for the reactive power;  \nmodel: cost model:\nmodel = 1: piecewise linear is being used;\nmodel = 2: polynomial is being used;\npiecewise: cost model defined by input-output points given as Array{Float64,2}:\nfirst column (pu or W): active power output of the generator;\nsecond column (currency/hr): cost for the specified active power output;\npolynomial: n-th degree polynomial coefficients given as Array{Float64,1}:\nfirst element (currency/puⁿhr or currency/Wⁿhr): coefficient of the n-th degree term, ...;\npenultimate element (currency/puhr or currency/Whr): coefficient of the first degree term;\nlast element (currency/hr): constant coefficient.\n\nUpdates\n\nThe function updates the generator.cost field within the PowerSystem composite type.  Furthermore, it guarantees that any modifications to the parameters are transmitted  to the Analysis type.\n\nDefault Settings\n\nBy default, the cost type is set to cost = :active. Additionally, when adding only a  piecewise or polynomial cost function, you can omit the model keyword, as the  appropriate model will be assigned based on the defined cost function.\n\nUnits\n\nBy default, the input units related with active powers are per-units (pu), but they can be modified using the macro @power.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 0.25, reactive = -0.04, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5)\ncost!(system; label = \"Generator 1\", polynomial = [1100.0; 500.0; 150.0])\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 25, reactive = -4, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 50, reactive = 10)\ncost!(system; label = \"Generator 1\", polynomial = [0.11; 5.0; 150.0])\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@generator","page":"Power System Model","title":"JuliaGrid.@generator","text":"@generator(kwargs...)\n\nThe macro generates a template for a generator, which can be utilized to define a generator using the addGenerator! function.\n\nKeywords\n\nTo define the generator template, the kwargs input arguments must be provided in accordance with the keywords specified within the addGenerator! function, along with their corresponding values.\n\nUnits\n\nBy default, the input units are associated with per-units (pu) as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nCreating a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 0.25, reactive = -0.04, base = 132e3)\n\n@generator(magnitude = 1.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5, reactive = 0.1)\n\nCreating a bus using a custom unit system:\n\n@power(MW, MVAr, MVA)\n@voltage(kV, deg, kV)\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 25, reactive = -4, base = 132)\n\n@generator(magnitude = 145.2)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 50, reactive = 10)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#AC-and-DC-Model-2","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/#JuliaGrid.acModel!","page":"Power System Model","title":"JuliaGrid.acModel!","text":"acModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with AC analyses.\n\nUpdates\n\nThe function modifies the model.ac field within the PowerSystem composite type, populating the following variables:\n\nnodalMatrix: the nodal matrix;\nnodalMatrixTranspose: the transpose of the nodal matrix;\nnodalFromFrom: the Y-parameters of the two-port branches;\nnodalFromTo: the Y-parameters of the two-port branches;\nnodalToTo: the Y-parameters of the two-port branches;\nnodalToFrom: the Y-parameters of the two-port branches;\nadmittance: the branch admittances.\n\nOnce these variables are established, they will be automatically adjusted upon using the following functions:\n\nshuntBus!,\naddBranch!,\nstatusBranch!,\nparameterBranch!.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.dcModel!","page":"Power System Model","title":"JuliaGrid.dcModel!","text":"dcModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with DC analyses.\n\nUpdates\n\nThe function modifies the model.dc field within the PowerSystem composite type, populating the following variables:\n\nnodalMatrix: the nodal matrix;\nadmittance: the branch admittances;\nshiftActivePower: the active powers related to phase-shifting transformers.\n\nOnce these variables are established, they will be automatically adjusted upon using the following functions:\n\naddBranch!,\nstatusBranch!,\nparameterBranch!.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"#JuliaGrid","page":"Introduction","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver, and allows a variety of display and manipulation options.","category":"page"},{"location":"api/optimalPowerFlow/#OptimalPowerFlowAPI","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"For further information on this topic, please see the AC Optimal Power Flow or DC Optimal Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for optimal power flow analysis.","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Build-AC-Optimal-Power-Flow-Model","page":"Optimal Power Flow","title":"Build AC Optimal Power Flow Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"acOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#Solve-AC-Optimal-Power-Flow","page":"Optimal Power Flow","title":"Solve AC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!","category":"page"},{"location":"api/optimalPowerFlow/#Build-DC-Optimal-Power-Flow-Model","page":"Optimal Power Flow","title":"Build DC Optimal Power Flow Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"dcOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#Solve-DC-Optimal-Power-Flow","page":"Optimal Power Flow","title":"Solve DC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Build-AC-Optimal-Power-Flow-Model-2","page":"Optimal Power Flow","title":"Build AC Optimal Power Flow Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"acOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.acOptimalPowerFlow","text":"acOptimalPowerFlow(system::PowerSystem, optimizer; bridge, name, balance, limit,\n    rating, capability)\n\nThe function takes the PowerSystem composite type as input to establish the structure for solving the AC optimal power flow. The optimizer argument is also required to create and solve the optimization problem. If the ac field within the PowerSystem composite type has not been created, the function will initiate an update automatically.\n\nKeywords\n\nJuliaGrid offers the ability to manipulate the jump model based on the guidelines provided in the JuMP documentation. However, certain configurations may require different method calls, such as:\n\nbridge: used to manage the bridging mechanism;\nname: used to manage the creation of string names.\n\nMoreover, we have included keywords that regulate the usage of different types of constraints:\n\nbalance: controls the equality constraints that relate to the active and reactive power balance equations;\nlimit: controls the inequality constraints that relate to the voltage magnitude and angle differences between buses;\nrating: controls the inequality constraints that relate to the long-term rating of branches;\ncapability: controls the inequality constraints that relate to the active and reactive power generator outputs.\n\nBy default, all of these keywords are set to true and are of the Bool type.\n\nJuMP\n\nThe JuliaGrid builds the AC optimal power flow around the JuMP package and supports commonly used solvers. For more information, refer to the JuMP documenatation.\n\nReturns\n\nThe function returns an instance of the ACOptimalPowerFlow type, which includes the following fields:\n\nvoltage: the bus voltage magnitudes and angles;\npower: the variable allocated to store the active and reactive powers;\ncurrent: the variable allocated to store the currents;\njump: the JuMP model;\nconstraint: holds the constraint references to the JuMP model.\n\nExamples\n\nCreate the complete AC optimal power flow model:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\n\nCreate the AC optimal power flow model without rating constraints:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer; rating = false)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Solve-AC-Optimal-Power-Flow-2","page":"Optimal Power Flow","title":"Solve AC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!(::PowerSystem, ::ACOptimalPowerFlow)","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::ACOptimalPowerFlow)\n\nThe function finds the AC optimal power flow solution and calculate the bus voltage magnitudes and angles, and output active and reactive powers of each generators.\n\nThe calculated voltage magnitudes and angles and active and reactive powers are then stored in the variables of the voltage and power fields of the ACOptimalPowerFlow composite type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Build-DC-Optimal-Power-Flow-Model-2","page":"Optimal Power Flow","title":"Build DC Optimal Power Flow Model","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"dcOptimalPowerFlow","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.dcOptimalPowerFlow","text":"dcOptimalPowerFlow(system::PowerSystem, optimizer; bridge, name, balance, limit,\n    rating, capability)\n\nThe function takes the PowerSystem composite type as input to establish the structure for solving the DC optimal power flow. The optimizer argument is also required to create and solve the optimization problem. If the dc field within the PowerSystem composite type has not been created, the function will initiate an update automatically.\n\nKeywords\n\nJuliaGrid offers the ability to manipulate the jump model based on the guidelines provided in the JuMP documentation. However, certain configurations may require different method calls, such as:\n\nbridge: used to manage the bridging mechanism;\nname: used to manage the creation of string names.\n\nMoreover, we have included keywords that regulate the usage of different types of constraints:\n\nbalance: controls the equality constraints that relate to the active power balance equations;\nlimit: controls the inequality constraints that relate to the voltage angle differences between buses;\nrating: controls the inequality constraints that relate to the long-term rating of branches;\ncapability: controls the inequality constraints that relate to the active power generator outputs.\n\nBy default, all of these keywords are set to true and are of the Bool type.\n\nJuMP\n\nThe JuliaGrid builds the DC optimal power flow around the JuMP package and supports commonly used solvers. For more information, refer to the JuMP documenatation.\n\nReturns\n\nThe function returns an instance of the DCOptimalPowerFlow type, which includes the following fields:\n\nvoltage: the variable allocated to store the bus voltage angle,\npower: the variable allocated to store the active powers,\njump: the JuMP model,\nconstraint: holds the constraint references to the JuMP model.\n\nExamples\n\nCreate the complete DC optimal power flow model:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\n\nCreate the DC optimal power flow model without rating constraints:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer; rating = false)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Solve-DC-Optimal-Power-Flow-2","page":"Optimal Power Flow","title":"Solve DC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"solve!(::PowerSystem, ::DCOptimalPowerFlow)","category":"page"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(system::PowerSystem, analysis::DCOptimalPowerFlow)\n\nThe function finds the DC optimal power flow solution and calculate the bus voltage angles and output active powers of the generators.\n\nThe calculated voltage angles and active powers are then stored in the angle variable of the voltage field and the generator variable of the power field.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)\nsolve!(system, analysis)\n\n\n\n\n\n","category":"method"}]
}
