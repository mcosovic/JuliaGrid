<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State Estimation Routines · JuliaGrid</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuliaGrid</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../input/">Input Data</a></li><li><a class="tocitem" href="../flow/">Power Flow</a></li><li><a class="tocitem" href="../optimalflow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../estimation/">State Estimation</a></li><li><a class="tocitem" href="../generator/">Measurement Generator</a></li><li><span class="tocitem">Theoretical Background</span><ul><li><a class="tocitem" href="../tbbranch/">Network Equations</a></li><li><a class="tocitem" href="../tbflow/">Power Flow</a></li><li><a class="tocitem" href="../tboptimal/">Optimal Power Flow</a></li><li><a class="tocitem" href="../tbestimate/">State Estimation</a></li><li class="is-active"><a class="tocitem" href>State Estimation Routines</a><ul class="internal"><li><a class="tocitem" href="#baddata"><span>Bad Data Processing</span></a></li><li><a class="tocitem" href="#lav"><span>Least Absolute Value Method</span></a></li><li><a class="tocitem" href="#observability"><span>Observability Analysis</span></a></li><li><a class="tocitem" href="#optimalpmu"><span>Optimal PMU Placement</span></a></li><li><a class="tocitem" href="#refrestestimate"><span>References</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Theoretical Background</a></li><li class="is-active"><a href>State Estimation Routines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State Estimation Routines</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/man/tbestimaterest.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="baddata"><a class="docs-heading-anchor" href="#baddata">Bad Data Processing</a><a id="baddata-1"></a><a class="docs-heading-anchor-permalink" href="#baddata" title="Permalink"></a></h2><p>We refer the reader to section <a href="../tbestimate/#stateestimation">State Estimation</a> which precedes the analysis given here. Besides the state estimation algorithm, one of the essential state estimation routines is the bad data processing, whose main task is to detect and identify measurement errors, and eliminate them if possible. State Estimation algorithms proceed with the bad data processing after the estimation process is finished. This is usually done by processing the measurement residuals <a href="#refrestestimate">[1, Ch. 5]</a>, and typically, the largest normalized residual test is used to identify bad data. The largest normalized residual test is performed after the algorithm converged in the repetitive process of identifying and eliminating bad data measurements one after another <a href="#refrestestimate">[2]</a>. The bad data processing described below is associated with the commonly used weighted least-squares methods. More precisely, state estimation methods, such as the least absolute value estimation, incorporate bad data processing as part of the state estimation procedure <a href="#refrestestimate">[1, Ch. 5]</a>.</p><p>This section describes the largest normalized residual test based on the residual sensitivity analysis given in <a href="#refrestestimate">[1, Sec. 5.7]</a>. Using weighted least-squares estimation methods (non-linear or linear), we obtained the state estimator <span>$\hat{\mathbf x}$</span> and elements of the measurement residual vector:</p><div>\[    r_{i} = z_i - h_i(\hat{\mathbf x}), \;\;\; i \in \mathcal{M}.\]</div><p>Normalized residual is defined as:</p><div>\[    c_{i} = \cfrac{|r_i|}{\sqrt{C_{ii}}}, \;\;\; i \in \mathcal{M},\]</div><p>where <span>$C_{ii}$</span> is the diagonal entries of the residual covariance matrix <span>$\mathbf C \in \mathbb{R}^{k \times k}$</span>. Using a residual sensitivity matrix <span>$\mathbf S$</span>, which represents the sensitivity of the measurement residuals to the measurement errors, the above equation becomes:</p><div>\[    c_{i} = \cfrac{|r_i|}{\sqrt{S_{ii}R_{ii}}}, \;\;\; i \in \mathcal{M},\]</div><p>where:</p><div>\[    \mathbf C = \mathbf S \mathbf R = \mathbf R - \mathbf J [\mathbf J^T \mathbf R^{-1} \mathbf J]^{-1} \mathbf J^T.\]</div><p>Note that only the diagonal entries of <span>$\mathbf C$</span> are needed. To obtain the inverse:</p><div>\[    [\mathbf J^T \mathbf R^{-1} \mathbf J]^{-1},\]</div><p>the JuliaGrid package uses a computationally efficient sparse inverse method to obtain only the necessary elements of the inverse. However, if the largest normalized residual:</p><div>\[    c_{j} \ge \epsilon; \;\;\; c_j = \text{max} \{c_i, i \in \mathcal{M} \},\]</div><p>then the <span>$j$</span>-th measurement will be suspected as the bad data and removed from the measurement set <span>$\mathcal{M}$</span> if possible, where <span>$\epsilon$</span> is a chosen the bad data identification threshold. State estimation can be repeated after the measurement is eliminated, in order to compute the new state estimate <span>$\hat{\mathbf x}$</span>.  Thus, we have the iterative process that sequentially identifies and eliminates bad data measurements one after another.</p><p>The elimination of measurements is possible only for the redundant measurements. Namely, the removal of critical or non-redundant measurements from the measurement set will result in an unobservable system. Furthermore, the measurement residual of a critical measurement will be always approximately equal to zero <a href="#refrestestimate">[1, Sec. 5.2]</a>. More precisely, if the measurement residual:</p><div>\[    |r_{i}| \le \gamma, \;\;\; i \in \mathcal{M},\]</div><p>JuliaGrid designates the corresponding measurement as critical, where <span>$\gamma$</span> is a predetermined critical measurement criteria.</p><hr/><h2 id="lav"><a class="docs-heading-anchor" href="#lav">Least Absolute Value Method</a><a id="lav-1"></a><a class="docs-heading-anchor-permalink" href="#lav" title="Permalink"></a></h2><p>The least absolute value method represents an alternative estimation method which is more robust as compared to the weighted least-squares. The weighted least-squares state estimation problem is formulated based on certain assumptions about the measurement errors, while robust estimators are expected to remain unbiased despite the existence of different types of measurement errors and outliers, making the bad data processing unnecessary <a href="#refrestestimate">[1, Ch. 6]</a>. Note that there is no free lunch, robustness is commonly achieved at the expense of computational complexity.</p><p>In the case of least absolute value method, it can be shown that the problem can be formulated as a linear programming problem, and this section describes the method given in <a href="#refrestestimate">[1, Sec. 6.5]</a>. Let us consider the system of linear equations:</p><div>\[  \mathbf{z}=\mathbf{h}(\mathbf{x})+\mathbf{u},\]</div><p>where <span>$\mathbf {x}=[x_1,\dots,x_{s}]^{T}$</span> is the vector of the state variables, <span>$\mathbf{h}(\mathbf{x})=$</span> <span>$[h_1(\mathbf{x})$</span>, <span>$\dots$</span>, <span>$h_k(\mathbf{x})]^{{T}}$</span> is the vector of linear functions, <span>$\mathbf{z} = [z_1,\dots,z_k]^{\mathrm{T}}$</span> is the vector of measurement values, and <span>$\mathbf{u} = [u_1,\dots,u_k]^{\mathrm{T}}$</span> is the vector of uncorrelated measurement errors. Then, the least absolute value state estimator <span>$\hat{\mathbf x}$</span> is defined as the solution of the optimization problem:</p><div>\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf a^T |\mathbf r(\mathbf x)|\\
    \text{subject\;to}&amp; \;\;\; \mathbf{z} - \mathbf{J}\mathbf{x} =\mathbf r(\mathbf x),
  \end{aligned}\]</div><p>where <span>$\mathbf a \in \mathbb {R}^{k}$</span> is the vector with all entries equal to one, <span>$\mathbf J \in \mathbb {R}^{k \times s}$</span> is the Jacobian matrix of measurement functions <span>$\mathbf h (\mathbf x)$</span>, and <span>$\mathbf r (\mathbf x)$</span> is the vector of measurement residuals. Further, we define <span>$\bm \eta$</span>:</p><div>\[  |\mathbf r(\mathbf x)| \preceq \bm \eta,\]</div><p>and replace the above inequality by two equalities via the introduction of two non-negative slack variables <span>$\mathbf q \in \mathbb {R}_{\ge 0}^{k}$</span> and <span>$\mathbf w \in \mathbb {R}_{\ge 0}^{k}$</span>:</p><div>\[  \begin{aligned}
    \mathbf r(\mathbf x) - \mathbf q &amp;= -\bm \eta \\
    \mathbf r(\mathbf x) + \mathbf w &amp;= \bm \eta.
  \end{aligned}\]</div><p>Let us now define four additional non-negative variables:</p><div>\[  \begin{aligned}
    \mathbf {x_y} \in \mathbb {R}_{\ge 0}^{s}; \;\;\; \mathbf {x_v} \in \mathbb {R}_{\ge 0}^{s} \\   
    \mathbf {y} \in \mathbb {R}_{\ge 0}^{k}; \;\;\; \mathbf {v} \in \mathbb {R}_{\ge 0}^{k},
  \end{aligned}\]</div><p>where:</p><div>\[  \begin{aligned}
    \mathbf {x} &amp;= \mathbf {x_y} - \mathbf {x_v} \\
    \mathbf r(\mathbf x) &amp;= \mathbf {y} - \mathbf {v} \\
    \mathbf {y} &amp;= \cfrac{1}{2} \mathbf q \\
    \mathbf {v} &amp;= \cfrac{1}{2} \mathbf w.
  \end{aligned}\]</div><p>Then, the above two equalities become:</p><div>\[  \begin{aligned}
    \mathbf r(\mathbf x) - 2\mathbf y &amp;= -2\bm \eta \\
    \mathbf r(\mathbf x) + 2\mathbf v &amp;= 2\bm \eta,
  \end{aligned}\]</div><p>that is:</p><div>\[  \begin{aligned}
    \mathbf y + \mathbf v = \bm \eta; \;\;\; \mathbf r(\mathbf x) = \mathbf y - \mathbf v.
  \end{aligned}\]</div><p>Hence, the optimization problem can be written:</p><div>\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf a^T (\mathbf y + \mathbf v)\\
    \text{subject\;to}&amp; \;\;\; \mathbf{J}(\mathbf {x_y} - \mathbf {x_v}) + \mathbf y - \mathbf v = \mathbf{z}   \\
                       &amp; \;\;\; \mathbf {x_y} \succeq \mathbf 0, \; \mathbf {x_v} \succeq \mathbf 0 \\
                       &amp; \;\;\; \mathbf {y} \succeq \mathbf 0, \; \mathbf {v} \succeq \mathbf 0.
  \end{aligned}\]</div><p>This can be written in compact form as a standard linear programming problem:</p><div>\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf g^T \mathbf t \\
    \text{subject\;to}&amp; \;\;\; \mathbf{A} \mathbf{t} = \mathbf z \\
                       &amp; \;\;\; \mathbf{t} \succeq \mathbf 0,
  \end{aligned}\]</div><p>where:</p><div>\[  \mathbf g =
  \begin{bmatrix}
    \mathbf 0_{s} \\ \mathbf 0_{s} \\ \mathbf 1_{k} \\ \mathbf 1_{k}
  \end{bmatrix}; \;\;\;
  \mathbf t =
  \begin{bmatrix}
    \mathbf {x_y} \\ \mathbf {x_v} \\ \mathbf {y} \\ \mathbf {v}
  \end{bmatrix}; \;\;\;
  \mathbf A =
  \begin{bmatrix}
    \mathbf{J} &amp; -\mathbf{J} &amp; \mathbf{E} &amp; -\mathbf{E}
  \end{bmatrix}.\]</div><p>Here, the all-zero vector <span>$\mathbf 0_{s}$</span> is of dimension <span>$s$</span>, the all-one vector <span>$\mathbf 1_{k}$</span> is of dimension <span>$k$</span> and <span>$\mathbf{E}$</span> is the identity matrix of dimension <span>$k \times k$</span>. After solving the above linear programming problem, we reveal the state estimator:</p><div>\[    \hat{\mathbf {x}} = \mathbf {x_y} - \mathbf {x_v}.\]</div><p>Note that the non-linear least absolute value state estimation is based on the successive set of linear programming problems, where we reveal state variables increments:</p><div>\[    \mathbf {\mathbf \Delta x} = \mathbf {\mathbf \Delta x_y} - \mathbf {\mathbf \Delta x_v}.\]</div><hr/><h2 id="observability"><a class="docs-heading-anchor" href="#observability">Observability Analysis</a><a id="observability-1"></a><a class="docs-heading-anchor-permalink" href="#observability" title="Permalink"></a></h2><p>Observability analysis in power systems is commonly performed on the linear decoupled measurement model <a href="#refrestestimate">[14, Ch. 7]</a>. Its function is to decide if the given set of measurements <span>$\mathcal{M}$</span> is sufficient to solve the system. When the given set of measurements <span>$\mathcal{M}$</span> is not sufficient, it must identify all the possible observable islands that can be independently solved <a href="#refrestestimate">[4]</a>.</p><p>The JuliaGrid uses the observability analysis with the restore routine proposed in the papers <a href="#refrestestimate">[5]</a> and <a href="#refrestestimate">[6]</a>, where pseudo-measurements are chosen in place of measurements that are marked as out-of-service in the input data.</p><h3 id="Linear-DC-State-Estimation"><a class="docs-heading-anchor" href="#Linear-DC-State-Estimation">Linear DC State Estimation</a><a id="Linear-DC-State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-DC-State-Estimation" title="Permalink"></a></h3><p>We observe the set of measurements <span>$\mathcal{M}$</span> in the DC framework:</p><ul><li>Legacy measurements:<ul><li>active power flow <span>$\{M_{P_{ij}}, M_{P_{ji}}\}, \; (i,j) \in \mathcal{E}$</span>;</li><li>active power injection <span>$\{M_{P_{i}}\}, \; i \in \mathcal{H}$</span>;</li></ul></li><li>Phasor measurements provided by PMUs:<ul><li>bus voltage angle <span>$\{{M}_{{\theta}_{i}}\}, \; i \in \mathcal{H}$</span>.</li></ul></li></ul><p>To recall, the measurement model can be described as:</p><div>\[  \mathbf{z}=\mathbf J \bm \theta + \mathbf{c} + \mathbf{u},\]</div><p>where <span>$\bm {\theta}=[\theta_1,\dots,\theta_{s}]^{T}$</span> is the vector of the state variables, <span>$\mathbf J \in \mathbb{R}^{k \times s}$</span> is the measurement Jacobian matrix, <span>$\mathbf c \in \mathbb {R}^{k}$</span> is the vector of constant terms, <span>$\mathbf{z} = [z_1,\dots,z_k]^{\mathrm{T}}$</span> is the vector of measurement values, and <span>$\mathbf{u} = [u_1,\dots,u_k]^{\mathrm{T}}$</span> is the vector of uncorrelated measurement errors.</p><p>For observability purposes, we consider the Jacobian matrix <span>$\mathbf J$</span>. The network is observable if:</p><div>\[  \text{rank}(\mathbf J) = s,\]</div><p>where the slack bus is always included in the measurement model, as well as its equation. Note that the condition provides a necessary but not sufficient condition for observability. For most power systems under normal operating conditions, observability condition will guarantee a reliable state estimate <a href="#refrestestimate">[6]</a>. More precisely, guaranteeing observability by the condition is not the same as guaranteeing a good estimation of the system state. This is so because numerical problems may deteriorate the estimation <a href="#refrestestimate">[7]</a>.</p><p>If the system is unobservable:</p><div>\[  \text{rank}(\mathbf J) &lt; s,\]</div><p>the observability analysis must identify all the possible observable islands that can be independently solved, where an observable island is defined as follows: An observable island is a part of the power system for which the flows across all branches of the observable island can be calculated from the set of available measurements, independent of the values adopted for angular reference <a href="#refrestestimate">[3, Sec. 7.1.1]</a>. Once the islands are determined, the observability analysis merges these islands in a way to protect previously-determined observable states from being altered by the new set of equations defined by the additional measurements. In general, this can be achieved by ensuring that the set of new measurements is a non-redundant set <a href="#refrestestimate">[3, Sec. 7.3.2]</a>,  i.e., the set of equations must be linearly independent with regard to the global system. The aim of the observability restoration is to find this non-redundant set.</p><h4 id="Determination-of-Observable-Islands"><a class="docs-heading-anchor" href="#Determination-of-Observable-Islands">Determination of Observable Islands</a><a id="Determination-of-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Determination-of-Observable-Islands" title="Permalink"></a></h4><p>The JuliaGrid uses several island detection algorithms:</p><ul><li>the topological method based on the multi-stage procedure <a href="#refrestestimate">[11]</a>,</li><li>the Gaussian belief propagation based method <a href="#refrestestimate">[12]</a>.</li></ul><p>The observable islands are defined only according to the power flow and the power injection measurement functions, whereby bus voltage angle measurements are ignored. The algorithms allow the identification of two types of islands on the basis of which it will be executed observability restoration. The simplest structure of the observable islands is formed using all the active power flow measurements to identify the flow islands <a href="#refrestestimate">[6]</a>. Then, these islands can be merged using the active power injection measurements to form maximal islands as the largest region in which an unobservable system is partitioned <a href="#refrestestimate">[5]</a>.</p><h4 id="Observability-Restoration"><a class="docs-heading-anchor" href="#Observability-Restoration">Observability Restoration</a><a id="Observability-Restoration-1"></a><a class="docs-heading-anchor-permalink" href="#Observability-Restoration" title="Permalink"></a></h4><p>As a result, we obtain the power system divided into <span>$n_{\text{i}}$</span> flow islands. Next, we observe the set of measurements <span>$\mathcal{M}_\text{b}$</span> that includes:</p><ul><li>active power injection measurements at boundary buses,</li><li>bus voltage angle measurements.</li></ul><p>Let us introduce the matrix <span>$\mathbf W_{\text{b}} \in \mathbb{R}^{n_{\text{b}} \times n_{\text{i}}}$</span>, where <span>$n_{\text{b}} = |\mathcal{M}_\text{b}|$</span> is the total number of measurements from the set <span>$\mathcal{M}_\text{b}$</span>. This matrix can be viewed as the Jacobian of a reduced network having <span>$n_{\text{i}}$</span> columns associated with flow islands, and <span>$n_{\text{b}}$</span> rows related to the set <span>$\mathcal{M}_\text{b}$</span>. Measurement functions related to the set <span>$\mathcal{M}_\text{b}$</span> define the Jacobian matrix <span>$\mathbf J_\text{b}$</span>, where the matrix <span>$\mathbf W_{\text{b}}$</span> is formed by summing the columns of <span>$\mathbf J_\text{b}$</span> belonging to a particular flow island <a href="#refrestestimate">[6]</a>.</p><p>Furthermore, we define the reduced Jacobian matrix <span>$\mathbf W_{\text{p}} \in \mathbb{R}^{n_{\text{p}} \times n_{\text{i}}}$</span> associated with the set of candidate pseudo-measurements <span>$\mathcal{M}_\text{p}$</span>:</p><ul><li>active power flow measurements between boundary buses,</li><li>active power injection measurements at unmeasured boundary buses,</li><li>bus voltage angle measurements at unmeasured boundary buses,</li></ul><p>where <span>$n_{\text{p}} = |\mathcal{M}_\text{p}|$</span> is the total number of candidate pseudo-measurements from the set <span>$\mathcal{M}_\text{p}$</span>. As before, measurement functions related to the set <span>$\mathcal{M}_\text{p}$</span> define the Jacobian matrix <span>$\mathbf J_\text{p}$</span>, where the matrix <span>$\mathbf W_{\text{p}}$</span> is formed by summing the columns of <span>$\mathbf J_\text{p}$</span> belonging to a particular flow island.</p><p>Thus, we form the reduced Jacobian matrix as:</p><div>\[  \mathbf W_{\text{bp}} = \begin{bmatrix} \mathbf W_{\text{b}} \\ \mathbf W_{\text{p}} \end{bmatrix},\]</div><p>and the corresponding Gram matrix:</p><div>\[  \mathbf M_{\text{bp}} = \mathbf W_{\text{bp}} \mathbf W_{\text{bp}}^T.\]</div><p>Let <span>$\mathbf M_{\text{bp}}$</span> be decomposed into its <span>$\mathbf Q$</span> and <span>$\mathbf R$</span> factors. Non-redundant measurements correspond to non-zero diagonal elements in <span>$\mathbf R$</span>. More precisely, if the diagonal element:</p><div>\[    |R_{ii}| &lt; \epsilon,\]</div><p>JuliaGrid marks the corresponding measurement as redundant, where <span>$\epsilon$</span> is a predetermined zero pivot threshold. The minimal set of pseudo-measurements for observability restoration corresponds to the non-zero diagonal elements at positions related to the candidate pseudo-measurements.   </p><p>Note that the incorrect choice of the zero pivot threshold may deteriorate observability restoration. Also, it can happen that the set of pseudo-measurements <span>$\mathcal{M}_\text{p}$</span> are not sufficient for observability restoration.</p><hr/><h2 id="optimalpmu"><a class="docs-heading-anchor" href="#optimalpmu">Optimal PMU Placement</a><a id="optimalpmu-1"></a><a class="docs-heading-anchor-permalink" href="#optimalpmu" title="Permalink"></a></h2><p>The JuliaGrid uses the optimal PMU placement algorithm proposed in <a href="#refrestestimate">[9]</a>. The optimal placement of PMUs is formulated as a problem of integer linear programming, as follows:</p><div>\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \sum_{i=1}^n x_i\\
    \text{subject\;to}&amp; \;\;\; \mathbf A \mathbf x \ge \mathbf b.
  \end{aligned}\]</div><p>Here, the vector <span>$\mathbf x = [x_1,\dots,x_n]^T$</span> is the optimization variable, where <span>$x_i \in \mathbb{F} = \{0,1\}$</span> is the PMU placement or a binary decision variable related to the bus <span>$i \in \mathcal{H}$</span>. The all-one vector <span>$\mathbf b$</span> is of dimension <span>$n$</span>. The binary connectivity matrix <span>$\mathbf A \in \mathbb{F}^{n \times n}$</span> can be directly obtained from the bus admittance matrix <span>$\mathbf Y$</span> by transforming its entries into binary form <a href="#refrestestimate">[10]</a>.</p><p>As a result, we observe the binary vector <span>$\mathbf x = [x_1,\dots,x_n]^T$</span>, where <span>$x_i = 1$</span>, <span>$i \in \mathcal{H}$</span>, suggests that we should place a PMU at bus <span>$i$</span>. Here, the objective of placing PMUs in the power system is to decide a minimal set of PMUs such that the whole system is observable without legacy measurements <a href="#refrestestimate">[9]</a>.</p><hr/><h2 id="refrestestimate"><a class="docs-heading-anchor" href="#refrestestimate">References</a><a id="refrestestimate-1"></a><a class="docs-heading-anchor-permalink" href="#refrestestimate" title="Permalink"></a></h2><p>[1] A. Abur and A. Exposito, <em>Power System State Estimation: Theory and Implementation</em>, ser. Power Engineering. Taylor &amp; Francis, 2004.</p><p>[2] G. N. Korres, &quot;A distributed multiarea state estimation,&quot; <em>IEEE Trans. Power Syst.</em>, vol. 26, no. 1, pp. 73–84, Feb. 2011.</p><p>[3] A. Monticelli, <em>State Estimation in Electric Power Systems: A Generalized Approach</em>, ser. Kluwer international series in engineering and computer science. Springer US, 1999.</p><p>[4] B. Gou, &quot;Jacobian matrix-based observability analysis for state estimation,&quot; <em>IEEE Trans. Power Syst.</em>, vol. 21, no. 1, pp. 348–356, Feb. 2006.</p><p>[5] G. C. Contaxis and G. N. Korres, &quot;A Reduced Model for Power System Observability Analysis and Restoration,&quot; <em>IEEE Trans. Power Syst.</em>, vol. 3, no. 4, pp. 1411-1417, Nov. 1988.</p><p>[6] N. M. Manousakis and G. N. Korres, &quot;Observability analysis for power systems including conventional and phasor measurements,&quot; <em>in Proc. MedPower 2010</em>, Agia Napa, 2010, pp. 1-8.</p><p>[7] G. N. Korres, &quot;Observability Analysis Based on Echelon Form of a Reduced Dimensional Jacobian Matrix,&quot; <em>IEEE Trans. Power Syst.</em>, vol. 26, no. 4, pp. 2572-2573, Nov. 2011.</p><p>[8] M. C. de Almeida, E. N. Asada, and A. V. Garcia, &quot;Power system observability analysis based on gram matrix and minimum norm solution,&quot; <em>IEEE Trans. Power Syst.</em>, vol. 23, no. 4, pp. 1611–1618, Nov. 2008.</p><p>[9] B. Gou, &quot;Optimal placement of PMUs by integer linear programming,&quot; <em>IEEE Trans. Power Syst.</em>, vol. 23, no. 3, pp. 1525–1526, Aug. 2008.</p><p>[10] B. Xu and A. Abur, &quot;Observability analysis and measurement placement for systems with PMUs,&quot; <em>in Proc. IEEE PES PSCE</em>, New York, NY, 2004, pp. 943-946 vol.2.</p><p>[11] H. Horisberger, &quot;Observability analysis for power systems with measurement deficiencies,&quot; <em>IFAC Proceedings Volumes</em>, vol. 18, no. 7, pp.51–58, 1985.</p><p>[12] M. Cosovic and D. Vukobratovic, &quot;Observability analysis for large-scale power systems using factor graphs&quot;, arXiv:1907.10338 (2019).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tbestimate/">« State Estimation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 4 October 2020 14:05">Sunday 4 October 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
