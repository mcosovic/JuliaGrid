<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State Estimation Routines · JuliaGrid</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuliaGrid</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../input/">Input Data</a></li><li><a class="tocitem" href="../flow/">Power Flow</a></li><li><a class="tocitem" href="../estimation/">State Estimation</a></li><li><a class="tocitem" href="../generator/">Measurement Generator</a></li><li><span class="tocitem">Theoretical Background</span><ul><li><a class="tocitem" href="../tbbranch/">Network Equations</a></li><li><a class="tocitem" href="../tbflow/">Power Flow</a></li><li><a class="tocitem" href="../tbestimate/">State Estimation</a></li><li class="is-active"><a class="tocitem" href>State Estimation Routines</a><ul class="internal"><li><a class="tocitem" href="#baddata-1"><span>Bad Data Processing</span></a></li><li><a class="tocitem" href="#lav-1"><span>Least Absolute Value Method</span></a></li><li><a class="tocitem" href="#observability-1"><span>Observability Analysis</span></a></li><li><a class="tocitem" href="#refbaddata-1"><span>References</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Theoretical Background</a></li><li class="is-active"><a href>State Estimation Routines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State Estimation Routines</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/man/tbestimaterest.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="baddata-1"><a class="docs-heading-anchor" href="#baddata-1">Bad Data Processing</a><a class="docs-heading-anchor-permalink" href="#baddata-1" title="Permalink"></a></h2><p>We refer the reader to section <a href="../tbestimate/#stateestimation-1">State Estimation</a> which precedes the analysis given here. Besides the state estimation algorithm, one of the essential state estimation routines is the bad data processing, whose main task is to detect and identify measurement errors, and eliminate them if possible. State Estimation algorithms proceed with the bad data processing after the estimation process is finished. This is usually done by processing the measurement residuals <a href="#refbaddata-1">[1, Ch. 5]</a>, and typically, the largest normalized residual test is used to identify bad data. The largest normalized residual test is performed after the algorithm converged in the repetitive process of identifying and eliminating bad data measurements one after another <a href="#refbaddata-1">[2]</a>. The bad data processing described bellow is associated with the commonly used weighted least-squares methods. More precisely, state estimation methods, such as least absolute value estimation, incorporate bad data processing as part of the state estimation procedure <a href="#refbaddata-1">[1, Ch. 5]</a>.</p><p>This section describes the largest normalized residual test based on the residual sensitivity analysis given in <a href="#refbaddata-1">[1, Sec. 5.7]</a>. Using weighted least-squares estimation methods (non-linear or linear), we obtained the state estimator <span>$\hat{\mathbf x}$</span> and elements of the measurement residual vector:</p><div>\[    r_{i} = z_i - h_i(\hat{\mathbf x}), \;\;\; i \in \mathcal{M}.\]</div><p>Normalized residual is defined as:</p><div>\[    c_{i} = \cfrac{|r_i|}{\sqrt{C_{ii}}}, \;\;\; i \in \mathcal{M},\]</div><p>where <span>$C_{ii}$</span> is the diagonal entries of the residual covariance matrix <span>$\mathbf C \in \mathbb{R}^{k \times k}$</span>. Using a residual sensitivity matrix <span>$\mathbf S$</span>, which represents the sensitivity of the measurement residuals to the measurement errors, the above equation became:</p><div>\[    c_{i} = \cfrac{|r_i|}{\sqrt{S_{ii}R_{ii}}}, \;\;\; i \in \mathcal{M},\]</div><p>where:</p><div>\[    \mathbf C = \mathbf S \mathbf R = \mathbf R - \mathbf J [\mathbf J^T \mathbf R^{-1} \mathbf J]^{-1} \mathbf J^T.\]</div><p>Note that only the diagonal entries of <span>$\mathbf C$</span> are needed. To obtain the inverse:</p><div>\[    [\mathbf J^T \mathbf R^{-1} \mathbf J]^{-1},\]</div><p>the JuliaGrid package uses a computationally efficient sparse inverse method to obtain only the necessary elements of the inverse. However, if the largest normalized residual:</p><div>\[    c_{j} &lt; \epsilon; \;\;\; c_j = \text{max} \{c_i, i \in \mathcal{M} \},\]</div><p>then the <span>$j$</span>-th measurement will be suspected as the bad data and removed from the measurement set <span>$\mathcal{M}$</span>, where <span>$\epsilon$</span> is a chosen the bad data identification threshold. State estimation can be repeated after the measurement is eliminating, where we compute the new state estimator <span>$\hat{\mathbf x}$</span>. Thus, we have the repetitive process of identifying and eliminating bad data measurements one after another.</p><p>The elimination of measurements is possible only for the redundant measurements. Namely, removal of critical or non-redundant measurements from the measurement set will result in an unobservable system. Furthermore, the measurement residual of a critical measurement will be always approximately equal to zero <a href="#refbaddata-1">[1, Sec. 5.2]</a>. More precisely, if the measurement residual:</p><div>\[    r_{i} &lt; \gamma, \;\;\; i \in \mathcal{M},\]</div><p>JuliaGrid marked the corresponding measurement as the critical, where <span>$\gamma$</span> is a predetermined critical measurement criteria.</p><hr/><h2 id="lav-1"><a class="docs-heading-anchor" href="#lav-1">Least Absolute Value Method</a><a class="docs-heading-anchor-permalink" href="#lav-1" title="Permalink"></a></h2><p>The least absolute value method represents the alternative estimation method which are more robust as compared to the weighted least-squares. The weighted least-squares state estimation problem is formulated based on certain assumptions about the measurement errors, robust estimators are expected to remain unbiased despite the existence of different types of measurement errors and outliers, making the bad data processing unnecessary <a href="#refbaddata-1">[1, Ch. 6]</a>. Note, there is no free lunch, robustness is commonly achieved at the expense of computational complexity.</p><p>In the case of least absolute value method, it can be shown that the problem can be formulated as a linear programming problem, and this section describes the method given in <a href="#refbaddata-1">[1, Sec. 6.5]</a>. Let us consider the system of linear equations:</p><div>\[  \mathbf{z}=\mathbf{h}(\mathbf{x})+\mathbf{u},\]</div><p>where <span>$\mathbf {x}=[x_1,\dots,x_{s}]^{T}$</span> is the vector of the state variables, <span>$\mathbf{h}(\mathbf{x})=$</span> <span>$[h_1(\mathbf{x})$</span>, <span>$\dots$</span>, <span>$h_k(\mathbf{x})]^{{T}}$</span> is the vector of linear functions, <span>$\mathbf{z} = [z_1,\dots,z_k]^{\mathrm{T}}$</span> is the vector of measurement values, and <span>$\mathbf{u} = [u_1,\dots,u_k]^{\mathrm{T}}$</span> is the vector of uncorrelated measurement errors. Then, the least absolute value state estimator <span>$\hat{\mathbf x}$</span> is defined as the solution of the optimization problem:</p><div>\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf a^T |\mathbf r(\mathbf x)|\\
    \text{subject\;to}&amp; \;\;\; \mathbf{z} - \mathbf{J}\mathbf{x} =\mathbf r(\mathbf x),
  \end{aligned}\]</div><p>where <span>$\mathbf a \in \mathbb {R}^{k}$</span> is the vector with all entries equal to one, <span>$\mathbf J \in \mathbb {R}^{k \times s}$</span> is the Jacobian matrix of measurement functions <span>$\mathbf h (\mathbf x)$</span>, and <span>$\mathbf r (\mathbf x)$</span> is the vector of measurement residuals. Further, we define <span>$\bm \eta$</span>:</p><div>\[  |\mathbf r(\mathbf x)| \preceq \bm \eta,\]</div><p>and replace the above inequality by two equalities via the introduction of two non-negative slack variables <span>$\mathbf q \in \mathbb {R}_{\ge 0}^{k}$</span> and <span>$\mathbf w \in \mathbb {R}_{\ge 0}^{k}$</span>:</p><div>\[  \begin{aligned}
    \mathbf r(\mathbf x) - \mathbf q &amp;= -\bm \eta \\
    \mathbf r(\mathbf x) + \mathbf w &amp;= \bm \eta.
  \end{aligned}\]</div><p>Let us now define four additional non-negative variables:</p><div>\[  \begin{aligned}
    \mathbf {x_y} \in \mathbb {R}_{\ge 0}^{s}; \;\;\; \mathbf {x_v} \in \mathbb {R}_{\ge 0}^{s} \\   
    \mathbf {y} \in \mathbb {R}_{\ge 0}^{k}; \;\;\; \mathbf {v} \in \mathbb {R}_{\ge 0}^{k},
  \end{aligned}\]</div><p>where:</p><div>\[  \begin{aligned}
    \mathbf {x} &amp;= \mathbf {x_y} - \mathbf {x_v} \\
    \mathbf r(\mathbf x) &amp;= \mathbf {y} - \mathbf {v} \\
    \mathbf {y} &amp;= \cfrac{1}{2} \mathbf q \\
    \mathbf {v} &amp;= \cfrac{1}{2} \mathbf w.
  \end{aligned}\]</div><p>Then, the above two equalities become:</p><div>\[  \begin{aligned}
    \mathbf r(\mathbf x) - 2\mathbf y &amp;= -2\bm \eta \\
    \mathbf r(\mathbf x) + 2\mathbf v &amp;= 2\bm \eta,
  \end{aligned}\]</div><p>that is:</p><div>\[  \begin{aligned}
    \mathbf y + \mathbf v = \bm \eta; \;\;\; \mathbf r(\mathbf x) = \mathbf y - \mathbf v.
  \end{aligned}\]</div><p>Hence, the optimization problem can be written:</p><div>\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf a^T (\mathbf y + \mathbf v)\\
    \text{subject\;to}&amp; \;\;\; \mathbf{J}(\mathbf {x_y} - \mathbf {x_v}) + \mathbf y - \mathbf v = \mathbf{z}   \\
                       &amp; \;\;\; \mathbf {x_y} \succeq 0, \; \mathbf {x_v} \succeq 0 \\
                       &amp; \;\;\; \mathbf {y} \succeq 0, \; \mathbf {v} \succeq 0.
  \end{aligned}\]</div><p>This can be written in compact form as a standard linear programming problem:</p><div>\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf g^T \mathbf t \\
    \text{subject\;to}&amp; \;\;\; \mathbf{A} \mathbf{t} = \mathbf z \\
                       &amp; \;\;\; \mathbf{t} \succeq 0,
  \end{aligned}\]</div><p>where:</p><div>\[  \mathbf g =
  \begin{bmatrix}
    \mathbf 0_{s} \\ \mathbf 0_{s} \\ \mathbf 1_{k} \\ \mathbf 1_{k}
  \end{bmatrix}; \;\;\;
  \mathbf t =
  \begin{bmatrix}
    \mathbf {x_y} \\ \mathbf {x_v} \\ \mathbf {y} \\ \mathbf {v}
  \end{bmatrix}; \;\;\;
  \mathbf A =
  \begin{bmatrix}
    \mathbf{J} &amp; -\mathbf{J} &amp; \mathbf{E} &amp; -\mathbf{E}
  \end{bmatrix}.\]</div><p>Here, the all-zero vector <span>$\mathbf 0_{s}$</span> is of dimension <span>$s$</span>, the all-one vector <span>$\mathbf 1_{k}$</span> is of dimension <span>$k$</span> and <span>$\mathbf{E}$</span> is the identity matrix of dimension <span>$k \times k$</span>. After solving the above linear programming problem, we reveal the state estimator:</p><div>\[    \hat{\mathbf {x}} = \mathbf {x_y} - \mathbf {x_v}.\]</div><p>Note that the non-linear least absolute value state estimation is based on the successive set of linear programming problems, where we reveal state variables increments:</p><div>\[    \mathbf {\bm \Delta x} = \mathbf {\bm \Delta x_y} - \mathbf { \bm \Delta x_v}.\]</div><hr/><h2 id="observability-1"><a class="docs-heading-anchor" href="#observability-1">Observability Analysis</a><a class="docs-heading-anchor-permalink" href="#observability-1" title="Permalink"></a></h2><hr/><h2 id="refbaddata-1"><a class="docs-heading-anchor" href="#refbaddata-1">References</a><a class="docs-heading-anchor-permalink" href="#refbaddata-1" title="Permalink"></a></h2><p>[1] A. Abur and A. Exposito, Power System State Estimation: Theory and Implementation, ser. Power Engineering. Taylor &amp; Francis, 2004.</p><p>[2] G. N. Korres, A distributed multiarea state estimation, IEEE Trans. Power Syst., vol. 26, no. 1, pp. 73–84, Feb. 2011.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tbestimate/">« State Estimation</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 14 June 2020 13:06">Sunday 14 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
