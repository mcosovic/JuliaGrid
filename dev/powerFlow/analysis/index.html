<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power Flow Analysis · JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Power System</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../powerSystem/model/">Power System Model</a></li><li><a class="tocitem" href="../../powerSystem/inDepthACDCModel/">In-depth AC and DC Model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Power Flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Power Flow Analysis</a><ul class="internal"><li><a class="tocitem" href="#Newton-Raphson-Method"><span>Newton-Raphson Method</span></a></li><li><a class="tocitem" href="#Fast-Newton-Raphson-Method"><span>Fast Newton-Raphson Method</span></a></li><li><a class="tocitem" href="#Gauss-Seidel-Method"><span>Gauss-Seidel Method</span></a></li><li><a class="tocitem" href="#DC-Power-Flow-Solution"><span>DC Power Flow Solution</span></a></li><li><a class="tocitem" href="#Post-processing-Analysis"><span>Post-processing Analysis</span></a></li><li><a class="tocitem" href="#Additional-Functions"><span>Additional Functions</span></a></li></ul></li><li><a class="tocitem" href="../inDepthAnalysis/">In-depth Power Flow Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Power Flow</a></li><li class="is-active"><a href>Power Flow Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power Flow Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/powerFlow/analysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="powerFlowAnalysis"><a class="docs-heading-anchor" href="#powerFlowAnalysis">Power Flow Analysis</a><a id="powerFlowAnalysis-1"></a><a class="docs-heading-anchor-permalink" href="#powerFlowAnalysis" title="Permalink"></a></h1><p>The calculation of bus voltages is essential to solving the power flow problem. The composite type <code>PowerSystem</code>, which includes <code>bus</code>, <code>branch</code>, and <code>generator</code> fields, is required to obtain a solution. Additionally, depending on the type of power flow used, either <code>acModel</code> or <code>dcModel</code> must be used.</p><p>After creating the composite type <code>PowerSystem</code>, the next step is to create the composite type <code>Result</code>, which has fields <code>bus</code>, <code>branch</code>, <code>generator</code>, and <code>algorithm</code>. In the DC power flow, <code>Result</code> is created when determining the bus voltage angles using the <a href="#JuliaGrid.dcPowerFlow"><code>dcPowerFlow()</code></a> function. On the other hand, the AC power flow requires the iterative method to be initialized, which is when the composite type <code>Result</code> is created using one of the following functions:</p><ul><li><a href="#JuliaGrid.newtonRaphson"><code>newtonRaphson()</code></a></li><li><a href="#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX()</code></a></li><li><a href="#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB()</code></a></li><li><a href="#JuliaGrid.gaussSeidel"><code>gaussSeidel()</code></a>.</li></ul><p>To calculate bus voltages, the appropriate function can be used depending on the type of power flow and method selected. The following functions are available:</p><ul><li><a href="#JuliaGrid.newtonRaphson!"><code>newtonRaphson!()</code></a></li><li><a href="#JuliaGrid.fastNewtonRaphson!"><code>fastNewtonRaphson!()</code></a></li><li><a href="#JuliaGrid.gaussSeidel!"><code>gaussSeidel!()</code></a></li><li><a href="#JuliaGrid.dcPowerFlow"><code>dcPowerFlow()</code></a>.</li></ul><p>Note that when solving the AC power flow problem, the methods should be called inside a loop to simulate an iterative process.</p><p>JuliaGrid offers a set of post-processing analysis functions for calculating powers, losses, and currents associated with buses, branches, or generators after obtaining AC or DC power flow solutions:</p><ul><li><a href="#JuliaGrid.bus!"><code>bus!()</code></a></li><li><a href="#JuliaGrid.branch!"><code>branch!()</code></a></li><li><a href="#JuliaGrid.generator!"><code>generator!()</code></a>.</li></ul><p>It&#39;s important to note that complex currents are stored in the polar coordinate system, while complex powers are stored in the rectangular coordinate system within JuliaGrid.</p><p>The JuliaGrid package provides two additional functions. One function validates the reactive power limits of generators once the AC power flow solution has been computed. The other function adjusts the voltage angles to match the angle of an arbitrary slack bus:</p><ul><li><a href="#JuliaGrid.reactivePowerLimit!"><code>reactivePowerLimit!()</code></a></li><li><a href="#JuliaGrid.adjustVoltageAngle!"><code>adjustVoltageAngle!()</code></a>.</li></ul><hr/><h2 id="Newton-Raphson-Method"><a class="docs-heading-anchor" href="#Newton-Raphson-Method">Newton-Raphson Method</a><a id="Newton-Raphson-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-Raphson-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.newtonRaphson" href="#JuliaGrid.newtonRaphson"><code>JuliaGrid.newtonRaphson</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function accepts the <code>PowerSystem</code> composite type as input, uses it to set up the  Newton-Raphson method, and then produces the <code>Result</code> composite type as output.</p><pre><code class="nohighlight hljs">newtonRaphson(system::PowerSystem)</code></pre><p>The <code>algorithm</code> field of the <code>Result</code> type is updated during the function&#39;s execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L134-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.newtonRaphson!" href="#JuliaGrid.newtonRaphson!"><code>JuliaGrid.newtonRaphson!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function updates the <code>bus.voltage</code> and <code>algorithm</code> fields of the <code>Result</code> composite  type by computing the magnitudes and angles of bus voltages using the Newton-Raphson  method.</p><pre><code class="nohighlight hljs">newtonRaphson!(system::PowerSystem, result::Result)</code></pre><p>It is intended to be used within a for loop as it performs only one iteration of the  Newton-Raphson method. It is recommended that the reader peruses the section on the  <a href="../inDepthAnalysis/#inDepthNewtonRaphson">Newton-Raphson Method</a> to gain a comprehensive understanding  of its implementation, including all relevant data.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:10
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L243-L269">source</a></section></article><hr/><h2 id="Fast-Newton-Raphson-Method"><a class="docs-heading-anchor" href="#Fast-Newton-Raphson-Method">Fast Newton-Raphson Method</a><a id="Fast-Newton-Raphson-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Newton-Raphson-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.fastNewtonRaphsonBX" href="#JuliaGrid.fastNewtonRaphsonBX"><code>JuliaGrid.fastNewtonRaphsonBX</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function accepts the <code>PowerSystem</code> composite type as input, uses it to set up the  fast Newton-Raphson method of version BX, and then produces the <code>Result</code> composite type as  output.</p><pre><code class="nohighlight hljs">fastNewtonRaphsonBX(system::PowerSystem)</code></pre><p>The <code>algorithm</code> field of the <code>Result</code> type is updated during the function&#39;s execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L370-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.fastNewtonRaphsonXB" href="#JuliaGrid.fastNewtonRaphsonXB"><code>JuliaGrid.fastNewtonRaphsonXB</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function accepts the <code>PowerSystem</code> composite type as input, uses it to set up the  fast Newton-Raphson method of version XB, and then produces the <code>Result</code> composite type as  output.</p><pre><code class="nohighlight hljs">fastNewtonRaphsonXB(system::PowerSystem)</code></pre><p>The <code>algorithm</code> field of the <code>Result</code> type is updated during the function&#39;s execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L386-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.fastNewtonRaphson!" href="#JuliaGrid.fastNewtonRaphson!"><code>JuliaGrid.fastNewtonRaphson!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function updates the <code>bus.voltage</code> and <code>algorithm</code> fields of the <code>Result</code> composite  type by computing the magnitudes and angles of bus voltages using the fast Newton-Raphson  method.</p><pre><code class="nohighlight hljs">fastNewtonRaphson!(system::PowerSystem, result::Result)</code></pre><p>It is intended to be used within a for loop as it performs only one iteration of the  fast Newton-Raphson method. It is recommended that the reader peruses the section on the  <a href="../inDepthAnalysis/#inDepthFastNewtonRaphson">Fast Newton-Raphson Method</a> to gain a comprehensive  understanding of its implementation, including all relevant data.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = fastNewtonRaphsonBX(system)
stopping = result.algorithm.iteration.stopping
for i = 1:100
    fastNewtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L569-L595">source</a></section></article><hr/><h2 id="Gauss-Seidel-Method"><a class="docs-heading-anchor" href="#Gauss-Seidel-Method">Gauss-Seidel Method</a><a id="Gauss-Seidel-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Gauss-Seidel-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.gaussSeidel" href="#JuliaGrid.gaussSeidel"><code>JuliaGrid.gaussSeidel</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function accepts the <code>PowerSystem</code> composite type as input, uses it to set up the  Gauss-Seidel method, and then produces the <code>Result</code> composite type as output.</p><pre><code class="nohighlight hljs">gaussSeidel(system::PowerSystem)</code></pre><p>The <code>algorithm</code> field of the <code>Result</code> type is updated during the function&#39;s execution.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L665-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.gaussSeidel!" href="#JuliaGrid.gaussSeidel!"><code>JuliaGrid.gaussSeidel!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function updates the <code>bus.voltage</code> and <code>algorithm</code> fields of the <code>Result</code> composite  type by computing the magnitudes and angles of bus voltages using the Gauss-Seidel method.</p><pre><code class="nohighlight hljs">gaussSeidel!(system::PowerSystem, result::Result)</code></pre><p>It is intended to be used within a for loop as it performs only one iteration of the  Gauss-Seidel method. It is recommended that the reader peruses the section on the  <a href="../inDepthAnalysis/#inDepthGaussSeidel">Gauss-Seidel Method</a> to gain a comprehensive understanding of  its implementation, including all relevant data.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = gaussSeidel(system)
stopping = result.algorithm.iteration.stopping
for i = 1:1000
    gaussSeidel!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L708-L733">source</a></section></article><hr/><h2 id="DC-Power-Flow-Solution"><a class="docs-heading-anchor" href="#DC-Power-Flow-Solution">DC Power Flow Solution</a><a id="DC-Power-Flow-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#DC-Power-Flow-Solution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.dcPowerFlow" href="#JuliaGrid.dcPowerFlow"><code>JuliaGrid.dcPowerFlow</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function takes a <code>PowerSystem</code> composite type as input and uses it to solve the DC  power flow problem by calculating the voltage angles for each bus. </p><pre><code class="nohighlight hljs">dcPowerFlow(system::PowerSystem)</code></pre><p>The function returns a composite type <code>Result</code> as output, which includes updated  <code>bus.voltage.angle</code> and <code>algorithm</code> fields. These fields are modified during the execution  of the function. It is recommended that the reader peruses the section on the  <a href="../inDepthAnalysis/#inDepthDCPowerFlowSolution">DC Power Flow Solution</a> to gain a comprehensive  understanding of its implementation, including all relevant data.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

result = dcPowerFlow(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L797-L816">source</a></section></article><hr/><h2 id="Post-processing-Analysis"><a class="docs-heading-anchor" href="#Post-processing-Analysis">Post-processing Analysis</a><a id="Post-processing-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Post-processing-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.bus!" href="#JuliaGrid.bus!"><code>JuliaGrid.bus!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function calculates the powers and currents associated with buses.</p><pre><code class="nohighlight hljs">bus!(system::PowerSystem, result::Result)</code></pre><p>After the function is executed, the <code>bus</code> field within the <code>Result</code> type gets updated. To  gain a comprehensive understanding of the equations used, along with all relevant data, it  is recommended that the reader examines either the section on  <a href="../inDepthAnalysis/#acPostprocessingAnalysisBus">AC Bus Post-processing Analysis</a> or the section on  <a href="../inDepthAnalysis/#dcPostprocessingAnalysisBus">DC Bus Post-processing Analysis</a>.</p><p><strong>AC Power Flow Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:10
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end

bus!(system, result)</code></pre><p><strong>DC Power Flow Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

result = dcPowerFlow(system)
bus!(system, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/analysis.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.branch!" href="#JuliaGrid.branch!"><code>JuliaGrid.branch!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function is used to calculate the powers and currents associated with branches for AC  power flow analysis and, in relation to DC power flow analysis, it only calculates active  powers. </p><pre><code class="nohighlight hljs">branch!(system::PowerSystem, result::Result)</code></pre><p>The function is responsible for updating the <code>branch</code> field within the <code>Result</code> type after  it has been executed. To gain a comprehensive understanding of the equations used, along  with all relevant data, it is recommended that the reader examines either the section on  <a href="../inDepthAnalysis/#acPostprocessingAnalysisBranch">AC Branch Post-processing Analysis</a> or the section  on <a href="../inDepthAnalysis/#dcPostprocessingAnalysisBranch">DC Branch Post-processing Analysis</a>.</p><p><strong>AC Power Flow Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:10
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end

branch!(system, result)</code></pre><p><strong>DC Power Flow Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

result = dcPowerFlow(system)
branch!(system, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/analysis.jl#L123-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.generator!" href="#JuliaGrid.generator!"><code>JuliaGrid.generator!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function computes powers related to generators.</p><pre><code class="nohighlight hljs">generator!(system::PowerSystem, result::Result)</code></pre><p>Once executed, the <code>generator</code> field within the <code>Result</code> type is updated accordingly. To  gain a comprehensive understanding of the equations used, along with all relevant data, it  is recommended that the reader examines either the section on  <a href="../inDepthAnalysis/#acPostprocessingAnalysisGenerator">AC Generator Post-processing Analysis</a> or the  section on <a href="../inDepthAnalysis/#dcPostprocessingAnalysisGenerator">DC Generator Post-processing Analysis</a>.</p><p><strong>AC Power Flow Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:10
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end

generator!(system, result)</code></pre><p><strong>DC Power Flow Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

result = dcPowerFlow(system)
generator!(system, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/analysis.jl#L248-L284">source</a></section></article><hr/><h2 id="Additional-Functions"><a class="docs-heading-anchor" href="#Additional-Functions">Additional Functions</a><a id="Additional-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.reactivePowerLimit!" href="#JuliaGrid.reactivePowerLimit!"><code>JuliaGrid.reactivePowerLimit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function verifies whether the generators in a power system exceed their reactive power  limits. This is done by setting the reactive power of the generators to within the limits  if they are violated, after determining the bus voltage magnitudes and angles. If the  limits are violated, the corresponding PV buses or the slack bus are converted to PQ buses. </p><p>The function returns the <code>violate</code> variable to indicate which buses violate the limits,  with -1 indicating a violation of the minimum limits and 1 indicating a violation of the  maximum limits.</p><pre><code class="nohighlight hljs">reactivePowerLimit!(system::PowerSystem, result::Result)</code></pre><p>First, if the <a href="#JuliaGrid.generator!"><code>generator!()</code></a> function has not been executed,  <a href="#JuliaGrid.reactivePowerLimit!"><code>reactivePowerLimit!()</code></a> will execute it and update the  <code>generator</code> field of the <code>Result</code> type. </p><p>Afterward, the function uses the results from <a href="#JuliaGrid.generator!"><code>generator!()</code></a> to assign  values to the <code>generator.output.active</code> and <code>bus.supply.active</code> fields of the <code>System</code>  type.</p><p>At the end of the process, the function inspects the reactive powers of the generator and  adjusts them to their maximum or minimum values if they violate the threshold. The  <code>generator.output.reactive</code> field of the <code>System</code> type is then modified accordingly. In  light of this modification, the <code>bus.supply.reactive</code> field of the <code>System</code> type is also  updated, and the bus types in <code>bus.layout.type</code> are adjusted. If the slack bus is  converted, the <code>bus.layout.slack</code> field is modified accordingly.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:200
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end

violate = reactivePowerLimit!(system, result)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:200
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L863-L915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.adjustVoltageAngle!" href="#JuliaGrid.adjustVoltageAngle!"><code>JuliaGrid.adjustVoltageAngle!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function modifies the bus voltage angles based on a different slack bus than the one  identified by the <code>bus.layout.slack</code> field. This function only updates the  <code>bus.voltage.angle</code> field of the <code>Result</code> type.</p><pre><code class="nohighlight hljs">adjustVoltageAngle!(system::PowerSystem, result::Result; slack)</code></pre><p>For instance, if the reactive power of the generator exceeds the limit on the slack bus,  the <a href="#JuliaGrid.reactivePowerLimit!"><code>reactivePowerLimit!()</code></a> function will change that bus to a  PQ bus and designate the first PV bus in the sequence as the new slack bus. After  obtaining the updated AC power flow solution based on the new slack bus, it is possible to  adjust the voltage angles to align with the angle of the original slack bus. The <code>slack</code>  keyword specifies the bus label of the original slack bus.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:200
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end

reactivePowerLimit!(system, result)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:200
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end

adjustVoltageAngle!(system, result; slack = 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/6d92a38b0030f6355dc5422fc4833efa4504620e/src/powerFlow/solution.jl#L976-L1017">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../powerSystem/inDepthACDCModel/">« In-depth AC and DC Model</a><a class="docs-footer-nextpage" href="../inDepthAnalysis/">In-depth Power Flow Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 16 March 2023 10:06">Thursday 16 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
