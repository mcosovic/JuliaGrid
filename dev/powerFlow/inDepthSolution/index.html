<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>In-depth Power Flow Solution · JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Power System</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../powerSystem/model/">Power System Model</a></li><li><a class="tocitem" href="../../powerSystem/inDepthACDCModel/">In-depth AC and DC Model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Power Flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../analysis/">Power Flow Analysis</a></li><li class="is-active"><a class="tocitem" href>In-depth Power Flow Solution</a><ul class="internal"><li><a class="tocitem" href="#inDepthNewtonRaphson"><span>Newton-Raphson Method</span></a></li><li><a class="tocitem" href="#inDepthFastNewtonRaphson"><span>Fast Newton-Raphson Method</span></a></li><li><a class="tocitem" href="#inDepthGaussSeidel"><span>Gauss-Seidel Method</span></a></li><li><a class="tocitem" href="#dcPowerFlowSolution"><span>DC Power Flow Solution</span></a></li><li><a class="tocitem" href="#acPowerFlowAnalysis"><span>AC Power Flow Anylsis</span></a></li><li><a class="tocitem" href="#dcPowerFlowAnalysis"><span>DC Power Flow Anylsis</span></a></li><li><a class="tocitem" href="#inDepthPowerFlowSolutionReference"><span>References</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Power Flow</a></li><li class="is-active"><a href>In-depth Power Flow Solution</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>In-depth Power Flow Solution</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/powerFlow/inDepthSolution.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="inDepthPowerFlowAnalysis"><a class="docs-heading-anchor" href="#inDepthPowerFlowAnalysis">In-depth Power Flow Analysis</a><a id="inDepthPowerFlowAnalysis-1"></a><a class="docs-heading-anchor-permalink" href="#inDepthPowerFlowAnalysis" title="Permalink"></a></h1><p>JuliaGrid utilizes standard network components and leverages the <a href="../../powerSystem/inDepthACDCModel/#inDepthACModel">unified branch model</a> to achieve power flow analysis, enabling the definition of load profiles, generator capacities, voltage specifications, contingency analysis, and planning. To begin, the <code>PowerSystem</code> composite type must be provided to JuliaGrid through the use of the <a href="../../powerSystem/model/#JuliaGrid.powerSystem"><code>powerSystem()</code></a> function, as illustrated by the following example:</p><pre><code class="language-julia-repl hljs">system = powerSystem(&quot;case14.h5&quot;)</code></pre><p>To review, we can conceptualize the bus/branch model as a graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where the collection of nodes <span>$\mathcal{N} = \{1, \dots, n\}$</span> signifies the buses of the power network, and the set of edges <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> represents the branches within the network. As previously demonstrated in the section on the <a href="../../powerSystem/inDepthACDCModel/#inDepthACModel">In-depth AC Model</a>, we can express the network as a system of nonlinear equations:</p><p class="math-container">\[    \mathbf{\bar {I}} = \mathbf{Y} \mathbf{\bar {V}}.\]</p><p>The complex current injection at the bus <span>$i \in \mathcal{N}$</span> is defined as:</p><p class="math-container">\[  	\bar{I}_{i} = \cfrac{S_{i}^*}{\bar{V}_{i}^*},\]</p><p>where <span>$\bar{V}_{i} = V_i \text{e}^{\text{j}\theta_{i}}$</span>. Thus, for any given bus <span>$i \in \mathcal{N}$</span>, we can express it as:</p><p class="math-container">\[  	\cfrac{S_{i}^*}{\bar{V}_{i}^*} = \sum_{j = 1}^n Y_{ij} \bar {V}_j.\]</p><p>The complex power injection denoted by <span>$S_i$</span> comprises of both the active power <span>$P_i$</span> and reactive power <span>$Q_i$</span>. This relationship can be represented as follows:</p><p class="math-container">\[  	\cfrac{P_i - \text{j}Q_i}{\bar{V}_{i}} = \sum_{j = 1}^n Y_{ij} \bar {V}_j.\]</p><p>As demonstrated by the above equation, the bus <span>$i \in \mathcal{N}$</span> contains four unknown variables, namely the active power injection <span>${P}_{i}$</span>, reactive power injection <span>${Q}_{i}$</span>, bus voltage magnitude <span>${V}_{i}$</span>, and bus voltage angle <span>${\theta}_{i}$</span>. To solve the system of equations, two variables must be specified for each equation. Although any two variables can be selected mathematically, the choice is determined by the devices that are connected to a particular bus. The standard options are listed in the table below, and these options are used to define the bus types <a href="#inDepthPowerFlowSolutionReference">[1]</a>.</p><table><tr><th style="text-align: left">Bus Type</th><th style="text-align: right">Label</th><th style="text-align: right">JuliaGrid</th><th style="text-align: right">Known</th><th style="text-align: right">Unknown</th></tr><tr><td style="text-align: left">Slack</td><td style="text-align: right"><span>$V \theta$</span></td><td style="text-align: right">3</td><td style="text-align: right"><span>$V_{i}$</span>, <span>${\theta_{i}}$</span></td><td style="text-align: right"><span>$P_{i}$</span>, <span>$Q_{i}$</span></td></tr><tr><td style="text-align: left">Generator</td><td style="text-align: right">PV</td><td style="text-align: right">2</td><td style="text-align: right"><span>$P_{i}$</span>, <span>$V_{i}$</span></td><td style="text-align: right"><span>$Q_{i}$</span>, <span>${\theta_{i}}$</span></td></tr><tr><td style="text-align: left">Demand</td><td style="text-align: right">PQ</td><td style="text-align: right">1</td><td style="text-align: right"><span>$P_{i}$</span>, <span>$Q_{i}$</span></td><td style="text-align: right"><span>$V_{i}$</span>, <span>${\theta_{i}}$</span></td></tr></table><p>Consequently, JuliaGrid operates with sets <span>$\mathcal{N}_{\text{pv}}$</span> and <span>$\mathcal{N}_{\text{pq}}$</span> that contain PV and PQ buses, respectively, and exactly one slack bus in the set <span>$\mathcal{N}_{\text{sb}}$</span>. The bus types are stored in the variable: </p><pre><code class="language-julia-repl hljs">julia&gt; system.bus.layout.type</code></pre><p>It should be noted that JuliaGrid cannot handle systems with multiple slack buses. Additionally, when using functions such as <a href="../analysis/#JuliaGrid.newtonRaphson"><code>newtonRaphson()</code></a>, <a href="../analysis/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX()</code></a>, <a href="../analysis/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB()</code></a>, and <a href="../analysis/#JuliaGrid.gaussSeidel"><code>gaussSeidel()</code></a>, the bus type can be modified in the following manner: If a bus was originally classified as a PV bus but does not have any in-service generators, it will be converted to a PQ bus.</p><p>Furthermore, the active power injections <span>${P}_{i}$</span> and reactive power injections <span>${Q}_{i}$</span> can be expressed as:</p><p class="math-container">\[  \begin{aligned}
  	P_{i} &amp;= P_{\text{s}i} - P_{\text{d}i} \\
    Q_{i} &amp;= Q_{\text{s}i} - Q_{\text{d}i},
  \end{aligned}\]</p><p>where <span>${P}_{\text{s}i}$</span> and <span>${Q}_{\text{s}i}$</span> correspond to the active and reactive power generated by the generators supplying the bus <span>$i \in \mathcal{N}$</span>, while <span>${P}_{\text{d}i}$</span> and <span>${Q}_{\text{d}i}$</span> denote the active and reactive power consumed by the consumers at the bus <span>$i \in \mathcal{N}$</span>. These values can be computed in JuliaGrid as:</p><pre><code class="language-julia-repl hljs">julia&gt; system.bus.supply.active - system.bus.demand.active
julia&gt; system.bus.supply.reactive - system.bus.demand.reactive</code></pre><hr/><h2 id="inDepthNewtonRaphson"><a class="docs-heading-anchor" href="#inDepthNewtonRaphson">Newton-Raphson Method</a><a id="inDepthNewtonRaphson-1"></a><a class="docs-heading-anchor-permalink" href="#inDepthNewtonRaphson" title="Permalink"></a></h2><p>The Newton-Raphson method is commonly used in power flow calculations due to its quadratic rate of convergence. It provides an accurate approximation of the roots of the system of nonlinear equations:</p><p class="math-container">\[  \mathbf{f}(\mathbf{x}) = \mathbf{0},\]</p><p>which in turn allows for the determination of the voltage magnitudes and angles of each bus, denoted as the state vector <span>$\mathbf x = [\bm \theta, \mathbf V]^T$</span>. The state vector comprises of <span>$\bm \theta \in \mathbb{R}^{n-1}$</span> and <span>$\mathbf V \in \mathbb{R}^{n_{\text{pq}}}$</span>, where <span>$n_{\text{pq}} = |\mathcal{N}_{\text{pq}}|$</span> is the total number of PQ buses. The voltage magnitudes and angles are known for certain types of buses, including:</p><ul><li>The voltage magnitude <span>$V_i$</span> and angle <span>$\theta_i$</span> at the slack bus <span>$i \in \mathcal{N}_{\text{sb}}$</span> are known.</li><li>The voltage magnitude <span>$V_i$</span> at PV buses <span>$i \in \mathcal{N}_{\text{pv}}$</span> is known.</li></ul><p>The complex power injection <span>$S_i$</span> at a bus <span>$i \in \mathcal{N}$</span> is a function of the complex bus voltages. Therefore, the active and reactive power injection expressions can be defined based on the real and imaginary components of the complex power as follows:</p><p class="math-container">\[  \begin{aligned}
    {P}_{i} &amp;={V}_{i}\sum\limits_{j=1}^n {V}_{j} (G_{ij}\cos\theta_{ij}+B_{ij}\sin\theta_{ij})\\
    {Q}_{i} &amp;={V}_{i}\sum\limits_{j=1}^n {V}_{j} (G_{ij}\sin\theta_{ij}-B_{ij}\cos\theta_{ij}).
	\end{aligned}\]</p><p>Using the above equations, we can define the active power injection function for PV and PQ buses as follows:</p><p class="math-container">\[    f_{P_i}(\mathbf x) = {V}_{i}\sum\limits_{j=1}^n {V}_{j}(G_{ij}\cos\theta_{ij}+B_{ij}\sin\theta_{ij}) - {P}_{i} = 0,
    \;\;\; i \in \mathcal{N}_{\text{pq}} \cup \mathcal{N}_{\text{pv}},\]</p><p>and the reactive power injection function for PQ buses as follows:</p><p class="math-container">\[    f_{Q_i}(\mathbf x) = {V}_{i}\sum\limits_{j=1}^n {V}_{j}(G_{ij}\sin\theta_{ij}-B_{ij}\cos\theta_{ij}) - {Q}_{i} = 0,
    \;\;\; i \in \mathcal{N}_{\text{pq}}.\]</p><p>The active and reactive mismatches, often denoted as <span>$\Delta P_i(\mathbf x)$</span> and <span>$\Delta Q_i(\mathbf x)$</span>, respectively, are defined as the functions <span>$f_{P_i}(\mathbf x)$</span> and <span>$f_{Q_i}(\mathbf x)$</span>. The first terms on the right-hand side represent power injections at a bus, while the second term is constant and is obtained based on the active and reactive powers of the generators that supply a bus and active and reactive powers demanded by consumers at the same bus. Therefore, the Newton-Raphson method solves the system of nonlinear equations:</p><p class="math-container">\[  \mathbf{f(x)} =
  \begin{bmatrix}
    \mathbf{f}_{P}(\mathbf x) \\ \mathbf{f}_{Q}(\mathbf x)
  \end{bmatrix} = \mathbf 0,\]</p><p>where the first <span>$n - 1$</span> equations correspond to PV and PQ buses, and the last <span>$n_{\text{pq}}$</span> equations correspond to PQ buses.</p><hr/><h4 id="Method-Implementation"><a class="docs-heading-anchor" href="#Method-Implementation">Method Implementation</a><a id="Method-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Method-Implementation" title="Permalink"></a></h4><p>To apply the Newton-Raphson method and determine the bus voltage magnitudes and angles for AC power flow in JuliaGrid, execute the following sequence of functions:</p><pre><code class="language-julia-repl hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:10
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end</code></pre><p>The Newton-Raphson method, also known as Newton&#39;s method, is an iterative approach based on the Taylor series expansion, where higher-order terms are neglected. In each iteration, the increments of bus voltage angle and magnitude are computed as: </p><p class="math-container">\[  \mathbf{\Delta x^{(\nu)}} = -\mathbf{J(x^{(\nu)})}^{-1}\mathbf{ f(x^{(\nu)})},\]</p><p>where <span>$\mathbf{\Delta x^{(\nu)}} = [\mathbf \Delta \bm \theta^{(\nu)}, \mathbf \Delta \mathbf V^{(\nu)}]^T$</span> consists of the vector of bus voltage angle increments <span>$\mathbf \Delta \bm \theta^{(\nu)} \in \mathbb{R}^{n-1}$</span> and bus voltage magnitude increments <span>$\mathbf \Delta \mathbf V^{(\nu)} \in \mathbb{R}^{n_{\text{pq}}}$</span>, and <span>$\mathbf{J(x^{(\nu)})}\in \mathbb{R}^{n_{\text{u}} \times n_{\text{u}}}$</span> is the Jacobian matrix, <span>$n_{\text{u}} = n + n_{\text{pq}} - 1$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.increment
julia&gt; result.algorithm.jacobian
julia&gt; result.algorithm.mismatch</code></pre><p>The JuliaGrid implementation stores the increment vector <span>$\mathbf{ \Delta x^{(\nu)}}$</span> and mismatch vector <span>$\mathbf{f(x^{(\nu)})}$</span> follows the same order as the one defined previously. The first <span>$n - 1$</span> elements represent bus voltage angle increments and active mismatches defined based on PV and PQ buses, in the same order as they appear in the input data. The last <span>$n_{\text{pq}}$</span> elements represent bus voltage magnitude increments and reactive mismatches defined based on PQ buses. Consequently, the Jacobian matrix <span>$\mathbf{J(x^{(\nu)})}$</span> is also constructed accordingly.</p><p>Subsequently, we modify the solution by adding an increment term:</p><p class="math-container">\[  \mathbf {x}^{(\nu + 1)} = \mathbf {x}^{(\nu)} + \mathbf \Delta \mathbf {x}^{(\nu)}.\]</p><p>The final outcomes of JuliaGrid are stored in arrays that hold the magnitudes and angles of the bus voltages:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.voltage.magnitude
julia&gt; result.bus.voltage.angle</code></pre><p>To obtain the current iteration number <span>$\nu$</span>, use the following command:</p><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.iteration.number</code></pre><p>The iteration process continues until the termination condition is met. Specifically, at each iteration, we evaluate the active power injection mismatch for PQ and PV buses:</p><p class="math-container">\[  f_{P_i}(\mathbf x^{(\nu+1)}) = {V}_{i}^{(\nu+1)}\sum\limits_{j=1}^n {V}_{j}^{(\nu+1)}(G_{ij}\cos\theta_{ij}^{(\nu+1)}+B_{ij}\sin\theta_{ij}^{(\nu+1)}) - {P}_{i},
  \;\;\; i \in \mathcal{N}_{\text{pq}} \cup \mathcal{N}_{\text{pv}},\]</p><p>as well as the reactive power injection mismatch for PQ buses:</p><p class="math-container">\[    f_{Q_i}(\mathbf x^{(\nu+1)}) = {V}_{i}^{(\nu+1)}\sum\limits_{j=1}^n {V}_{j}^{(\nu+1)}(G_{ij}\sin\theta_{ij}^{(\nu+1)}-B_{ij}\cos\theta_{ij}^{(\nu+1)}) - {Q}_{i},
    \;\;\; i \in \mathcal{N}_{\text{pq}}.\]</p><p>The iteration stops when the following criteria are satisfied:</p><p class="math-container">\[    \max \{|f_{P_i}(\mathbf x^{(\nu+1)})|,\; i \in \mathcal{N}_{\text{pq}} \cup \mathcal{N}_{\text{pv}} \} &lt; \epsilon \\
    \max \{|f_{Q_i}(\mathbf x^{(\nu+1)})|,\; i \in \mathcal{N}_{\text{pq}} \} &lt; \epsilon.\]</p><p>Here, <span>$\epsilon$</span> is a predefined stopping criterion. These values are stored in JuliaGrid&#39;s variables, which can be used to terminate the iteration loop:</p><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.iteration.stopping.active
julia&gt; result.algorithm.iteration.stopping.reactive</code></pre><p>Finally, it is worth noting that the Newton-Raphson method may encounter difficulties when dealing with initial conditions during a &quot;flat start&quot;.</p><hr/><h4 id="Jacobian-Matrix"><a class="docs-heading-anchor" href="#Jacobian-Matrix">Jacobian Matrix</a><a id="Jacobian-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian-Matrix" title="Permalink"></a></h4><p>Without loss of generality, we assume that the slack bus is the first bus, followed by the set of PQ buses and the set of PV buses:</p><p class="math-container">\[  \begin{aligned}
    \mathcal{N}_{\text{sb}} &amp;= \{ 1 \} \\
    \mathcal{N}_{\text{pq}} &amp;= \{2, \dots, m\} \\
    \mathcal{N}_{\text{pv}} &amp;= \{m + 1,\dots, n\},
  \end{aligned}\]</p><p>where <span>$\mathcal{N} = \mathcal{N}_{\text{sb}} \cup \mathcal{N}_{\text{pq}} \cup \mathcal{N}_{\text{pv}}$</span>. Therefore, we can express:</p><p class="math-container">\[  \begin{aligned}
    \bm \theta &amp;= [\theta_2,\dots,\theta_n]^T; \;\;\;\;\;\; \mathbf \Delta \bm \theta = [\Delta \theta_2,\dots,\Delta \theta_n]^T \\
    \mathbf V &amp;= [V_2,\dots,V_{m}]^T; \;\;\; \mathbf \Delta \mathbf V = [\Delta V_2,\dots,\Delta V_{m}]^T.
  \end{aligned}\]</p><p>The Jacobian matrix <span>$\mathbf{J(x^{(\nu)})} \in \mathbb{R}^{n_{\text{u}} \times n_{\text{u}}}$</span> is:</p><p class="math-container">\[  \mathbf{J(x^{(\nu)})}=
  \left[
  \begin{array}{ccc|ccc}
  \cfrac{\mathrm \partial{{f_{P_2}}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_2} &amp; \cdots &amp;
  \cfrac{\mathrm \partial{{f_{P_2}}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_{n}} &amp;
  \cfrac{\mathrm \partial{{f_{P_2}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_{2}} &amp;\cdots &amp;
  \cfrac{\mathrm \partial{{f_{P_2}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_{m}}\\
  \;\vdots  &amp; \\
  \cfrac{\mathrm \partial{{f_{P_n}}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_2} &amp; \cdots &amp;
  \cfrac{\mathrm \partial{{f_{P_n}}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_{n}} &amp;
  \cfrac{\mathrm \partial{{f_{P_n}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_{2}} &amp;\cdots &amp;
  \cfrac{\mathrm \partial{{f_{P_n}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_{m}} \\[10pt]
  \hline \\
  \cfrac{\mathrm \partial{{f_{Q_2}}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_2} &amp; \cdots &amp;
  \cfrac{\mathrm \partial{{f_{Q_2}}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_{n}} &amp;
  \cfrac{\mathrm \partial{{f_{Q_2}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_{2}} &amp;\cdots &amp;
  \cfrac{\mathrm \partial{{f_{Q_2}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_{m}}\\
  \;\vdots  &amp; \\
  \cfrac{\mathrm \partial{{f_{Q_{m}}}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_2} &amp; \cdots &amp;
  \cfrac{\mathrm \partial{{f_{Q_{m}}}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_{n}} &amp;
  \cfrac{\mathrm \partial{{f_{Q_{m}}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_{2}} &amp;\cdots &amp;
  \cfrac{\mathrm \partial{{f_{Q_{m}}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_{m}}
  \end{array}
  \right].\]</p><p>The Jacobian matrix can be expressed using four block matrices:</p><p class="math-container">\[	  \mathbf{J(x^{(\nu)})} =
  \begin{bmatrix}
    \mathbf{J_{11}(x^{(\nu)})} &amp;\mathbf{J_{12}(x^{(\nu)})} \\ \mathbf{J_{21}(x^{(\nu)})} &amp;
	   \mathbf{J_{22}(x^{(\nu)})}
  \end{bmatrix},\]</p><p>where diagonal elements of the Jacobian sub-matrices are defined as follows:</p><p class="math-container">\[  \begin{aligned}
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_{i}} &amp;=
  {V}_{i}^{(\nu)}\sum\limits_{j=1}^n {V}_{j}^{(\nu)}(-G_{ij}
  \sin\theta_{ij}^{(\nu)}+B_{ij}\cos\theta_{ij}^{(\nu)}) - ({V}_{i}^{(\nu)})^2B_{ii}\\
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x^{(\nu)})}}
  {\mathrm \partial V_{i}^{(\nu)}} &amp;= \sum\limits_{
  j=1}^n {V}_{j}^{(\nu)}(G_{ij}\cos
  \theta_{ij}^{(\nu)}+B_{ij}\sin\theta_{ij}^{(\nu)})+{V}_{i}^{(\nu)} G_{ii}\\
  \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x^{(\nu)})}}
  {\mathrm \partial \theta_{i}}&amp;={V}_{i}^{(\nu)}
  \sum\limits_{j=1}^n {V}_{j}^{(\nu)}
  (G_{ij}\cos\theta_{ij}^{(\nu)}+B_{ij}\sin\theta_{ij}^{(\nu)})- ({V}_{i}^{(\nu)})^2G_{ii}\\
  \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x^{(\nu)})}}
  {\mathrm \partial V_{i}}&amp;=\sum\limits_{j=1
  }^n {V}_{j}^{(\nu)}(G_{ij}\sin\theta_{ij}^{(\nu)}-
  B_{ij}\cos\theta_{ij}^{(\nu)})-{V}_{i}^{(\nu)} B_{ii},
  \end{aligned}\]</p><p>while non-diagonal elements of the Jacobian sub-matrices are:</p><p class="math-container">\[  \begin{aligned}
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x^{(\nu)})}}
  {\mathrm \partial \theta_{j}}&amp;={V}_{i}^{(\nu)}{V}_{j}^{(\nu)}
  (G_{ij}\sin\theta_{ij}^{(\nu)}-B_{ij}\cos\theta_{ij}^{(\nu)})\\
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x^{(\nu)})}}
  {\mathrm \partial V_{j}^{(\nu)}} &amp;= {V}_{i}^{(\nu)}(G_{ij}\cos
  \theta_{ij}^{(\nu)}+B_{ij}\sin\theta_{ij}^{(\nu)})\\
  \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x^{(\nu)})}}
  {\mathrm \partial \theta_{j}}&amp;={V}_{i}^{(\nu)}{V}_{j}^{(\nu)}
  (-G_{ij}\cos\theta_{ij}^{(\nu)} -B_{ij}\sin\theta_{ij}^{(\nu)})\\
  \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x^{(\nu)})}}{\mathrm
  \partial V_{j}}&amp;={V}_{i}^{(\nu)}(G_{ij}\sin\theta_{ij}^{(\nu)}-
  B_{ij}\cos\theta_{ij}^{(\nu)}).
  \end{aligned}\]</p><hr/><h2 id="inDepthFastNewtonRaphson"><a class="docs-heading-anchor" href="#inDepthFastNewtonRaphson">Fast Newton-Raphson Method</a><a id="inDepthFastNewtonRaphson-1"></a><a class="docs-heading-anchor-permalink" href="#inDepthFastNewtonRaphson" title="Permalink"></a></h2><p>Although the fast Newton-Raphson method may converge more slowly than the traditional Newton-Raphson method, the shorter solution time for the updates often compensates for this slower convergence, resulting in a shorter overall solution time. This is particularly true for systems that are not heavily loaded, where a shorter overall solution time is almost always achieved. It is important to note that if the algorithm converges, it will converge to a correct solution <a href="#inDepthPowerFlowSolutionReference">[2]</a>.</p><p>The fast Newton-Raphson method involves decoupling the power flow equations. Namely, the Newton-Raphson method is based on the equations:</p><p class="math-container">\[  \begin{bmatrix}
    \mathbf{J_{11}(x)} &amp;\mathbf{J_{12}(x)} \\ \mathbf{J_{21}(x)} &amp;
	   \mathbf{J_{22}(x)}
  \end{bmatrix}
  \begin{bmatrix}
    \mathbf{\Delta \theta} \\ \mathbf{\Delta V}
  \end{bmatrix}	+
  \begin{bmatrix}
    \mathbf{f}_{P}(\mathbf x) \\ \mathbf{f}_{Q}(\mathbf x)
  \end{bmatrix} = \mathbf 0,\]</p><p>where the iteration index has been omitted for simplicity. However, in transmission grids, there exists a strong coupling between active powers and voltage angles, as well as between reactive powers and voltage magnitudes. To achieve decoupling, two conditions must be satisfied: first, the resistance values <span>$r_{ij}$</span> of the branches must be small compared to their reactance values <span>$x_{ij}$</span>, and second, the angle differences must be small, i.e., <span>$\theta_{ij} \approx 0$</span> <a href="#inDepthPowerFlowSolutionReference">[3]</a>. Therefore, starting from the above equation, we have:</p><p class="math-container">\[  \begin{bmatrix}
    \mathbf{J_{11}(x)} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{J_{22}(x)}
  \end{bmatrix}
  \begin{bmatrix}
    \mathbf{\Delta \bm \theta} \\ \mathbf{\Delta V}
  \end{bmatrix}	+
  \begin{bmatrix}
    \mathbf{f}_{P}(\mathbf x) \\ \mathbf{f}_{Q}(\mathbf x)
  \end{bmatrix} = \mathbf 0,\]</p><p>which gives the decoupled system as follows:</p><p class="math-container">\[  \begin{aligned}
    \mathbf{f}_{P}(\mathbf x) &amp;= -\mathbf{J_{11}(x)} \mathbf{\Delta \bm  \theta} \\
    \mathbf{f}_{Q}(\mathbf x) &amp;= -\mathbf{J_{22}(x)} \mathbf{\Delta V}.
  \end{aligned}\]</p><p>To examine the problem, it is helpful to express it as:</p><p class="math-container">\[  \begin{aligned}
    {f}_{P_2}(\mathbf x) &amp;= -\Delta \theta_2\cfrac{\mathrm \partial{{f_{P_2}}(\mathbf x)}} {\mathrm \partial \theta_2} - \cdots -
    \Delta \theta_n \cfrac{\mathrm \partial{{f_{P_2}}(\mathbf x)}}{\mathrm \partial \theta_{n}} \\
    &amp; \vdots \\
    {f}_{P_n}(\mathbf x) &amp;= -\Delta \theta_2\cfrac{\mathrm \partial{{f_{P_n}}(\mathbf x)}} {\mathrm \partial \theta_2} - \cdots -
    \Delta \theta_n \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x)}}{\mathrm \partial \theta_{n}}\\
    {f}_{Q_2}(\mathbf x) &amp;= - \Delta V_2 \cfrac{\mathrm \partial{{f_{Q_2}}(\mathbf x)}}{\mathrm \partial V_{2}} - \cdots -
    \Delta V_{n_{\text{pq}}}  \cfrac{\mathrm \partial{{f_{Q_2}}(\mathbf x)}}{\mathrm \partial V_{m}}\\
    &amp; \vdots \\
    {f}_{Q_{m}}(\mathbf x) &amp;= - \Delta V_2 \cfrac{\mathrm \partial{{f_{Q_{m}}}(\mathbf x)}}{\mathrm \partial V_{2}} - \cdots -
    \Delta V_{m}  \cfrac{\mathrm \partial{{f_{Q_{m}}}(\mathbf x)}}{\mathrm \partial V_{m}}.
  \end{aligned}\]</p><p>Firstly, the second part of the expressions is expanded as follows:</p><p class="math-container">\[  \begin{aligned}
  {f}_{Q_2}(\mathbf x) &amp;=
  -\cfrac{\Delta V_2}{V_2}V_2 \cfrac{\mathrm \partial{{f_{Q_2}}(\mathbf x)}}{\mathrm \partial V_{2}} - \cdots -
  \cfrac{\Delta V_{m}}{V_{m}} V_{m}
  \cfrac{\mathrm \partial{{f_{Q_2}}(\mathbf x)}}{\mathrm \partial V_{m}}\\
  &amp; \vdots \\
  {f}_{Q_{m}}(\mathbf x) &amp;=
  - \cfrac{\Delta V_2}{V_2}V_2 \cfrac{\mathrm \partial{{f_{Q_{m}}}(\mathbf x)}}{\mathrm \partial V_{2}} - \cdots -
  \cfrac{\Delta V_{m}}{V_{m}} V_{m}
  \cfrac{\mathrm \partial{{f_{Q_{m}}}(\mathbf x)}}{\mathrm \partial V_{m}}.
  \end{aligned}\]</p><p>Next, the Jacobian elements are derived. To achieve this, we can use the expressions defined for the Newton-Raphson method. For PQ buses, the above expansions are applied as:</p><p class="math-container">\[  \begin{aligned}
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x)}} {\mathrm \partial \theta_{i}} &amp;=
  {V}_{i}\sum\limits_{j=1}^n {V}_{j}(-G_{ij}
  \sin\theta_{ij}+B_{ij}\cos\theta_{ij}) - {V}_{i}^2B_{ii}\\
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x)}}
  {\mathrm \partial \theta_{j}}&amp;={V}_{i}{V}_{j}
  (G_{ij}\sin\theta_{ij}-B_{ij}\cos\theta_{ij})\\
  V_i \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x)}}
  {\mathrm \partial V_{i}} &amp;= V_i\sum\limits_{j=1
  }^n {V}_{j}(G_{ij}\sin\theta_{ij}-
  B_{ij}\cos\theta_{ij})-{V}_{i}^2 B_{ii}\\
  V_j \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x)}}{\mathrm
  \partial V_{j}} &amp;= {V}_{i}V_j (G_{ij}\sin\theta_{ij}-
  B_{ij}\cos\theta_{ij}).
  \end{aligned}\]</p><p>As the definition of reactive power is given by the equation:</p><p class="math-container">\[    {Q}_{i} ={V}_{i}\sum\limits_{j=1}^n {V}_{j}(G_{ij}\sin\theta_{ij}-B_{ij}\cos\theta_{ij}),\]</p><p>the Jacobian elements can be expressed in the following manner:</p><p class="math-container">\[  \begin{aligned}
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x)}} {\mathrm \partial \theta_{i}} &amp;=
  -Q_i - {V}_{i}^2B_{ii}\\
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x)}}
  {\mathrm \partial \theta_{j}}&amp;={V}_{i}{V}_{j}
  (G_{ij}\sin\theta_{ij}-B_{ij}\cos\theta_{ij})\\
  V_i \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x)}}
  {\mathrm \partial V_{i}} &amp;= Q_i-{V}_{i}^2 B_{ii}\\
  V_j \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x)}}{\mathrm
  \partial V_{j}} &amp;= {V}_{i}V_j (G_{ij}\sin\theta_{ij}-
  B_{ij}\cos\theta_{ij}).
  \end{aligned}\]</p><p>The decoupled model is established through the following approximations:</p><p class="math-container">\[  \begin{aligned}
    \sin(\theta_{ij}) \approx 0 \\
    \cos(\theta_{ij}) \approx 1 \\
    Q_i &lt;&lt; B_{ii}V_i^2.
  \end{aligned}\]</p><p>Thus, when the approximations are made, the Jacobian elements are simplified, resulting in the decoupled model where the Jacobian elements are:</p><p class="math-container">\[  \begin{aligned}
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x)}} {\mathrm \partial \theta_{i}} &amp;= -{V}_{i}^2B_{ii}\\
  \cfrac{\mathrm \partial{{f_{P_i}}(\mathbf x)}} {\mathrm \partial \theta_{j}} &amp;= -{V}_{i}{V}_{j}B_{ij}\\
  V_i \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x)}} {\mathrm \partial V_{i}} &amp;= -{V}_{i}^2B_{ii}\\
  V_j \cfrac{\mathrm \partial{{f_{Q_i}}(\mathbf x)}}{\mathrm\partial V_{j}} &amp;=  -{V}_{i}{V}_{j}B_{ij}.
  \end{aligned}\]</p><p>Thus, the initial system of equations becomes:</p><p class="math-container">\[  \begin{aligned}
    {f}_{P_2}(\mathbf x) &amp;= {V}_{2}^2B_{22} \Delta \theta_2 + \cdots + {V}_{2}{V}_{n}B_{2n} \Delta \theta_n \\
    &amp; \vdots \\
    {f}_{P_n}(\mathbf x) &amp;= {V}_{2}{V}_{n}B_{n2} \Delta \theta_2 + \cdots + {V}_{n}^2B_{nn} \Delta \theta_n \\
    {f}_{Q_2}(\mathbf x) &amp;=  {V}_{2}^2B_{22} \cfrac{\Delta V_2}{V_2} + \cdots +
     {V}_{2}V_{m}B_{2m} \cfrac{\Delta V_{m}}{V_{m}} \\
    &amp; \vdots \\
    {f}_{Q_{m}}(\mathbf x) &amp;= {V}_{2}V_{m}B_{m2} \cfrac{\Delta V_2}{V_2} + \cdots +
    V_{m}^2 B_{mm} \cfrac{\Delta V_{m}}{V_{m}}.
  \end{aligned}\]</p><p>Using <span>$V_j \approx 1$</span>, wherein <span>$V_i^2 = V_iV_j, j=i$</span>, the first part of the equations can be simplified to:</p><p class="math-container">\[  \begin{aligned}
    {f}_{P_2}(\mathbf x) &amp;= {V}_{2}B_{22} \Delta \theta_2 + \cdots + {V}_{2}B_{2n} \Delta \theta_n \\
    &amp; \vdots \\
    {f}_{P_n}(\mathbf x) &amp;= {V}_{n}B_{n2} \Delta \theta_2 + \cdots + {V}_{n}B_{nn} \Delta \theta_n.
  \end{aligned}\]</p><p>Similarly, the second part of the equations can be simplified to:</p><p class="math-container">\[  \begin{aligned}
    {f}_{Q_2}(\mathbf x) &amp;=  {V}_{2}B_{22} \Delta V_2 + \cdots +
     V_2 B_{2m} \Delta V_{m}
    \\
    &amp; \vdots \\
    {f}_{Q_{m}}(\mathbf x) &amp;= V_{m}B_{m2} \Delta V_2 + \cdots +
    V_{m} B_{mm} \Delta V_{m}.
  \end{aligned}\]</p><p>The fast Newton-Raphson method is ultimately based on the system of equations presented below:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{{f}_{P_2}(\mathbf x)}{{V}_{2}} &amp;= B_{22} \Delta \theta_2 + \cdots + B_{2n} \Delta \theta_n \\
    &amp; \vdots \\
    \cfrac{{f}_{P_n}(\mathbf x)}{{V}_{n}} &amp;= B_{n2} \Delta \theta_2 + \cdots + B_{nn} \Delta \theta_n \\
    \cfrac{{f}_{Q_2}(\mathbf x)}{{V}_{2}} &amp;=  B_{22} \Delta V_2 + \cdots + B_{2m} \Delta V_{m} \\
    &amp; \vdots \\
    \cfrac{{f}_{Q_{m}}(\mathbf x)}{V_{m}} &amp;= B_{m2} \Delta V_2 + \cdots +
    B_{mm} \Delta V_{m}.
  \end{aligned}\]</p><p>This system can be rewritten as:</p><p class="math-container">\[  \begin{aligned}
    \mathbf{h}_{P}(\mathbf x) &amp;= \mathbf{B}_1 \mathbf{\Delta \bm \theta} \\
    \mathbf{h}_{Q}(\mathbf x) &amp;= \mathbf{B}_2 \mathbf{\Delta V}.
  \end{aligned}\]</p><p>One of the main advantages of this approach is that the Jacobian matrices <span>$\mathbf{B}_1$</span> and <span>$\mathbf{B}_2$</span> are constant and need only be formed once. Furthermore, this method can be used to define both the XB and BX versions of the fast Newton-Raphson algorithm.</p><hr/><h4 id="XB-Version"><a class="docs-heading-anchor" href="#XB-Version">XB Version</a><a id="XB-Version-1"></a><a class="docs-heading-anchor-permalink" href="#XB-Version" title="Permalink"></a></h4><p>The matrix <span>$\mathbf{B}_1$</span> is formed by neglecting the resistance <span>$r_{ij}$</span>, shunt susceptance <span>$\Im \{ y_{\text{sh}i} \}$</span>, charging susceptance <span>$\Im \{ y_{\text{s}ij} \}$</span>, and transformer tap ratio magnitude<span>$\tau_{ij}$</span>. The matrix <span>$\mathbf{B}_2$</span> is constructed by disregarding the transformer phase shift angle <span>$\phi_{ij}$</span>. This approach corresponds to the standard fast Newton-Raphson method and is known to exhibit exceptional convergence properties in typical scenarios <a href="#inDepthPowerFlowSolutionReference">[3]</a>.</p><p>To initialize the XB version of the fast Newton-Raphson method, one can utilize the following code snippet:</p><pre><code class="language-julia-repl hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = fastNewtonRaphsonXB(system)</code></pre><hr/><h4 id="BX-Version"><a class="docs-heading-anchor" href="#BX-Version">BX Version</a><a id="BX-Version-1"></a><a class="docs-heading-anchor-permalink" href="#BX-Version" title="Permalink"></a></h4><p>The matrix <span>$\mathbf{B}_1$</span> ignores the shunt susceptance<span>$\Im \{ y_{\text{sh}i} \}$</span>, charging susceptance <span>$\Im \{ y_{\text{s}ij} \}$</span>, and transformer tap ratio magnitude <span>$\tau_{ij}$</span>. The matrix <span>$\mathbf{B}_2$</span> ignores the resistance <span>$r_{ij}$</span> and transformer phase shift angle <span>$\phi_{ij}$</span>. In usual cases, the iteration count for the BX version is comparable to the XB scheme. However, for systems with high <span>$r_{ij}/x_{ij}$</span> ratios, the BX scheme requires considerably fewer iterations than the XB scheme to solve the power flow <a href="#inDepthPowerFlowSolutionReference">[3]</a>.</p><p>To initialize the BX version of the fast Newton-Raphson method, you can use the following code:</p><pre><code class="language-julia-repl hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = fastNewtonRaphsonBX(system)</code></pre><hr/><h4 id="Method-Implementation-2"><a class="docs-heading-anchor" href="#Method-Implementation-2">Method Implementation</a><a class="docs-heading-anchor-permalink" href="#Method-Implementation-2" title="Permalink"></a></h4><p>To start, the JuliaGrid computes the Jacobian matrices <span>$\mathbf{B}_1$</span> and <span>$\mathbf{B}_2$</span> that correspond to the active and reactive power equations, respectively. These matrices can be accessed using the following commands:</p><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.active.jacobian
julia&gt; result.algorithm.reactive.jacobian</code></pre><p>Next, JuliaGrid utilizes the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.lu">LU factorization</a> of matrices <span>$\mathbf{B}_1$</span> and <span>$\mathbf{B}_2$</span> to compute solutions through iterations. The lower and upper triangular matrices, as well as the right and left permutation matrices, and the diagonal scaling matrix can be accessed using the following commands:</p><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.active.lower
julia&gt; result.algorithm.active.upper
julia&gt; result.algorithm.active.right
julia&gt; result.algorithm.active.left
julia&gt; result.algorithm.active.scaling</code></pre><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.reactive.lower
julia&gt; result.algorithm.reactive.upper
julia&gt; result.algorithm.reactive.right
julia&gt; result.algorithm.reactive.left
julia&gt; result.algorithm.reactive.scaling</code></pre><p>To solve the AC power flow and obtain bus voltage magnitudes and angles, JuliaGrid provides the following function sequence:</p><pre><code class="language-julia-repl hljs">stopping = result.algorithm.iteration.stopping
for i = 1:100
    fastNewtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end</code></pre><p>The fast Newton-Raphson method first solves the equation:</p><p class="math-container">\[  \mathbf{\Delta \bm \theta}^{(\nu)} = \mathbf{B}_1^{-1} \mathbf{h}_{P}(\bm \theta^{(\nu)}, \mathbf V^{(\nu)}).\]</p><p>The corresponding increment and mismatch can be accessed via:</p><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.active.increment
julia&gt; result.algorithm.active.mismatch</code></pre><p>After that, the solution is updated as follows:</p><p class="math-container">\[  \bm{\theta}^{(\nu+1)} = \bm{\theta}^{(\nu)} + {\mathbf \Delta \bm \theta}^{(\nu)}.\]</p><p>The final results are stored in the vector that contains all bus voltage angles:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.voltage.angle</code></pre><p>The fast Newton-Raphson method then solves the equation:</p><p class="math-container">\[  \mathbf{\Delta V}^{(\nu)} = \mathbf{B}_2^{-1} \mathbf{h}_{Q}(\bm \theta^{(\nu + 1)}, \mathbf V^{(\nu)}).\]</p><p>The corresponding increment and mismatch can be accessed via:</p><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.reactive.increment
julia&gt; result.algorithm.reactive.mismatch</code></pre><p>Finally, the solution is updated as follows:</p><p class="math-container">\[  \mathbf{V}^{(\nu+1)} = \mathbf{V}^{(\nu)} + \mathbf{\Delta V}^{(\nu)}.\]</p><p>The final results are stored in the vector that contains all bus voltage magnitudes:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.voltage.magnitude</code></pre><p>The functions <span>$\mathbf{f}_{P}(\mathbf x)$</span> and <span>$\mathbf{f}_{Q}(\mathbf x)$</span> remain free of approximations, with only the calculation of the state variable increments affected <a href="#inDepthPowerFlowSolutionReference">[2]</a>. As a result, we still use the following equations to compute the mismatches:</p><p class="math-container">\[  \begin{aligned}
    f_{P_i}(\mathbf x) &amp;= {V}_{i}\sum\limits_{j=1}^n {V}_{j}(G_{ij}\cos\theta_{ij}+B_{ij}\sin\theta_{ij}) - {P}_{i} = 0,
    \;\;\; i \in \mathcal{N}_{\text{pq}} \cup \mathcal{N}_{\text{pv}}\\
    f_{Q_i}(\mathbf x) &amp;= {V}_{i}\sum\limits_{j=1}^n {V}_{j} (G_{ij}\sin\theta_{ij}-B_{ij}\cos\theta_{ij}) - {Q}_{i} = 0,
    \;\;\; i \in \mathcal{N}_{\text{pq}}.
  \end{aligned}\]</p><p>Therefore, we compute the mismatches in active power injection for PQ and PV buses as:</p><p class="math-container">\[  {h}_{P_i}(\mathbf x^{(\nu+1)}) =
  \sum\limits_{j=1}^n {V}_{j}^{(\nu+1)}(G_{ij}\cos\theta_{ij}^{(\nu+1)}+B_{ij}\sin\theta_{ij}^{(\nu+1)}) - \cfrac{{P}_{i}}{{V}_{i}^{(\nu+1)}},
  \;\;\;  i \in \mathcal{N}_{\text{pq}} \cup \mathcal{N}_{\text{pv}},\]</p><p>and in reactive power injection for PQ buses as:</p><p class="math-container">\[    {h}_{Q_i}(\mathbf x^{(\nu+1)}) =
    \sum\limits_{j=1}^n {V}_{j}^{(\nu+1)} (G_{ij}\sin\theta_{ij}^{(\nu)}-B_{ij}\cos\theta_{ij}^{(\nu+1)}) - \cfrac{{Q}_{i}}{{V}_{i}^{(\nu+1)}},
    \;\;\; i \in \mathcal{N}_{\text{pq}}.\]</p><p>The iteration loop is terminated when the following conditions are met:</p><p class="math-container">\[    \max \{|h_{P_i}(\mathbf x^{(\nu)})|,\; i \in \mathcal{N}_{\text{pq}} \cup \mathcal{N}_{\text{pv}} \} &lt; \epsilon \\
    \max \{|h_{Q_i}(\mathbf x^{(\nu)})|,\; i \in \mathcal{N}_{\text{pq}} \} &lt; \epsilon.\]</p><p>Here, <span>$\epsilon$</span> refers to the pre-defined stopping criteria. JuliaGrid stores these values to break the iteration loop in the following variables:</p><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.iteration.stopping.active
julia&gt; result.algorithm.iteration.stopping.reactive</code></pre><hr/><h2 id="inDepthGaussSeidel"><a class="docs-heading-anchor" href="#inDepthGaussSeidel">Gauss-Seidel Method</a><a id="inDepthGaussSeidel-1"></a><a class="docs-heading-anchor-permalink" href="#inDepthGaussSeidel" title="Permalink"></a></h2><p>By defining the complex current injection at bus <span>$i \in \mathcal{N}$</span> as:</p><p class="math-container">\[	\bar{I}_{i} = \frac{{P}_{i} - j{Q}_{i}}{\bar{V}_{i}^*},\]</p><p>the power flow problem can be represented as a system of nonlinear equations:</p><p class="math-container">\[    \mathbf {\bar {I}} = \mathbf{Y} \mathbf {\bar {V}}.\]</p><p>This system of equations can be expanded to <span>$n$</span> complex equations:</p><p class="math-container">\[  \begin{aligned}
    Y_{11} &amp; \bar{V}_{1}  + \cdots+ Y_{1n}\bar{V}_{n} = \frac{{P}_{1} - j{Q}_{1}}{\bar{V}_{1}^*} \\
    \; \vdots &amp; \\
    Y_{n1} &amp; \bar{V}_{1} + \cdots+ Y_{nn}\bar{V}_{n} = \frac{{P}_{n} - j{Q}_{n}}{\bar{V}_{n}^*}.
	\end{aligned}\]</p><p>While the Gauss-Seidel method directly solves the system of equations, it suffers from very slow convergence, which increases almost linearly with the system size, necessitating numerous iterations to obtain the desired solution <a href="#inDepthPowerFlowSolutionReference">[4]</a>. Moreover, the convergence time of the Gauss-Seidel method increases significantly for large-scale systems and can face convergence issues for systems with high active power transfers. Nevertheless, power flow programs utilize both the Gauss-Seidel and Newton-Raphson methods in a complementary manner. Specifically, the Gauss-Seidel method is employed to obtain a quick approximate solution from a &quot;flat start&quot;, while the Newton-Raphson method is utilized to obtain the final accurate solution <a href="#inDepthPowerFlowSolutionReference">[5]</a>.</p><p>The Gauss-Seidel method is typically based on the system of equations with <span>$n$</span> complex equations, one of which represents the slack bus. As a result, one equation can be eliminated, resulting in a power flow problem with <span>$n-1$</span> equations.</p><hr/><h4 id="Method-Implementation-3"><a class="docs-heading-anchor" href="#Method-Implementation-3">Method Implementation</a><a class="docs-heading-anchor-permalink" href="#Method-Implementation-3" title="Permalink"></a></h4><p>To solve the AC power flow and determine the bus voltage magnitudes and angles, the Gauss-Seidel method can be used with the help of JuliaGrid. The sequence of functions provided by JuliaGrid for this purpose is shown below:</p><pre><code class="language-julia-repl hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = gaussSeidel(system)
stopping = result.algorithm.iteration.stopping
for i = 1:1000
    gaussSeidel!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end</code></pre><p>The Gauss-Seidel method starts by using initial complex bus voltages <span>$\bar{V}_i^{(0)}$</span>, <span>$i \in \mathcal{N}$</span>. The method then computes bus complex voltages for PQ buses using the following iteration scheme:</p><p class="math-container">\[    \bar{V}_{i}^{(\nu + 1)} =
    \cfrac{1}{{Y}_{ii}} \Bigg(\cfrac{{P}_{i} - j{Q}_{i}}{\bar{V}_{i}^{*(\nu)}} -
    \sum\limits_{\substack{j = 1}}^{i - 1} {Y}_{ij}\bar{V}_{j}^{(\nu + 1)} -
    \sum\limits_{\substack{j = i + 1}}^{n} {Y}_{ij}\bar{V}_{j}^{(\nu)}\Bigg),
    \;\;\; i \in \mathcal{N}_{\text{pq}}.\]</p><p>The next step is to determine the solution for PV buses in two stages: first, the reactive power injection is calculated, and then the bus complex voltage is updated using the following equations:</p><p class="math-container">\[  \begin{aligned}
    Q_i^{(\nu+1)} &amp;=
    -\Im \left\{ \bar{V}_{i}^{*(\nu + 1)} \sum\limits_{j=1}^n {Y}_{ij}\bar{V}_{j}^{(\nu+1)}\right\}, \;\;\; i \in \mathcal{N}_{\text{pv}} \\
    \bar{V}_{i}^{(\nu + 1)} &amp;:=
    \cfrac{1}{{Y}_{ii}} \Bigg(\cfrac{{P}_{i} - j{Q}_{i}^{(\nu + 1)}}{\bar{V}_{i}^{*(\nu + 1)}}-
    \sum\limits_{\substack{j = 1,\;j \neq i}}^{n} {Y}_{ij}\bar{V}_{j}^{(\nu + 1)} \Bigg), \;\;\; i \in \mathcal{N}_{\text{pv}}.
  \end{aligned}\]</p><p>The obtained voltage magnitude may not be equal to the magnitude specified for the PV bus, so a voltage correction step is necessary:</p><p class="math-container">\[      \bar{V}_{i}^{(\nu+1)} := {V}_{i}^{(0)} \cfrac{\bar{V}_{i}^{(\nu+1)}}{{V}_{i}^{(\nu+1)}}, \;\;\; i \in \mathcal{N}_{\text{pv}}.\]</p><p>JuliaGrid stores the final results in vectors that contain all bus voltage magnitudes and angles:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.voltage.magnitude
julia&gt; result.bus.voltage.angle</code></pre><p>The iteration loop is executed repeatedly until the stopping condition is met. After each loop, we calculate the active power injection mismatch for PQ and PV buses as:</p><p class="math-container">\[    {f}_{P_i}(\mathbf x^{(\nu+1)}) = \Re\{\bar{V}_i^{(\nu + 1)} \bar{I}_i^{*(\nu + 1)}\} - P_i, \;\;\; i \in \mathcal{N}_{\text{pq}} \cup \mathcal{N}_{\text{pv}},\]</p><p>and the reactive power injection mismatch for PQ buses as:</p><p class="math-container">\[  {f}_{Q_i}(\mathbf x^{(\nu+1)}) = \Im\{\bar{V}_i^{(\nu + 1)} \bar{I}_i^{*(\nu + 1)}\} - Q_i, \;\;\; i \in \mathcal{N}_{\text{pq}}.\]</p><p>The iteration loop is terminated when the following conditions are satisfied:</p><p class="math-container">\[    \max \{|{f}_{P_i}(\mathbf x^{(\nu+1)})|,\; i \in \mathcal{N}_{\text{pq}} \cup \mathcal{N}_{\text{pv}} \} &lt; \epsilon \\
    \max \{|{f}_{Q_i}(\mathbf x^{(\nu+1)})|,\; i \in \mathcal{N}_{\text{pq}} \} &lt; \epsilon\]</p><p>where <span>$\epsilon$</span> is a pre-determined stopping criterion. JuliaGrid stores these values in order to break the iteration loop:</p><pre><code class="language-julia-repl hljs">julia&gt; result.algorithm.iteration.stopping.active
julia&gt; result.algorithm.iteration.stopping.reactive</code></pre><hr/><h2 id="dcPowerFlowSolution"><a class="docs-heading-anchor" href="#dcPowerFlowSolution">DC Power Flow Solution</a><a id="dcPowerFlowSolution-1"></a><a class="docs-heading-anchor-permalink" href="#dcPowerFlowSolution" title="Permalink"></a></h2><p>As discussed in section <a href="../../powerSystem/inDepthACDCModel/#inDepthDCModel">In-depth DC Model</a>, the DC power flow problem can be represented by a set of linear equations given by:</p><p class="math-container">\[  \mathbf {P} = \mathbf{B} \bm {\theta} + \mathbf{P_\text{gs}} + \mathbf{P}_\text{sh}.\]</p><hr/><h4 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h4><p>JuliaGrid offers a set of functions to solve the DC power flow problem and obtain the bus voltage angles. Firstly, the power system is loaded and the DC model is built using the following code sequence:</p><pre><code class="language-julia-repl hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)</code></pre><p>Next, the DC power flow solution is obtained through a non-iterative approach by solving the linear equation:</p><p class="math-container">\[    \bm {\theta} = \mathbf{B}^{-1}(\mathbf {P} - \mathbf{P_\text{gs}} - \mathbf{P}_\text{sh}).\]</p><pre><code class="language-julia-repl hljs">result = dcPowerFlow(system)</code></pre><p>It is worth noting that the slack bus voltage angle is excluded from the vector <span>$\bm{\theta}$</span>. Therefore, the corresponding elements in the vectors <span>$\mathbf {P}$</span>, <span>$\mathbf{P_\text{gs}}$</span>, <span>$\mathbf{P}_\text{sh}$</span>, and the corresponding column of the matrix <span>$\mathbf{B}$</span> are removed during the calculation process.</p><p>Finally, the resulting bus voltage angles are saved in a vector as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.voltage.angle</code></pre><h2 id="acPowerFlowAnalysis"><a class="docs-heading-anchor" href="#acPowerFlowAnalysis">AC Power Flow Anylsis</a><a id="acPowerFlowAnalysis-1"></a><a class="docs-heading-anchor-permalink" href="#acPowerFlowAnalysis" title="Permalink"></a></h2><p>To perform the AC power flow analysis using JuliaGrid, a sequence of functions is provided to calculate the powers and currents associated with buses and branches, as well as powers related to generators: </p><pre><code class="language-julia-repl hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
stopping = result.algorithm.iteration.stopping
for i = 1:10
    newtonRaphson!(system, result)
    if stopping.active &lt; 1e-8 &amp;&amp; stopping.reactive &lt; 1e-8
        break
    end
end

bus!(system, result)
branch!(system, result)
generator!(system, result)</code></pre><hr/><h4 id="Bus"><a class="docs-heading-anchor" href="#Bus">Bus</a><a id="Bus-1"></a><a class="docs-heading-anchor-permalink" href="#Bus" title="Permalink"></a></h4><p>To obtain the complex current injection at a particular bus, the following expression can be used:</p><p class="math-container">\[    \bar{I}_{i} = \sum\limits_{j = 1}^n {Y}_{ij} \bar{V}_{j},\;\;\; i \in \mathcal{N}.\]</p><p>In JuliaGrid, the magnitude and angle of the complex current injection at each bus can be obtained using:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.current.injection.magnitude
julia&gt; result.bus.current.injection.angle</code></pre><p>The active and reactive power injections at the bus can be computed as:</p><p class="math-container">\[    {S}_{i} =\bar{V}_{i}\bar{I}_{i}^*,\;\;\; i \in \mathcal{N}.\]</p><p>You can retrieve the active and reactive power injections using:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.power.injection.active
julia&gt; result.bus.power.injection.reactive</code></pre><p>For generators that supply bus <span>$i \in \mathcal{N}_{\text{pv}}$</span>, the active power is equal to the sum of the given generator active powers in the input data, except for the slack bus, which can be determined as:</p><p class="math-container">\[    P_{\text{s}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{sb}},\]</p><p>where <span>${P}_{\text{d}i}$</span> represents the active power demanded by consumers at the slack bus. You can retrieve the active power using:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.power.supply.active</code></pre><p>The reactive power of the generators that supply the bus can be computed using the equation:</p><p class="math-container">\[    Q_{\text{s}i} = Q_i + Q_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{pv}} \cup \mathcal{N}_{\text{sb}},\]</p><p>where <span>${Q}_{\text{d}i}$</span> represents the reactive power demanded by consumers at the corresponding bus. You can retrieve the reactive power using: </p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.power.supply.reactive</code></pre><p>To obtain the active and reactive powers related to the shunt element at the bus, use the equations:</p><p class="math-container">\[  {S}_{\text{sh}i} =\bar{V}_{i}\bar{I}_{\text{sh}i}^* = {y}_{\text{sh}i}^*|\bar{V}_{i}|^2,\;\;\; i \in \mathcal{N}.\]</p><p>You can retrieve the active and reactive powers using:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.power.shunt.active
julia&gt; result.bus.power.shunt.reactive</code></pre><hr/><h4 id="Branch"><a class="docs-heading-anchor" href="#Branch">Branch</a><a id="Branch-1"></a><a class="docs-heading-anchor-permalink" href="#Branch" title="Permalink"></a></h4><p>To obtain the complex current flow at bus &quot;from&quot; <span>$i \in \mathcal{N}$</span> of the branch, the <a href="../../powerSystem/inDepthACDCModel/#ACBranchModel">unified branch model</a> can be used:</p><p class="math-container">\[    \bar{I}_{ij} = \cfrac{1}{\tau_{ij}^2}({y}_{ij} + y_{\text{s}ij}) \bar{V}_{i} - \alpha_{ij}^*{y}_{ij} \bar{V}_{j},\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The magnitude and angle of the resulting complex current flow at the &quot;from&quot; bus can be obtained using the following Julia code:</p><pre><code class="language-julia-repl hljs">julia&gt; result.branch.current.from.magnitude
julia&gt; result.branch.current.from.angle</code></pre><p>Similarly, the complex current flow at the bus &quot;to&quot; <span>$j \in \mathcal{N}$</span> of the branch can be obtained using the same unified branch model:</p><p class="math-container">\[    \bar{I}_{ji} = -\alpha_{ij}{y}_{ij} \bar{V}_{i} + ({y}_{ij} + y_{\text{s}ij}) \bar{V}_{j},\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The magnitude and angle of the resulting complex current flow at the &quot;to&quot; bus can be obtained using the following Julia code:</p><pre><code class="language-julia-repl hljs">julia&gt; result.branch.current.to.magnitude
julia&gt; result.branch.current.to.angle</code></pre><p>Finally, the complex current flow through the series impedance of the branch in the direction from bus <span>$i \in \mathcal{N}$</span> to bus <span>$j \in \mathcal{N}$</span> can be determined as:</p><p class="math-container">\[    \bar{I}_{\text{b}ij} =  y_{ij} (\alpha_{ij}\bar{V}_{i} - \bar{V}_{j}),,\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The magnitude and angle of the resulting complex current flow through the series impedance can be obtained using the following Julia code:</p><pre><code class="language-julia-repl hljs">julia&gt; result.branch.current.impedance.magnitude
julia&gt; result.branch.current.impedance.angle</code></pre><p>To obtain the active and reactive power flows at the bus &quot;from&quot; <span>$i \in \mathcal{N}$</span> of the branch, we use the following equations, based on the <a href="../../powerSystem/inDepthACDCModel/#ACBranchModel">unified branch model</a>:</p><p class="math-container">\[    {S}_{ij} = \bar{V}_{i}\bar{I}_{ij}^*,\;\;\; (i,j) \in \mathcal{E}.\]</p><p>We can retrieve the active and reactive power flows using the following Julia commands:</p><pre><code class="language-julia-repl hljs">julia&gt; result.branch.power.from.active
julia&gt; result.branch.power.from.reactive</code></pre><p>Similarly, to obtain the active and reactive power flows at the bus &quot;to&quot; <span>$j \in \mathcal{N}$</span> of the branch, we use the following equations:</p><p class="math-container">\[    {S}_{ji} = \bar{V}_{j}\bar{I}_{ji}^*,\;\;\; (i,j) \in \mathcal{E}.\]</p><p>We can retrieve the active and reactive power flows using the following Julia commands:</p><pre><code class="language-julia-repl hljs">julia&gt; result.branch.power.to.active
julia&gt; result.branch.power.to.reactive</code></pre><p>The series impedance <span>$z_{ij}$</span> of the branch causes active and reactive power losses. We can obtain these losses using the following equations:</p><p class="math-container">\[    \begin{aligned}
        P_{\text{loss}ij} &amp;= r_{ij}|\bar{I}_{\text{b}ij}|^2 \\
        Q_{\text{loss}ij} &amp;= x_{ij}|\bar{I}_{\text{b}ij}|^2,
    \end{aligned}\]</p><p>where <span>$(i,j) \in \mathcal{E}$</span>. We can retrieve the active and reactive power losses using the following Julia commands:</p><pre><code class="language-julia-repl hljs">julia&gt; result.branch.power.loss.active
julia&gt; result.branch.power.loss.reactive</code></pre><p>The capacitive susceptances of the branch lead to reactive power injection. We can obtain the total reactive power injected by the branch using the following equation:</p><p class="math-container">\[    Q_{\text{ch}ij} = b_{\text{s}i} (|\alpha_{ij}\bar{V}_{i}|^2 - |\bar{V}_{j}|^2),\;\;\; (i,j) \in \mathcal{E}.\]</p><p>We can retrieve the injected reactive power using the following Julia command:</p><pre><code class="language-julia-repl hljs">julia&gt; result.branch.power.shunt.reactive</code></pre><hr/><h4 id="Generator"><a class="docs-heading-anchor" href="#Generator">Generator</a><a id="Generator-1"></a><a class="docs-heading-anchor-permalink" href="#Generator" title="Permalink"></a></h4><p>To obtain the output active power of a generator located at bus <span>$i \in \mathcal{N}_{\text{pv}}$</span>, the given active power in the input data is used. If there are multiple generators at the same bus, their output active powers are also equal to the active powers specified in the input data. The output active power of the generator at the slack bus is determined as:</p><p class="math-container">\[    P_{\text{g}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{sb}}.\]</p><p>If there are several generators at the slack bus, the active power <span>$P_{\text{g}i}$</span> assigned to the first generator in the list of input data is reduced by the output active power of the other generators.</p><p>The output reactive power of a generator at the bus is given by:</p><p class="math-container">\[    Q_{\text{g}i} = Q_i + Q_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{pv}} \cup \mathcal{N}_{\text{sb}}.\]</p><p>If multiple generators are present, the reactive power is distributed proportionally between the generators based on their capabilities. </p><p>To retrieve the output active and reactive powers of the generators in the solved power flow, the following Julia code can be used:</p><pre><code class="language-julia-repl hljs">julia&gt; result.generator.power.active
julia&gt; result.generator.power.reactive</code></pre><hr/><h2 id="dcPowerFlowAnalysis"><a class="docs-heading-anchor" href="#dcPowerFlowAnalysis">DC Power Flow Anylsis</a><a id="dcPowerFlowAnalysis-1"></a><a class="docs-heading-anchor-permalink" href="#dcPowerFlowAnalysis" title="Permalink"></a></h2><p>Performing the DC power flow analysis involves computing active powers associated with buses, branches, and generators. JuliaGrid offers a sequence of functions to carry out this analysis:</p><pre><code class="language-julia-repl hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

result = dcPowerFlow(system)

bus!(system, result)
branch!(system, result)
generator!(system, result)</code></pre><hr/><h4 id="Bus-2"><a class="docs-heading-anchor" href="#Bus-2">Bus</a><a class="docs-heading-anchor-permalink" href="#Bus-2" title="Permalink"></a></h4><p>The expression for obtaining the active power injection at bus i \in \mathcal{N} is:</p><p class="math-container">\[   P_i = \sum_{j = 1}^n {B}_{ij} \theta_j + P_{\text{gs}i} + P_{\text{sh}i},\;\;\; i \in \mathcal{N}.\]</p><p>This value can be obtained using the following code:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.power.injection.active</code></pre><p>For the generators that supply bus<span>$i \in \mathcal{N}_{\text{pv}}$</span>, their output active power is equal to the given active power in the input data. However, for the slack bus, its output active power is determined as:</p><p class="math-container">\[    P_{\text{s}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{sb}},\]</p><p>where <span>${P}_{\text{d}i}$</span> represents the active power demanded by consumers at the slack bus. This information can be obtained using the following code:</p><pre><code class="language-julia-repl hljs">julia&gt; result.bus.power.supply.active</code></pre><hr/><h4 id="Branch-2"><a class="docs-heading-anchor" href="#Branch-2">Branch</a><a class="docs-heading-anchor-permalink" href="#Branch-2" title="Permalink"></a></h4><p>The active power flowing from bus <span>$i \in \mathcal{N}$</span> of the branch can be obtained using the following equation:</p><p class="math-container">\[    P_{ij} = \cfrac{1}{\tau_{ij} x_{ij}} (\theta_{i} -\theta_{j}-\phi_{ij}),\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The corresponding JuliaGrid function to obtain these values are:</p><pre><code class="language-julia-repl hljs">julia&gt; result.branch.power.from.active</code></pre><p>Similarly, the active power flowing to bus <span>$j \in \mathcal{N}$</span> of the branch can be obtained as:</p><p class="math-container">\[    P_{ji} = - P_{ij},\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The corresponding JuliaGrid function to obtain these values are:</p><pre><code class="language-julia-repl hljs">julia&gt; result.branch.power.to.active</code></pre><hr/><h4 id="Generator-2"><a class="docs-heading-anchor" href="#Generator-2">Generator</a><a class="docs-heading-anchor-permalink" href="#Generator-2" title="Permalink"></a></h4><p>The active power output of a generator located at bus <span>$i \in \mathcal{N}_{\text{pv}}$</span> is equal to the active power specified in the input data. If there are multiple generators at bus <span>$i \in \mathcal{N}_{\text{pv}}$</span>, their active power outputs are also equal to the active power specified in the input data. However, the active power output of a generator located at the slack bus is determined as:</p><p class="math-container">\[    P_{\text{g}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{sb}}.\]</p><p>If there are multiple generators at the slack bus, the active power output of the first generator in the input data is assigned to <span>$P_{\text{g}i}$</span>, and the output active power of the remaining generators is subtracted from it. This information can be obtained using the following Julia command:</p><pre><code class="language-julia-repl hljs">julia&gt; result.generator.power.active</code></pre><h2 id="inDepthPowerFlowSolutionReference"><a class="docs-heading-anchor" href="#inDepthPowerFlowSolutionReference">References</a><a id="inDepthPowerFlowSolutionReference-1"></a><a class="docs-heading-anchor-permalink" href="#inDepthPowerFlowSolutionReference" title="Permalink"></a></h2><p>[1] A. Wood and B. Wollenberg, <em>Power Generation, Operation, and Control</em>, ser. A Wiley-Interscience publication. Wiley, 1996.</p><p>[2] G. Andersson, <em>Modelling and analysis of electric power systems</em>, EEH-Power Systems Laboratory, Swiss Federal Institute of Technology (ETH), Zürich, Switzerland (2008).</p><p>[3] R. A. M. van Amerongen, &quot;A general-purpose version of the fast decoupled load flow,&quot; <em>IEEE Trans. Power Syst.</em>, vol. 4, no. 2, pp. 760-770, May 1989.</p><p>[4] D. P. Chassin, P. R. Armstrong, D. G. Chavarria-Miranda, and R. T. Guttromson, &quot;Gauss-seidel accelerated: implementing flow solvers on field programmable gate arrays,&quot; <em>in Proc. IEEE PES General Meeting</em>, 2006, pp. 5.</p><p>[5] R. D. Zimmerman, C. E. Murillo-Sanchez, <em>MATPOWER User’s Manual</em>, Version 7.0. 2019.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../analysis/">« Power Flow Analysis</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 8 March 2023 09:45">Wednesday 8 March 2023</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
