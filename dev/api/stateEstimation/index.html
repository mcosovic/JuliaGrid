<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State Estimation · JuliaGrid</title><meta name="title" content="State Estimation · JuliaGrid"/><meta property="og:title" content="State Estimation · JuliaGrid"/><meta property="twitter:title" content="State Estimation · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li class="is-active"><a class="tocitem" href>State Estimation</a><ul class="internal"><li><a class="tocitem" href="#Observability-Analysis-2"><span>Observability Analysis</span></a></li><li><a class="tocitem" href="#PMU-State-Estimation-2"><span>PMU State Estimation</span></a></li><li><a class="tocitem" href="#DC-State-Estimation-2"><span>DC State Estimation</span></a></li><li><a class="tocitem" href="#Bad-Data-Analysis-2"><span>Bad Data Analysis</span></a></li><li><a class="tocitem" href="#Utility-Function-2"><span>Utility Function</span></a></li></ul></li><li><a class="tocitem" href="../analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/api/stateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="StateEstimationAPI"><a class="docs-heading-anchor" href="#StateEstimationAPI">State Estimation</a><a id="StateEstimationAPI-1"></a><a class="docs-heading-anchor-permalink" href="#StateEstimationAPI" title="Permalink"></a></h1><p>For further information on this topic, please see the <a href="../../manual/dcStateEstimation/#DCStateEstimationManual">AC State Estimation</a> or <a href="../../manual/dcStateEstimation/#DCStateEstimationManual">DC State Estimation</a> sections of the Manual. Below, we have provided a list of functions that can be utilized for power flow analysis.</p><hr/><h6 id="Observability-Analysis"><a class="docs-heading-anchor" href="#Observability-Analysis">Observability Analysis</a><a id="Observability-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Observability-Analysis" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.islandTopologicalFlow-Tuple{PowerSystem, Wattmeter}"><code>islandTopologicalFlow</code></a></li><li><a href="#JuliaGrid.islandTopological-Tuple{PowerSystem, Wattmeter}"><code>islandTopological</code></a></li><li><a href="#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, IslandWatt}"><code>restorationGram!</code></a></li></ul><h6 id="PMU-State-Estimation"><a class="docs-heading-anchor" href="#PMU-State-Estimation">PMU State Estimation</a><a id="PMU-State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#PMU-State-Estimation" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a></li><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimationWLS{LinearWLS}}"><code>solve!</code></a></li></ul><h6 id="DC-State-Estimation"><a class="docs-heading-anchor" href="#DC-State-Estimation">DC State Estimation</a><a id="DC-State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#DC-State-Estimation" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a></li><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS{LinearWLS}}"><code>solve!</code></a></li></ul><h6 id="Bad-Data-Analysis"><a class="docs-heading-anchor" href="#Bad-Data-Analysis">Bad Data Analysis</a><a id="Bad-Data-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Bad-Data-Analysis" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.residualTest!"><code>residualTest!</code></a></li></ul><h6 id="Utility-Function"><a class="docs-heading-anchor" href="#Utility-Function">Utility Function</a><a id="Utility-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Function" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.pmuPlacement"><code>pmuPlacement</code></a></li></ul><hr/><h2 id="Observability-Analysis-2"><a class="docs-heading-anchor" href="#Observability-Analysis-2">Observability Analysis</a><a class="docs-heading-anchor-permalink" href="#Observability-Analysis-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.islandTopologicalFlow-Tuple{PowerSystem, Wattmeter}" href="#JuliaGrid.islandTopologicalFlow-Tuple{PowerSystem, Wattmeter}"><code>JuliaGrid.islandTopologicalFlow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islandTopologicalFlow(system::PowerSystem, meter::Union{Wattmeter, Varmeter})</code></pre><p>The function employs a topological method to identify observable islands solely through  active power flow measurements from the <code>Wattmeter</code> composite type or reactive power flow  measurements from the <code>Varmeter</code> composite type. This results in the formation of  disconnected and loop-free subgraphs. To be more specific, the function utilizes wattmeters  or varmeters strategically placed on the branches to detect observable islands. To elaborate  further, this approach detects islands based on the linear decoupled measurement model.</p><p><strong>Arguments</strong></p><p>To define flow observable islands, this function requires the composite types <code>PowerSystem</code>  and either <code>Wattmeter</code> or <code>Varmeter</code>.</p><p><strong>Returns</strong></p><p>The function returns an abstract type <code>Island</code>, containing information about the islands:</p><ul><li><code>island</code>: a list enumerating observable islands with indices of buses;</li><li><code>bus</code>: the positions of buses in relation to each island;</li><li><code>tie</code>: tie data associated with buses and branches.</li></ul><p><strong>Examples</strong></p><p>Find flow islands for the given set of measurement data using wattmeters:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)
statusWattmeter!(system, device; inservice = 15)

islands = islandTopologicalFlow(system, device.wattmeter)</code></pre><p>Find flow islands for the given set of measurement data using varmeters:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)
statusVarmeter!(system, device; inservice = 15)

islands = islandTopologicalFlow(system, device.varmeter)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/b514ae416bf2f96226ff56c239d1a92c29bd7d02/src/stateEstimation/observability.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.islandTopological-Tuple{PowerSystem, Wattmeter}" href="#JuliaGrid.islandTopological-Tuple{PowerSystem, Wattmeter}"><code>JuliaGrid.islandTopological</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islandTopological(system::PowerSystem, meter::Union{Wattmeter, Varmeter})</code></pre><p>The function employs a topological method to identify maximal observable islands solely  through active power measurements from the <code>Wattmeter</code> composite type or reactive power   measurements from the <code>Varmeter</code> composite type. Specifically, it employs wattmeters or  varmeters positioned on the branches to pinpoint flow observable islands. Subsequently,  these islands are merged based on the available injection measurements obtained from the  wattmeters or varmeters. To elaborate further, this approach detects islands based on the  linear decoupled measurement model.</p><p><strong>Arguments</strong></p><p>To define maximal flow observable islands, this function requires the composite types  <code>PowerSystem</code> and either <code>Wattmeter</code> or <code>Varmeter</code>.</p><p><strong>Returns</strong></p><p>The function returns an abstract type <code>Island</code>, containing information about the islands:</p><ul><li><code>island</code>: a list enumerating observable islands with indices of buses;</li><li><code>bus</code>: the positions of buses in relation to each island;</li><li><code>tie</code>: tie data associated with buses and branches.</li></ul><p><strong>Examples</strong></p><p>Find maximal islands for the given set of measurement data using wattmeters:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)
statusWattmeter!(system, device; inservice = 12)

islands = islandTopological(system, device.wattmeter)</code></pre><p>Find maximal islands for the given set of measurement data using varmeters:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)
statusVarmeter!(system, device; inservice = 12)

islands = islandTopological(system, device.varmeter)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/b514ae416bf2f96226ff56c239d1a92c29bd7d02/src/stateEstimation/observability.jl#L66-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, IslandWatt}" href="#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, IslandWatt}"><code>JuliaGrid.restorationGram!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restorationGram!(system::PowerSystem, device::Measurement, pseudo::Measurement, 
    islands::Island; threshold)</code></pre><p>Upon identifying the <code>islands</code>, the function incorporates measurements from the available  pseudo-measurements in the <code>pseudo</code> variable into the <code>device</code> variable to reinstate  observability. If the abstract type <code>Island</code> is derived from wattmeters, candidates for  restoring observability include active power measurements and bus voltage angle measurements  from the <code>pseudo</code> variable. Conversely, if the abstract type <code>Island</code> is derived from  varmeters, candidates for restoring observability encompass reactive power measurements  and bus voltage magnitude measurements from the <code>pseudo</code> variable. This method relies on  reduced coefficient matrices and the Gram matrix. </p><p>It is important to note that the device labels in the <code>device</code> and <code>pseudo</code> variables must  be different to enable the function to successfully incorporate measurements from <code>pseudo</code>  into the <code>device</code> set of measurements.</p><p><strong>Arguments</strong></p><p>This function requires the composite types <code>PowerSystem</code> and <code>device</code>, which holds  measurements from which the <code>islands</code> variable is obtained. To restore observability, the  function uses measurements from the <code>pseudo</code> variable and adds a non-redundant set from it  to the <code>device</code> variable.</p><p><strong>Keyword</strong></p><p>The keyword threshold defines the zero pivot threshold value with a default value of <code>1e-5</code>.  More precisely, all computed pivots less than this value will be treated as zero pivots.</p><p><strong>Updates</strong></p><p>The function updates the <code>device</code> variable of the <code>Measurement</code> composite type.</p><p><strong>Example</strong></p><p>Restore observability for DC state estimation:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)
statusWattmeter!(system, device; inservice = 10)
statusPmu!(system, device; inservice = 0)

pseudo = measurement(&quot;pseudomeasurement14.h5&quot;)
islands = islandTopological(system, device.wattmeter)
restorationGram!(system, device, pseudo, islands)

analysis = dcStateEstimation(system, device)
solve!(system, analysis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/b514ae416bf2f96226ff56c239d1a92c29bd7d02/src/stateEstimation/observability.jl#L377-L422">source</a></section></article><hr/><h2 id="PMU-State-Estimation-2"><a class="docs-heading-anchor" href="#PMU-State-Estimation-2">PMU State Estimation</a><a class="docs-heading-anchor-permalink" href="#PMU-State-Estimation-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.pmuStateEstimation" href="#JuliaGrid.pmuStateEstimation"><code>JuliaGrid.pmuStateEstimation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pmuStateEstimation(system::PowerSystem, device::Measurement, method; correlated)</code></pre><p>The function sets up the framework to solve the linear state estimation model with PMUs  only, where the vector of state variables is given in rectangular coordinates.</p><p><strong>Arguments</strong></p><p>This function establishes the framework by requiring the <code>PowerSystem</code> and <code>Measurement</code>  composite types.</p><p>Moreover, the presence of the <code>method</code> parameter is not mandatory. It provides various  approaches for addressing PMU state estimation. To address the WLS state estimation method,  users can opt to utilize factorization techniques to decompose the gain matrix, such as  <code>LU</code>, <code>QR</code>, or <code>LDLt</code>, especially when the gain matrix is symmetric. Opting for the  <code>Orthogonal</code> method is advisable for a more robust solution in scenarios involving  ill-conditioned data, particularly when substantial variations in variances are present.</p><p>Alternatively, instead of solving the WLS state estimation problem, users can utilize the  LAV method to find an estimator. This can be achieved by selecting one of  the <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">optimization solvers</a>,  where typically <code>Ipopt.Optimizer</code> suffices for common scenarios.</p><p>If the <code>method</code> parameter is not provided, the default method for solving the PMU  estimation will be LU factorization using the WLS framework.</p><p><strong>Keyword</strong></p><p>The boolean keyword <code>correlated</code> defines the correlation between measurement errors of a  single PMU and is only relevant for WLS state estimation.</p><p>When <code>correlated = false</code>, which is the default setting, the measurement errors of a  single PMU are not correlated. This results in the covariance matrix maintaining a  diagonal form. In this case, users can also run the <code>Orthogonal</code> method to find the  estimate of state variables.</p><p>On the other hand, when <code>correlated = true</code>, the covariance matrix does not maintain a  diagonal form. Instead, it becomes a block diagonal matrix due to the correlation between  measurement errors, and in this case, the <code>Orthogonal</code> method is not allowed. Users can  then use LU, QR, or LDLt factorization over the gain matrix to obtain the solution.</p><p><strong>Updates</strong></p><p>If the AC model has not been created, the function will automatically trigger an update of  the <code>ac</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>DCStateEstimation</code> abstract type, which includes  the following fields:</p><ul><li><code>voltage</code>: the variable allocated to store the bus voltage magnitudes and angles;</li><li><code>power</code>: the variable allocated to store the active and reactive powers;</li><li><code>method</code>: the system model vectors and matrices, or alternatively, the optimization model;</li><li><code>bad</code>: the variable linked to identifying bad data within the measurement set. </li></ul><p><strong>Examples</strong></p><p>Set up the PMU state estimation WLS framework to be solved using the default LU factorization  method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuStateEstimation(system, device)</code></pre><p>Set up the PMU state estimation WLS framework to be solved using the default LU factorization  method, where measurement errors are correlated:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuStateEstimation(system, device; correlated = true)</code></pre><p>Set up the PMU state estimation WLS framework to be solved using the orthogonal method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuStateEstimation(system, device, Orthogonal)</code></pre><p>Set up the PMU state estimation LAV framework:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuStateEstimation(system, device, Ipopt.Optimizer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/b514ae416bf2f96226ff56c239d1a92c29bd7d02/src/stateEstimation/pmuStateEstimation.jl#L1-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimationWLS{LinearWLS}}" href="#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimationWLS{LinearWLS}}"><code>JuliaGrid.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(system::PowerSystem, analysis::PMUStateEstimation)</code></pre><p>This function computes the bus voltage magnitudes and angles to solve the state estimation  problem exclusively using PMU data.</p><p><strong>Updates</strong></p><p>The resulting bus voltage magnitudes and angles are stored in the <code>voltage</code> field of the  <code>PMUStateEstimation</code> type.</p><p><strong>Examples</strong></p><p>Solving the PMU state estimation model with WLS:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>Solving the PMU state estimation model with LAV:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuStateEstimation(system, device, Ipopt.Optimizer)
solve!(system, analysis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/b514ae416bf2f96226ff56c239d1a92c29bd7d02/src/stateEstimation/pmuStateEstimation.jl#L383-L413">source</a></section></article><hr/><h2 id="DC-State-Estimation-2"><a class="docs-heading-anchor" href="#DC-State-Estimation-2">DC State Estimation</a><a class="docs-heading-anchor-permalink" href="#DC-State-Estimation-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.dcStateEstimation" href="#JuliaGrid.dcStateEstimation"><code>JuliaGrid.dcStateEstimation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dcStateEstimation(system::PowerSystem, device::Measurement, method)</code></pre><p>The function sets up the framework to solve the DC state estimation.</p><p><strong>Arguments</strong></p><p>This function requires the <code>PowerSystem</code> and <code>Measurement</code> composite types to establish the  framework. </p><p>Moreover, the presence of the <code>method</code> parameter is not mandatory. It provides various  approaches for addressing DC state estimation. To address the WLS state estimation method,  users can opt to utilize factorization techniques to decompose the gain matrix, such as  <code>LU</code>, <code>QR</code>, or <code>LDLt</code>, especially when the gain matrix is symmetric. Opting for the  <code>Orthogonal</code> method is advisable for a more robust solution in scenarios involving  ill-conditioned data, particularly when substantial variations in variances are present.</p><p>Alternatively, instead of solving the WLS state estimation problem, users can utilize the  LAV method to find an estimator. This can be achieved by selecting one of  the <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">optimization solvers</a>,  where typically <code>Ipopt.Optimizer</code> suffices for common scenarios.</p><p>If the user does not provide the <code>method</code>, the default method for solving the DC estimation  will be LU factorization.</p><p><strong>Updates</strong></p><p>If the DC model was not created, the function will automatically initiate an update of the <code>dc</code> field within the <code>PowerSystem</code> composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as  the first generator bus with an in-service generator in the bus type list.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>DCStateEstimation</code> abstract type, which includes  the following fields:</p><ul><li><code>voltage</code>: the variable allocated to store the bus voltage angles;</li><li><code>power</code>: the variable allocated to store the active powers;</li><li><code>method</code>: the system model vectors and matrices, or alternatively, the optimization model;</li><li><code>bad</code>: the variable linked to identifying bad data within the measurement set. </li></ul><p><strong>Examples</strong></p><p>Set up the DC state estimation WLS framework to be solved using the default LU factorization  method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device)</code></pre><p>Set up the DC state estimation WLS framework to be solved using the orthogonal method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device, Orthogonal)</code></pre><p>Set up the DC state estimation LAV framework:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device, Ipopt.Optimizer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/b514ae416bf2f96226ff56c239d1a92c29bd7d02/src/stateEstimation/dcStateEstimation.jl#L1-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS{LinearWLS}}" href="#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS{LinearWLS}}"><code>JuliaGrid.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(system::PowerSystem, analysis::DCStateEstimation)</code></pre><p>By computing the bus voltage angles, the function solves the DC state estimation problem.</p><p><strong>Updates</strong></p><p>The resulting bus voltage angles are stored in the <code>voltage</code> field of the <code>DCStateEstimation</code>  type.</p><p><strong>Examples</strong></p><p>Solving the DC state estimation model with WLS:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>Solving the DC state estimation model with LAV:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device, Ipopt.Optimizer)
solve!(system, analysis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/b514ae416bf2f96226ff56c239d1a92c29bd7d02/src/stateEstimation/dcStateEstimation.jl#L298-L327">source</a></section></article><hr/><h2 id="Bad-Data-Analysis-2"><a class="docs-heading-anchor" href="#Bad-Data-Analysis-2">Bad Data Analysis</a><a class="docs-heading-anchor-permalink" href="#Bad-Data-Analysis-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.residualTest!" href="#JuliaGrid.residualTest!"><code>JuliaGrid.residualTest!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">residualTest!(system::PowerSystem, device::Measurement, analysis::StateEstimation; 
    threshold)</code></pre><p>The function conducts bad data detection and identification using the largest normalized  residual test, subsequently removing measurement outliers from the measurement set. It can  be executed after obtaining estimation solutions.</p><p><strong>Arguments</strong></p><p>This function requires the composite types <code>PowerSystem</code> and <code>Measurement</code>, along with an  abstract type. The abstract type <code>StateEstimation</code> can have the following subtypes:</p><ul><li><code>DCStateEstimation</code>: conducts bad data analysis within DC state estimation;</li><li><code>PMUStateEstimation</code>: conducts bad data analysis within PMU state estimation.</li></ul><p><strong>Keyword</strong></p><p>The keyword <code>threshold</code> establishes the identification threshold. If the largest  normalized residual surpasses this threshold, the measurement is flagged as bad data. The  default threshold value is set to <code>threshold = 3.0</code>.</p><p><strong>Updates</strong></p><p>In case bad data is detected, the function removes measurements from the <code>coefficient</code> and  <code>precision</code> matrices, and <code>mean</code> vector within the <code>DCStateEstimation</code> type. Additionally,  it marks the respective measurement within the <code>Measurement</code> type as out-of-service.</p><p>Furthermore, the variable <code>outlier</code> within the <code>StateEstimation</code> type stores information  regarding bad data detection and identification:</p><ul><li><code>detect</code>: returns <code>true</code> after the function&#39;s execution if bad data is detected;</li><li><code>maxNormalizedResidual</code>: denotes the value of the largest normalized residual;</li><li><code>label</code>: signifies the label of the bad data;</li><li><code>index</code>: represents the index of the bad data.</li></ul><p><strong>Example</strong></p><p>Obtaining the solution after detecting and removing bad data:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device)
solve!(system, analysis)

residualTest!(system, device, analysis; threshold = 4.0)
solve!(system, analysis)</code></pre><p>Obtaining the solution while bad data is detected:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device)

while analysis.bad.detect
    solve!(system, analysis)
    residualTest!(system, device, analysis; threshold = 4.0)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/b514ae416bf2f96226ff56c239d1a92c29bd7d02/src/stateEstimation/badData.jl#L1-L57">source</a></section></article><hr/><h2 id="Utility-Function-2"><a class="docs-heading-anchor" href="#Utility-Function-2">Utility Function</a><a class="docs-heading-anchor-permalink" href="#Utility-Function-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.pmuPlacement" href="#JuliaGrid.pmuPlacement"><code>JuliaGrid.pmuPlacement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pmuPlacement(system::PowerSystem, optimizer; bridge)</code></pre><p>The function determines the optimal placement of PMUs through integer linear programming.  Specifically, it identifies the minimum set of PMU locations required for effective power  system state estimation, ensuring observability with the least number of PMUs.</p><p>The function accepts a <code>PowerSystem</code> composite type as input to establish the framework  for finding the optimal PMU placement. If the <code>ac</code> field within the <code>PowerSystem</code>  composite type is not yet created, the function automatically initiates an update process.</p><p>Additionally, the <code>optimizer</code> argument is a crucial component for formulating and solving  the optimization problem. Typically, using the GLPK or HiGHS solver is sufficient. For  more detailed information, please refer to the JuMP  <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">JuMP documenatation</a>.</p><p><strong>Keyword</strong></p><p>The <code>bridge</code> keyword enables users to manage the bridging mechanism within the JuMP  package.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>PlacementPMU</code> type, containing variables such as:</p><ul><li><code>bus</code>: bus labels with indices marking the positions of PMUs at buses;</li><li><code>from</code>: branch labels with indices marking the positions of PMUs at &quot;from&quot; bus ends;</li><li><code>to</code>: branch labels with indices marking the positions of PMUs at &quot;to&quot; bus ends.</li></ul><p>Note that if the conventional understanding of a PMU involves a device measuring the bus  voltage phasor and all branch current phasors incident to the bus, the result is saved  only in the bus variable. However, if we consider that a PMU measures individual phasors,  each described with magnitude and angle, then measurements are needed at each bus in the  <code>bus</code> variable, and each branch with positions given according to <code>from</code> and <code>to</code>  variables. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using GLPK, Ipopt

system = powerSystem(&quot;case14.h5&quot;)
analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)
solve!(system, analysis)
current!(system, analysis)

V = analysis.voltage.magnitude
θ = analysis.voltage.angle
If = analysis.current.from.magnitude
ψf = analysis.current.from.angle
It = analysis.current.to.magnitude
ψt = analysis.current.to.angle

placement = pmuPlacement(system, GLPK.Optimizer)
device = measurement()

@pmu(label = &quot;PMU ?: !&quot;)
for (label, i) in placement.bus
    addPmu!(system, device; bus = label, magnitude = V[i], angle = θ[i])
end
for (label, i) in placement.from
    addPmu!(system, device; from = label, magnitude = If[i], angle = ψf[i])
end
for (label, i) in placement.to
    addPmu!(system, device; to = label, magnitude = It[i], angle = ψt[i])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/b514ae416bf2f96226ff56c239d1a92c29bd7d02/src/stateEstimation/pmuStateEstimation.jl#L489-L552">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../measurementModel/">« Measurement Model</a><a class="docs-footer-nextpage" href="../analysis/">Power and Current Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 5 March 2024 14:38">Tuesday 5 March 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
