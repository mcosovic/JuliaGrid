<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State Estimation · JuliaGrid</title><meta name="title" content="State Estimation · JuliaGrid"/><meta property="og:title" content="State Estimation · JuliaGrid"/><meta property="twitter:title" content="State Estimation · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li class="is-active"><a class="tocitem" href>State Estimation</a><ul class="internal"><li><a class="tocitem" href="#Observability-Analysis-2"><span>Observability Analysis</span></a></li><li><a class="tocitem" href="#AC-State-Estimation-2"><span>AC State Estimation</span></a></li><li><a class="tocitem" href="#PMU-State-Estimation-2"><span>PMU State Estimation</span></a></li><li><a class="tocitem" href="#DC-State-Estimation-2"><span>DC State Estimation</span></a></li><li><a class="tocitem" href="#Bad-Data-Analysis-2"><span>Bad Data Analysis</span></a></li></ul></li><li><a class="tocitem" href="../analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../setupPrint/">Setup and Print</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/api/stateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="StateEstimationAPI"><a class="docs-heading-anchor" href="#StateEstimationAPI">State Estimation</a><a id="StateEstimationAPI-1"></a><a class="docs-heading-anchor-permalink" href="#StateEstimationAPI" title="Permalink"></a></h1><p>For further information on this topic, please see the <a href="../../manual/acStateEstimation/#ACStateEstimationManual">AC State Estimation</a>, <a href="../../manual/pmuStateEstimation/#PMUStateEstimationManual">PMU State Estimation</a> or <a href="../../manual/dcStateEstimation/#DCStateEstimationManual">DC State Estimation</a> sections of the Manual. Below, we have provided a list of functions that can be utilized for state estimation, observability analysis, or bad data processing.</p><p>To load state estimation API functionalities into the current scope, utilize the following command:</p><pre><code class="language-julia hljs">using JuliaGrid</code></pre><hr/><h6 id="Observability-Analysis"><a class="docs-heading-anchor" href="#Observability-Analysis">Observability Analysis</a><a id="Observability-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Observability-Analysis" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.islandTopologicalFlow-Tuple{PowerSystem, Measurement}"><code>islandTopologicalFlow</code></a></li><li><a href="#JuliaGrid.islandTopological-Tuple{PowerSystem, Measurement}"><code>islandTopological</code></a></li><li><a href="#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, Island}"><code>restorationGram!</code></a></li></ul><h6 id="AC-State-Estimation"><a class="docs-heading-anchor" href="#AC-State-Estimation">AC State Estimation</a><a id="AC-State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#AC-State-Estimation" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.gaussNewton"><code>gaussNewton</code></a></li><li><a href="#JuliaGrid.acLavStateEstimation"><code>acLavStateEstimation</code></a></li><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>solve!</code></a></li></ul><h6 id="PMU-State-Estimation"><a class="docs-heading-anchor" href="#PMU-State-Estimation">PMU State Estimation</a><a id="PMU-State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#PMU-State-Estimation" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.pmuPlacement"><code>pmuPlacement</code></a></li><li><a href="#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a></li><li><a href="#JuliaGrid.pmuLavStateEstimation"><code>pmuLavStateEstimation</code></a></li><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{LinearWLS{Normal}}}"><code>solve!</code></a></li></ul><h6 id="DC-State-Estimation"><a class="docs-heading-anchor" href="#DC-State-Estimation">DC State Estimation</a><a id="DC-State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#DC-State-Estimation" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a></li><li><a href="#JuliaGrid.dcLavStateEstimation"><code>dcLavStateEstimation</code></a></li><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimation{LinearWLS{Normal}}}"><code>solve!</code></a></li></ul><h6 id="Bad-Data-Analysis"><a class="docs-heading-anchor" href="#Bad-Data-Analysis">Bad Data Analysis</a><a id="Bad-Data-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Bad-Data-Analysis" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.residualTest!"><code>residualTest!</code></a></li></ul><hr/><h2 id="Observability-Analysis-2"><a class="docs-heading-anchor" href="#Observability-Analysis-2">Observability Analysis</a><a class="docs-heading-anchor-permalink" href="#Observability-Analysis-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.islandTopologicalFlow-Tuple{PowerSystem, Measurement}" href="#JuliaGrid.islandTopologicalFlow-Tuple{PowerSystem, Measurement}"><code>JuliaGrid.islandTopologicalFlow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">islandTopologicalFlow(system::PowerSystem, device::Measurement)</code></pre><p>The function utilizes a topological approach to detect flow observable islands, resulting in the formation of disconnected and loop-free subgraphs. It is assumed that active and reactive power measurements are paired, indicating a standard observability analysis. In this analysis, islands formed by active power measurements correspond to those formed by reactive power measurements.</p><p><strong>Arguments</strong></p><p>To define flow observable islands, this function necessitates the composite types <code>PowerSystem</code> and <code>Measurement</code>.</p><p><strong>Returns</strong></p><p>The function returns an <code>Island</code> type, containing information about the islands:</p><ul><li><code>island</code>: List enumerating observable islands with indices of buses.</li><li><code>bus</code>: Positions of buses in relation to each island.</li><li><code>tie</code>: Tie data associated with buses and branches.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

statusWattmeter!(system, device; inservice = 15)
device.varmeter.reactive.status = copy(device.wattmeter.active.status)

islands = islandTopologicalFlow(system, device)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/observability.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.islandTopological-Tuple{PowerSystem, Measurement}" href="#JuliaGrid.islandTopological-Tuple{PowerSystem, Measurement}"><code>JuliaGrid.islandTopological</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">islandTopological(system::PowerSystem, meter::Measurement)</code></pre><p>The function employs a topological method to identify maximal observable islands. Specifically, it employs active power measurements to pinpoint flow observable islands. Subsequently, these islands are merged based on the available injection measurements.</p><p>It is assumed that active and reactive power measurements are paired, indicating a standard observability analysis. In this analysis, islands formed by active power measurements correspond to those formed by reactive power measurements.</p><p><strong>Arguments</strong></p><p>To define flow observable islands, this function necessitates the composite types <code>PowerSystem</code> and <code>Measurement</code>.</p><p><strong>Returns</strong></p><p>The function returns an <code>Island</code> type, containing information about the islands:</p><ul><li><code>island</code>: List enumerating observable islands with indices of buses.</li><li><code>bus</code>: Positions of buses in relation to each island.</li><li><code>tie</code>: Tie data associated with buses and branches.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

statusWattmeter!(system, device; inservice = 15)
device.varmeter.reactive.status = copy(device.wattmeter.active.status)

islands = islandTopological(system, device)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/observability.jl#L45-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, Island}" href="#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, Island}"><code>JuliaGrid.restorationGram!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">restorationGram!(system::PowerSystem, device::Measurement, pseudo::Measurement,
    islands::Island; threshold)</code></pre><p>Upon identifying the <code>islands</code>, the function incorporates measurements from the available pseudo-measurements in the <code>pseudo</code> variable into the <code>device</code> variable to reinstate observability. This method relies on reduced coefficient matrices and the Gram matrix.</p><p>It is important to note that the device labels in the <code>device</code> and <code>pseudo</code> variables must be different to enable the function to successfully incorporate measurements from <code>pseudo</code> into the <code>device</code> set of measurements.</p><p><strong>Keyword</strong></p><p>The keyword threshold defines the zero pivot threshold value, with a default value of <code>1e-5</code>. More precisely, all computed pivots less than this value will be treated as zero pivots.</p><p><strong>Updates</strong></p><p>The function updates the <code>device</code> variable of the <code>Measurement</code> composite type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)
pseudo = measurement(&quot;pseudomeasurement14.h5&quot;)

statusWattmeter!(system, device; inservice = 10)
islands = islandTopological(system, device)

restorationGram!(system, device, pseudo, islands)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/observability.jl#L373-L403">source</a></section></article><hr/><h2 id="AC-State-Estimation-2"><a class="docs-heading-anchor" href="#AC-State-Estimation-2">AC State Estimation</a><a class="docs-heading-anchor-permalink" href="#AC-State-Estimation-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.gaussNewton" href="#JuliaGrid.gaussNewton"><code>JuliaGrid.gaussNewton</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussNewton(system::PowerSystem, device::Measurement, [method = LU])</code></pre><p>The function sets up the Gauss-Newton method to solve the nonlinear or AC state estimation model, where the vector of state variables is given in polar coordinates. The Gauss-Newton method throughout iterations provided WLS estimator.</p><p><strong>Arguments</strong></p><p>This function requires the <code>PowerSystem</code> and <code>Measurement</code> composite types to establish the nonlinear WLS state estimation framework.</p><p>Moreover, the presence of the <code>method</code> parameter is not mandatory. To address the WLS state estimation method, users can opt to utilize factorization techniques to decompose the gain matrix, such as <code>LU</code>, <code>QR</code>, or <code>LDLt</code> especially when the gain matrix is symmetric. Opting for the <code>Orthogonal</code> method is advisable for a more robust solution in scenarios involving ill-conditioned data, particularly when substantial variations in variances are present.</p><p>If the user does not provide the <code>method</code>, the default method for solving the estimation model will be LU factorization.</p><p><strong>Updates</strong></p><p>If the AC model has not been created, the function will automatically trigger an update of the <code>ac</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>ACStateEstimation</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: The variable allocated to store the bus voltage magnitudes and angles.</li><li><code>power</code>: The variable allocated to store the active and reactive powers.</li><li><code>method</code>: The system model vectors and matrices.</li></ul><p><strong>Examples</strong></p><p>Set up the AC state estimation model to be solved using the default LU factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = gaussNewton(system, device)</code></pre><p>Set up the AC state estimation model to be solved using the orthogonal method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = gaussNewton(system, device, Orthogonal)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/acStateEstimation.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.acLavStateEstimation" href="#JuliaGrid.acLavStateEstimation"><code>JuliaGrid.acLavStateEstimation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acLavStateEstimation(system::PowerSystem, device::Measurement, optimizer)</code></pre><p>The function sets up the LAV method to solve the nonlinear or AC state estimation model, where the vector of state variables is given in polar coordinates.</p><p><strong>Arguments</strong></p><p>This function requires the <code>PowerSystem</code> and <code>Measurement</code> composite types to establish the LAV state estimation model. The LAV method offers increased robustness compared to WLS, ensuring unbiasedness even in the presence of various measurement errors and outliers.</p><p>Users can employ the LAV method to find an estimator by choosing one of the available <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">optimization solvers</a>. Typically, <code>Ipopt.Optimizer</code> suffices for most scenarios.</p><p><strong>Updates</strong></p><p>If the AC model has not been created, the function will automatically trigger an update of the <code>ac</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>ACStateEstimation</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: The variable allocated to store the bus voltage magnitudes and angles.</li><li><code>power</code>: The variable allocated to store the active and reactive powers.</li><li><code>method</code>: The optimization model.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = acLavStateEstimation(system, device, Ipopt.Optimizer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/acStateEstimation.jl#L555-L591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}" href="#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>JuliaGrid.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(system::PowerSystem, analysis::ACStateEstimation)</code></pre><p>By computing the bus voltage magnitudes and angles, the function solves the AC state estimation model.</p><p><strong>Updates</strong></p><p>The resulting bus voltage magnitudes and angles are stored in the <code>voltage</code> field of the <code>ACStateEstimation</code> type.</p><p><strong>Examples</strong></p><p>Solving the AC state estimation model and obtaining the WLS estimator:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = gaussNewton(system, device)
for iteration = 1:20
    stopping = solve!(system, analysis)
    if stopping &lt; 1e-8
        break
    end
end</code></pre><p>Solving the AC state estimation model and obtaining the LAV estimator:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = acLavStateEstimation(system, device, Ipopt.Optimizer)
solve!(system, analysis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/acStateEstimation.jl#L807-L842">source</a></section></article><hr/><h2 id="PMU-State-Estimation-2"><a class="docs-heading-anchor" href="#PMU-State-Estimation-2">PMU State Estimation</a><a class="docs-heading-anchor-permalink" href="#PMU-State-Estimation-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.pmuPlacement" href="#JuliaGrid.pmuPlacement"><code>JuliaGrid.pmuPlacement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pmuPlacement(system::PowerSystem, optimizer; bridge)</code></pre><p>The function determines the optimal placement of PMUs through integer linear programming. Specifically, it identifies the minimum set of PMU locations required for effective power system state estimation, ensuring observability with the least number of PMUs.</p><p>The function accepts a <code>PowerSystem</code> composite type as input to establish the framework for finding the optimal PMU placement. If the <code>ac</code> field within the <code>PowerSystem</code> composite type is not yet created, the function automatically initiates an update process.</p><p>Additionally, the <code>optimizer</code> argument is a crucial component for formulating and solving the optimization problem. Typically, using the GLPK or HiGHS solver is sufficient. For more detailed information, please refer to the <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">JuMP documenatation</a>.</p><p><strong>Keyword</strong></p><p>The <code>bridge</code> keyword enables users to manage the bridging mechanism within the JuMP package.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>PlacementPMU</code> type, containing variables such as:</p><ul><li><code>bus</code>: Bus labels with indices marking the positions of PMUs at buses.</li><li><code>from</code>: Branch labels with indices marking the positions of PMUs at from-bus ends.</li><li><code>to</code>: Branch labels with indices marking the positions of PMUs at to-bus ends.</li></ul><p>Note that if the conventional understanding of a PMU involves a device measuring the bus voltage phasor and all branch current phasors incident to the bus, the result is saved only in the bus variable. However, if we consider that a PMU measures individual phasors, each described with magnitude and angle, then measurements are needed at each bus in the <code>bus</code> variable, and each branch with positions given according to <code>from</code> and <code>to</code> variables.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using GLPK, Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement()

analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)
solve!(system, analysis)
current!(system, analysis)

placement = pmuPlacement(system, GLPK.Optimizer)

@pmu(label = &quot;PMU ?: !&quot;)
for (bus, i) in placement.bus
    Vi, θi = analysis.voltage.magnitude[i], analysis.voltage.angle[i]
    addPmu!(system, device; bus = bus, magnitude = Vi, angle = θi)
end
for branch in keys(placement.from)
    Iij, ψij = fromCurrent(system, analysis; label = branch)
    addPmu!(system, device; from = branch, magnitude = Iij, angle = ψij)
end
for branch in keys(placement.to)
    Iji, ψji = toCurrent(system, analysis; label = branch)
    addPmu!(system, device; to = branch, magnitude = Iji, angle = ψji)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/pmuStateEstimation.jl#L454-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.pmuStateEstimation" href="#JuliaGrid.pmuStateEstimation"><code>JuliaGrid.pmuStateEstimation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pmuStateEstimation(system::PowerSystem, device::Measurement, [method = LU])</code></pre><p>The function establishes the linear WLS model for state estimation with PMUs only. In this model, the vector of state variables contains bus voltages, given in rectangular coordinates.</p><p><strong>Arguments</strong></p><p>This function requires the <code>PowerSystem</code> and <code>Measurement</code> composite types to establish the WLS state estimation model.</p><p>Moreover, the presence of the <code>method</code> parameter is not mandatory. To address the WLS state estimation method, users can opt to utilize factorization techniques to decompose the gain matrix, such as <code>LU</code>, <code>QR</code>, or <code>LDLt</code> especially when the gain matrix is symmetric. Opting for the <code>Orthogonal</code> method is advisable for a more robust solution in scenarios involving ill-conditioned data, particularly when substantial variations in variances are present.</p><p>If the user does not provide the <code>method</code>, the default method for solving the estimation model will be LU factorization.</p><p><strong>Updates</strong></p><p>If the AC model has not been created, the function will automatically trigger an update of the <code>ac</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>PMUStateEstimation</code> abstract type, which includes the following fields:</p><ul><li><code>voltage</code>: The variable allocated to store the bus voltage magnitudes and angles.</li><li><code>power</code>: The variable allocated to store the active and reactive powers.</li><li><code>method</code>: The system model vectors and matrices.</li></ul><p><strong>Examples</strong></p><p>Set up the PMU state estimation model to be solved using the default LU factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuStateEstimation(system, device)</code></pre><p>Set up the PMU state estimation model to be solved using the orthogonal method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuStateEstimation(system, device, Orthogonal)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/pmuStateEstimation.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.pmuLavStateEstimation" href="#JuliaGrid.pmuLavStateEstimation"><code>JuliaGrid.pmuLavStateEstimation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pmuLavStateEstimation(system::PowerSystem, device::Measurement, optimizer)</code></pre><p>The function establishes the LAV model for state estimation with PMUs only. In this model, the vector of state variables contains bus voltages, given in rectangular coordinates.</p><p><strong>Arguments</strong></p><p>This function requires the <code>PowerSystem</code> and <code>Measurement</code> composite types to establish the LAV state estimation model. The LAV method offers increased robustness compared to WLS, ensuring unbiasedness even in the presence of various measurement errors and outliers.</p><p>Users can employ the LAV method to find an estimator by choosing one of the available <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">optimization solvers</a>. Typically, <code>Ipopt.Optimizer</code> suffices for most scenarios.</p><p><strong>Updates</strong></p><p>If the AC model has not been created, the function will automatically trigger an update of the <code>ac</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>PMUStateEstimation</code> abstract type, which includes the following fields:</p><ul><li><code>voltage</code>: The variable allocated to store the bus voltage magnitudes and angles.</li><li><code>power</code>: The variable allocated to store the active and reactive powers.</li><li><code>method</code>: The optimization model.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuLavStateEstimation(system, device, Ipopt.Optimizer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/pmuStateEstimation.jl#L205-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{LinearWLS{Normal}}}" href="#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{LinearWLS{Normal}}}"><code>JuliaGrid.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(system::PowerSystem, analysis::PMUStateEstimation)</code></pre><p>By computing the bus voltage magnitudes and angles, the function solves the PMU state estimation model.</p><p><strong>Updates</strong></p><p>The resulting bus voltage magnitudes and angles are stored in the <code>voltage</code> field of the <code>PMUStateEstimation</code> type.</p><p><strong>Examples</strong></p><p>Solving the PMU state estimation model and obtaining the WLS estimator:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>Solving the PMU state estimation model and obtaining the LAV estimator:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = pmuLavStateEstimation(system, device, Ipopt.Optimizer)
solve!(system, analysis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/pmuStateEstimation.jl#L332-L362">source</a></section></article><hr/><h2 id="DC-State-Estimation-2"><a class="docs-heading-anchor" href="#DC-State-Estimation-2">DC State Estimation</a><a class="docs-heading-anchor-permalink" href="#DC-State-Estimation-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.dcStateEstimation" href="#JuliaGrid.dcStateEstimation"><code>JuliaGrid.dcStateEstimation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dcStateEstimation(system::PowerSystem, device::Measurement, [method = LU])</code></pre><p>The function establishes the WLS model for DC state estimation, where the vector of state variables contains only bus voltage angles.</p><p><strong>Arguments</strong></p><p>This function requires the <code>PowerSystem</code> and <code>Measurement</code> composite types to establish the WLS state estimation model.</p><p>Moreover, the presence of the <code>method</code> parameter is not mandatory. To address the WLS state estimation method, users can opt to utilize factorization techniques to decompose the gain matrix, such as <code>LU</code>, <code>QR</code>, or <code>LDLt</code> especially when the gain matrix is symmetric. Opting for the <code>Orthogonal</code> method is advisable for a more robust solution in scenarios involving ill-conditioned data, particularly when substantial variations in variances are present.</p><p>If the user does not provide the <code>method</code>, the default method for solving the estimation model will be LU factorization.</p><p><strong>Updates</strong></p><p>If the DC model was not created, the function will automatically initiate an update of the <code>dc</code> field within the <code>PowerSystem</code> composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>DCStateEstimation</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: The variable allocated to store the bus voltage angles.</li><li><code>power</code>: The variable allocated to store the active powers.</li><li><code>method</code>: The system model vectors and matrices.</li></ul><p><strong>Examples</strong></p><p>Set up the DC state estimation model to be solved using the default LU factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device)</code></pre><p>Set up the DC state estimation model to be solved using the orthogonal method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device, Orthogonal)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/dcStateEstimation.jl#L1-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.dcLavStateEstimation" href="#JuliaGrid.dcLavStateEstimation"><code>JuliaGrid.dcLavStateEstimation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dcLavStateEstimation(system::PowerSystem, device::Measurement, optimizer)</code></pre><p>The function establishes the LAV model for DC state estimation, where the vector of state variables contains only bus voltage angles.</p><p><strong>Arguments</strong></p><p>This function requires the <code>PowerSystem</code> and <code>Measurement</code> composite types to establish the LAV state estimation model. The LAV method offers increased robustness compared to WLS, ensuring unbiasedness even in the presence of various measurement errors and outliers.</p><p>Users can employ the LAV method to find an estimator by choosing one of the available <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">optimization solvers</a>. Typically, <code>Ipopt.Optimizer</code> suffices for most scenarios.</p><p><strong>Updates</strong></p><p>If the DC model was not created, the function will automatically initiate an update of the <code>dc</code> field within the <code>PowerSystem</code> composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>DCStateEstimation</code> abstract type, which includes the following fields:</p><ul><li><code>voltage</code>: The variable allocated to store the bus voltage angles.</li><li><code>power</code>: The variable allocated to store the active powers.</li><li><code>method</code>: The optimization model.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcLavStateEstimation(system, device, Ipopt.Optimizer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/dcStateEstimation.jl#L182-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimation{LinearWLS{Normal}}}" href="#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimation{LinearWLS{Normal}}}"><code>JuliaGrid.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(system::PowerSystem, analysis::DCStateEstimation)</code></pre><p>By computing the bus voltage angles, the function solves the DC state estimation model.</p><p><strong>Updates</strong></p><p>The resulting bus voltage angles are stored in the <code>voltage</code> field of the <code>DCStateEstimation</code> type.</p><p><strong>Examples</strong></p><p>Solving the DC state estimation model and obtaining the WLS estimator:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>Solving the DC state estimation model and obtaining the LAV estimator:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcLavStateEstimation(system, device, Ipopt.Optimizer)
solve!(system, analysis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/dcStateEstimation.jl#L312-L341">source</a></section></article><hr/><h2 id="Bad-Data-Analysis-2"><a class="docs-heading-anchor" href="#Bad-Data-Analysis-2">Bad Data Analysis</a><a class="docs-heading-anchor-permalink" href="#Bad-Data-Analysis-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.residualTest!" href="#JuliaGrid.residualTest!"><code>JuliaGrid.residualTest!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residualTest!(system::PowerSystem, device::Measurement, analysis::StateEstimation;
    threshold)</code></pre><p>The function conducts bad data detection and identification using the largest normalized residual test, subsequently removing measurement outliers from the measurement set. It can be executed after obtaining WLS estimator.</p><p><strong>Arguments</strong></p><p>This function requires the types <code>PowerSystem</code>, <code>Measurement</code>, and <code>StateEstimation</code>. The abstract type <code>StateEstimation</code> can have the following subtypes:</p><ul><li><code>ACStateEstimation</code>: Conducts bad data analysis within AC state estimation.</li><li><code>PMUStateEstimation</code>: Conducts bad data analysis within PMU state estimation.</li><li><code>DCStateEstimation</code>: Conducts bad data analysis within DC state estimation.</li></ul><p><strong>Keyword</strong></p><p>The keyword <code>threshold</code> establishes the identification threshold. If the largest normalized residual surpasses this threshold, the measurement is flagged as bad data. The default threshold value is set to <code>threshold = 3.0</code>.</p><p><strong>Updates</strong></p><p>If bad data is detected, the function flags the corresponding measurement within the <code>Measurement</code> type as out-of-service.</p><p>Moreover, for <code>DCStateEstimation</code> and <code>PMUStateEstimation</code> types, the function removes the corresponding measurement from the coefficient matrix and mean vector. This facilitates direct progress to the function that solves the state estimation problem.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>BadData</code> type, which includes:</p><ul><li><code>detect</code>: Returns <code>true</code> after the function&#39;s execution if bad data is detected.</li><li><code>maxNormalizedResidual</code>: Denotes the value of the largest normalized residual.</li><li><code>label</code>: Signifies the label of the bad data.</li><li><code>index</code>: Represents the index of the bad data.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
device = measurement(&quot;measurement14.h5&quot;)

analysis = dcStateEstimation(system, device)
solve!(system, analysis)

outlier = residualTest!(system, device, analysis; threshold = 4.0)
solve!(system, analysis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/beb06921d92c197664cad2310d4a6d814c87d5d3/src/stateEstimation/badData.jl#L1-L47">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../measurementModel/">« Measurement Model</a><a class="docs-footer-nextpage" href="../analysis/">Power and Current Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 22 January 2025 14:52">Wednesday 22 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
