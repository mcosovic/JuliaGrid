<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power Flow · JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li class="is-active"><a class="tocitem" href>Power Flow</a><ul class="internal"><li><a class="tocitem" href="#Build-Model-2"><span>Build Model</span></a></li><li><a class="tocitem" href="#Solve-Power-Flow-2"><span>Solve Power Flow</span></a></li><li><a class="tocitem" href="#Additional-Functions-2"><span>Additional Functions</span></a></li></ul></li><li><a class="tocitem" href="../optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/api/powerFlow.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerFlowAPI"><a class="docs-heading-anchor" href="#PowerFlowAPI">Power Flow</a><a id="PowerFlowAPI-1"></a><a class="docs-heading-anchor-permalink" href="#PowerFlowAPI" title="Permalink"></a></h1><p>For further information on this topic, please see the <a href="../../manual/acPowerFlow/#ACPowerFlowManual">AC Power Flow</a> or <a href="../../manual/dcPowerFlow/#DCPowerFlowManual">DC Power Flow</a> sections of the Manual. Below, we have provided a list of functions that can be utilized for power flow analysis.</p><h6 id="Build-Model"><a class="docs-heading-anchor" href="#Build-Model">Build Model</a><a id="Build-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Build-Model" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a></li><li><a href="#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a></li><li><a href="#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a></li><li><a href="../../tutorials/acPowerFlow/#gaussSeidel"><code>gaussSeidel</code></a></li><li><a href="#JuliaGrid.dcPowerFlow"><code>dcPowerFlow</code></a></li></ul><h6 id="Solve-Power-Flow"><a class="docs-heading-anchor" href="#Solve-Power-Flow">Solve Power Flow</a><a id="Solve-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-Power-Flow" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>mismatch!</code></a></li><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}"><code>solve!</code></a></li></ul><h6 id="Power-Analysis"><a class="docs-heading-anchor" href="#Power-Analysis">Power Analysis</a><a id="Power-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Analysis" title="Permalink"></a></h6><ul><li><a href="../analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a></li><li><a href="../analysis/#JuliaGrid.powerInjection-Tuple{PowerSystem, ACAnalysis}"><code>powerInjection</code></a></li><li><a href="../analysis/#JuliaGrid.powerSupply-Tuple{PowerSystem, ACPowerFlow}"><code>powerSupply</code></a></li><li><a href="../analysis/#JuliaGrid.powerShunt-Tuple{PowerSystem, ACAnalysis}"><code>powerShunt</code></a></li><li><a href="../analysis/#JuliaGrid.powerFrom-Tuple{PowerSystem, ACAnalysis}"><code>powerFrom</code></a></li><li><a href="../analysis/#JuliaGrid.powerTo-Tuple{PowerSystem, ACAnalysis}"><code>powerTo</code></a></li><li><a href="../analysis/#JuliaGrid.powerCharging-Tuple{PowerSystem, ACAnalysis}"><code>powerCharging</code></a></li><li><a href="../analysis/#JuliaGrid.powerLoss-Tuple{PowerSystem, ACAnalysis}"><code>powerLoss</code></a></li><li><a href="../analysis/#JuliaGrid.powerGenerator-Tuple{PowerSystem, ACPowerFlow}"><code>powerGenerator</code></a></li></ul><h6 id="Current-Analysis"><a class="docs-heading-anchor" href="#Current-Analysis">Current Analysis</a><a id="Current-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Analysis" title="Permalink"></a></h6><ul><li><a href="../analysis/#JuliaGrid.current!-Tuple{PowerSystem, ACAnalysis}"><code>current!</code></a></li><li><a href="../analysis/#JuliaGrid.currentInjection-Tuple{PowerSystem, ACAnalysis}"><code>currentInjection</code></a></li><li><a href="../analysis/#JuliaGrid.currentFrom-Tuple{PowerSystem, ACAnalysis}"><code>currentFrom</code></a></li><li><a href="../analysis/#JuliaGrid.currentTo-Tuple{PowerSystem, ACAnalysis}"><code>currentTo</code></a></li><li><a href="../analysis/#JuliaGrid.currentLine-Tuple{PowerSystem, ACAnalysis}"><code>currentLine</code></a></li></ul><h6 id="Additional-Functions"><a class="docs-heading-anchor" href="#Additional-Functions">Additional Functions</a><a id="Additional-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Functions" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.reactiveLimit!"><code>reactiveLimit!</code></a></li><li><a href="#JuliaGrid.adjustAngle!"><code>adjustAngle!</code></a></li></ul><hr/><h2 id="Build-Model-2"><a class="docs-heading-anchor" href="#Build-Model-2">Build Model</a><a class="docs-heading-anchor-permalink" href="#Build-Model-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.newtonRaphson" href="#JuliaGrid.newtonRaphson"><code>JuliaGrid.newtonRaphson</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newtonRaphson(system::PowerSystem)</code></pre><p>The function accepts the <code>PowerSystem</code> composite type as input and uses it to set up the Newton-Raphson method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the <code>acModel</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>NewtonRaphson</code> subtype of the abstract <code>ACPowerFlow</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: the magnitudes and angles of bus voltages</li><li><code>power</code>: the variable allocated to store the active and reactive powers,</li><li><code>current</code>: the variable allocated to store the currents,</li><li><code>jacobian</code>: the Jacobian matrix</li><li><code>mismatch</code>: the active and reactive power injection mismatches</li><li><code>increment</code>: the magnitudes and angles of bus voltage increments</li><li><code>pq</code>: indices of demand buses</li><li><code>pvpq</code>: indices of demand and generator buses.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

model = newtonRaphson(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/acPowerFlow.jl#L49-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.fastNewtonRaphsonBX" href="#JuliaGrid.fastNewtonRaphsonBX"><code>JuliaGrid.fastNewtonRaphsonBX</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fastNewtonRaphsonBX(system::PowerSystem)</code></pre><p>The function accepts the <code>PowerSystem</code> composite type as input and uses it to set up the Fast Newton-Raphson method of version BX to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the <code>acModel</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>FastNewtonRaphson</code> subtype of the abstract <code>ACPowerFlow</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: the magnitudes and angles of bus voltages</li><li><code>power</code>: the variable allocated to store the active and reactive powers,</li><li><code>current</code>: the variable allocated to store the currents,</li><li><code>active</code>:<ul><li><code>jacobian</code>: the Jacobian matrix associated with active power equations</li><li><code>mismatch</code>: the active power injection mismatches</li><li><code>increment</code>: the angles of bus voltage increments</li><li><code>factorization</code>: the factorized Jacobian matrix</li></ul></li><li><code>reactive</code>:<ul><li><code>jacobian</code>: the Jacobian matrix associated with reactive power equations</li><li><code>mismatch</code>: the reative power injection mismatches</li><li><code>increment</code>: the magnitudes of bus voltage increments</li><li><code>factorization</code>: the factorized Jacobian matrix</li></ul></li><li><code>pq</code>: indices of demand buses</li><li><code>pvpq</code>: indices of demand and generator buses.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

model = fastNewtonRaphsonBX(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/acPowerFlow.jl#L185-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.fastNewtonRaphsonXB" href="#JuliaGrid.fastNewtonRaphsonXB"><code>JuliaGrid.fastNewtonRaphsonXB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fastNewtonRaphsonXB(system::PowerSystem)</code></pre><p>The function accepts the <code>PowerSystem</code> composite type as input and uses it to set up the Fast Newton-Raphson method of version XB to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the <code>acModel</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>FastNewtonRaphson</code> subtype of the abstract <code>ACPowerFlow</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: the magnitudes and angles of bus voltages</li><li><code>active</code>:<ul><li><code>jacobian</code>: the Jacobian matrix associated with active power equations</li><li><code>mismatch</code>: the active power injection mismatches</li><li><code>increment</code>: the angles of bus voltage increments</li><li><code>factorization</code>: the factorized Jacobian matrix</li></ul></li><li><code>reactive</code>:<ul><li><code>jacobian</code>: the Jacobian matrix associated with reactive power equations</li><li><code>mismatch</code>: the reative power injection mismatches</li><li><code>increment</code>: the magnitudes of bus voltage increments</li><li><code>factorization</code>: the factorized Jacobian matrix</li></ul></li><li><code>pq</code>: indices of demand buses</li><li><code>pvpq</code>: indices of demand and generator buses.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

model = fastNewtonRaphsonXB(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/acPowerFlow.jl#L227-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.gaussSeidel" href="#JuliaGrid.gaussSeidel"><code>JuliaGrid.gaussSeidel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaussSeidel(system::PowerSystem)</code></pre><p>The function accepts the <code>PowerSystem</code> composite type as input and uses it to set up the Gauss-Seidel method to solve AC power flow. Additionally, if the AC model was not created, the function will automatically initiate an update of the <code>acModel</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>GaussSeidel</code> subtype of the abstract <code>ACPowerFlow</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: the magnitudes and angles of bus voltages</li><li><code>complex</code>: the complex voltages</li><li><code>magnitude</code>: the bus voltage magnitudes for corrections</li><li><code>pq</code>: indices of demand buses</li><li><code>pv</code>: indices of generator buses.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

model = gaussSeidel(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/acPowerFlow.jl#L430-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.dcPowerFlow" href="#JuliaGrid.dcPowerFlow"><code>JuliaGrid.dcPowerFlow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dcPowerFlow(system::PowerSystem)</code></pre><p>The function accepts the <code>PowerSystem</code> composite type as input, which is utilized to establish the structure for solving the DC power flow.</p><p>If the DC model was not created, the function will automatically initiate an update of the <code>dcModel</code> field within the <code>PowerSystem</code> composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>DCPowerFlow</code> type, which includes the following filled fields:</p><ul><li><code>voltage</code>: the variable allocated to store the angles of bus voltages,</li><li><code>power</code>: the variable allocated to store the active powers,</li><li><code>factorization</code>: the factorized nodal matrix.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

model = dcPowerFlow(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/dcPowerFlow.jl#L10-L35">source</a></section></article><hr/><h2 id="Solve-Power-Flow-2"><a class="docs-heading-anchor" href="#Solve-Power-Flow-2">Solve Power Flow</a><a class="docs-heading-anchor-permalink" href="#Solve-Power-Flow-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}" href="#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>JuliaGrid.mismatch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mismatch!(system::PowerSystem, model::ACPowerFlow)</code></pre><p>The function calculates both active and reactive power injection mismatches and returns their maximum absolute values, which can be utilized to terminate the iteration loop of methods employed to solve the AC power flow problem.</p><p>This function updates the mismatch variables in the Newton-Raphson and fast Newton-Raphson methods. It should be employed during the iteration loop before invoking the <a href="../optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function.</p><p>In contrast, the Gauss-Seidel method does not need mismatches to obtain bus voltages, but the maximum absolute values are commonly employed to stop the iteration loop. The function does not save any data and should be utilized during the iteration loop before invoking the <a href="../optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function.</p><p><strong>Abstract type</strong></p><p>The abstract type <code>ACPowerFlow</code> can have the following subtypes:</p><ul><li><code>NewtonRaphson</code>: computes the power mismatches within the Newton-Raphson method,</li><li><code>FastNewtonRaphson</code>: computes the power mismatches within the fast Newton-Raphson method,</li><li><code>GaussSeidel</code>: computes the power mismatches within the Gauss-Seidel method.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

model = newtonRaphson(system)
mismatch!(system, model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/acPowerFlow.jl#L501-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}" href="#JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}"><code>JuliaGrid.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(system::PowerSystem, model::ACPowerFlow)</code></pre><p>The function employs the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel method to solve the AC power flow problem and calculate the magnitudes and angles of bus voltages.</p><p>After the <a href="#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>mismatch!</code></a> function is called, <a href="../optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> should be executed to perform a single iteration of the method. The calculated voltages are stored in the <code>voltage</code> field of the respective struct type.</p><p><strong>Abstract type</strong></p><p>The abstract type <code>ACPowerFlow</code> can have the following subtypes:</p><ul><li><code>NewtonRaphson</code>: computes the bus voltages within the Newton-Raphson method</li><li><code>FastNewtonRaphson</code>: computes the bus voltages within the fast Newton-Raphson method</li><li><code>GaussSeidel</code>: computes the bus voltages within the Gauss-Seidel method.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

model = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, model)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, model)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/acPowerFlow.jl#L634-L664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}" href="#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}"><code>JuliaGrid.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(system::PowerSystem, model::DCPowerFlow)</code></pre><p>By computing the voltage angles for each bus, the function solves the DC power flow problem. The resulting voltage angles are stored in the <code>voltage</code> field of the <code>DCPowerFlow</code> type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

model = dcPowerFlow(system)
solve!(system, model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/dcPowerFlow.jl#L75-L89">source</a></section></article><hr/><h2 id="Additional-Functions-2"><a class="docs-heading-anchor" href="#Additional-Functions-2">Additional Functions</a><a class="docs-heading-anchor-permalink" href="#Additional-Functions-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.reactiveLimit!" href="#JuliaGrid.reactiveLimit!"><code>JuliaGrid.reactiveLimit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactiveLimit!(system::PowerSystem, model::ACPowerFlow)</code></pre><p>The function verifies whether the generators in a power system exceed their reactive power limits. This is done by setting the reactive power of the generators to within the limits if they are violated, after determining the bus voltage magnitudes and angles. If the limits are violated, the corresponding generator buses or the slack bus are converted to demand buses.</p><p>The function assigns values to the <code>generator.output.active</code> and <code>bus.supply.active</code> variables of the <code>PowerSystem</code> type. Additionally, it examines the reactive powers of the generator and adjusts them to their maximum or minimum values if they exceed the specified threshold. Subsequently, the <code>generator.output.reactive</code> variable of the <code>PowerSystem</code> type is modified accordingly. As a result of this adjustment, the <code>bus.supply.reactive</code> variable of the <code>PowerSystem</code> type is also updated, and the bus types specified in <code>bus.layout.type</code> are modified. If the slack bus is converted, the <code>bus.layout.slack</code> field is correspondingly adjusted.</p><p><strong>Abstract type</strong></p><p>The abstract type <code>ACPowerFlow</code> can have the following subtypes:</p><ul><li><code>NewtonRaphson</code>: computes the bus voltages within the Newton-Raphson method</li><li><code>FastNewtonRaphson</code>: computes the bus voltages within the fast Newton-Raphson method</li><li><code>GaussSeidel</code>: computes the bus voltages within the Gauss-Seidel method.</li></ul><p><strong>Returns</strong></p><p>The function returns the <code>violate</code> variable to indicate which buses violate the limits, with -1 indicating a violation of the minimum limits and 1 indicating a violation of the maximum limits.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

model = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, model)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, model)
end

violate = reactiveLimit!(system, model)

model = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, model)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, model)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/acPowerFlow.jl#L805-L859">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.adjustAngle!" href="#JuliaGrid.adjustAngle!"><code>JuliaGrid.adjustAngle!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adjustAngle!(system::PowerSystem, model::ACPowerFlow; slack)</code></pre><p>The function modifies the bus voltage angles based on a different slack bus than the one identified by the <code>bus.layout.slack</code> field. This function only updates the <code>voltage.angle</code> variable of the <code>Model</code> composite type.</p><p>For instance, if the reactive power of the generator exceeds the limit on the slack bus, the <a href="#JuliaGrid.reactiveLimit!"><code>reactiveLimit!</code></a> function will change that bus to the demand bus and designate the first generator bus in the sequence as the new slack bus. After obtaining the updated AC power flow solution based on the new slack bus, it is possible to adjust the voltage angles to align with the angle of the original slack bus. The <code>slack</code> keyword specifies the bus label of the original slack bus.</p><p><strong>Abstract type</strong></p><p>The abstract type <code>ACPowerFlow</code> can have the following subtypes:</p><ul><li><code>NewtonRaphson</code>: computes the bus voltages within the Newton-Raphson method</li><li><code>FastNewtonRaphson</code>: computes the bus voltages within the fast Newton-Raphson method</li><li><code>GaussSeidel</code>: computes the bus voltages within the Gauss-Seidel method.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

model = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, model)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, model)
end

reactiveLimit!(system, model)

model = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, model)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, model)
end

adjustAngle!(system, model; slack = 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/1be87eaada3146dcfca8d77051358d8ffbf9e415/src/powerFlow/acPowerFlow.jl#L927-L974">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powerSystemModel/">« Power System Model</a><a class="docs-footer-nextpage" href="../optimalPowerFlow/">Optimal Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 1 August 2023 11:11">Tuesday 1 August 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
