<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power Flow Solution · JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/powerFlowAnalysis/">Power Flow Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlowAnalysis/">AC Power Flow Analysis</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlowAnalysis/">DC Power Flow Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li class="is-active"><a class="tocitem" href>Power Flow Solution</a><ul class="internal"><li><a class="tocitem" href="#API-Index"><span>API Index</span></a></li><li><a class="tocitem" href="#Newton-Raphson-Method"><span>Newton-Raphson Method</span></a></li><li><a class="tocitem" href="#Fast-Newton-Raphson-Method"><span>Fast Newton-Raphson Method</span></a></li><li><a class="tocitem" href="#Gauss-Seidel-Method"><span>Gauss-Seidel Method</span></a></li><li><a class="tocitem" href="#DC-Power-Flow"><span>DC Power Flow</span></a></li><li><a class="tocitem" href="#Additional-Functions"><span>Additional Functions</span></a></li></ul></li><li><a class="tocitem" href="../postprocessing/">Post-processing Analysis</a></li><li><a class="tocitem" href="../configuration/">Configuration Setup</a></li><li><a class="tocitem" href="../wrapper/">Wrapper Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Power Flow Solution</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power Flow Solution</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/api/powerFlowSolution.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="powerFlowSolutionAPI"><a class="docs-heading-anchor" href="#powerFlowSolutionAPI">Power Flow Solution</a><a id="powerFlowSolutionAPI-1"></a><a class="docs-heading-anchor-permalink" href="#powerFlowSolutionAPI" title="Permalink"></a></h1><p>For further information on this topic, please see the <a href="../../manual/powerSystemModel/#PowerSystemModelManual">Power System Analysis</a> section of the Manual.</p><hr/><h2 id="API-Index"><a class="docs-heading-anchor" href="#API-Index">API Index</a><a id="API-Index-1"></a><a class="docs-heading-anchor-permalink" href="#API-Index" title="Permalink"></a></h2><ul><li><p><a href="#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a></p></li><li><p><a href="#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a></p></li><li><p><a href="#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a></p></li><li><p><a href="../../tutorials/acPowerFlowAnalysis/#gaussSeidel"><code>gaussSeidel</code></a></p></li><li><p><a href="#JuliaGrid.dcPowerFlow"><code>dcPowerFlow</code></a></p></li><li><p><a href="#JuliaGrid.mismatchNewtonRaphson!"><code>mismatchNewtonRaphson!</code></a></p></li><li><p><a href="#JuliaGrid.mismatchFastNewtonRaphson!"><code>mismatchFastNewtonRaphson!</code></a></p></li><li><p><a href="#JuliaGrid.mismatchGaussSeidel!"><code>mismatchGaussSeidel!</code></a></p></li><li><p><a href="#JuliaGrid.solveNewtonRaphson!"><code>solveNewtonRaphson!</code></a></p></li><li><p><a href="#JuliaGrid.solveFastNewtonRaphson!"><code>solveFastNewtonRaphson!</code></a></p></li><li><p><a href="#JuliaGrid.solveGaussSeidel!"><code>solveGaussSeidel!</code></a></p></li><li><p><a href="#JuliaGrid.solveDCPowerFlow!"><code>solveDCPowerFlow!</code></a></p></li><li><p><a href="#JuliaGrid.reactivePowerLimit!"><code>reactivePowerLimit!</code></a></p></li><li><p><a href="#JuliaGrid.adjustVoltageAngle!"><code>adjustVoltageAngle!</code></a></p></li></ul><hr/><h2 id="Newton-Raphson-Method"><a class="docs-heading-anchor" href="#Newton-Raphson-Method">Newton-Raphson Method</a><a id="Newton-Raphson-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-Raphson-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.newtonRaphson" href="#JuliaGrid.newtonRaphson"><code>JuliaGrid.newtonRaphson</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function accepts the <code>PowerSystem</code> composite type as input and uses it to set up the Newton-Raphson method to solve AC power flow. Its output is the <code>Result</code> composite type.</p><pre><code class="nohighlight hljs">newtonRaphson(system::PowerSystem)</code></pre><p>The <code>model</code> field of the <code>Result</code> type is updated during the function&#39;s execution. Furthermore, if the AC model was not created, the function will automatically initiate an update of the <code>acModel</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L102-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.mismatchNewtonRaphson!" href="#JuliaGrid.mismatchNewtonRaphson!"><code>JuliaGrid.mismatchNewtonRaphson!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function calculates both active and reactive power injection mismatches and returns their maximum absolute values, which can be utilized to terminate the iteration loop of the Newton-Raphson method that is employed to solve the AC power flow problem.</p><pre><code class="nohighlight hljs">mismatchNewtonRaphson!(system::PowerSystem, result::Result)</code></pre><p>This function updates the <code>mismatch</code> field in the <code>Result</code> composite type and should be employed during the iteration loop before invoking the <a href="#JuliaGrid.solveNewtonRaphson!"><code>solveNewtonRaphson!</code></a> function.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
mismatchNewtonRaphson!(system, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L567-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.solveNewtonRaphson!" href="#JuliaGrid.solveNewtonRaphson!"><code>JuliaGrid.solveNewtonRaphson!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function employs the Newton-Raphson method to determine the magnitudes and angles of bus voltages, which is used to solve the AC power flow problem.</p><pre><code class="nohighlight hljs">solveNewtonRaphson!(system, result)</code></pre><p>This function updates the <code>bus.voltage</code> and <code>model</code> fields of the <code>Result</code> composite type during the iteration loop, which should follow the <a href="#JuliaGrid.mismatchNewtonRaphson!"><code>mismatchNewtonRaphson!</code></a> function. Together, these functions collaborate to execute one iteration of the Newton-Raphson algorithm.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
for i = 1:10
    stopping = mismatchNewtonRaphson!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solveNewtonRaphson!(system, result)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L795-L820">source</a></section></article><hr/><h2 id="Fast-Newton-Raphson-Method"><a class="docs-heading-anchor" href="#Fast-Newton-Raphson-Method">Fast Newton-Raphson Method</a><a id="Fast-Newton-Raphson-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Newton-Raphson-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.fastNewtonRaphsonBX" href="#JuliaGrid.fastNewtonRaphsonBX"><code>JuliaGrid.fastNewtonRaphsonBX</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function accepts the <code>PowerSystem</code> composite type as input and uses it to set up the Fast Newton-Raphson method of version BX to solve AC power flow. Its output is the <code>Result</code> composite type.</p><pre><code class="nohighlight hljs">fastNewtonRaphsonBX(system::PowerSystem)</code></pre><p>The <code>model</code> field of the <code>Result</code> type is updated during the function&#39;s execution. Furthermore, if the AC model was not created, the function will automatically initiate an update of the <code>acModel</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = fastNewtonRaphsonBX(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L215-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.fastNewtonRaphsonXB" href="#JuliaGrid.fastNewtonRaphsonXB"><code>JuliaGrid.fastNewtonRaphsonXB</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function accepts the <code>PowerSystem</code> composite type as input and uses it to set up the Fast Newton-Raphson method of version XB to solve AC power flow. Its output is the <code>Result</code> composite type.</p><pre><code class="nohighlight hljs">fastNewtonRaphsonXB(system::PowerSystem)</code></pre><p>The <code>model</code> field of the <code>Result</code> type is updated during the function&#39;s execution. Furthermore, if the AC model was not created, the function will automatically initiate an update of the <code>acModel</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = fastNewtonRaphsonXB(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L241-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.mismatchFastNewtonRaphson!" href="#JuliaGrid.mismatchFastNewtonRaphson!"><code>JuliaGrid.mismatchFastNewtonRaphson!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function calculates both active and reactive power injection mismatches and returns their maximum absolute values, which can be utilized to terminate the iteration loop of the fast Newton-Raphson method that is employed to solve the AC power flow problem.</p><pre><code class="nohighlight hljs">mismatchFastNewtonRaphson!(system::PowerSystem, result::Result)</code></pre><p>This function updates the <code>mismatch</code> field in the <code>Result</code> composite type and should be employed during the iteration loop before invoking the <a href="#JuliaGrid.solveFastNewtonRaphson!"><code>solveFastNewtonRaphson!</code></a> function.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = fastNewtonRaphson(system)
mismatchFastNewtonRaphson!(system, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L625-L644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.solveFastNewtonRaphson!" href="#JuliaGrid.solveFastNewtonRaphson!"><code>JuliaGrid.solveFastNewtonRaphson!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function employs the fast Newton-Raphson method to determine the magnitudes and angles of bus voltages, which is used to solve the AC power flow problem.</p><pre><code class="nohighlight hljs">solveFastNewtonRaphson!(system, result)</code></pre><p>This function updates the <code>bus.voltage</code> and <code>model</code> fields of the <code>Result</code> composite type during the iteration loop, which should follow the <a href="#JuliaGrid.mismatchFastNewtonRaphson!"><code>mismatchFastNewtonRaphson!</code></a> function. Together, these functions collaborate to execute one iteration of the fast Newton-Raphson algorithm.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = fastNewtonRaphsonBX(system)
for i = 1:10
    stopping = mismatchFastNewtonRaphson!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solveFastNewtonRaphson!(system, result)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L890-L915">source</a></section></article><hr/><h2 id="Gauss-Seidel-Method"><a class="docs-heading-anchor" href="#Gauss-Seidel-Method">Gauss-Seidel Method</a><a id="Gauss-Seidel-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Gauss-Seidel-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.gaussSeidel" href="#JuliaGrid.gaussSeidel"><code>JuliaGrid.gaussSeidel</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function accepts the <code>PowerSystem</code> composite type as input and uses it to set up the Gauss-Seidel method to solve AC power flow. Its output is the <code>Result</code> composite type.</p><pre><code class="nohighlight hljs">gaussSeidel(system::PowerSystem)</code></pre><p>The <code>model</code> field of the <code>Result</code> type is updated during the function&#39;s execution. Furthermore, if the AC model was not created, the function will automatically initiate an update of the <code>acModel</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = gaussSeidel(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L422-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.mismatchGaussSeidel!" href="#JuliaGrid.mismatchGaussSeidel!"><code>JuliaGrid.mismatchGaussSeidel!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function calculates both active and reactive power injection mismatches and returns their maximum absolute values, which can be utilized to terminate the iteration loop of the Gauss-Seidel method that is employed to solve the AC power flow problem.</p><pre><code class="nohighlight hljs">mismatchGaussSeidel!(system::PowerSystem, result::Result)</code></pre><p>The Gauss-Seidel method does not need mismatches to obtain bus voltages, but the maximum absolute values are commonly employed to stop the iteration loop. As a result, the function does not save any data and should be utilized during the iteration loop before invoking the <a href="#JuliaGrid.solveGaussSeidel!"><code>solveGaussSeidel!</code></a> function.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = gaussSeidel(system)
mismatchGaussSeidel!(system, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L683-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.solveGaussSeidel!" href="#JuliaGrid.solveGaussSeidel!"><code>JuliaGrid.solveGaussSeidel!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function employs the Gauss-Seidel method to determine the magnitudes and angles of bus voltages, which is used to solve the AC power flow problem.</p><pre><code class="nohighlight hljs">solveGaussSeidel!(system, result)</code></pre><p>This function updates the <code>bus.voltage</code> and <code>model</code> fields of the <code>Result</code> composite type during the iteration loop. The <a href="#JuliaGrid.mismatchGaussSeidel!"><code>mismatchGaussSeidel!</code></a> function can also be used in conjunction with this function to terminate the iteration loop.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = gaussSeidel(system)
for i = 1:10
    stopping = mismatchGaussSeidel!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solveGaussSeidel!(system, result)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L956-L980">source</a></section></article><hr/><h2 id="DC-Power-Flow"><a class="docs-heading-anchor" href="#DC-Power-Flow">DC Power Flow</a><a id="DC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#DC-Power-Flow" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.dcPowerFlow" href="#JuliaGrid.dcPowerFlow"><code>JuliaGrid.dcPowerFlow</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function accepts the <code>PowerSystem</code> composite type as input, which is utilized to establish the structure for solving the DC power flow. Its output is the <code>Result</code> composite type.</p><pre><code class="nohighlight hljs">dcPowerFlow(system::PowerSystem)</code></pre><p>The <code>model</code> field of the <code>Result</code> type is updated during the function&#39;s execution. Furthermore, if the DC model was not created, the function will automatically initiate an update of the <code>dcModel</code> field within the <code>PowerSystem</code> composite type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

result = dcPowerFlow(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L476-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.solveDCPowerFlow!" href="#JuliaGrid.solveDCPowerFlow!"><code>JuliaGrid.solveDCPowerFlow!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>By computing the voltage angles for each bus, the function solves the DC power flow problem.</p><pre><code class="nohighlight hljs">solveDCPowerFlow!(system, result)</code></pre><p>The <code>voltage.angle</code> field of the composite type <code>Result</code> is modified by the function.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

result = dcPowerFlow(system)
solveDCPowerFlow!(system, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L1017-L1032">source</a></section></article><hr/><h2 id="Additional-Functions"><a class="docs-heading-anchor" href="#Additional-Functions">Additional Functions</a><a id="Additional-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.reactivePowerLimit!" href="#JuliaGrid.reactivePowerLimit!"><code>JuliaGrid.reactivePowerLimit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function verifies whether the generators in a power system exceed their reactive power limits. This is done by setting the reactive power of the generators to within the limits if they are violated, after determining the bus voltage magnitudes and angles. If the limits are violated, the corresponding generator buses or the slack bus are converted to demand buses.</p><p>The function returns the <code>violate</code> variable to indicate which buses violate the limits, with -1 indicating a violation of the minimum limits and 1 indicating a violation of the maximum limits.</p><pre><code class="nohighlight hljs">reactivePowerLimit!(system::PowerSystem, result::Result)</code></pre><p>Initially, if the <a href="../postprocessing/#JuliaGrid.generator!"><code>generator!</code></a> function has not been run, it will be executed to update the <code>generator</code> field of the <code>Result</code> type.</p><p>Afterward, the function uses the results from the <code>generator</code> field to assign values to the <code>generator.output.active</code> and <code>bus.supply.active</code> fields of the <code>System</code> type.</p><p>At the end of the process, the function inspects the reactive powers of the generator and adjusts them to their maximum or minimum values if they violate the threshold. The <code>generator.output.reactive</code> field of the <code>System</code> type is then modified accordingly. In light of this modification, the <code>bus.supply.reactive</code> field of the <code>System</code> type is also updated, and the bus types in <code>bus.layout.type</code> are adjusted. If the slack bus is converted, the <code>bus.layout.slack</code> field is modified accordingly.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, result)
end

violate = reactivePowerLimit!(system, result)

result = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, result)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L1051-L1101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaGrid.adjustVoltageAngle!" href="#JuliaGrid.adjustVoltageAngle!"><code>JuliaGrid.adjustVoltageAngle!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The function modifies the bus voltage angles based on a different slack bus than the one identified by the <code>bus.layout.slack</code> field. This function only updates the <code>bus.voltage.angle</code> field of the <code>Result</code> type.</p><pre><code class="nohighlight hljs">adjustVoltageAngle!(system::PowerSystem, result::Result; slack)</code></pre><p>For instance, if the reactive power of the generator exceeds the limit on the slack bus, the <a href="#JuliaGrid.reactivePowerLimit!"><code>reactivePowerLimit!</code></a> function will change that bus to a demand bus and designate the first generator bus in the sequence as the new slack bus. After obtaining the updated AC power flow solution based on the new slack bus, it is possible to adjust the voltage angles to align with the angle of the original slack bus. The <code>slack</code> keyword specifies the bus label of the original slack bus.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

result = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, result)
end

reactivePowerLimit!(system, result)

result = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, result)
end

adjustVoltageAngle!(system, result; slack = 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/4eab455bf7e2f5b543932d26995a4f53c86a9f89/src/powerFlow/solution.jl#L1168-L1209">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powerSystemModel/">« Power System Model</a><a class="docs-footer-nextpage" href="../postprocessing/">Post-processing Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 4 May 2023 12:00">Thursday 4 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
