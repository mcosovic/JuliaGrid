<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power System Model · JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Power System Model</a><ul class="internal"><li><a class="tocitem" href="#BuildModelManual"><span>Build Model</span></a></li><li><a class="tocitem" href="#SaveModelManual"><span>Save Model</span></a></li><li><a class="tocitem" href="#AddBusManual"><span>Add Bus</span></a></li><li><a class="tocitem" href="#BusLabelsManual"><span>Bus Labels</span></a></li><li><a class="tocitem" href="#AddBranchManual"><span>Add Branch</span></a></li><li><a class="tocitem" href="#BranchLabelsManual"><span>Branch Labels</span></a></li><li><a class="tocitem" href="#AddGeneratorManual"><span>Add Generator</span></a></li><li><a class="tocitem" href="#GeneratorLabelsManual"><span>Generator Labels</span></a></li><li><a class="tocitem" href="#AddTemplatesManual"><span>Add Templates</span></a></li><li><a class="tocitem" href="#ACDCModelManual"><span>AC and DC Model</span></a></li><li><a class="tocitem" href="#AlterShuntElementsManual"><span>Alter Shunt Elements</span></a></li><li><a class="tocitem" href="#ChangeBranchStatusManual"><span>Change Branch Status</span></a></li><li><a class="tocitem" href="#ChangeBranchParametersManual"><span>Change Branch Parameters</span></a></li><li><a class="tocitem" href="#ChangeGeneratorStatusManual"><span>Change Generator Status</span></a></li><li><a class="tocitem" href="#ChangeGeneratorOutputsManual"><span>Change Generator Outputs</span></a></li><li><a class="tocitem" href="#AddActiveReactiveCostsManual"><span>Add Active and Reactive Costs</span></a></li></ul></li><li><a class="tocitem" href="../powerFlowAnalysis/">Power Flow Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/modelACDC/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/powerFlowSolution/">Power Flow Solution</a></li><li><a class="tocitem" href="../../tutorials/powerCurrentAnalysis/">Power and Current Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlowSolution/">Power Flow Solution</a></li><li><a class="tocitem" href="../../api/postprocessing/">Post-processing Analysis</a></li><li><a class="tocitem" href="../../api/unit/">Unit System</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Power System Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power System Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/powerSystemModel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerSystemModelManual"><a class="docs-heading-anchor" href="#PowerSystemModelManual">Power System Model</a><a id="PowerSystemModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#PowerSystemModelManual" title="Permalink"></a></h1><p>The JuliaGrid supports the composite type <code>PowerSystem</code> to preserve power system data, with the following fields: <code>bus</code>, <code>branch</code>, <code>generator</code>, <code>base</code>, <code>acModel</code>, and <code>dcModel</code>. The fields <code>bus</code>, <code>branch</code>, and <code>generator</code> hold data related to buses, branches, and generators, respectively. The <code>base</code> field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes (VA) for the base power and line-to-line voltages measured in volts (V) for base voltages. The <code>acModel</code> and <code>dcModel</code> store vectors and matrices that are related to the topology and parameters of the power system.</p><p>The composite type <code>PowerSystem</code> can be created using a function:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.powerSystem"><code>powerSystem</code></a>.</li></ul><p>JuliaGrid supports three modes for populating the <code>PowerSystem</code> type: using built-in functions, using HDF5 file format, and using <a href="https://matpower.org">Matpower</a> case files.</p><p>It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.savePowerSystem"><code>savePowerSystem</code></a>.</li></ul><p>Once the <code>PowerSystem</code> type is created, you can add buses, branches, and generators using the following functions:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a></li><li><a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a></li><li><a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a>.</li></ul><p>Additionally, JuliaGrid provides macros <a href="../../api/powerSystemModel/#JuliaGrid.@bus"><code>@bus</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.@branch"><code>@branch</code></a>, and <a href="../../api/powerSystemModel/#JuliaGrid.@generator"><code>@generator</code></a> to define templates that aid in creating buses, branches, and generators. These templates help avoid entering the same parameters repeatedly.</p><p>To create vectors and matrices based on the power system topology and parameters, you can use the following functions:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a></li><li><a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a>.</li></ul><p>In addition, it is possible to manipulate the parameters of buses, branches, and generators using the following functions:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.shuntBus!"><code>shuntBus!</code></a></li><li><a href="../../api/powerSystemModel/#JuliaGrid.statusBranch!"><code>statusBranch!</code></a></li><li><a href="../../api/powerSystemModel/#JuliaGrid.parameterBranch!"><code>parameterBranch!</code></a></li><li><a href="../../api/powerSystemModel/#JuliaGrid.statusGenerator!"><code>statusGenerator!</code></a></li><li><a href="../../api/powerSystemModel/#JuliaGrid.outputGenerator!"><code>outputGenerator!</code></a>.</li></ul><p>Executing these functions will automatically update all fields affected by them. You can also change other parameters of the power system by accessing and modifying the values in the <code>bus</code>, <code>branch</code>, <code>generator</code>, and <code>base</code> fields of the <code>PowerSystem</code> composite type.</p><p>Finally, after adding the generator, JualiGrid provides the following functions to incorporate costs for the active and reactive power generated by the generator:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a></li><li><a href="../../api/powerSystemModel/#JuliaGrid.addReactiveCost!"><code>addReactiveCost!</code></a>.</li></ul><hr/><h2 id="BuildModelManual"><a class="docs-heading-anchor" href="#BuildModelManual">Build Model</a><a id="BuildModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#BuildModelManual" title="Permalink"></a></h2><p>The <a href="../../api/powerSystemModel/#JuliaGrid.powerSystem"><code>powerSystem</code></a> function generates the <code>PowerSystem</code> composite type and requires a string-formatted path to either Matpower case or HDF5 files as input. Alternatively, the <code>PowerSystem</code> can be created without any initial data by initializing it as empty, allowing the user to construct the power system from scratch.</p><hr/><h5 id="Matpower-or-HDF5-File"><a class="docs-heading-anchor" href="#Matpower-or-HDF5-File">Matpower or HDF5 File</a><a id="Matpower-or-HDF5-File-1"></a><a class="docs-heading-anchor-permalink" href="#Matpower-or-HDF5-File" title="Permalink"></a></h5><p>To create the <code>PowerSystem</code> type using the Matpower case file for the IEEE 14-bus test case, which is named <code>case14.m</code> and located in the folder <code>C:\matpower</code>, the following Julia code can be used:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;C:/matpower/case14.m&quot;)</code></pre><p>In order to use the HDF5 file as input to create the <code>PowerSystem</code> object, it is necessary to have saved the data using the <a href="../../api/powerSystemModel/#JuliaGrid.savePowerSystem"><code>savePowerSystem</code></a> function beforehand. As an example, let us say we saved the power system as <code>case14.h5</code> in the directory <code>C:\hdf5</code>. In this case, the following Julia code can be used to construct the <code>PowerSystem</code> composite type:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;C:/hdf5/case14.h5&quot;)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>It is recommended to load the power system from the HDF5 file to reduce the loading time.</p></div></div><hr/><h5 id="Model-from-Scratch"><a class="docs-heading-anchor" href="#Model-from-Scratch">Model from Scratch</a><a id="Model-from-Scratch-1"></a><a class="docs-heading-anchor-permalink" href="#Model-from-Scratch" title="Permalink"></a></h5><p>Alternatively, the model can be build from the scratch using built-in functions, for example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)

addBranch!(system; label = 1, from = 1, to = 2, resistance = 0.008, reactance = 0.05)</code></pre><hr/><h5 id="Base-Units"><a class="docs-heading-anchor" href="#Base-Units">Base Units</a><a id="Base-Units-1"></a><a class="docs-heading-anchor-permalink" href="#Base-Units" title="Permalink"></a></h5><p>The <code>PowerSystem</code> composite type stores all electrical quantities in per-unit (pu) and radians (rad), except for the base values of power and voltages. The base power value is expressed in volt-amperes (VA), while the base voltages are given in volts (V). For instance, if you run the previous example, the base power can be obtained as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.power.value, system.base.power.unit</code><code class="nohighlight hljs ansi" style="display:block;">(1.0e8, &quot;VA&quot;)</code></pre><p>Likewise, the base voltages are specified as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.voltage.value, system.base.voltage.unit</code><code class="nohighlight hljs ansi" style="display:block;">([138000.0, 138000.0], &quot;V&quot;)</code></pre><hr/><h5 id="Change-Base-Units"><a class="docs-heading-anchor" href="#Change-Base-Units">Change Base Units</a><a id="Change-Base-Units-1"></a><a class="docs-heading-anchor-permalink" href="#Change-Base-Units" title="Permalink"></a></h5><p>By using the <a href="../../api/unit/#JuliaGrid.@base"><code>@base</code></a> macro, users can change the prefixes of the base units. For instance, if the user wishes to convert base power and base voltage values to megavolt-amperes (MVA) and kilovolts (kV) respectively, they can execute the following command:</p><pre><code class="language-julia hljs">@base(system, MVA, kV)</code></pre><p>After executing the macro, the updated base power is:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.power.value, system.base.power.unit</code><code class="nohighlight hljs ansi" style="display:block;">(100.0, &quot;MVA&quot;)</code></pre><p>Likewise, the updated base voltage values can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.voltage.value, system.base.voltage.unit</code><code class="nohighlight hljs ansi" style="display:block;">([138.0, 138.0], &quot;kV&quot;)</code></pre><p>Therefore, by using the <a href="../../api/unit/#JuliaGrid.@base"><code>@base</code></a> macro to modify the base unit, users can convert the output data from various analyses to specific units with desired prefixes.</p><hr/><h2 id="SaveModelManual"><a class="docs-heading-anchor" href="#SaveModelManual">Save Model</a><a id="SaveModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#SaveModelManual" title="Permalink"></a></h2><p>Once the <code>PowerSystem</code> type has been created using one of the methods outlined in <a href="#BuildModelManual">Build Model</a>, the current data can be stored in the HDF5 file by using  <a href="../../api/powerSystemModel/#JuliaGrid.savePowerSystem"><code>savePowerSystem</code></a> function:</p><pre><code class="language-julia hljs">savePowerSystem(system; path = &quot;C:/matpower/case14.h5&quot;, reference = &quot;IEEE 14-bus test case&quot;)</code></pre><p>All electrical quantities saved in the HDF5 file are in per-units and radians, except for base values for power and voltages, which are given in volt-amperes and volts. It is important to note that even if the user modifies the base units using the <a href="../../api/unit/#JuliaGrid.@base"><code>@base</code></a> macro, the units will still be saved in the default settings.</p><hr/><h2 id="AddBusManual"><a class="docs-heading-anchor" href="#AddBusManual">Add Bus</a><a id="AddBusManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddBusManual" title="Permalink"></a></h2><p>We have the option to add buses to a loaded power system or to one created from scratch. As an illustration, we can initiate the <code>PowerSystem</code> type and then incorporate two buses by utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, angle = -0.034907, base = 138e3)</code></pre><p>In this case, we have created two buses, where the active and reactive powers demanded by consumers at buses labelled with 1 and 2 are specified in per-units, which are the same units used to store electrical quantities:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.1
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.05</code></pre><p>Further, the <code>base</code> keyword is related to base voltages, and its default units are in volts (V):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.voltage.value, system.base.voltage.unit</code><code class="nohighlight hljs ansi" style="display:block;">([138000.0, 138000.0], &quot;V&quot;)</code></pre><p>Finally, we set the bus voltage angle in radians for the bus with label 2 to its initial value:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
  0.0
 -0.034907</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend reading the documentation for the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, where all the keywords used in the function are explained in detail.</p></div></div><hr/><h5 id="Change-Input-Units"><a class="docs-heading-anchor" href="#Change-Input-Units">Change Input Units</a><a id="Change-Input-Units-1"></a><a class="docs-heading-anchor-permalink" href="#Change-Input-Units" title="Permalink"></a></h5><p>By default, all keywords related to electrical quantities must be given in per-units (pu) and radians (rad). To specify some of the units other than the default per-units and radians, users can utilize macros such as the following:</p><pre><code class="language-julia hljs">@power(MW, MVAr, MVA)
@voltage(pu, deg)</code></pre><p>We can create identical two buses as before using new system of units as follows:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, active = 10.0, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 5.0, angle = -2.0, base = 138e3)</code></pre><p>As can be observed, electrical quantities will continue to be stored in per-units and radians format:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.1
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.05</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
  0.0
 -0.03490658503988659</code></pre><p>The input unit of the <code>base</code> keyword can be changed using the <a href="../../api/unit/#JuliaGrid.@base"><code>@base</code></a> macro. For example:</p><pre><code class="language-julia hljs">@power(MW, MVAr, MVA)
@voltage(pu, deg)

system = powerSystem()
@base(system, MVA, kV)

addBus!(system; label = 1, type = 3, active = 10.0, base = 138.0)
addBus!(system; label = 2, type = 1, reactive = 5.0, angle = -2.0, base = 138.0)</code></pre><p>Unlike the preceding examples where base voltages are given in volts, the current illustration adopts units of kilovolts (kV):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.voltage.value, system.base.voltage.unit</code><code class="nohighlight hljs ansi" style="display:block;">([138.0, 138.0], &quot;kV&quot;)</code></pre><hr/><h2 id="BusLabelsManual"><a class="docs-heading-anchor" href="#BusLabelsManual">Bus Labels</a><a id="BusLabelsManual-1"></a><a class="docs-heading-anchor-permalink" href="#BusLabelsManual" title="Permalink"></a></h2><p>In JuliaGrid, if the labels assigned to buses are not in the increasing ordered set of integers, the system internally renumbers all labels to satisfy the requirement of the increasing ordered set of integers. For instance, suppose we have a power system with buses labelled as:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 30)
addBus!(system; label = 20)
addBus!(system; label = 40)
addBus!(system; label = 10)</code></pre><p>These labels, along with their internally assigned labels, are stored in the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.label</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Int64, Int64} with 4 entries:
  20 =&gt; 2
  10 =&gt; 4
  30 =&gt; 1
  40 =&gt; 3</code></pre><p>If a user needs to retrieve the original labels and match them with other parameters related to the buses, they can do so using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label = collect(keys(sort(system.bus.label; byvalue = true)))</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
 30
 20
 40
 10</code></pre><hr/><h2 id="AddBranchManual"><a class="docs-heading-anchor" href="#AddBranchManual">Add Branch</a><a id="AddBranchManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddBranchManual" title="Permalink"></a></h2><p>After adding buses with unique labels, we can define branches between them. The branch cannot be added unless the buses are already defined, and the <code>from</code> and <code>to</code> keywords should correspond to the already defined bus labels. Additionally, each branch should be labelled with its own unique label. For instance:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1)
addBus!(system; label = 2, type = 1, reactive = 0.05, angle = -0.034907)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)</code></pre><p>Here, we created branch from bus 1 to bus 2 with following parameters:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.branch.parameter.reactance</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.branch.parameter.shiftAngle</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.1745</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is recommended to consult the documentation for the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function, which provides an explanation of all the keywords used in the function.</p></div></div><hr/><h5 id="Change-Input-Units-2"><a class="docs-heading-anchor" href="#Change-Input-Units-2">Change Input Units</a><a class="docs-heading-anchor-permalink" href="#Change-Input-Units-2" title="Permalink"></a></h5><p>To use units other than per-units (pu) and radians (rad), macros can be employed to change the input units. For example, if the need arises to use ohms (Ω) and degrees (deg), the macros below can be employed:</p><pre><code class="language-julia hljs">@parameter(Ω, pu)
@voltage(pu, deg)

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1)
addBus!(system; label = 2, type = 1, reactive = 0.05, angle = -2.0)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 22.8528, shiftAngle = 10.0)</code></pre><p>Still, all electrical quantities are stored in per-units and radians, and the same branch as before is created, as shown in the following output:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.branch.parameter.reactance</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 119999.99999999999</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.branch.parameter.shiftAngle</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.17453292519943295</code></pre><p>It is important to note that, when working with impedance and admittance values in ohms (Ω) and siemens (S) that are related to a transformer, the assignment must be based on the primary side of the transformer.</p><hr/><h2 id="BranchLabelsManual"><a class="docs-heading-anchor" href="#BranchLabelsManual">Branch Labels</a><a id="BranchLabelsManual-1"></a><a class="docs-heading-anchor-permalink" href="#BranchLabelsManual" title="Permalink"></a></h2><p>If the branch labels are not in an ordered set of increasing integers, the system will internally renumber all labels, similar to how <a href="#BusLabelsManual">bus lables</a> are handled. For example, consider a power system with non-ordered bus and branch labels as shown below:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 30)
addBus!(system; label = 20)
addBus!(system; label = 40)

addBranch!(system; label = 100, from = 30, to = 20, reactance = 0.8)
addBranch!(system; label = 200, from = 20, to = 40, reactance = 0.5)</code></pre><p>The system stores the original branch labels along with their internally assigned labels:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.branch.label</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Int64, Int64} with 2 entries:
  200 =&gt; 2
  100 =&gt; 1</code></pre><p>To retrieve the original labels and match them with other branch parameters, users can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label = collect(keys(sort(system.branch.label; byvalue = true)))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 100
 200</code></pre><p>Furthermore, the <code>from</code> and <code>to</code> keywords are saved based on the internally assigned numerical values, which are derived from the increasing ordered set of integers based on bus labels:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.label</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Int64, Int64} with 3 entries:
  20 =&gt; 2
  30 =&gt; 1
  40 =&gt; 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [system.branch.layout.from system.branch.layout.to]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Int64}:
 1  2
 2  3</code></pre><p>To retrieve the original <code>from</code> and <code>to</code> labels, the following approach can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; labelBus = collect(keys(sort(system.bus.label; byvalue = true)))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 30
 20
 40</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [labelBus[system.branch.layout.from] labelBus[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Int64}:
 30  20
 20  40</code></pre><hr/><h2 id="AddGeneratorManual"><a class="docs-heading-anchor" href="#AddGeneratorManual">Add Generator</a><a id="AddGeneratorManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddGeneratorManual" title="Permalink"></a></h2><p>After defining the buses, generators can be added to the power system. Each generator must have a unique label assigned to it, and the <code>bus</code> keyword should correspond to the unique label of the bus it is connected to. For instance:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1)
addBus!(system; label = 2)

addGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)</code></pre><p>In the above code, we add the generator to the bus labelled 2, with active and reactive power outputs set to:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.output.active</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.output.reactive</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.1</code></pre><p>Similar to buses and branches, the input units can be changed to units other than per-units and radians using different macros.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is recommended to refer to the documentation for the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function, which explains all the keywords used in the function.</p></div></div><hr/><h2 id="GeneratorLabelsManual"><a class="docs-heading-anchor" href="#GeneratorLabelsManual">Generator Labels</a><a id="GeneratorLabelsManual-1"></a><a class="docs-heading-anchor-permalink" href="#GeneratorLabelsManual" title="Permalink"></a></h2><p>Similar to how the system handles <a href="#BusLabelsManual">bus labels</a> and <a href="#BranchLabelsManual">branch labels</a>, the system will internally renumber all generator labels if they are not in an ordered set of increasing integers. As an example, let us take the power system with non-ordered bus and generator labels, as illustrated below:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 30)
addBus!(system; label = 20)
addBus!(system; label = 40)

addGenerator!(system; label = 200, bus = 40)
addGenerator!(system; label = 100, bus = 30)</code></pre><p>The JuliaGrid stores both the original generator labels and their corresponding internally assigned labels.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.label</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Int64, Int64} with 2 entries:
  200 =&gt; 1
  100 =&gt; 2</code></pre><p>To retrieve the original labels and match them with other generator parameters, users can utilize the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label = collect(keys(sort(system.generator.label; byvalue = true)))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 200
 100</code></pre><p>Additionally, the <code>bus</code> keyword is saved based on the internally assigned numerical values, which are derived from the ordered set of integers based on bus labels:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.label</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Int64, Int64} with 3 entries:
  20 =&gt; 2
  30 =&gt; 1
  40 =&gt; 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.layout.bus</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 3
 1</code></pre><p>To retrieve the original <code>bus</code> labels, the following method can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; labelBus = collect(keys(sort(system.bus.label; byvalue = true)))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 30
 20
 40</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; label = labelBus[system.generator.layout.bus]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 40
 30</code></pre><hr/><h2 id="AddTemplatesManual"><a class="docs-heading-anchor" href="#AddTemplatesManual">Add Templates</a><a id="AddTemplatesManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddTemplatesManual" title="Permalink"></a></h2><p>The functions <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a>, and <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> are used to add bus, branch, and generator to the power system, respectively. If certain keywords are not specified, default values are assigned to some parameters.</p><p>For the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, if the <code>type</code> keyword is not provided, the bus type is automatically set to a demand bus with a value of 1 for <code>type</code>. The initial bus voltage <code>magnitude</code> is set to 1.0 per-unit, and the <code>base</code> voltage is set to 138e3 volts. These default values are important to prevent issues with algorithm execution, such as a singular Jacobian when <code>magnitude = 0.0</code>.</p><p>The <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function assigns default values of 1 for <code>status</code>, indicating that the branch is in-service, and 1 for <code>type</code>, representing the type of ratings.</p><p>Similarly, the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function assigns default values of 1 for <code>status</code>, indicating that the generator is in-service, and 1.0 per-unit for <code>magnitude</code>, which represents the voltage magnitude setpoint.</p><p>The remaining parameters are initialized with default values of zero.</p><p>In JuliaGrid, users are allowed to modify default values and assign non-zero values to other keywords using the <a href="../../api/powerSystemModel/#JuliaGrid.@bus"><code>@bus</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.@branch"><code>@branch</code></a>, and <a href="../../api/powerSystemModel/#JuliaGrid.@generator"><code>@generator</code></a> macros. These macros create bus, branch, and generator templates that are used every time the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a>, and <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> functions are called. For instance, the code block shows an example of creating bus, branch, and generator templates with customized default values:</p><pre><code class="language-julia hljs">system = powerSystem()

@bus(type = 2, active = 0.1)
addBus!(system; label = 1, reactive = 0.2)
addBus!(system; label = 2, type = 1, active = 0.5, reactive = 0.3)

@branch(reactance = 0.12)
addBranch!(system; label = 1, from = 1, to = 2)
addBranch!(system; label = 2, from = 1, to = 2, reactance = 0.06)

@generator(magnitude = 1.1)
addGenerator!(system; label = 1, bus = 1, active = 50, reactive = 10)
addGenerator!(system; label = 2, bus = 1, active = 20, reactive = 30)</code></pre><p>This code example involves two uses of the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> functions. In the first use, the functions rely on the default values set by the templates created with the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> and<a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> macros. In contrast, the second use passes specific values that match the keywords used in the templates. As a result, the templates are overridden:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.layout.type</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 2
 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.1
 0.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.branch.parameter.reactance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.12
 0.06</code></pre><p>In the given example, the <a href="../../api/powerSystemModel/#JuliaGrid.@generator"><code>@generator</code></a> macro is utilized instead of repeatedly specifying the <code>magnitude</code> keyword in the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. This macro creates a generator template with a default value for <code>magnitude</code>, which is automatically applied every time the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function is called. Therefore, it eliminates the requirement to set the magnitude value for each individual generator:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.1
 1.1</code></pre><hr/><h5 id="Change-Input-Units-3"><a class="docs-heading-anchor" href="#Change-Input-Units-3">Change Input Units</a><a class="docs-heading-anchor-permalink" href="#Change-Input-Units-3" title="Permalink"></a></h5><p>The JuliaGrid requires users to specify electrical quantity-related keywords in per-units (pu) and radians (rad) by default. However, it provides macros, such as <a href="../../api/unit/#JuliaGrid.@power"><code>@power</code></a>, that allow users to specify other units:</p><pre><code class="language-julia hljs">system = powerSystem()

@power(MW, MVAr, MVA)

@bus(type = 2, active = 100, reactive = 200)
addBus!(system; label = 1)
addBus!(system; label = 2, magnitude = 1.1)

@power(pu, pu, pu)

addBus!(system; label = 3, type = 2, active = 1.0, reactive = 1.0)</code></pre><p>In this example, we create the bus template and two buses using SI power units, and then we switch to per-units and add a third bus. It is important to note that once the template is defined in any unit system, it remains valid regardless of subsequent unit system changes. The resulting power values are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 1.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 2.0
 2.0
 1.0</code></pre><p>Thus, JuliaGrid automatically tracks the unit system used to create templates and provides the appropriate conversion to per-units. Even if the user switches to a different unit system later on, the previously defined template will still be valid.</p><p>Finally, it is worth noting that the unit of base voltage for the bus template is determined by the last call of the <a href="../../api/unit/#JuliaGrid.@base"><code>@base</code></a> macro before calling the <a href="../../api/powerSystemModel/#JuliaGrid.@bus"><code>@bus</code></a> macro. For example:</p><pre><code class="language-julia hljs">system1 = powerSystem()
system2 = powerSystem()

@base(system1, MVA, kV)
@base(system2, MVA, V)

@bus(type = 2, active = 1.0, reactive = 2.0, base = 138e3)
addBus!(system1; label = 1)
addBus!(system2; label = 2, magnitude = 1.1)</code></pre><p>In this case, since the last execution of the <a href="../../api/unit/#JuliaGrid.@base"><code>@base</code></a> macro before creating the bus template specified volt (V) units, the <code>base</code> keyword value must be given in volts.</p><hr/><h5 id="Multiple-Bus-Templates"><a class="docs-heading-anchor" href="#Multiple-Bus-Templates">Multiple Bus Templates</a><a id="Multiple-Bus-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Bus-Templates" title="Permalink"></a></h5><p>In the case of calling the <a href="../../api/powerSystemModel/#JuliaGrid.@bus"><code>@bus</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.@branch"><code>@branch</code></a>, or <a href="../../api/powerSystemModel/#JuliaGrid.@generator"><code>@generator</code></a> macros multiple times, the provided keywords and values will be combined into a single template for the corresponding component (bus, branch, or generator), which will be used for generating the component.</p><hr/><h5 id="Reset-Templates"><a class="docs-heading-anchor" href="#Reset-Templates">Reset Templates</a><a id="Reset-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Reset-Templates" title="Permalink"></a></h5><p>To reset the bus, branch, and generator templates to their default settings, users can utilize the following macros:</p><pre><code class="language-julia hljs">@default(bus)
@default(branch)
@default(generator)</code></pre><p>Additionally, users can reset all templates for the bus, branch, and generator components using the macro:</p><pre><code class="language-julia hljs">@default(template)</code></pre><hr/><h2 id="ACDCModelManual"><a class="docs-heading-anchor" href="#ACDCModelManual">AC and DC Model</a><a id="ACDCModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACDCModelManual" title="Permalink"></a></h2><p>When we constructed the power system, we can create an AC and/or DC model, which include vectors and matrices related to the power system&#39;s topology and parameters. The following code snippet demonstrates this:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1)
addBus!(system; label = 2, type = 1, reactive = 0.05)
addBus!(system; label = 3, type = 1, susceptance = 0.05)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)
addBranch!(system; label = 2, from = 2, to = 3, resistance = 0.008, reactance = 0.05)

acModel!(system)
dcModel!(system)</code></pre><p>One of the components of the AC and DC models are nodal matrices, which can be accessed through the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.dcModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
  8.33333   -8.33333     ⋅
 -8.33333   28.3333   -20.0
   ⋅       -20.0       20.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.acModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 7 stored entries:
    0.0-8.33333im   -1.4468+8.20678im           ⋅
 1.4468+8.20678im   3.12012-27.8341im  -3.12012+19.5008im
        ⋅          -3.12012+19.5008im   3.12012-19.4508im</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The AC model is used for performing AC power flow, AC optimal power flow, nonlinear state estimation, or state estimation with PMUs, whereas the DC model is essential for various DC or linear analyses. Consequently, once these models are developed, they can be applied to various types of simulations. We recommend that the reader refer to the tutorial on <a href="../../tutorials/modelACDC/#ACDCModelTutorials">AC and DC models</a>.</p></div></div><hr/><h5 id="New-Branch-Triggers-Model-Update"><a class="docs-heading-anchor" href="#New-Branch-Triggers-Model-Update">New Branch Triggers Model Update</a><a id="New-Branch-Triggers-Model-Update-1"></a><a class="docs-heading-anchor-permalink" href="#New-Branch-Triggers-Model-Update" title="Permalink"></a></h5><p>We can execute the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a> functions after defining the final number of buses, and each new branch added will trigger an update of the AC and DC vectors and matrices. Here&#39;s an example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1)
addBus!(system; label = 2, type = 1, reactive = 0.05)
addBus!(system; label = 3, type = 1, susceptance = 0.05)

acModel!(system)
dcModel!(system)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)
addBranch!(system; label = 2, from = 2, to = 3, resistance = 0.008, reactance = 0.05)</code></pre><p>The DC nodal matrix has the same values as before:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.dcModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
  8.33333   -8.33333     ⋅
 -8.33333   28.3333   -20.0
   ⋅       -20.0       20.0</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>It is not fully recommended to create AC and DC models before adding a large number of branches if the execution time of functions is important. Instead, triggering updates to the AC and DC models using the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function is useful for power systems that require the addition of several branches. This update avoids the need to recreate vectors and matrices from scratch.</p></div></div><hr/><h5 id="New-Bus-Triggers-Model-Erasure"><a class="docs-heading-anchor" href="#New-Bus-Triggers-Model-Erasure">New Bus Triggers Model Erasure</a><a id="New-Bus-Triggers-Model-Erasure-1"></a><a class="docs-heading-anchor-permalink" href="#New-Bus-Triggers-Model-Erasure" title="Permalink"></a></h5><p>The AC and DC models must be defined when a finite number of buses are defined, otherwise, adding a new bus will delete them. For example, if we attempt to add a new bus to the <code>system</code> variable, the current AC and DC models will be completely erased:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; addBus!(system; label = 4, type = 2, base = 138e3)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: The current AC model has been completely erased.
[ Info: The current DC model has been completely erased.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.dcModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">0×0 SparseArrays.SparseMatrixCSC{Float64, Int64} with 0 stored entries</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.acModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">0×0 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 0 stored entries</code></pre><hr/><h2 id="AlterShuntElementsManual"><a class="docs-heading-anchor" href="#AlterShuntElementsManual">Alter Shunt Elements</a><a id="AlterShuntElementsManual-1"></a><a class="docs-heading-anchor-permalink" href="#AlterShuntElementsManual" title="Permalink"></a></h2><p>To modify or add new shunt element at bus, you can use the <a href="../../api/powerSystemModel/#JuliaGrid.shuntBus!"><code>shuntBus!</code></a> function. If AC and DC models have not yet been created, you can directly access the <code>bus.shunt.conductance</code> and <code>bus.shunt.susceptance</code> variables to change their values. However, if AC and DC models have been created, using the <a href="../../api/powerSystemModel/#JuliaGrid.shuntBus!"><code>shuntBus!</code></a> function will automatically update all relevant fields in these models. This avoids the need to recreate the AC and DC models from scratch.</p><p>Therefore, it is recommended to use this function after executing the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a> functions. For example, let us start by creating the AC model:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1)
addBus!(system; label = 2, type = 1, reactive = 0.05)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)

acModel!(system)</code></pre><p>Then, the AC nodal matrix is given as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.acModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
    0.0-8.33333im  -1.4468+8.20678im
 1.4468+8.20678im      0.0-8.33333im</code></pre><p>For example, to add a shunt element at bus 1 with a specified conductance value and modify the susceptance value of the shunt element at bus 2, we can execute the following code:</p><pre><code class="language-julia hljs">shuntBus!(system; label = 1, conductance = 0.04)
shuntBus!(system; label = 2, susceptance = 0.25)</code></pre><p>Upon examining the AC nodal matrix, it can be inferred that the <a href="../../api/powerSystemModel/#JuliaGrid.shuntBus!"><code>shuntBus!</code></a> function automatically updates this matrix:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.acModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
   0.04-8.33333im  -1.4468+8.20678im
 1.4468+8.20678im      0.0-8.08333im</code></pre><hr/><h2 id="ChangeBranchStatusManual"><a class="docs-heading-anchor" href="#ChangeBranchStatusManual">Change Branch Status</a><a id="ChangeBranchStatusManual-1"></a><a class="docs-heading-anchor-permalink" href="#ChangeBranchStatusManual" title="Permalink"></a></h2><p>We can use the <a href="../../api/powerSystemModel/#JuliaGrid.statusBranch!"><code>statusBranch!</code></a> function to switch the branch&#39;s status between in-service and out-of-service. If the AC and DC models are not created, the function will perform the same operation as accessing <code>branch.layout.status</code> and changing the value from 1 to 0 or vice versa. However, if the AC and DC models are created, the function will trigger updates to all affected vectors and matrices.</p><p>Therefore, it is recommended to use this function after executing the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a> functions. The following code demonstrates the usage of the <a href="../../api/powerSystemModel/#JuliaGrid.statusBranch!"><code>statusBranch!</code></a> function:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1)
addBus!(system; label = 2)
addBus!(system; label = 3)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)
addBranch!(system; label = 2, from = 2, to = 3, resistance = 0.008, reactance = 0.05)

acModel!(system)
dcModel!(system)

statusBranch!(system; label = 1, status = 0)</code></pre><p>This code sets the branch labelled with 1 to out-of-service. For example, the DC nodal matrix has the following form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.dcModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
 0.0    0.0     ⋅
 0.0   20.0  -20.0
  ⋅   -20.0   20.0</code></pre><hr/><h5 id="Drop-Zeros"><a class="docs-heading-anchor" href="#Drop-Zeros">Drop Zeros</a><a id="Drop-Zeros-1"></a><a class="docs-heading-anchor-permalink" href="#Drop-Zeros" title="Permalink"></a></h5><p>After the execution of the <a href="../../api/powerSystemModel/#JuliaGrid.statusBranch!"><code>statusBranch!</code></a> function, the nodal matrices will contain zeros, as demonstrated in the code example. If needed, the user can remove these zeros by using the <code>dropzeros!</code> function, as shown below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SparseArrays</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dropzeros!(system.dcModel.nodalMatrix)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  ⋅      ⋅      ⋅
  ⋅    20.0  -20.0
  ⋅   -20.0   20.0</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It should be noted that in simulations conducted with the JuliaGrid package, the accuracy of the results will not be affected by leaving zeros.</p></div></div><hr/><h2 id="ChangeBranchParametersManual"><a class="docs-heading-anchor" href="#ChangeBranchParametersManual">Change Branch Parameters</a><a id="ChangeBranchParametersManual-1"></a><a class="docs-heading-anchor-permalink" href="#ChangeBranchParametersManual" title="Permalink"></a></h2><p>The <a href="../../api/powerSystemModel/#JuliaGrid.parameterBranch!"><code>parameterBranch!</code></a> function is used to modify the parameters of a branch, which include resistance, reactance, susceptance, turns ratio, and shift angle. Although one can modify these parameters by accessing the corresponding variables within the <code>branch.parameter</code> field, using the <a href="../../api/powerSystemModel/#JuliaGrid.parameterBranch!"><code>parameterBranch!</code></a> function will update all affected vectors and matrices, provided that the AC and DC models have been created.</p><p>Therefore, this function is useful after executing the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a> functions. For example, let us start by creating the AC model:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1)
addBus!(system; label = 2)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)

acModel!(system)</code></pre><p>Then the AC nodal matrix is:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.acModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
    0.0-8.33333im  -1.4468+8.20678im
 1.4468+8.20678im      0.0-8.33333im</code></pre><p>We can modify the reactance value of branch 1 and add resistance to it while keeping the shift angle constant using the <a href="../../api/powerSystemModel/#JuliaGrid.parameterBranch!"><code>parameterBranch!</code></a> function as shown below:</p><pre><code class="language-julia hljs">parameterBranch!(system; label = 1, reactance = 0.10, resistance = 0.02)</code></pre><p>After executing this code, we can observe that the nodal matrix of the AC model is automatically updated by the function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.acModel.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
  1.92308-9.61538im  -3.56325+9.13548im
 -0.22449+9.80324im   1.92308-9.61538im</code></pre><hr/><h2 id="ChangeGeneratorStatusManual"><a class="docs-heading-anchor" href="#ChangeGeneratorStatusManual">Change Generator Status</a><a id="ChangeGeneratorStatusManual-1"></a><a class="docs-heading-anchor-permalink" href="#ChangeGeneratorStatusManual" title="Permalink"></a></h2><p>The <a href="../../api/powerSystemModel/#JuliaGrid.statusGenerator!"><code>statusGenerator!</code></a> function can be used to change the status of a generator between in-service and out-of-service. It is important to always use this function when changing the status of a previously defined generator. Directly accessing the corresponding variable to change the status can result in incorrect results because it will not affect the variable that holds the active and reactive powers generated by the generators that supply buses. Therefore, using the <a href="../../api/powerSystemModel/#JuliaGrid.statusGenerator!"><code>statusGenerator!</code></a> function is a safe way to put a generator in or out of service.</p><p>Let us create the power system with two generators connected to the same bus labelled with 2:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1)
addBus!(system; label = 2)

addGenerator!(system; label = 1, bus = 2, active = 0.4)
addGenerator!(system; label = 2, bus = 2, active = 0.6)</code></pre><p>To check the the powers being generated by the generators that supply the buses and outputs of the generators, you can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.output.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.4
 0.6</code></pre><p>To put the second generator out of service, you can use the <a href="../../api/powerSystemModel/#JuliaGrid.statusGenerator!"><code>statusGenerator!</code></a> function:</p><pre><code class="language-julia hljs">statusGenerator!(system; label = 2, status = 0)</code></pre><p>Here, we can see the updated variables, where the second generator has been taken out of the system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.output.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.4
 0.6</code></pre><p>It is worth noting that even if the generator is out-of-service, the <code>generator.output.active</code> variable still reflects its production. This is because it allows the same generator to be put back in-service with the same output power as before.</p><hr/><h2 id="ChangeGeneratorOutputsManual"><a class="docs-heading-anchor" href="#ChangeGeneratorOutputsManual">Change Generator Outputs</a><a id="ChangeGeneratorOutputsManual-1"></a><a class="docs-heading-anchor-permalink" href="#ChangeGeneratorOutputsManual" title="Permalink"></a></h2><p>The function <a href="../../api/powerSystemModel/#JuliaGrid.outputGenerator!"><code>outputGenerator!</code></a> can be utilized to change the output of a generator. Similar to the <a href="#ChangeGeneratorStatusManual">Change Generator Status</a>, this function provides a safe way to modify the active and reactive powers produced by the previously defined generator.</p><p>To demonstrate how to use this function, we can use the example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1)
addBus!(system; label = 2)

addGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)
addGenerator!(system; label = 2, bus = 2, active = 0.5, reactive = 0.1)

outputGenerator!(system; label = 1, active = 1.0)</code></pre><p>In this example, we increase the output active power of the first generator, and the results can be observed below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.output.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.0
 0.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 1.5</code></pre><p>It is worth noting that the output reactive power of the generators remains the same, as shown in the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.output.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.1
 0.1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.supply.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.2</code></pre><hr/><h2 id="AddActiveReactiveCostsManual"><a class="docs-heading-anchor" href="#AddActiveReactiveCostsManual">Add Active and Reactive Costs</a><a id="AddActiveReactiveCostsManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddActiveReactiveCostsManual" title="Permalink"></a></h2><p>The <a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.addReactiveCost!"><code>addReactiveCost!</code></a> functions are responsible for adding costs for the active and reactive power produced by the corresponding generator. These costs are added only if the corresponding generator is defined. We will be using the <a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a> function throughout this manual. The same steps can be applied for the <a href="../../api/powerSystemModel/#JuliaGrid.addReactiveCost!"><code>addReactiveCost!</code></a> function.</p><p>To begin, let us create an example of the power system using the following code:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1)
addBus!(system; label = 2)

addGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)</code></pre><hr/><h5 id="Polynomial-Cost"><a class="docs-heading-anchor" href="#Polynomial-Cost">Polynomial Cost</a><a id="Polynomial-Cost-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Cost" title="Permalink"></a></h5><p>Let us define a quadratic polynomial cost function <span>$f(P_g) = 1100P^2_g + 500P_g + 150$</span> for the active power produced by the generator labelled with 1 using the following code:</p><pre><code class="language-julia hljs">addActiveCost!(system; label = 1, model = 2, polynomial = [1100.0; 500.0; 150.0])</code></pre><p>As previously, the default input units are related with per-units (pu), and the coefficients of the cost function have units of currency/pu²hr for 1100, currency/puhr for 500, and currency/hr for 150. Hence, the coefficients are stored exactly as entered:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.cost.active.polynomial</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Vector{Float64}}:
 [1100.0, 500.0, 150.0]</code></pre><p>By setting <code>model = 2</code> in the <a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a> function, we specify that the quadratic polynomial cost is being used for the corresponding generator. This can be particularly useful if we have also defined a piecewise linear cost function for the same generator. In such cases, we can choose between these two cost functions depending on our simulation requirements.</p><hr/><h5 id="Piecewise-Linear-Cost"><a class="docs-heading-anchor" href="#Piecewise-Linear-Cost">Piecewise Linear Cost</a><a id="Piecewise-Linear-Cost-1"></a><a class="docs-heading-anchor-permalink" href="#Piecewise-Linear-Cost" title="Permalink"></a></h5><p>We can also create a piecewise linear cost function for the active power of the same generator by using the following code:</p><pre><code class="language-julia hljs">addActiveCost!(system; label = 1, piecewise =  [0.1085 12.3; 0.1477 16.8; 0.18 18.1])</code></pre><p>In this case, the first column specifies the output active powers of the generator in per-units, while the second column specifies the corresponding costs for the specified active power in currency/hr. Thus, the data is stored exactly as entered:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.cost.active.piecewise</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Matrix{Float64}}:
 [0.1085 12.3; 0.1477 16.8; 0.18 18.1]</code></pre><p>If we want to use this piecewise linear cost function instead of the polynomial cost function that was defined earlier, we need to set <code>model = 1</code>.</p><hr/><h5 id="Change-Input-Units-4"><a class="docs-heading-anchor" href="#Change-Input-Units-4">Change Input Units</a><a class="docs-heading-anchor-permalink" href="#Change-Input-Units-4" title="Permalink"></a></h5><p>Changing input units from per-units (pu) can be particularly useful since cost functions are usually related to SI units of powers. To demonstrate this, let us set active powers in megawatts (MW) while keeping the rest of the units in per-units:</p><pre><code class="language-julia hljs">@power(MW, pu, pu)

system = powerSystem()

addBus!(system; label = 1)
addBus!(system; label = 2)

addGenerator!(system; label = 1, bus = 2, active = 50, reactive = 0.1)</code></pre><p>Now, we can add the quadratic polynomial function using megawatts:</p><pre><code class="language-julia hljs">addActiveCost!(system; label = 1, model = 2, polynomial = [0.11; 5.0; 150.0])</code></pre><p>After inspecting the resulting cost data, we can see that it is the same as before:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.cost.active.polynomial</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Vector{Float64}}:
 [1100.0, 500.0, 150.0]</code></pre><p>Similarly, we can define the linear piecewise cost:</p><pre><code class="language-julia hljs">addActiveCost!(system; label = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])</code></pre><p>Upon inspection, we can see that the stored data is the same as before:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.cost.active.piecewise</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Matrix{Float64}}:
 [0.1085 12.3; 0.1477 16.8; 0.18 18.1]</code></pre><hr/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><a class="docs-footer-nextpage" href="../powerFlowAnalysis/">Power Flow Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 29 April 2023 16:36">Saturday 29 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
