<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC State Estimation · JuliaGrid</title><meta name="title" content="AC State Estimation · JuliaGrid"/><meta property="og:title" content="AC State Estimation · JuliaGrid"/><meta property="twitter:title" content="AC State Estimation · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li class="is-active"><a class="tocitem" href>AC State Estimation</a><ul class="internal"><li><a class="tocitem" href="#ACSEBusTypeModificationManual"><span>Bus Type Modification</span></a></li><li><a class="tocitem" href="#ACSEObservabilityAnalysisManual"><span>Observability Analysis</span></a></li><li><a class="tocitem" href="#ACLSStateEstimationSolutionManual"><span>Weighted Least-squares Estimator</span></a></li><li><a class="tocitem" href="#ACBadDataDetectionManual"><span>Bad Data Processing</span></a></li><li><a class="tocitem" href="#PMULAVtateEstimationSolutionManual"><span>Least Absolute Value Estimator</span></a></li><li><a class="tocitem" href="#ACMeasurementsAlterationManual"><span>Measurement Set Update</span></a></li><li><a class="tocitem" href="#ACStateEstimationReferenceManual"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>AC State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/acStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACStateEstimationManual"><a class="docs-heading-anchor" href="#ACStateEstimationManual">AC State Estimation</a><a id="ACStateEstimationManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACStateEstimationManual" title="Permalink"></a></h1><p>To perform nonlinear or AC state estimation, the initial requirement is to have the <code>PowerSystem</code> composite type configured with the AC model, along with the <code>Measurement</code> composite type storing measurement data. Next, we can develop either the weighted least-squares (WLS) model, utilizing the Gauss-Newton method, or the least absolute value (LAV) model. These models are encapsulated within the <code>ACStateEstimation</code> type:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.acLavStateEstimation"><code>acLavStateEstimation</code></a>.</li></ul><p>For resolving the AC state estimation problem and obtaining bus voltage magnitudes and angles, utilize the following function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>solve!</code></a>.</li></ul><p>After executing the function <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>solve!</code></a>, where the user employs the Gauss-Newton method, the user has the ability to check if the measurement set contains outliers throughout bad data analysis and remove those measurements using:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.residualTest!"><code>residualTest!</code></a>.</li></ul><p>Moreover, before the creating <code>ACStateEstimation</code> type, users can initiate observability analysis to identify observable islands and restore observability by employing:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.islandTopologicalFlow-Tuple{PowerSystem, Measurement}"><code>islandTopologicalFlow</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.islandTopological-Tuple{PowerSystem, Measurement}"><code>islandTopological</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, Island}"><code>restorationGram!</code></a>.</li></ul><hr/><p>After obtaining the AC state estimation solution, JuliaGrid offers post-processing analysis functions for calculating powers and currents associated with buses and branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a>.</li></ul><p>Furthermore, there are specialized functions dedicated to calculating specific types of powers related to particular buses and branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, AC}"><code>injectionPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, ACPowerFlow}"><code>supplyPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.shuntPower-Tuple{PowerSystem, AC}"><code>shuntPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, AC}"><code>fromPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, AC}"><code>toPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.seriesPower-Tuple{PowerSystem, AC}"><code>seriesPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.chargingPower-Tuple{PowerSystem, AC}"><code>chargingPower</code></a>,</li></ul><p>Likewise, there are specialized functions dedicated to calculating specific types of currents related to particular buses or branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionCurrent-Tuple{PowerSystem, AC}"><code>injectionCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromCurrent-Tuple{PowerSystem, AC}"><code>fromCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toCurrent-Tuple{PowerSystem, AC}"><code>toCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.seriesCurrent-Tuple{PowerSystem, AC}"><code>seriesCurrent</code></a>.</li></ul><hr/><h2 id="ACSEBusTypeModificationManual"><a class="docs-heading-anchor" href="#ACSEBusTypeModificationManual">Bus Type Modification</a><a id="ACSEBusTypeModificationManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACSEBusTypeModificationManual" title="Permalink"></a></h2><p>In AC state estimation, it is necessary to designate a slack bus, where the bus voltage angle is known. Therefore, when executing the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> or <a href="../../api/stateEstimation/#JuliaGrid.acLavStateEstimation"><code>acLavStateEstimation</code></a> function, the initially assigned slack bus is evaluated and may be altered. If the designated slack bus (<code>type = 3</code>) lacks a connected in-service generator, it will be changed to a demand bus (<code>type = 1</code>). Conversely, the first generator bus (<code>type = 2</code>) with an active in-service generator linked to it will be reassigned as the new slack bus (<code>type = 3</code>).</p><hr/><h2 id="ACSEObservabilityAnalysisManual"><a class="docs-heading-anchor" href="#ACSEObservabilityAnalysisManual">Observability Analysis</a><a id="ACSEObservabilityAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACSEObservabilityAnalysisManual" title="Permalink"></a></h2><p>To initiate the power system with measurements at specific locations, follow the provided example code:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.05)
addBus!(system; label = &quot;Bus 4&quot;, type = 1, active = 0.05)
addBus!(system; label = &quot;Bus 5&quot;, type = 1, active = 0.05)
addBus!(system; label = &quot;Bus 6&quot;, type = 1, active = 0.05)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 3&quot;, to = &quot;Bus 5&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 4&quot;, from = &quot;Bus 3&quot;, to = &quot;Bus 4&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 5&quot;, from = &quot;Bus 5&quot;, to = &quot;Bus 6&quot;, reactance = 0.01)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, reactive = 0.1)

addWattmeter!(system, device; label = &quot;Wattmeter 1&quot;, from = &quot;Branch 1&quot;, active = 0.31)
addVarmeter!(system, device; label = &quot;Varmeter 1&quot;, from = &quot;Branch 1&quot;, reactive = -0.19)

addWattmeter!(system, device; label = &quot;Wattmeter 2&quot;, from = &quot;Branch 3&quot;, active = 0.09)
addVarmeter!(system, device; label = &quot;Varmeter 2&quot;, from = &quot;Branch 3&quot;, reactive = -0.08)

addWattmeter!(system, device; label = &quot;Wattmeter 3&quot;, bus = &quot;Bus 3&quot;, active = -0.05)
addVarmeter!(system, device; label = &quot;Varmeter 3&quot;, bus = &quot;Bus 3&quot;, reactive = 0.0)

addWattmeter!(system, device; label = &quot;Wattmeter 4&quot;, bus = &quot;Bus 3&quot;, active = -0.04)
addVarmeter!(system, device; label = &quot;Varmeter 4&quot;, bus = &quot;Bus 3&quot;, reactive = 0.0001)</code></pre><p>Attempting to solve this system immediately may not be possible because the gain matrix will be singular. To avoid this situation, users can perform observability analysis. JuliaGrid employs standard observability analysis performed on the linear decoupled measurement model. Active power measurements from wattmeters are utilized to estimate bus voltage angles, while reactive power measurements from varmeters are used to estimate bus voltage magnitudes. This necessitates that measurements of active and reactive power come in pairs.</p><p>However, the initial step involves defining observable islands. JuliaGrid offers users two options for obtaining observable islands: flow observable islands or maximal observable islands. The selection depends on the power system&#39;s structure and available measurements. Identifying only flow observable islands reduces complexity in the island detection function but increases complexity in the restoration function.</p><hr/><h5 id="Flow-Observable-Islands"><a class="docs-heading-anchor" href="#Flow-Observable-Islands">Flow Observable Islands</a><a id="Flow-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Flow-Observable-Islands" title="Permalink"></a></h5><p>Now, let us identify flow observable islands:</p><pre><code class="language-julia hljs">islands = islandTopologicalFlow(system, device)</code></pre><p>As a result, four flow observable islands are identified: <code>Bus 1</code> and <code>Bus 2</code> form the first island, <code>Bus 3</code> and <code>Bus 5</code> form the second island, and <code>Bus 4</code> and <code>Bus 6</code> constitute the third and fourth islands, respectively:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 5]
 [4]
 [6]</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><hr/><h5 id="Maximal-Observable-Islands"><a class="docs-heading-anchor" href="#Maximal-Observable-Islands">Maximal Observable Islands</a><a id="Maximal-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-Observable-Islands" title="Permalink"></a></h5><p>Following that, we will instruct the user on obtaining maximal observable islands:</p><pre><code class="language-julia hljs">islands = islandTopological(system, device)</code></pre><p>The outcome reveals the identification of two maximal observable islands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Vector{Int64}}:
 [1, 2, 3, 5, 4]
 [6]</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>It is evident that upon comparing this result with the flow observable islands, the merging of the two injection measurements at <code>Bus 3</code> consolidated the first, second, and third flow observable islands into a single island.</p><hr/><h5 id="Restore-Observability"><a class="docs-heading-anchor" href="#Restore-Observability">Restore Observability</a><a id="Restore-Observability-1"></a><a class="docs-heading-anchor-permalink" href="#Restore-Observability" title="Permalink"></a></h5><p>Before commencing the restoration of observability in the context of the linear decoupled measurement model and observability analysis, it is imperative to ensure that the system possesses one bus voltage magnitude measurement. This necessity arises from the fact that observable islands are identified based on wattmeters, where wattmeters are tasked with estimating voltage angles. Since one voltage angle is already known from the slack bus, the same principle should be applied to bus voltage magnitudes. Therefore, to address this requirement, we add:</p><pre><code class="language-julia hljs">addVoltmeter!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0)</code></pre><p>Subsequently, the user needs to establish a set of pseudomeasurements, where measurements must come in pairs as well. Let us create that set:</p><pre><code class="language-julia hljs">pseudo = measurement()

addWattmeter!(system, pseudo; label = &quot;Pseudowattmeter 1&quot;, bus = &quot;Bus 1&quot;, active = 0.31)
addVarmeter!(system, pseudo; label = &quot;Pseudovarmeter 1&quot;, bus = &quot;Bus 1&quot;, reactive = -0.19)

addWattmeter!(system, pseudo; label = &quot;Pseudowattmeter 2&quot;, bus = &quot;Bus 6&quot;, active = -0.05)
addVarmeter!(system, pseudo; label = &quot;Pseudovarmeter 2&quot;, bus = &quot;Bus 6&quot;, reactive = 0.0)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The labels for specific pseudomeasurements must differ from those defined in the measurements stored in the <code>device</code> set. This is necessary because the next step involves adding pseudomeasurements to the <code>device</code> set.</p></div></div><p>Subsequently, the user can execute the <a href="../../api/stateEstimation/#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, Island}"><code>restorationGram!</code></a> function:</p><pre><code class="language-julia hljs">restorationGram!(system, device, pseudo, islands)</code></pre><p>This function attempts to restore observability using pseudomeasurements. As a result, the inclusion of measurements from <code>Pseudowattmeter 2</code> and <code>Pseudovarmeter 2</code> facilitates observability restoration, and these measurements are subsequently added to the <code>device</code> variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; device.wattmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 5 entries:
  &quot;Wattmeter 1&quot;       =&gt; 1
  &quot;Wattmeter 2&quot;       =&gt; 2
  &quot;Wattmeter 3&quot;       =&gt; 3
  &quot;Wattmeter 4&quot;       =&gt; 4
  &quot;Pseudowattmeter 2&quot; =&gt; 5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; device.varmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 5 entries:
  &quot;Varmeter 1&quot;       =&gt; 1
  &quot;Varmeter 2&quot;       =&gt; 2
  &quot;Varmeter 3&quot;       =&gt; 3
  &quot;Varmeter 4&quot;       =&gt; 4
  &quot;Pseudovarmeter 2&quot; =&gt; 5</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Consequently, the power system becomes observable, allowing the user to proceed with forming the AC state estimation model and solving it. Ensuring the observability of the system does not guarantee obtaining accurate estimates of the state variables. Numerical ill-conditioning may adversely impact the state estimation algorithm. However, in most cases, efficient estimation becomes feasible when the system is observable <a href="#ACStateEstimationReferenceManual">[1]</a>.</p><p>Additionally, it is worth mentioning that restoration might encounter difficulties due to the default zero pivot threshold set at <code>1e-5</code>. This threshold can be modified using the <a href="../../api/stateEstimation/#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, Island}"><code>restorationGram!</code></a> function.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>During the restoration step, if users define bus phasor measurements at any point, these measurements will be considered. Consequently, the system may achieve observability even if multiple islands persist.</p></div></div><hr/><h2 id="ACLSStateEstimationSolutionManual"><a class="docs-heading-anchor" href="#ACLSStateEstimationSolutionManual">Weighted Least-squares Estimator</a><a id="ACLSStateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACLSStateEstimationSolutionManual" title="Permalink"></a></h2><p>To begin, we will define the <code>PowerSystem</code> and <code>Measurement</code> types. Within the measurement set, we choose to utilize measurement values by setting <code>noise = false</code>:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1, reactive = 0.01)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 2.5, reactive = 0.2)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.03)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, reactive = 0.3)

@wattmeter(label = &quot;Wattmeter ? (!)&quot;)
addWattmeter!(system, device; from = &quot;Branch 1&quot;, active = 1.046, noise = false)
addWattmeter!(system, device; bus = &quot;Bus 2&quot;, active = -0.1, noise = false)

@varmeter(label = &quot;Varmeter ? (!)&quot;)
addVarmeter!(system, device; from = &quot;Branch 1&quot;, reactive = 0.059, noise = false)
addVarmeter!(system, device; bus = &quot;Bus 2&quot;, reactive = -0.01, noise = false)

@ammeter(label = &quot;Ammeter ? (!)&quot;)
addAmmeter!(system, device; from = &quot;Branch 3&quot;, magnitude = 0.947, noise = false)
addAmmeter!(system, device; to = &quot;Branch 2&quot;, magnitude = 1.674, noise = false)

@voltmeter(label = &quot;Voltmeter ? (!)&quot;)
addVoltmeter!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0, noise = false)</code></pre><p>Next, to establish the AC state estimation model, we will utilize the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> function:</p><pre><code class="language-julia hljs">analysis = gaussNewton(system, device)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Here, the user triggers LU factorization as the default method for solving the system of linear equations within each iteration of the Gauss-Newton method. However, the user also has the option to select alternative factorization methods such as <code>LDLt</code> or <code>QR</code>:</p><pre><code class="language-julia hljs">analysis = gaussNewton(system, device, QR)</code></pre></div></div><hr/><h5 id="Setup-Starting-Voltages"><a class="docs-heading-anchor" href="#Setup-Starting-Voltages">Setup Starting Voltages</a><a id="Setup-Starting-Voltages-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Starting-Voltages" title="Permalink"></a></h5><p>The initial voltages for the Gauss-Newton method are determined based on the specified initial voltage magnitudes and angles within the buses of the <code>PowerSystem</code> type. These values are then forwarded to the <code>ACStateEstimation</code> during the execution of the [<code>gaussNewton</code>] function. Therefore, the starting voltages in this example are as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, 0.0
Bus 2: 1.0, 0.0
Bus 3: 1.0, 0.0</code></pre><p>Users have the flexibility to modify these vectors according to their own requirements in order to adjust the starting voltages. For instance, users can conduct an initial AC power flow analysis and utilize the obtained solution as the starting voltages for AC state estimation:</p><pre><code class="language-julia hljs">powerFlow = newtonRaphson(system)
for iteration = 1:10
    mismatch!(system, powerFlow)
    solve!(system, powerFlow)
end

for i = 1:system.bus.number
    analysis.voltage.magnitude[i] = powerFlow.voltage.magnitude[i]
    analysis.voltage.angle[i] = powerFlow.voltage.angle[i]
end</code></pre><hr/><h5 id="State-Estimator"><a class="docs-heading-anchor" href="#State-Estimator">State Estimator</a><a id="State-Estimator-1"></a><a class="docs-heading-anchor-permalink" href="#State-Estimator" title="Permalink"></a></h5><p>To conduct an iterative process using the Gauss-Newton method, it is essential to include the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>solve!</code></a> function inside the iteration loop. For example:</p><pre><code class="language-julia hljs">for iteration = 1:20
    solve!(system, analysis)
end</code></pre><p>Once the state estimator is obtained, users can access the bus voltage magnitudes and angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.9999246871835211, 0.0
Bus 2: 0.9763706385517099, -0.05197605935770629
Bus 3: 0.9562335533901274, -0.08055289647415956</code></pre><hr/><h5 id="Breaking-the-Iterative-Process"><a class="docs-heading-anchor" href="#Breaking-the-Iterative-Process">Breaking the Iterative Process</a><a id="Breaking-the-Iterative-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Breaking-the-Iterative-Process" title="Permalink"></a></h5><p>The iterative process can be terminated using the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>solve!</code></a> function. The following code demonstrates how to utilize this function to break out of the iteration loop:</p><pre><code class="language-julia hljs">analysis = gaussNewton(system, device)
for iteration = 1:20
    stopping = solve!(system, analysis)
    if stopping &lt; 1e-8
        break
    end
end</code></pre><p>The <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>solve!</code></a> function returns the maximum absolute values of the state variable increment, which are commonly used as a convergence criterion in the iterative Gauss-Newton algorithm.</p><hr/><h5 id="Inclusion-of-PMUs-in-Polar-Coordinates"><a class="docs-heading-anchor" href="#Inclusion-of-PMUs-in-Polar-Coordinates">Inclusion of PMUs in Polar Coordinates</a><a id="Inclusion-of-PMUs-in-Polar-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Inclusion-of-PMUs-in-Polar-Coordinates" title="Permalink"></a></h5><p>In the example above, we focus on solving the AC state estimation solely with SCADA measurements. However, users can also incorporate PMUs into the AC state estimation, and several methods exist for achieving this.</p><p>The most straightforward approach is to include these measurements in the polar coordinate system. For instance:</p><pre><code class="language-julia hljs">@pmu(label = &quot;PMU ? (!)&quot;)
addPmu!(system, device; from = &quot;Branch 1&quot;, magnitude = 1.048, angle = -0.057)</code></pre><p>This inclusion of PMUs provides more accurate state estimates compared to rectangular inclusion but demands longer computing time. PMUs are handled in the same manner as SCADA measurements. However, this approach is susceptible to ill-conditioned problems arising in polar coordinates due to small values of current magnitudes <a href="#ACStateEstimationReferenceManual">[2, 3]</a>.</p><hr/><h5 id="Inclusion-of-PMUs-in-Rectangular-Coordinates"><a class="docs-heading-anchor" href="#Inclusion-of-PMUs-in-Rectangular-Coordinates">Inclusion of PMUs in Rectangular Coordinates</a><a id="Inclusion-of-PMUs-in-Rectangular-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Inclusion-of-PMUs-in-Rectangular-Coordinates" title="Permalink"></a></h5><p>The second approach to include PMUs is in the rectangular coordinate system, by setting <code>polar = false</code>:</p><pre><code class="language-julia hljs">addPmu!(system, device; to = &quot;Branch 1&quot;, magnitude = 1.05, angle = 3.04, polar = false)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is important to note that with each individual phasor measurement, we can set the coordinate system, providing flexibility to include some in polar and some in rectangular systems.</p></div></div><p>In the case of the rectangular system, inclusion resolves ill-conditioned problems arising in polar coordinates due to small values of current magnitudes. However, this approach&#39;s main disadvantage is related to measurement errors, as measurement errors correspond to polar coordinates. Therefore, the covariance matrix must be transformed from polar to rectangular coordinates <a href="#ACStateEstimationReferenceManual">[4]</a>. As a result, measurement errors of a single PMU are correlated, and the covariance matrix does not have a diagonal form. Despite that, the measurement error covariance matrix is usually considered as a diagonal matrix, affecting the accuracy of the SE.</p><p>In the example above, we specifically include PMUs where measurement error correlations are disregarded. This is evident through the precision matrix, which maintains a diagonal form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis = gaussNewton(system, device);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">11×11 SparseArrays.SparseMatrixCSC{Float64, Int64} with 11 stored entries:
 100.0     ⋅      ⋅      ⋅      ⋅      ⋅   …        ⋅        ⋅        ⋅
    ⋅   100.0     ⋅      ⋅      ⋅      ⋅            ⋅        ⋅        ⋅
    ⋅      ⋅   100.0     ⋅      ⋅      ⋅            ⋅        ⋅        ⋅
    ⋅      ⋅      ⋅   100.0     ⋅      ⋅            ⋅        ⋅        ⋅
    ⋅      ⋅      ⋅      ⋅   100.0     ⋅            ⋅        ⋅        ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅   100.0  …        ⋅        ⋅        ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅      ⋅            ⋅        ⋅        ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅      ⋅            ⋅        ⋅        ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      100000.0       ⋅        ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅      ⋅            ⋅   99898.9       ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅      ⋅   …        ⋅        ⋅   91329.1</code></pre><p>Lastly, we incorporate correlation into our model by adding new PMUs with the desired error correlation:</p><pre><code class="language-julia hljs">addPmu!(system, device; bus = &quot;Bus 3&quot;, magnitude = 1, angle = 0, polar = false, correlated = true)</code></pre><p>Now, we can observe the precision matrix that does not hold a diagonal form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis = gaussNewton(system, device);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">13×13 SparseArrays.SparseMatrixCSC{Float64, Int64} with 15 stored entries:
 100.0     ⋅      ⋅      ⋅      ⋅   …       ⋅         ⋅         ⋅
    ⋅   100.0     ⋅      ⋅      ⋅           ⋅         ⋅         ⋅
    ⋅      ⋅   100.0     ⋅      ⋅           ⋅         ⋅         ⋅
    ⋅      ⋅      ⋅   100.0     ⋅           ⋅         ⋅         ⋅
    ⋅      ⋅      ⋅      ⋅   100.0          ⋅         ⋅         ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅   …       ⋅         ⋅         ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅           ⋅         ⋅         ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅           ⋅         ⋅         ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅           ⋅         ⋅         ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅           ⋅         ⋅         ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅   …  91329.1        ⋅         ⋅
    ⋅      ⋅      ⋅      ⋅      ⋅           ⋅   100000.0      -0.47092
    ⋅      ⋅      ⋅      ⋅      ⋅           ⋅       -0.47092   1.0026e5</code></pre><hr/><h5 id="Alternative-Formulation"><a class="docs-heading-anchor" href="#Alternative-Formulation">Alternative Formulation</a><a id="Alternative-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Formulation" title="Permalink"></a></h5><p>The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from finding a satisfactory solution. In such cases, users may opt for an alternative formulation of the WLS state estimation, namely, employing an approach called orthogonal factorization <a href="#ACStateEstimationReferenceManual">[5, Sec. 3.2]</a>.</p><p>This approach is suitable when measurement errors are uncorrelated, and the precision matrix remains diagonal. Therefore, as a preliminary step, we need to eliminate the correlation, as we did previously:</p><pre><code class="language-julia hljs">updatePmu!(system, device; label = &quot;PMU 3 (Bus 3)&quot;, correlated = false)</code></pre><p>Subsequently, by specifying the <code>Orthogonal</code> argument in the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> function, JuliaGrid implements a more robust approach to obtain the WLS estimator, which proves particularly beneficial when substantial differences exist among measurement variances:</p><pre><code class="language-julia hljs">analysis = gaussNewton(system, device, Orthogonal)
for iteration = 1:20
    stopping = solve!(system, analysis)
    if stopping &lt; 1e-8
        break
    end
end</code></pre><hr/><h2 id="ACBadDataDetectionManual"><a class="docs-heading-anchor" href="#ACBadDataDetectionManual">Bad Data Processing</a><a id="ACBadDataDetectionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACBadDataDetectionManual" title="Permalink"></a></h2><p>After acquiring the WLS solution using the Gauss-Newton method, users can conduct bad data analysis employing the largest normalized residual test. Continuing with our defined power system and measurement set, let us introduce a new measurement. Upon proceeding to find the solution for this updated state:</p><pre><code class="language-julia hljs">addWattmeter!(system, device; from = &quot;Branch 2&quot;, active = 31.1)

analysis = gaussNewton(system, device)
for iteration = 1:20
    stopping = solve!(system, analysis)
    if stopping &lt; 1e-8
        break
    end
end</code></pre><p>Here, we can observe the impact of the outlier on the solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.271063714766143, 0.0
Bus 2: 1.2464217129448352, -0.04104507811817254
Bus 3: 1.108924605905296, -0.19701477186955013</code></pre><p>Following the solution acquisition, we can verify the presence of erroneous data. Detection of such data is determined by the <code>threshold</code> keyword. If the largest normalized residual&#39;s value exceeds the threshold, the measurement will be identified as bad data and consequently removed from the PMU state estimation model:</p><pre><code class="language-julia hljs">residualTest!(system, device, analysis; threshold = 4.0)</code></pre><p>Users can examine the data obtained from the bad data analysis:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.outlier.detect</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.outlier.maxNormalizedResidual</code><code class="nohighlight hljs ansi" style="display:block;">275.3160335118659</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.outlier.label</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Wattmeter 3 (From Branch 2)&quot;</code></pre><p>Hence, upon detecting bad data, the <code>detect</code> variable will hold <code>true</code>. The <code>maxNormalizedResidual</code> variable retains the value of the largest normalized residual, while the <code>label</code> contains the label of the measurement identified as bad data. JuliaGrid will mark the respective measurement as out-of-service within the <code>Measurement</code> type.</p><p>After removing bad data, a new estimate can be computed without considering this specific measurement. The user has the option to either restart the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> function or proceed directly to the iteration loop. However, if the latter option is chosen, using voltages obtained with outlier presence as the starting point could significantly impede algorithm convergence. To avoid this undesirable outcome, the user should first establish a new starting point and commence the iteration procedure. For instance:</p><pre><code class="language-julia hljs">for i = 1:system.bus.number
    analysis.voltage.magnitude[i] = system.bus.voltage.magnitude[i]
    analysis.voltage.angle[i] = system.bus.voltage.angle[i]
end

for iteration = 1:20
    stopping = solve!(system, analysis)
    if stopping &lt; 1e-8
        break
    end
end</code></pre><p>Consequently, we obtain a new solution devoid of the impact of the outlier measurement: Here, we can observe solutin impact with bad measurments:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.05254950488454, 0.0
Bus 2: 1.0286453678190524, -0.04910870704054685
Bus 3: 0.997910487239584, -0.03557756871582651</code></pre><hr/><h2 id="PMULAVtateEstimationSolutionManual"><a class="docs-heading-anchor" href="#PMULAVtateEstimationSolutionManual">Least Absolute Value Estimator</a><a id="PMULAVtateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMULAVtateEstimationSolutionManual" title="Permalink"></a></h2><p>The LAV method presents an alternative estimation technique known for its increased robustness compared to WLS. While the WLS method relies on specific assumptions regarding measurement errors, robust estimators like LAV are designed to maintain unbiasedness even in the presence of various types of measurement errors and outliers. This characteristic often eliminates the need for extensive bad data processing procedures <a href="#ACStateEstimationReferenceManual">[5, Ch. 6]</a>. However, it is important to note that achieving robustness typically involves increased computational complexity.</p><p>To obtain an LAV estimator, users need to employ one of the <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> listed in the JuMP documentation. In many common scenarios, the Ipopt solver proves sufficient to obtain a solution:</p><pre><code class="language-julia hljs">using Ipopt

analysis = acLavStateEstimation(system, device, Ipopt.Optimizer)</code></pre><hr/><h5 id="Setup-Starting-Primal-Values"><a class="docs-heading-anchor" href="#Setup-Starting-Primal-Values">Setup Starting Primal Values</a><a id="Setup-Starting-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Starting-Primal-Values" title="Permalink"></a></h5><p>In JuliaGrid, the assignment of starting primal values for optimization variables takes place when the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>solve!</code></a> function is executed. Starting primal values are determined based on the <code>voltage</code> fields within the <code>ACStateEstimation</code> type. By default, these values are initially established using the the initial bus voltage magnitudes and angles from <code>PowerSystem</code> type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, 0.0
Bus 2: 1.0, 0.0
Bus 3: 1.0, 0.0</code></pre><p>Users have the flexibility to customize these values according to their requirements, and they will be utilized as the starting primal values when executing the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>solve!</code></a> function.</p><hr/><h5 id="Solution"><a class="docs-heading-anchor" href="#Solution">Solution</a><a id="Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solution" title="Permalink"></a></h5><p>To solve the formulated LAV state estimation model, simply execute the following function:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Upon obtaining the solution, access the bus voltage magnitudes and angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0000000001928129, 0.0
Bus 2: 0.9763806814542022, -0.05194273657775739
Bus 3: 0.9562026489938944, -0.08049120131340715</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><hr/><h2 id="ACMeasurementsAlterationManual"><a class="docs-heading-anchor" href="#ACMeasurementsAlterationManual">Measurement Set Update</a><a id="ACMeasurementsAlterationManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACMeasurementsAlterationManual" title="Permalink"></a></h2><p>After establishing the <code>Measurement</code> composite type using the <a href="../../api/measurementModel/#JuliaGrid.measurement"><code>measurement</code></a> function, users gain the capability to incorporate new measurement devices or update existing ones.</p><p>Once updates are completed, users can seamlessly progress towards generating the <code>ACStateEstimation</code> type using the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> or <a href="../../api/stateEstimation/#JuliaGrid.acLavStateEstimation"><code>acLavStateEstimation</code></a> function. Ultimately, resolving the AC state estimation is achieved through the utilization of the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, ACStateEstimation{NonlinearWLS{Normal}}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1, reactive = 0.01)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 2.5, reactive = 0.2)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.03)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, reactive = 0.3)

@wattmeter(label = &quot;Wattmeter ? (!)&quot;)
addWattmeter!(system, device; from = &quot;Branch 1&quot;, active = 1.046, noise = false)
addWattmeter!(system, device; bus = &quot;Bus 2&quot;, active = -0.1, noise = false)

@varmeter(label = &quot;Varmeter ? (!)&quot;)
addVarmeter!(system, device; from = &quot;Branch 1&quot;, reactive = 0.059, noise = false)
addVarmeter!(system, device; bus = &quot;Bus 2&quot;, reactive = -0.01, noise = false)

@voltmeter(label = &quot;Voltmeter ? (!)&quot;)
addVoltmeter!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0, noise = false)

analysis = gaussNewton(system, device)
for iteration = 1:20
    stopping = solve!(system, analysis)
    if stopping &lt; 1e-8
        break
    end
end

addWattmeter!(system, device; from = &quot;Branch 3&quot;, active = 0.924)
updateWattmeter!(system, device; label = &quot;Wattmeter 2 (Bus 2)&quot;, variance = 1e-3)

addVarmeter!(system, device; to = &quot;Branch 3&quot;, reactive = -0.044, variance = 1e-5)
updateVarmeter!(system, device; label = &quot;Varmeter 2 (Bus 2)&quot;, reactive = -0.011)

analysis = gaussNewton(system, device)
for iteration = 1:20
    stopping = solve!(system, analysis)
    if stopping &lt; 1e-8
        break
    end
end</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This method removes the need to restart and recreate the <code>Measurement</code> type from the beginning when implementing changes to the existing measurement set.</p></div></div><hr/><h2 id="ACStateEstimationReferenceManual"><a class="docs-heading-anchor" href="#ACStateEstimationReferenceManual">References</a><a id="ACStateEstimationReferenceManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACStateEstimationReferenceManual" title="Permalink"></a></h2><p>[1] G. Korres, <em>Observability analysis based on echelon form of a reduced dimensional Jacobian matrix</em>, IEEE Trans. Power Syst., vol. 26, no. 4, pp. 2572–2573, 2011.</p><p>[2] G. N. Korres and N. M. Manousakis, <em>State estimation and observability analysis for phasor measurement unit measured systems</em>, IET Gener. Transm. Dis., vol. 6, no. 9, 2012.</p><p>[3] A. Gomez-Exposito, A. Abur, P. Rousseaux, A. de la Villa Jaen, and C. Gomez-Quiles, <em>On the use of PMUs in power system state estimation</em>, Proc. IEEE PSCC, 2011.</p><p>[4] M. Zhou, V. A. Centeno, J. S. Thorp, and A. G. Phadke, <em>An alternative for including phasor measurements in state estimators</em>, IEEE Trans. Power Syst., vol. 21, no. 4, 2006.</p><p>[5] A. Abur and A. Exposito, <em>Power System State Estimation: Theory and Implementation</em>, Taylor &amp; Francis, 2004.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../measurementModel/">« Measurement Model</a><a class="docs-footer-nextpage" href="../pmuStateEstimation/">PMU State Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 9 April 2024 09:08">Tuesday 9 April 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
