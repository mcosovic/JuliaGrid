<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power Flow Analysis · JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li class="is-active"><a class="tocitem" href>Power Flow Analysis</a><ul class="internal"><li><a class="tocitem" href="#BusTypeModificationManual"><span>Bus Type Modification</span></a></li><li><a class="tocitem" href="#SetupStartingVoltagesManual"><span>Setup Starting Voltages</span></a></li><li><a class="tocitem" href="#ACPowerFlowSolutionManual"><span>AC Power Flow Solution</span></a></li><li><a class="tocitem" href="#DCPowerFlowSolutionManual"><span>DC Power Flow Solution</span></a></li><li><a class="tocitem" href="#ReusablePowerSystemModel"><span>Reusable Power System Model</span></a></li><li><a class="tocitem" href="#PostProcessingAnalysisModel"><span>Post-Processing Analysis</span></a></li><li><a class="tocitem" href="#GeneratorReactivePowerLimitsManual"><span>Generator Reactive Power Limits</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/modelACDC/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/powerFlowSolution/">Power Flow Solution</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlowSolution/">Power Flow Solution</a></li><li><a class="tocitem" href="../../api/postprocessing/">Post-processing Analysis</a></li><li><a class="tocitem" href="../../api/unit/">Unit System</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Power Flow Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power Flow Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/powerFlowAnalysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerFlowAnalysisManual"><a class="docs-heading-anchor" href="#PowerFlowAnalysisManual">Power Flow Analysis</a><a id="PowerFlowAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#PowerFlowAnalysisManual" title="Permalink"></a></h1><p>The calculation of bus voltages is essential to solving the power flow problem. The composite type <code>PowerSystem</code>, which includes <code>bus</code>, <code>branch</code>, and <code>generator</code> fields, is required to obtain a solution. Additionally, depending on the type of power flow used, either <code>acModel</code> or <code>dcModel</code> must be used.</p><p>After creating the composite type <code>PowerSystem</code>, the next step is to create the composite type <code>Result</code>, which has fields <code>bus</code>, <code>branch</code>, <code>generator</code>, and <code>algorithm</code>. To initialize the iterative method for the AC power flow, the <code>Result</code> composite type must be created using any of the following functions:</p><ul><li><a href="../../tutorials/powerFlowSolution/#newtonRaphson"><code>newtonRaphson</code></a></li><li><a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a></li><li><a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a></li><li><a href="../../tutorials/powerFlowSolution/#gaussSeidel"><code>gaussSeidel</code></a>.</li></ul><p>To solve the AC power flow problem and obtain bus voltages, the following functions can be employed:</p><ul><li><a href="../../api/powerFlowSolution/#JuliaGrid.mismatch!"><code>mismatch!</code></a></li><li><a href="../../api/powerFlowSolution/#JuliaGrid.solvePowerFlow!"><code>solvePowerFlow!</code></a>.</li></ul><p>On the other hand, for the DC power flow, the <code>Result</code> composite type is created when determining the bus voltage angles through the use of the function:</p><ul><li><a href="../../api/powerFlowSolution/#JuliaGrid.solvePowerFlow"><code>solvePowerFlow</code></a>.</li></ul><p>JuliaGrid offers a set of post-processing analysis functions for calculating powers, losses, and currents associated with buses, branches, or generators after obtaining AC or DC power flow solutions:</p><ul><li><a href="../../api/postprocessing/#JuliaGrid.bus!"><code>bus!</code></a></li><li><a href="../../api/postprocessing/#JuliaGrid.branch!"><code>branch!</code></a></li><li><a href="../../api/postprocessing/#JuliaGrid.generator!"><code>generator!</code></a>.</li></ul><p>Finally, the package provides two additional functions. One function validates the reactive power limits of generators once the AC power flow solution has been computed. The other function adjusts the voltage angles to match the angle of an arbitrary slack bus:</p><ul><li><a href="../../api/powerFlowSolution/#JuliaGrid.reactivePowerLimit!"><code>reactivePowerLimit!</code></a></li><li><a href="../../api/powerFlowSolution/#JuliaGrid.adjustVoltageAngle!"><code>adjustVoltageAngle!</code></a>.</li></ul><hr/><h2 id="BusTypeModificationManual"><a class="docs-heading-anchor" href="#BusTypeModificationManual">Bus Type Modification</a><a id="BusTypeModificationManual-1"></a><a class="docs-heading-anchor-permalink" href="#BusTypeModificationManual" title="Permalink"></a></h2><p>Depending on how the system is constructed, the types of buses that are initially set are checked and can be changed during the initialization process, using one of the available functions such as <a href="../../tutorials/powerFlowSolution/#newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../tutorials/powerFlowSolution/#gaussSeidel"><code>gaussSeidel</code></a>. Assuming the Newton-Raphson method has been chosen, to explain the details, we can observe a power system with only buses and generators. The following code snippet can be used:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3)
addBus!(system; label = 2, type = 2)
addBus!(system; label = 3, type = 2)

addGenerator!(system; label = 1, bus = 2)

acModel!(system)

result = newtonRaphson(system)

nothing # hide</code></pre><p>Initially, the bus labelled with 1 is set as the slack bus (<code>type = 3</code>), and the buses with labels 2 and 3 are generator buses (<code>type = 2</code>). However, the bus labelled with 3 does not have a generator, and JuliaGrid considers this a mistake and changes the corresponding bus to a demand bus (<code>type = 1</code>):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.layout.type</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 3
 2
 2</code></pre><p>In contrast, if a bus is initially defined as a demand bus (<code>type = 1</code>) and later a generator is added to it, the bus type will not be changed to a generator bus (<code>type = 2</code>). Instead, it will remain as a demand bus:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3)
addBus!(system; label = 2, type = 1)
addBus!(system; label = 3, type = 2)

addGenerator!(system; label = 1, bus = 2)

acModel!(system)

result = newtonRaphson(system)

nothing # hide</code></pre><p>In this example, the bus labelled with 2 remains a demand bus (<code>type = 1</code>) even though it has a generator:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.layout.type</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 3
 1
 2</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Only buses that are defined as generator buses (<code>type = 2</code>) but do not have a in-service generator connected to them will have their type changed to a demand bus (<code>type = 1</code>).</p></div></div><hr/><h2 id="SetupStartingVoltagesManual"><a class="docs-heading-anchor" href="#SetupStartingVoltagesManual">Setup Starting Voltages</a><a id="SetupStartingVoltagesManual-1"></a><a class="docs-heading-anchor-permalink" href="#SetupStartingVoltagesManual" title="Permalink"></a></h2><p>To begin analysing the AC power flow in JuliaGrid, we must first establish the <code>PowerSystem</code> composite type and define the AC model by calling the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> function. Once the power system is set up, we can select one of the available methods for solving the AC power flow problem, such as <a href="../../tutorials/powerFlowSolution/#newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../tutorials/powerFlowSolution/#gaussSeidel"><code>gaussSeidel</code></a>. Assuming we have selected the Newton-Raphson method, we can use the following code snippet:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, magnitude = 1.0, angle = 0.0)
addBus!(system; label = 2, type = 1, magnitude = 0.9, angle = -0.1)
addBus!(system; label = 3, type = 2, magnitude = 0.8, angle = -0.2)

addGenerator!(system; label = 1, bus = 2, magnitude = 1.1)
addGenerator!(system; label = 2, bus = 3, magnitude = 1.2)

acModel!(system)

result = newtonRaphson(system)

nothing # hide</code></pre><p>Here, in this code snippet, the function <a href="../../tutorials/powerFlowSolution/#newtonRaphson"><code>newtonRaphson</code></a> generates starting voltage vectors in polar coordinates, where the magnitudes and angles are constructed as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: result not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: result not defined</code></pre><p>The starting values for the voltage angles are defined based on the initial values given within the buses:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.1
 -0.2</code></pre><p>On the other hand, the starting voltage magnitudes are determined by a combination of the initial values specified within the buses and the setpoints provided within the generators:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 0.9
 0.8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">Float64[]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The rule governing the specification of starting voltage magnitudes is simple. If a bus has an in-service generator and is declared the generator bus (<code>type = 2</code>), then the starting voltage magnitudes are specified using the setpoint provided within the generator. This is because the generator bus has known values of voltage magnitude that are specified within the generator.</p></div></div><p>Finally, let us add the generator at the slack bus using the following code snippet:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, magnitude = 1.0, angle = 0.0)
addBus!(system; label = 2, type = 1, magnitude = 0.9, angle = -0.1)
addBus!(system; label = 3, type = 2, magnitude = 0.8, angle = -0.2)

addGenerator!(system; label = 1, bus = 2, magnitude = 1.1)
addGenerator!(system; label = 2, bus = 3, magnitude = 1.2)
addGenerator!(system; label = 3, bus = 1, magnitude = 1.3)

acModel!(system)

result = newtonRaphson(system)

nothing # hide</code></pre><p>The starting voltages are now as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: result not defined</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Thus, if an in-service generator exists on the slack bus, the starting value of the voltage magnitude is specified using the setpoints provided within the generators. This is a consequence of the fact that the slack bus has a known voltage magnitude. If a generator exists on the slack bus, its value is used, otherwise, the value is defined based on the initial voltage magnitude specified within the bus.</p></div></div><hr/><h5 id="Custom-Starting-Voltages"><a class="docs-heading-anchor" href="#Custom-Starting-Voltages">Custom Starting Voltages</a><a id="Custom-Starting-Voltages-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Starting-Voltages" title="Permalink"></a></h5><p>This method of specifying starting values has a significant advantage in that it allows the user to easily change the starting voltage magnitudes and angles, which play a crucial role in iterative methods. For instance, suppose we define our power system as follows:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, magnitude = 1.0, angle = 0.0)
addBus!(system; label = 2, type = 1, magnitude = 0.9, angle = -0.1)
addBus!(system; label = 3, type = 2, magnitude = 0.8, angle = -0.2)

addGenerator!(system; label = 2, bus = 3, magnitude = 1.2)

acModel!(system)

nothing # hide</code></pre><p>Now, the user can initiate a &quot;flat start&quot; without interfering with the input data. This can be easily done as follows:</p><pre><code class="language-julia hljs">for i = 1:system.bus.number
    system.bus.voltage.magnitude[i] = 1.0
    system.bus.voltage.angle[i] = 0.0
end

result = newtonRaphson(system)</code></pre><p>The starting voltage values are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 1.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>Thus, we start with a set of voltage magnitude values that are constant throughout iteration, and the rest of the values correspond to the &quot;flat start&quot;.</p><hr/><h2 id="ACPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#ACPowerFlowSolutionManual">AC Power Flow Solution</a><a id="ACPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerFlowSolutionManual" title="Permalink"></a></h2><p>To solve the AC power flow problem using JuliaGrid, we first need to create the <code>PowerSystem</code> composite type and define the AC model by calling the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> function. Here is an example:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)
addBus!(system; label = 2, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)
addBus!(system; label = 3, type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)

addBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)
addBranch!(system; label = 2, from = 1, to = 3, resistance = 0.02, reactance = 0.01)

addGenerator!(system; label = 1, bus = 2, active = 3.2, magnitude = 1.2)

acModel!(system)

nothing # hide</code></pre><p>Once the AC model is defined, we can choose the method to solve the power flow problem. JuliaGrid provides four methods: <a href="../../tutorials/powerFlowSolution/#newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, and <a href="../../tutorials/powerFlowSolution/#gaussSeidel"><code>gaussSeidel</code></a>. For example, to use the Newton-Raphson method to solve the power flow problem, we can call the newtonRaphson <a href="../../tutorials/powerFlowSolution/#newtonRaphson"><code>newtonRaphson</code></a> as follows:</p><pre><code class="language-julia hljs">result = newtonRaphson(system)</code></pre><p>This function sets up the desired method for an iterative process based on two functions: <a href="manual/@ref mismatch!">mismatch!</a> and <a href="manual/@ref solvePowerFlow!">solvePowerFlow!</a>. The <a href="manual/@ref mismatch!">mismatch!</a> function calculates the active and reactive power injection mismatches using the given voltage magnitudes and angles, while <a href="manual/@ref solvePowerFlow!">solvePowerFlow!</a> computes the new voltage magnitudes and angles.</p><p>To perform an iterative process with the Newton-Raphson or Fast Newton-Raphson methods in JuliaGrid, the <a href="../../api/powerFlowSolution/#JuliaGrid.mismatch!"><code>mismatch!</code></a> function must be included inside the iteration loop. For instance:</p><pre><code class="language- hljs">result = newtonRaphson(system)
for iteration = 1:100
    mismatch!(system, result)
    solvePowerFlow!(system, result)
end
nothing # hide</code></pre><p>After the process is completed, the solution to the AC power flow problem can be accessed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.9
 1.1
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.1
 -0.2</code></pre><p>In contrast, the iterative loop of the Gauss-Seidel method does not require the <a href="../../api/powerFlowSolution/#JuliaGrid.mismatch!"><code>mismatch!</code></a> function:</p><pre><code class="language- hljs">result = gaussSeidel(system)
for iteration = 1:100
    solvePowerFlow!(system, result)
end
nothing # hide</code></pre><p>In these examples, the algorithms run until the specified number of iterations is reached.</p><hr/><h5 id="Breaking-the-Iterative-Process"><a class="docs-heading-anchor" href="#Breaking-the-Iterative-Process">Breaking the Iterative Process</a><a id="Breaking-the-Iterative-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Breaking-the-Iterative-Process" title="Permalink"></a></h5><p>You can terminate the iterative process using the <a href="../../api/powerFlowSolution/#JuliaGrid.mismatch!"><code>mismatch!</code></a> function, which is why mismatches are computed separately. The following code shows an example of how to use the <a href="../../api/powerFlowSolution/#JuliaGrid.mismatch!"><code>mismatch!</code></a> function to break out of the iteration loop:</p><pre><code class="language- hljs">result = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solvePowerFlow!(system, result)
end
nothing # hide</code></pre><p>The <a href="manual/@ref mismatch!">mismatch!</a> function returns the maximum values of active and reactive power injection mismatches, which are commonly used as a convergence criterion in iterative AC power flow algorithms. Note that the <a href="../../api/powerFlowSolution/#JuliaGrid.mismatch!"><code>mismatch!</code></a> function can also be used to terminate the loop when using the Gauss-Seidel method, even though it is not required.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To ensure an accurate count of iterations, it is important for the user to place the iteration counter after the condition expressions within the if construct. Counting the iterations before this point can result in an incorrect number of iterations, as it leads to an additional iteration being performed.</p></div></div><hr/><h2 id="DCPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#DCPowerFlowSolutionManual">DC Power Flow Solution</a><a id="DCPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCPowerFlowSolutionManual" title="Permalink"></a></h2><p>To solve the DC power flow problem using JuliaGrid, we start by creating the <code>PowerSystem</code> composite type and defining the DC model with the <a href="manual/@ref dcModel!">dcModel!</a> function. Here&#39;s an example:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)
addBus!(system; label = 2, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)
addBus!(system; label = 3, type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)

addBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)
addBranch!(system; label = 2, from = 1, to = 3, resistance = 0.02, reactance = 0.01)

addGenerator!(system; label = 1, bus = 2, active = 3.2, magnitude = 1.2)

dcModel!(system)

nothing # hide</code></pre><p>Next, we can solve the DC problem by calling the <a href="../../api/powerFlowSolution/#JuliaGrid.solvePowerFlow"><code>solvePowerFlow</code></a> function, which also returns the <code>Result</code> composite type:</p><pre><code class="language- hljs">result = solvePowerFlow(system)
nothing # hide</code></pre><p>The bus voltage angles obtained can be accessed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: result not defined</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><hr/><h2 id="ReusablePowerSystemModel"><a class="docs-heading-anchor" href="#ReusablePowerSystemModel">Reusable Power System Model</a><a id="ReusablePowerSystemModel-1"></a><a class="docs-heading-anchor-permalink" href="#ReusablePowerSystemModel" title="Permalink"></a></h2><p>After creating the power system, the AC and/or DC models can be generated for it, and they can then be reused for different types of power flow analysis, as demonstrated by creating the power system and its models once again:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.5, magnitude = 1.0)
addBus!(system; label = 2, type = 1, reactive = 0.05, magnitude = 1.0)
addBus!(system; label = 3, type = 1, active = 0.5, magnitude = 1.0)

addBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)
addBranch!(system; label = 2, from = 1, to = 3, resistance = 0.02, reactance = 0.01)
addBranch!(system; label = 3, from = 2, to = 3, resistance = 0.03, reactance = 0.04)

addGenerator!(system; label = 1, bus = 2, active = 3.2, magnitude = 1.0)

acModel!(system)
dcModel!(system)

nothing # hide</code></pre><p>Applying different methods sequentially can be beneficial. For example, the Gauss-Seidel method is often used to obtain a quick approximate solution, while the Newton-Raphson method is typically used to obtain the final accurate solution. Therefore, we can run the Gauss-Seidel method for just a few iterations, as shown below:</p><pre><code class="language- hljs">resultGS = gaussSeidel(system)
for iteration = 1:3
    solvePowerFlow!(system, resultGS)
end</code></pre><p>The resulting voltages are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; resultGS.bus.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 1.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; resultGS.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>Next, we can initialize the Newton-Raphson method with the voltages obtained from the Gauss-Seidel method and start the algorithm from that point:</p><pre><code class="language- hljs">result = newtonRaphson(system)
for i = 1:system.bus.number
    result.bus.voltage.magnitude[i] = resultGS.bus.voltage.magnitude[i]
    result.bus.voltage.angle[i] = resultGS.bus.voltage.angle[i]
end

for iteration = 1:100
    stopping = mismatch!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solvePowerFlow!(system, result)
end</code></pre><p>The final solutions are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 1.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>It can be noted that in the given example, the same <code>PowerSystem</code> composite type is repeatedly utilized. Additionally, the same type can also be employed in the context of DC power flow analysis:</p><pre><code class="language- hljs">resultDC = solvePowerFlow(system)
nothing # hide</code></pre><p>The bus voltage angles are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; resultDC.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: resultDC not defined</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The functions <a href="../../tutorials/powerFlowSolution/#newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlowSolution/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../tutorials/powerFlowSolution/#gaussSeidel"><code>gaussSeidel</code></a> only modify the <code>PowerSystem</code> type to eliminate mistakes in the bus types as explained in the section <a href="#BusTypeModificationManual">Bus Type Modification</a>. Further, the functions <a href="../../api/powerFlowSolution/#JuliaGrid.mismatch!"><code>mismatch!</code></a>, <a href="../../api/powerFlowSolution/#JuliaGrid.solvePowerFlow!"><code>solvePowerFlow!</code></a>, and <a href="../../api/powerFlowSolution/#JuliaGrid.solvePowerFlow"><code>solvePowerFlow</code></a> do not modify the <code>PowerSystem</code> type at all.</p></div></div><hr/><h2 id="PostProcessingAnalysisModel"><a class="docs-heading-anchor" href="#PostProcessingAnalysisModel">Post-Processing Analysis</a><a id="PostProcessingAnalysisModel-1"></a><a class="docs-heading-anchor-permalink" href="#PostProcessingAnalysisModel" title="Permalink"></a></h2><p>After obtaining the solution from the AC or DC power flow analysis, we can calculate various electrical quantities related to buses, branches, and generators using the <a href="../../api/postprocessing/#JuliaGrid.bus!"><code>bus!</code></a>, <a href="../../api/postprocessing/#JuliaGrid.branch!"><code>branch!</code></a>, and <a href="../../api/postprocessing/#JuliaGrid.generator!"><code>generator!</code></a> functions. Let us set up an AC power flow analysis:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.5, magnitude = 1.0)
addBus!(system; label = 2, type = 1, reactive = 0.05, magnitude = 1.0)
addBus!(system; label = 3, type = 1, active = 0.5, magnitude = 1.0)

addBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)
addBranch!(system; label = 2, from = 1, to = 2, resistance = 0.02, reactance = 0.01)
addBranch!(system; label = 3, from = 2, to = 3, resistance = 0.03, reactance = 0.04)

addGenerator!(system; label = 1, bus = 2, active = 3.2, magnitude = 1.0)

acModel!(system)

result = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solvePowerFlow!(system, result)
end

nothing # hide</code></pre><p>Once the power flow analysis is completed using the Newton-Raphson method, we can use the above-mentioned functions to compute the relevant data for buses, branches, and generators. Here is an example code snippet that demonstrates this process:</p><pre><code class="language- hljs">bus!(system, result)
branch!(system, result)
generator!(system, result)

nothing # hide</code></pre><p>Each of these functions is responsible for populating the corresponding fields of the <code>Result</code> type, such as <code>bus</code>, <code>branch</code>, or <code>generator</code>. For instance, we can compute the active and reactive power injections in megawatts (MW) and megavolt-ampere reactive (MVAr) using the code snippet below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @base(system, MVA, V);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.power.value * result.bus.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: result not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.power.value * result.bus.power.injection.reactive</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: result not defined</code></pre><hr/><h2 id="GeneratorReactivePowerLimitsManual"><a class="docs-heading-anchor" href="#GeneratorReactivePowerLimitsManual">Generator Reactive Power Limits</a><a id="GeneratorReactivePowerLimitsManual-1"></a><a class="docs-heading-anchor-permalink" href="#GeneratorReactivePowerLimitsManual" title="Permalink"></a></h2><p>After obtaining the solution from the AC power flow analysis, user can check whether the output of reactive power of the generators is within the defined limits using function <a href="../../api/powerFlowSolution/#JuliaGrid.reactivePowerLimit!"><code>reactivePowerLimit!</code></a>:</p><pre><code class="language- hljs">using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.5, magnitude = 1.0)
addBus!(system; label = 2, type = 1, reactive = 0.05, magnitude = 1.0)
addBus!(system; label = 3, type = 1, active = 0.5, magnitude = 1.0)

addBranch!(system; label = 1, from = 1, to = 2, resistance = 0.01, reactance = 0.05)
addBranch!(system; label = 2, from = 1, to = 2, resistance = 0.02, reactance = 0.01)
addBranch!(system; label = 3, from = 2, to = 3, resistance = 0.03, reactance = 0.04)

addGenerator!(system; label = 1, bus = 2, active = 3.2, magnitude = 1.0)

acModel!(system)

result = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solvePowerFlow!(system, result)
end

violate = reactivePowerLimit!(system, result)

nothing # hide</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powerSystemModel/">« Power System Model</a><a class="docs-footer-nextpage" href="../../tutorials/modelACDC/">AC and DC Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 26 April 2023 20:51">Wednesday 26 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
