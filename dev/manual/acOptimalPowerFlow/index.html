<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC Optimal Power Flow · JuliaGrid</title><meta name="title" content="AC Optimal Power Flow · JuliaGrid"/><meta property="og:title" content="AC Optimal Power Flow · JuliaGrid"/><meta property="twitter:title" content="AC Optimal Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li class="is-active"><a class="tocitem" href>AC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#ACOptimalPowerFlowModelManual"><span>Optimal Power Flow Model</span></a></li><li><a class="tocitem" href="#ACOptimizationVariablesManual"><span>Optimization Variables</span></a></li><li><a class="tocitem" href="#DCConstraintFunctionsManual"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#ACObjectiveFunctionManual"><span>Objective Function</span></a></li><li><a class="tocitem" href="#ACSetupPrimalStartingValuesManual"><span>Setup Primal Starting Values</span></a></li><li><a class="tocitem" href="#ACOptimalPowerFlowSolutionManual"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#ACOptimalPowerCurrentAnalysisManual"><span>Power and Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>AC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/acOptimalPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACOptimalPowerFlowManual"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowManual">AC Optimal Power Flow</a><a id="ACOptimalPowerFlowManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowManual" title="Permalink"></a></h1><p>JuliaGrid utilizes the <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> package to construct optimal power flow models, allowing users to manipulate these models using the standard functions provided by JuMP. As a result, JuliaGrid supports popular <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> mentioned in the JuMP documentation to solve the optimization problem.</p><p>To perform the AC optimal power flow, you first need to have the <code>PowerSystem</code> composite type that has been created with the <code>ac</code> model. After that, create the <code>ACOptimalPowerFlow</code> composite type to establish the AC optimal power flow framework using the function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a>.</li></ul><p>To solve the AC optimal power flow problem and acquire bus voltage magnitudes and angles, and generator active and reactive power outputs, make use of the following function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a>.</li></ul><p>After obtaining the AC optimal power flow solution, JuliaGrid offers post-processing analysis functions for calculating powers and currents associated with buses and branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a>.</li></ul><p>Furthermore, there are specialized functions dedicated to calculating specific types of powers related to particular buses, branches, or generators:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, AC}"><code>injectionPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, ACPowerFlow}"><code>supplyPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.shuntPower-Tuple{PowerSystem, AC}"><code>shuntPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, AC}"><code>fromPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, AC}"><code>toPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.seriesPower-Tuple{PowerSystem, AC}"><code>seriesPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.chargingPower-Tuple{PowerSystem, AC}"><code>chargingPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.generatorPower-Tuple{PowerSystem, ACPowerFlow}"><code>generatorPower</code></a>.</li></ul><p>Likewise, there are specialized functions dedicated to calculating specific types of currents related to particular buses or branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionCurrent-Tuple{PowerSystem, AC}"><code>injectionCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromCurrent-Tuple{PowerSystem, AC}"><code>fromCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toCurrent-Tuple{PowerSystem, AC}"><code>toCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.seriesCurrent-Tuple{PowerSystem, AC}"><code>seriesCurrent</code></a>.</li></ul><hr/><h2 id="ACOptimalPowerFlowModelManual"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowModelManual">Optimal Power Flow Model</a><a id="ACOptimalPowerFlowModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowModelManual" title="Permalink"></a></h2><p>To set up the AC optimal power flow, we begin by creating the model. To illustrate this, consider the following example:</p><pre><code class="language-julia hljs">using JuMP, Ipopt

system = powerSystem()

@bus(minMagnitude = 0.95, maxMagnitude = 1.05)
addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.1, angle = -0.1)
addBus!(system; label = &quot;Bus 2&quot;, reactive = 0.01, magnitude = 1.1)

@branch(minDiffAngle = -pi, maxDiffAngle = pi, reactance = 0.5, type = 2)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, longTerm = 0.15)

@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1, status = 0)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.4, reactive = 0.2)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.2, reactive = 0.1)

cost!(system; label = &quot;Generator 1&quot;, active = 2, polynomial = [800.0; 200.0; 80.0])
cost!(system; label = &quot;Generator 2&quot;, active = 1, piecewise = [10.8 12.3; 14.7 16.8; 18 18.1])

cost!(system; label = &quot;Generator 1&quot;, reactive = 2, polynomial = [2.0])
cost!(system; label = &quot;Generator 2&quot;, reactive = 1, piecewise = [2.0 4.0; 6.0 8.0])

acModel!(system)</code></pre><p>Next, the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function is utilized to formulate the AC optimal power flow problem:</p><pre><code class="language-julia hljs">analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)</code></pre><hr/><h2 id="ACOptimizationVariablesManual"><a class="docs-heading-anchor" href="#ACOptimizationVariablesManual">Optimization Variables</a><a id="ACOptimizationVariablesManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimizationVariablesManual" title="Permalink"></a></h2><p>In the AC optimal power flow model, the active and reactive power outputs of the generators are expressed as nonlinear functions of the bus voltage magnitudes and angles. As a result, the variables in this model include the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.all_variables(analysis.jump)</code><code class="nohighlight hljs ansi" style="display:block;">8-element Vector{VariableRef}:
 active[1]
 active[2]
 reactive[1]
 reactive[2]
 magnitude[1]
 magnitude[2]
 angle[1]
 angle[2]</code></pre><p>It is important to note that this is not a comprehensive set of optimization variables. When the cost function is defined as a linear piecewise function comprising multiple segments, as illustrated in the case of the active power output cost for <code>Generator 2</code>, JuliaGrid automatically generates helper optimization variables named <code>actwise</code> and <code>reactwise</code>, and formulates a set of linear constraints to effectively address these cost functions. It is worth emphasizing that in instances where a linear piecewise cost function consists of only a single segment, as demonstrated by the reactive power output cost of <code>Generator 2</code>, the function is modelled as a standard linear function, obviating the need for additional helper optimization variables.</p><p>For the sake of simplicity, we initially assume that both generators are out-of-service. Consequently, the helper variable is not included in the set of optimization variables. However, as we progress through this manual, we will activate the generators, introducing helper variables and additional constraints to the optimization model.</p><p>Please be aware that JuliaGrid maintains references to all variables, which are categorized into six fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.variable))</code><code class="nohighlight hljs ansi" style="display:block;">(:active, :reactive, :magnitude, :angle, :actwise, :reactwise)</code></pre><hr/><h5 id="Add-Variables"><a class="docs-heading-anchor" href="#Add-Variables">Add Variables</a><a id="Add-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Variables" title="Permalink"></a></h5><p>The user has the ability to easily add new variables to the defined AC optimal power flow model by using the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.@variable"><code>@variable</code></a> macro from the JuMP package. Here is an example:</p><pre><code class="language-julia hljs">JuMP.@variable(analysis.jump, newVariable)</code></pre><p>We can verify that the new variable is included in the defined model by using the function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(analysis.jump, newVariable)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><hr/><h5 id="Delete-Variables"><a class="docs-heading-anchor" href="#Delete-Variables">Delete Variables</a><a id="Delete-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Variables" title="Permalink"></a></h5><p>The variable can be deleted, but this operation is only applicable if the objective function is either affine or quadratic. To achieve this, you can utilize the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.delete"><code>delete</code></a> function provided by the JuMP package, as demonstrated below:</p><pre><code class="language-julia hljs">JuMP.delete(analysis.jump, newVariable)</code></pre><p>After deletion, the variable is no longer part of the model:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(analysis.jump, newVariable)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><hr/><h2 id="DCConstraintFunctionsManual"><a class="docs-heading-anchor" href="#DCConstraintFunctionsManual">Constraint Functions</a><a id="DCConstraintFunctionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCConstraintFunctionsManual" title="Permalink"></a></h2><p>JuliaGrid keeps track of all the references to internally formed constraints in the <code>constraint</code> field of the <code>ACOptimalPowerFlow</code> composite type. These constraints are divided into six fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.constraint))</code><code class="nohighlight hljs ansi" style="display:block;">(:slack, :balance, :voltage, :flow, :capability, :piecewise)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that readers refer to the tutorial on <a href="../../tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowTutorials">AC Optimal Power Flow</a> for insights into the implementation.</p></div></div><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The <code>slack</code> field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function using the <code>angle</code> keyword:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: angle[1] = -0.1</code></pre><p>Users have the flexibility to modify this constraint by changing which bus serves as the slack bus and by adjusting the value of the bus angle. This can be achieved using the <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a> function, for example:</p><pre><code class="language-julia hljs">updateBus!(system, analysis; label = &quot;Bus 1&quot;, type = 1)
updateBus!(system, analysis; label = &quot;Bus 2&quot;, type = 3, angle = -0.2)</code></pre><p>Subsequently, the updated slack constraint can be inspected as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 2: angle[2] = -0.2</code></pre><hr/><h5 id="Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Power-Balance-Constraints">Power Balance Constraints</a><a id="Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Balance-Constraints" title="Permalink"></a></h5><p>The <code>balance</code> field contains references to the equality constraints associated with the active and reactive power balance equations defined for each bus. These constraints ensure that the total active and reactive power injected by the generators matches the total active and reactive power demanded at each bus.</p><p>The constant term in the active power balance equations is determined by the <code>active</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, which defines the active power demanded at the bus. You can access the references to the active power balance constraints using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -(magnitude[1] * (0.0 + ((2 magnitude[2]) * sin(angle[1] - angle[2])))) - 0.1 = 0
Bus 2: -(magnitude[2] * (0.0 + ((2 magnitude[1]) * sin(-angle[1] + angle[2])))) - 0.0 = 0</code></pre><p>Similarly, the constant term in the reactive power balance equations is determined by the <code>reactive</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, which defines the reactive power demanded at the bus. You can access the references to the reactive power balance constraints using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.balance.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -(magnitude[1] * ((2 magnitude[1]) - ((2 magnitude[2]) * cos(angle[1] - angle[2])))) - 0.0 = 0
Bus 2: -(magnitude[2] * ((2 magnitude[2]) - ((2 magnitude[1]) * cos(-angle[1] + angle[2])))) - 0.01 = 0</code></pre><p>During the execution of functions that add or update power system components, these constraints are automatically adjusted to reflect the current configuration of the power system. An example of this adaptability is demonstrated below:</p><pre><code class="language-julia hljs">updateBus!(system, analysis; label = &quot;Bus 2&quot;, active = 0.5)
updateBranch!(system, analysis; label = &quot;Branch 1&quot;, reactance = 0.25)</code></pre><p>For example, the updated set of active power balance constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -(magnitude[1] * (0.0 + ((4 magnitude[2]) * sin(angle[1] - angle[2])))) - 0.1 = 0
Bus 2: -(magnitude[2] * (0.0 + ((4 magnitude[1]) * sin(-angle[1] + angle[2])))) - 0.5 = 0</code></pre><hr/><h5 id="Voltage-Constraints"><a class="docs-heading-anchor" href="#Voltage-Constraints">Voltage Constraints</a><a id="Voltage-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Voltage-Constraints" title="Permalink"></a></h5><p>The <code>voltage</code> field within the model contains references to the inequality constraints associated with the voltage magnitude and voltage angle difference limits. These constraints ensure that the bus voltage magnitudes and the angle differences between the &quot;from&quot; and &quot;to&quot; bus ends of each branch are within specified limits.</p><p>The minimum and maximum bus voltage magnitude limits are set using the <code>minMagnitude</code> and <code>maxMagnitude</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. The constraints associated with these limits can be accessed using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.voltage.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: magnitude[1] ∈ [0.95, 1.05]
Bus 2: magnitude[2] ∈ [0.95, 1.05]</code></pre><p>Similarly, the minimum and maximum voltage angle difference limits between the &quot;from&quot; and &quot;to&quot; bus ends of each branch are set using the <code>minDiffAngle</code> and <code>maxDiffAngle</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. The constraints associated with these limits can be accessed using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: angle[1] - angle[2] ∈ [-3.141592653589793, 3.141592653589793]</code></pre><p>Please note that if the limit constraints are set to <code>minDiffAngle = -2π</code> and <code>maxDiffAngle = 2π</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.</p><p>Additionally, by employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> functions, user has the ability to modify these specific constraints as follows:</p><pre><code class="language-julia hljs">updateBus!(system, analysis; label = &quot;Bus 1&quot;, minMagnitude = 1.0, maxMagnitude = 1.0)
updateBranch!(system, analysis; label = &quot;Branch 1&quot;, minDiffAngle = -1.7, maxDiffAngle = 1.7)</code></pre><p>Subsequently, the updated set of constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.voltage.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: magnitude[1] = 1
Bus 2: magnitude[2] ∈ [0.95, 1.05]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: angle[1] - angle[2] ∈ [-1.7, 1.7]</code></pre><hr/><h5 id="Flow-Constraints"><a class="docs-heading-anchor" href="#Flow-Constraints">Flow Constraints</a><a id="Flow-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Flow-Constraints" title="Permalink"></a></h5><p>The <code>flow</code> field contains references to the inequality constraints associated with the apparent power flow, active power flow, or current magnitude limits at the &quot;from&quot; and &quot;to&quot; bus ends of each branch. The type which one of the constraint will be applied is defined according to the <code>type</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function, <code>type = 1</code> for the apparent power flow, <code>type = 2</code> for the active power flow, or <code>type = 3</code> for the current magnitude. These limits are specified using the <code>longTerm</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function.</p><p>By default, the <code>longTerm</code> keyword is linked to apparent power (<code>type = 1</code>). However, in the example, we configured it to use active power flow by setting <code>type = 2</code>. To access the flow constraints of branches at the &quot;from&quot; bus end, you can utilize the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.flow.from)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: ((0) - ((-4 magnitude[1]*magnitude[2]) * sin(angle[1] - angle[2]))) - 0.15 ≤ 0</code></pre><p>Similarly, to access the &quot;to&quot; bus end flow constraints of branches you can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.flow.to)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: (0.0 + ((-4 magnitude[1]*magnitude[2]) * sin(angle[1] - angle[2]))) - 0.15 ≤ 0</code></pre><p>Please note that if the flow constraints are set to <code>longTerm = 0.0</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.</p><p>Additionally, by employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function, you have the ability to modify these specific constraints, for example:</p><pre><code class="language-julia hljs">updateBranch!(system, analysis; label = &quot;Branch 1&quot;, reactance = 0.8, longTerm = 0.14)</code></pre><p>The updated set of flow constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.flow.from)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: ((0) - ((-1.25 magnitude[1]*magnitude[2]) * sin(angle[1] - angle[2]))) - 0.14 ≤ 0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.flow.to)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: (0.0 + ((-1.25 magnitude[1]*magnitude[2]) * sin(angle[1] - angle[2]))) - 0.14 ≤ 0</code></pre><hr/><h5 id="Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Power-Capability-Constraints">Power Capability Constraints</a><a id="Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Capability-Constraints" title="Permalink"></a></h5><p>The <code>capability</code> field contains references to the inequality constraints associated with the minimum and maximum active and reactive power outputs of the generators.</p><p>The constraints associated with the minimum and maximum active power output limits of the generators are defined using the <code>minActive</code> and <code>maxActive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. To access the constraints associated with these limits, you can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: active[1] = 0
Generator 2: active[2] = 0</code></pre><p>Similarly, the constraints associated with the minimum and maximum reactive power output limits of the generators are specified using the <code>minReactive</code> and <code>maxReactive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. To access these constraints, you can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.capability.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: reactive[1] = 0
Generator 2: reactive[2] = 0</code></pre><p>As demonstrated, the active and reactive power outputs of <code>Generator 1</code> and <code>Generator 2</code> are currently fixed at zero due to previous actions that set these generators out-of-service. However, you can modify these specific constraints by utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a> function, as shown below:</p><pre><code class="language-julia hljs">updateGenerator!(system, analysis; label = &quot;Generator 1&quot;, status = 1)
updateGenerator!(system, analysis; label = &quot;Generator 2&quot;, status = 1, minActive = 0.1)</code></pre><p>Subsequently, the updated set of constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: active[1] ∈ [0, 0.5]
Generator 2: active[2] ∈ [0.1, 0.5]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.capability.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: reactive[1] ∈ [-0.1, 0.1]
Generator 2: reactive[2] ∈ [-0.1, 0.1]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This representation may not provide the most accurate portrayal of the generator&#39;s power output behavior. In reality, there is a tradeoff between the active and reactive power outputs of the generators, and JuliaGrid has the capability to integrate this tradeoff into the optimization model. For more details, please refer to the tutorial on <a href="../../tutorials/acOptimalPowerFlow/#ACPowerCapabilityConstraintsTutorials">Power Capability Constraints</a>.</p></div></div><hr/><h5 id="Power-Piecewise-Constraints"><a class="docs-heading-anchor" href="#Power-Piecewise-Constraints">Power Piecewise Constraints</a><a id="Power-Piecewise-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Piecewise-Constraints" title="Permalink"></a></h5><p>In the context of cost modelling, the <code>piecewise</code> field acts as a reference to the inequality constraints associated with linear piecewise cost functions. These constraints are established using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function, with <code>active = 1</code> or <code>reactive = 1</code> specified when working with linear piecewise cost functions that consist of multiple segments. In our example, only the active power cost of <code>Generator 2</code> is modelled as a linear piecewise function with two segments, and JuliaGrid takes care of setting up the appropriate inequality constraints for each segment:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.piecewise.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 2: 1.1538461538461542 active[2] - actwise[2] ≤ 0.16153846153846452
Generator 2: 0.3939393939393941 active[2] - actwise[2] ≤ -11.009090909090908</code></pre><p>It is worth noting that these constraints can also be automatically updated using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function. Readers can find more details in the section discussing the objective function. </p><p>As mentioned at the beginning, a linear piecewise cost functions with multiple segments will also introduce helper variables that are added to the objective function. In this specific example, the helper variable is:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.variable.actwise[2]</code><code class="nohighlight hljs ansi" style="display:block;">actwise[2]</code></pre><hr/><h5 id="Add-Constraints"><a class="docs-heading-anchor" href="#Add-Constraints">Add Constraints</a><a id="Add-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Constraints" title="Permalink"></a></h5><p>Users can effortlessly introduce additional constraints into the defined AC optimal power flow model by utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> or <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> functions. Specifically, if a user wishes to include a new branch or generator in an already defined <code>PowerSystem</code> and <code>ACOptimalPowerFlow</code> type, using these functions will automatically add and update all constraints:</p><pre><code class="language-julia hljs">addBranch!(system, analysis; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 1)
addGenerator!(system, analysis; label = &quot;Generator 3&quot;, bus = &quot;Bus 2&quot;, active = 2, status = 1)</code></pre><p>This will affect all constraints related to branches and generators, but it will also update balance constraints to configure the optimization model to match the current state of the power system. For example, you can observe the following updated constraints:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: angle[1] - angle[2] ∈ [-1.7, 1.7]
Branch 2: angle[1] - angle[2] ∈ [-3.141592653589793, 3.141592653589793]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: active[1] ∈ [0, 0.5]
Generator 2: active[2] ∈ [0.1, 0.5]
Generator 3: active[3] ∈ [0, 0.5]</code></pre><hr/><h5 id="Add-User-Defined-Constraints"><a class="docs-heading-anchor" href="#Add-User-Defined-Constraints">Add User-Defined Constraints</a><a id="Add-User-Defined-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-User-Defined-Constraints" title="Permalink"></a></h5><p>Users also have the option to include their custom constraints within the established AC optimal power flow model by employing the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.@constraint"><code>@constraint</code></a> macro. For example, the addition of a new constraint can be achieved as follows:</p><pre><code class="language-julia hljs">JuMP.@constraint(analysis.jump, 0.0 &lt;= analysis.variable.active[3] &lt;= 0.3)</code></pre><hr/><h5 id="Delete-Constraints"><a class="docs-heading-anchor" href="#Delete-Constraints">Delete Constraints</a><a id="Delete-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Constraints" title="Permalink"></a></h5><p>To delete a constraint, users can make use of the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.delete"><code>delete</code></a> function from the JuMP package. When handling constraints that have been internally created, users can refer to the constraint references stored in the <code>constraint</code> field of the <code>ACOptimalPowerFlow</code> type.</p><p>For example, if the intention is to eliminate constraints related to the capability of <code>Generator 3</code>, the following code snippet can be employed:</p><pre><code class="language-julia hljs">JuMP.delete(analysis.jump, analysis.constraint.capability.active[3])</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In the event that a user deletes a constraint and subsequently executes a function that updates bus, branch, or generator parameters, and if the deleted constraint is affected by these functions, JuliaGrid will automatically reinstate that constraint. Users should exercise caution when deleting constraints, as this action is considered potentially harmful since it operates independently of power system data.</p></div></div><hr/><h2 id="ACObjectiveFunctionManual"><a class="docs-heading-anchor" href="#ACObjectiveFunctionManual">Objective Function</a><a id="ACObjectiveFunctionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACObjectiveFunctionManual" title="Permalink"></a></h2><p>The objective function of the AC optimal power flow is formulated using polynomial and linear piecewise cost functions associated with the generators, defined using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions.</p><p>In the provided example, the objective function to be minimized in order to obtain optimal values for the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles, is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.jump)</code><code class="nohighlight hljs ansi" style="display:block;">800 active[1]² + 200 active[1] + actwise[2] + reactive[2] + 84</code></pre><p>JuliaGrid also stores the objective function in a separate variable, which can be accessed by referring to the variable <code>analysis.objective</code>. In this variable, the objective function is organized in a way that separates the quadratic and nonlinear components of the objective function.</p><hr/><h5 id="Update-Objective-Function"><a class="docs-heading-anchor" href="#Update-Objective-Function">Update Objective Function</a><a id="Update-Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Update-Objective-Function" title="Permalink"></a></h5><p>By utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions, users have the flexibility to modify the objective function by adjusting polynomial or linear piecewise cost coefficients or by changing the type of polynomial or linear piecewise function employed. For instance, consider <code>Generator 1</code>, which originally employs a quadratic polynomial cost function for active power. You can redefine the cost function for this generator as a cubic polynomial and thereby define a nonlinear objective function, as shown below:</p><pre><code class="language-julia hljs">cost!(system, analysis; label = &quot;Generator 1&quot;, active = 2, polynomial = [631; 257; 40; 5.0])</code></pre><p>This leads to an updated objective function, which can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.jump)</code><code class="nohighlight hljs ansi" style="display:block;">(257 active[1]² + 40 active[1] + actwise[2] + reactive[2] + 9) + (631.0 * (active[1] ^ 3.0))</code></pre><hr/><h5 id="User-Defined-Objective-Function"><a class="docs-heading-anchor" href="#User-Defined-Objective-Function">User-Defined Objective Function</a><a id="User-Defined-Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#User-Defined-Objective-Function" title="Permalink"></a></h5><p>Users can modify the objective function using the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.set_objective_function"><code>set_objective_function</code></a> function from the JuMP package. This operation is considered destructive because it is independent of power system data; however, in certain scenarios, it may be more straightforward than using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function for updates. Moreover, using this methodology, users can combine a defined function with a newly defined expression.</p><p>In this context, we can utilize the saved objective function within the <code>objective</code> field of the <code>ACOptimalPowerFlow</code> type. For example, you can easily eliminate nonlinear parts and alter the quadratic component of the objective as follows:</p><pre><code class="language-julia hljs">expr = 5.0 * analysis.variable.active[1] * analysis.variable.active[1]
JuMP.set_objective_function(analysis.jump, analysis.objective.quadratic - expr)</code></pre><p>You can now observe the updated objective function as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.jump)</code><code class="nohighlight hljs ansi" style="display:block;">252 active[1]² + 40 active[1] + actwise[2] + reactive[2] + 9</code></pre><hr/><h2 id="ACSetupPrimalStartingValuesManual"><a class="docs-heading-anchor" href="#ACSetupPrimalStartingValuesManual">Setup Primal Starting Values</a><a id="ACSetupPrimalStartingValuesManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACSetupPrimalStartingValuesManual" title="Permalink"></a></h2><p>In JuliaGrid, the assignment of starting primal values for optimization variables takes place when the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function is executed. Starting primal values are determined based on the <code>generator</code> and <code>voltage</code> fields within the <code>ACOptimalPowerFlow</code> type. By default, these values are initially established using the active and reactive power outputs of the generators and the initial bus voltage magnitudes and angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; generator = analysis.power.generator;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, generator.active, generator.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.4, 0.2
Generator 2: 0.2, 0.1
Generator 3: 2.0, 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, -0.1
Bus 2: 1.1, -0.2</code></pre><p>You have the flexibility to adjust these values to your specifications, and they will be utilized as the starting primal values when you run the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function.</p><hr/><h5 id="Using-AC-Power-Flow"><a class="docs-heading-anchor" href="#Using-AC-Power-Flow">Using AC Power Flow</a><a id="Using-AC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Using-AC-Power-Flow" title="Permalink"></a></h5><p>In this perspective, users have the capability to conduct the AC power flow analysis and leverage the resulting solution to configure starting primal values. Here is an illustration of how this can be achieved:</p><pre><code class="language-julia hljs">flow = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, flow)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, flow)
end</code></pre><p>After obtaining the solution, we can calculate the active and reactive power outputs of the generators and utilize the bus voltage magnitudes and angles to set the starting values. In this case, the <code>generator</code> and <code>voltage</code> fields of the <code>ACOptimalPowerFlow</code> type can be employed to store the new starting values:</p><pre><code class="language-julia hljs">for (key, value) in system.generator.label
    active, reactive = generatorPower(system, flow; label = key)
    analysis.power.generator.active[value] = active
    analysis.power.generator.reactive[value] = reactive
end

for i = 1:system.bus.number
    analysis.voltage.magnitude[i] = flow.voltage.magnitude[i]
    analysis.voltage.angle[i] = flow.voltage.angle[i]
end</code></pre><hr/><h2 id="ACOptimalPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowSolutionManual">Optimal Power Flow Solution</a><a id="ACOptimalPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowSolutionManual" title="Permalink"></a></h2><p>To establish the AC optimal power flow problem, you can utilize the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function. After setting up the problem, you can use the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function to compute the optimal values for the active and reactive power outputs of the generators and the bus voltage magnitudes angles. Also, to turn off the solver output within the REPL, we use the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.set_silent"><code>set_silent</code></a> function before calling <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function. Here is an example:</p><pre><code class="language-julia hljs">JuMP.set_silent(analysis.jump)
solve!(system, analysis)</code></pre><p>By executing this function, you will obtain the solution with the optimal values for the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; generator = analysis.power.generator;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, generator.active, generator.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: -9.846985885398597e-9, 0.04976946905919965
Generator 2: 0.3000000150593341, -0.10000000423962996
Generator 3: 0.2999999947876518, 0.06577586941092359</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, -0.24541853116946893
Bus 2: 0.9788897103039467, -0.2</code></pre><hr/><h5 id="Objective-Value"><a class="docs-heading-anchor" href="#Objective-Value">Objective Value</a><a id="Objective-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Value" title="Permalink"></a></h5><p>To obtain the objective value of the optimal power flow solution, you can use the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.objective_value"><code>objective_value</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_value(analysis.jump)</code><code class="nohighlight hljs ansi" style="display:block;">20.027272231047704</code></pre><hr/><h5 id="Warm-Start"><a class="docs-heading-anchor" href="#Warm-Start">Warm Start</a><a id="Warm-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Warm-Start" title="Permalink"></a></h5><p>Utilizing the <code>ACOptimalPowerFlow</code> type and proceeding directly to the solver offers the advantage of a &quot;warm start&quot;. In this scenario, the starting primal values for the subsequent solving step correspond to the solution obtained from the previous step.</p><p>In the previous example, we obtained the following solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; generator = analysis.power.generator;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, generator.active, generator.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: -9.846985885398597e-9, 0.04976946905919965
Generator 2: 0.3000000150593341, -0.10000000423962996
Generator 3: 0.2999999947876518, 0.06577586941092359</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, -0.24541853116946893
Bus 2: 0.9788897103039467, -0.2</code></pre><p>Now, let us introduce changes to the power system from the previous example:</p><pre><code class="language-julia hljs">updateGenerator!(system, analysis; label = &quot;Generator 2&quot;, maxActive = 0.08)</code></pre><p>Next, solve this new power system. During the execution of the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function, the primal starting values will first be set, and these values will be defined according to the values given above.</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>As a result, we obtain a new solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, generator.active, generator.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: -9.846985885398597e-9, 0.04976946905919965
Generator 2: 0.3000000150593341, -0.10000000423962996
Generator 3: 0.2999999947876518, 0.06577586941092359</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, -0.24541853116946893
Bus 2: 0.9788897103039467, -0.2</code></pre><p>Users retain the flexibility to reset these initial primal values to their default configurations at any juncture. This can be accomplished by utilizing the active and reactive power outputs of the generators and the initial bus voltage magnitudes and angles extracted from the <code>PowerSystem</code> composite type, employing the <a href="../../api/optimalPowerFlow/#JuliaGrid.startingPrimal!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>startingPrimal!</code></a> function:</p><pre><code class="language-julia hljs">startingPrimal!(system, analysis)</code></pre><p>These values are precisely identical to what we would obtain if we executed the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function following all the updates we performed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, generator.active, generator.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.4, 0.2
Generator 2: 0.2, 0.1
Generator 3: 2.0, 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, -0.1
Bus 2: 1.1, -0.2</code></pre><hr/><h2 id="ACOptimalPowerCurrentAnalysisManual"><a class="docs-heading-anchor" href="#ACOptimalPowerCurrentAnalysisManual">Power and Current Analysis</a><a id="ACOptimalPowerCurrentAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerCurrentAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the AC optimal power flow, we can calculate various electrical quantities related to buses, branches, and generators using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions. For instance, let us consider the power system for which we obtained the AC optimal power flow solution:</p><pre><code class="language-julia hljs">using JuMP, Ipopt

system = powerSystem()

@bus(minMagnitude = 0.9, maxMagnitude = 1.1)
addBus!(system; label = &quot;Bus 1&quot;, type = 3, magnitude = 1.05, angle = 0.17)
addBus!(system; label = &quot;Bus 2&quot;, active = 0.1, reactive = 0.01, conductance = 0.04)
addBus!(system; label = &quot;Bus 3&quot;, active = 0.05, reactive = 0.02)

@branch(resistance = 0.5, reactance = 1.0, conductance = 1e-4, susceptance = 0.01)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, longTerm = 0.15)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, longTerm = 0.10)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, longTerm = 0.25)

@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, reactive = 0.5)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.2, reactive = 0.1)

cost!(system; label = &quot;Generator 1&quot;, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; label = &quot;Generator 2&quot;, active = 1, piecewise = [10.8 12.3; 14.7 16.8; 18 18.1])

acModel!(system)

analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)
solve!(system, analysis)</code></pre><p>We can now utilize the following functions to calculate powers and currents:</p><pre><code class="language-julia hljs">power!(system, analysis)
current!(system, analysis)</code></pre><p>For instance, if we want to show the active power injections at each bus and the current flow magnitudes at each &quot;from&quot; bus end of the branch, we can employ the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -9.620540583794857e-9
Bus 2: 0.08516606801635107
Bus 3: -0.04999999999897997</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.current.from.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: 0.026571245613638255
Branch 2: 0.02327515579762493
Branch 3: 0.038138710710893406</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers and current associated with buses and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions, we suggest referring to the tutorials on <a href="../../tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowTutorials">AC Optimal Power Flow</a>.</p></div></div><p>To compute specific quantities for particular components, rather than calculating powers or currents for all components, users can utilize one of the provided functions below.</p><hr/><h5 id="Active-and-Reactive-Power-Injection"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection">Active and Reactive Power Injection</a><a id="Active-and-Reactive-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection" title="Permalink"></a></h5><p>To calculate the active and reactive power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = injectionPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-9.620540584662218e-9, 0.030765801875305195)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection-from-Generators">Active and Reactive Power Injection from Generators</a><a id="Active-and-Reactive-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = supplyPower(system, analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.18516606801523944, -0.022836348119282302)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Shunt-Element"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Shunt-Element">Active and Reactive Power at Shunt Element</a><a id="Active-and-Reactive-Power-at-Shunt-Element-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Shunt-Element" title="Permalink"></a></h5><p>To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = shuntPower(system, analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.03341803114531875, -0.0)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Flow"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Flow">Active and Reactive Power Flow</a><a id="Active-and-Reactive-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active and reactive power flow at both the &quot;from&quot; and &quot;to&quot; bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = fromPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.017183819173556, 0.013083736295848414)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = toPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-0.016754074906889488, -0.02074674916342745)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Charging-Admittances"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Charging-Admittances">Active and Reactive Power at Charging Admittances</a><a id="Active-and-Reactive-Power-at-Charging-Admittances-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Charging-Admittances" title="Permalink"></a></h5><p>To calculate the total active and reactive power linked with branch charging admittances of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = chargingPower(system, analysis; label = &quot;Branch 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(8.482584216518542e-5, -0.008482584216518542)</code></pre><p>Active powers indicate active losses within the branch&#39;s charging or shunt admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.</p><hr/><h5 id="Active-and-Reactive-Power-at-Series-Impedance"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Series-Impedance">Active and Reactive Power at Series Impedance</a><a id="Active-and-Reactive-Power-at-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Series-Impedance" title="Permalink"></a></h5><p>To calculate the active and reactive power across the series impedance of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = seriesPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0003461903313633867, 0.0006923806627267733)</code></pre><p>The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance&#39;s inductive characteristics.</p><hr/><h5 id="Current-Injection"><a class="docs-heading-anchor" href="#Current-Injection">Current Injection</a><a id="Current-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injection" title="Permalink"></a></h5><p>To calculate the current injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = injectionCurrent(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.03315507404284225, -1.4007966394973068)</code></pre><hr/><h5 id="Current-Flow"><a class="docs-heading-anchor" href="#Current-Flow">Current Flow</a><a id="Current-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow" title="Permalink"></a></h5><p>We can compute the current flow at both the &quot;from&quot; and &quot;to&quot; bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = fromCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.02327515579762493, -0.48075640477812265)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = toCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.029629721662614236, 2.4100114878509347)</code></pre><hr/><h5 id="Current-Through-Series-Impedance"><a class="docs-heading-anchor" href="#Current-Through-Series-Impedance">Current Through Series Impedance</a><a id="Current-Through-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Through-Series-Impedance" title="Permalink"></a></h5><p>To calculate the current passing through the series impedance of the branch in the direction from the &quot;from&quot; bus end to the &quot;to&quot; bus end, you can use the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = seriesCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.02631312719398387, -0.6225889445656966)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dcPowerFlow/">« DC Power Flow</a><a class="docs-footer-nextpage" href="../dcOptimalPowerFlow/">DC Optimal Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 22 February 2024 13:01">Thursday 22 February 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
