<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC Optimal Power Flow · JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li class="is-active"><a class="tocitem" href>AC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#ACOptimizationVariablesManual"><span>Optimization Variables</span></a></li><li><a class="tocitem" href="#ACConstraintFunctionsManual"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#ACObjectiveFunctionManual"><span>Objective Function</span></a></li><li><a class="tocitem" href="#ACSetupPrimalStartingValuesManual"><span>Setup Primal Starting Values</span></a></li><li><a class="tocitem" href="#ACOptimalPowerFlowSolutionManual"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#ACOptimalPowerCurrentAnalysisManual"><span>Power and Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>AC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/acOptimalPowerFlow.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ACOptimalPowerFlowManual"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowManual">AC Optimal Power Flow</a><a id="ACOptimalPowerFlowManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowManual" title="Permalink"></a></h1><p>JuliaGrid utilizes the <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> package to construct optimal power flow models, allowing users to manipulate these models using the standard functions provided by JuMP. As a result, JuliaGrid supports popular <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> mentioned in the JuMP documentation to solve the optimization problem.</p><p>To perform the AC optimal power flow, you first need to have the <code>PowerSystem</code> composite type that has been created with the <code>acModel</code>. After that, create the <code>Model</code> composite type to establish the AC optimal power flow framework using the function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a>.</li></ul><p>To solve the AC optimal power flow problem and acquire bus voltage magnitudes and angles, and generator active and reactive power outputs, make use of the following function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a>.</li></ul><p>After obtaining the AC optimal power flow solution, JuliaGrid offers post-processing analysis functions for calculating powers and currents associated with buses and branches:</p><ul><li><a href="manual/@ref power(::PowerSystem, ::ACPowerFlow)"><code>power!</code></a>,</li><li><a href="manual/@ref current(::PowerSystem, ::ACPowerFlow)"><code>current!</code></a>.</li></ul><p>Additionally, there are specialized functions dedicated to calculating specific types of powers and currents related to to particular buses or branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.powerInjection-Tuple{PowerSystem, ACAnalysis}"><code>powerInjection</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.powerSupply-Tuple{PowerSystem, ACPowerFlow}"><code>powerSupply</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.powerShunt-Tuple{PowerSystem, ACAnalysis}"><code>powerShunt</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.powerFrom-Tuple{PowerSystem, ACAnalysis}"><code>powerFrom</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.powerTo-Tuple{PowerSystem, ACAnalysis}"><code>powerTo</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.powerCharging-Tuple{PowerSystem, ACAnalysis}"><code>powerCharging</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.powerLoss-Tuple{PowerSystem, ACAnalysis}"><code>powerLoss</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.currentInjection-Tuple{PowerSystem, ACAnalysis}"><code>currentInjection</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.currentFrom-Tuple{PowerSystem, ACAnalysis}"><code>currentFrom</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.currentTo-Tuple{PowerSystem, ACAnalysis}"><code>currentTo</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.currentLine-Tuple{PowerSystem, ACAnalysis}"><code>currentLine</code></a>.</li></ul><hr/><h2 id="ACOptimizationVariablesManual"><a class="docs-heading-anchor" href="#ACOptimizationVariablesManual">Optimization Variables</a><a id="ACOptimizationVariablesManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimizationVariablesManual" title="Permalink"></a></h2><p>To set up the AC optimal power flow, we begin by creating the model. To illustrate this, consider the following example:</p><pre><code class="language-julia hljs">system = powerSystem()

@bus(minMagnitude = 0.9, maxMagnitude = 1.1)
addBus!(system; label = 1, type = 3, magnitude = 1.05, angle = 0.17)
addBus!(system; label = 2, active = 0.1, reactive = 0.01, conductance = 0.04)
addBus!(system; label = 3, active = 0.05, reactive = 0.02)

@branch(minDiffAngle = -pi, maxDiffAngle = pi, resistance = 0.5, susceptance = 0.01)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 1.0, longTerm = 0.15)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 1.0, longTerm = 0.10)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 1.0, longTerm = 0.25)

@generator(minActive = 0.0, minReactive = -0.1, maxReactive = 0.1)
addGenerator!(system; label = 1, bus = 1, active = 3.2, reactive = 0.5, maxActive = 0.5)
addGenerator!(system; label = 2, bus = 2, active = 0.2, reactive = 0.1, maxActive = 0.2)

addActiveCost!(system; label = 1, model = 2, polynomial = [1100.2; 500; 80])
addActiveCost!(system; label = 2, model = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])

addReactiveCost!(system; label = 1, model = 2, polynomial = [30.2; 20; 5])
addReactiveCost!(system; label = 2, model = 2, polynomial = [10.3; 5.1; 1.2])

acModel!(system)

model = acOptimalPowerFlow(system, Ipopt.Optimizer)</code></pre><p>In the AC optimal power flow model, the active and reactive power outputs of the generators are expressed as nonlinear functions of the bus voltage magnitudes and angles. As a result, the variables in this model include the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.all_variables(model.jump)</code><code class="nohighlight hljs ansi" style="display:block;">11-element Vector{VariableRef}:
 angle[1]
 angle[2]
 angle[3]
 magnitude[1]
 magnitude[2]
 magnitude[3]
 active[1]
 active[2]
 reactive[1]
 reactive[2]
 helperActive[1]</code></pre><p>Additionally, when dealing with linear piecewise cost functions that have more than one segment, JuliaGrid automatically generates a helper variable for each linear segment. This is done using a constrained cost variable approach, where the original cost function is replaced by the helper variable and a set of linear constraints.</p><p>Please note that in the given example, we include reactive cost functions for each generator for the sake of completeness. However, in typical scenarios, only active cost functions are considered.</p><hr/><h5 id="Add-Variables"><a class="docs-heading-anchor" href="#Add-Variables">Add Variables</a><a id="Add-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Variables" title="Permalink"></a></h5><p>The user has the ability to easily add new variables to the defined DC optimal power flow model by using the <a href="https://jump.dev/JuMP.jl/stable/reference/variables/#JuMP.@variable"><code>@variable</code></a> macro from the JuMP package. Here is an example:</p><pre><code class="language-julia hljs">JuMP.@variable(model.jump, new)</code></pre><p>We can verify that the new variable is included in the defined model by using the function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(model.jump, new)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><hr/><h5 id="Delete-Variables"><a class="docs-heading-anchor" href="#Delete-Variables">Delete Variables</a><a id="Delete-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Variables" title="Permalink"></a></h5><p>To delete a variable, the <a href="https://jump.dev/JuMP.jl/stable/reference/constraints/#JuMP.delete"><code>delete</code></a> function from the JuMP package can be used:</p><pre><code class="language-julia hljs">JuMP.delete(model.jump, new)</code></pre><p>After deletion, the variable is no longer part of the model:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(model.jump, new)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><hr/><h2 id="ACConstraintFunctionsManual"><a class="docs-heading-anchor" href="#ACConstraintFunctionsManual">Constraint Functions</a><a id="ACConstraintFunctionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACConstraintFunctionsManual" title="Permalink"></a></h2><p>JuliGrid keeps track of all the references to internally formed constraints in the <code>constraint</code> field of the <code>Model</code> composite type. These constraints are divided into six fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(model.constraint))</code><code class="nohighlight hljs ansi" style="display:block;">(:slack, :balance, :limit, :rating, :capability, :piecewise)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that readers refer to the tutorial on <a href="../../tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowTutorials">AC optimal power flow</a> for insights into the implementation.</p></div></div><hr/><h5 id="Slack-Bus-Constraints"><a class="docs-heading-anchor" href="#Slack-Bus-Constraints">Slack Bus Constraints</a><a id="Slack-Bus-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraints" title="Permalink"></a></h5><p>The <code>slack</code> field within the model contains references to the equality constraints that enforce fixed values for the bus voltage magnitude and angle at the slack bus. These constraints are set when adding the slack bus using the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, specifically by specifying the <code>magnitude</code> and <code>angle</code> keywords. To access the references to these constraints, you can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.slack.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">magnitude[1] = 1.05</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.slack.angle</code><code class="nohighlight hljs ansi" style="display:block;">angle[1] = 0.17</code></pre><hr/><h5 id="Active-and-Reactive-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Balance-Constraints">Active and Reactive Power Balance Constraints</a><a id="Active-and-Reactive-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Balance-Constraints" title="Permalink"></a></h5><p>The <code>balance</code> field contains references to the equality constraints associated with the active and reactive power balance equations defined for each bus. These constraints ensure that the total active and reactive power injected by the generators matches the total active and reactive power demanded at each bus.</p><p>The constant term in the active power balance equations is determined by the <code>active</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, which defines the active power demanded at the bus. You can access the references to the active power balance constraints using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.balance.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 ((0.0 - active[1]) + magnitude[1] * (((0.8 * magnitude[1]) * cos(0.0) + (-1.59 * magnitude[1]) * sin(0.0)) + ((-0.4 * magnitude[2]) * cos(angle[1] + -1.0 * angle[2]) + (0.8 * magnitude[2]) * sin(angle[1] + -1.0 * angle[2])) + ((-0.4 * magnitude[3]) * cos(angle[1] + -1.0 * angle[3]) + (0.8 * magnitude[3]) * sin(angle[1] + -1.0 * angle[3])))) - 0.0 = 0
 ((0.1 - active[2]) + magnitude[2] * (((-0.4 * magnitude[1]) * cos(angle[2] + -1.0 * angle[1]) + (0.8 * magnitude[1]) * sin(angle[2] + -1.0 * angle[1])) + ((0.8400000000000001 * magnitude[2]) * cos(0.0) + (-1.59 * magnitude[2]) * sin(0.0)) + ((-0.4 * magnitude[3]) * cos(angle[2] + -1.0 * angle[3]) + (0.8 * magnitude[3]) * sin(angle[2] + -1.0 * angle[3])))) - 0.0 = 0
 ((0.05 - 0.0) + magnitude[3] * (((-0.4 * magnitude[1]) * cos(angle[3] + -1.0 * angle[1]) + (0.8 * magnitude[1]) * sin(angle[3] + -1.0 * angle[1])) + ((-0.4 * magnitude[2]) * cos(angle[3] + -1.0 * angle[2]) + (0.8 * magnitude[2]) * sin(angle[3] + -1.0 * angle[2])) + ((0.8 * magnitude[3]) * cos(0.0) + (-1.59 * magnitude[3]) * sin(0.0)))) - 0.0 = 0</code></pre><p>Similarly, the constant term in the reactive power balance equations is determined by the <code>reactive</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, which defines the reactive power demanded at the bus. You can access the references to the reactive power balance constraints using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.balance.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 ((0.0 - reactive[1]) + magnitude[1] * (((0.8 * magnitude[1]) * sin(0.0) - (-1.59 * magnitude[1]) * cos(0.0)) + ((-0.4 * magnitude[2]) * sin(angle[1] + -1.0 * angle[2]) - (0.8 * magnitude[2]) * cos(angle[1] + -1.0 * angle[2])) + ((-0.4 * magnitude[3]) * sin(angle[1] + -1.0 * angle[3]) - (0.8 * magnitude[3]) * cos(angle[1] + -1.0 * angle[3])))) - 0.0 = 0
 ((0.01 - reactive[2]) + magnitude[2] * (((-0.4 * magnitude[1]) * sin(angle[2] + -1.0 * angle[1]) - (0.8 * magnitude[1]) * cos(angle[2] + -1.0 * angle[1])) + ((0.8400000000000001 * magnitude[2]) * sin(0.0) - (-1.59 * magnitude[2]) * cos(0.0)) + ((-0.4 * magnitude[3]) * sin(angle[2] + -1.0 * angle[3]) - (0.8 * magnitude[3]) * cos(angle[2] + -1.0 * angle[3])))) - 0.0 = 0
 ((0.02 - 0.0) + magnitude[3] * (((-0.4 * magnitude[1]) * sin(angle[3] + -1.0 * angle[1]) - (0.8 * magnitude[1]) * cos(angle[3] + -1.0 * angle[1])) + ((-0.4 * magnitude[2]) * sin(angle[3] + -1.0 * angle[2]) - (0.8 * magnitude[2]) * cos(angle[3] + -1.0 * angle[2])) + ((0.8 * magnitude[3]) * sin(0.0) - (-1.59 * magnitude[3]) * cos(0.0)))) - 0.0 = 0</code></pre><p>If you want to exclude these constraints and skip their formation, you can utilize the <code>balance = false</code> keyword within the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function. By specifying this keyword, you indicate that the problem does not involve active and reactive power balance constraints.</p><hr/><h5 id="Voltage-Magnitude-and-Voltage-Angle-Difference-Limit-Constraints"><a class="docs-heading-anchor" href="#Voltage-Magnitude-and-Voltage-Angle-Difference-Limit-Constraints">Voltage Magnitude and Voltage Angle Difference Limit Constraints</a><a id="Voltage-Magnitude-and-Voltage-Angle-Difference-Limit-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Voltage-Magnitude-and-Voltage-Angle-Difference-Limit-Constraints" title="Permalink"></a></h5><p>The <code>limit</code> field within the model contains references to the inequality constraints associated with the voltage magnitude and voltage angle difference limits. These constraints ensure that the bus voltage magnitudes and the angle differences between the &quot;from&quot; and &quot;to&quot; bus ends of each branch are within specified limits. </p><p>The minimum and maximum bus voltage magnitude limits are set using the <code>minMagnitude</code> and <code>maxMagnitude</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. The constraints associated with these limits can be accessed using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.limit.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 magnitude[1] ∈ [0.9, 1.1]
 magnitude[2] ∈ [0.9, 1.1]
 magnitude[3] ∈ [0.9, 1.1]</code></pre><p>Similarly, the minimum and maximum voltage angle difference limits between the &quot;from&quot; and &quot;to&quot; bus ends of each branch are set using the <code>minDiffAngle</code> and <code>maxDiffAngle</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. The constraints associated with these limits can be accessed using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.limit.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 angle[1] - angle[2] ∈ [-3.141592653589793, 3.141592653589793]
 angle[1] - angle[3] ∈ [-3.141592653589793, 3.141592653589793]
 angle[2] - angle[3] ∈ [-3.141592653589793, 3.141592653589793]</code></pre><p>Please note that if the limit constraints are set to <code>minDiffAngle = -2π</code> and <code>maxDiffAngle = 2π</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint. </p><p>Furthermore, if you want to exclude all limit constraints and skip their formation, you can use the <code>limit = false</code> keyword within the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function.</p><hr/><h5 id="Rating-Constraints"><a class="docs-heading-anchor" href="#Rating-Constraints">Rating Constraints</a><a id="Rating-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Rating-Constraints" title="Permalink"></a></h5><p>The <code>rating</code> field contains references to the inequality constraints associated with the apparent power flow, active power flow, or current magnitude limits at the &quot;from&quot; and &quot;to&quot; bus ends of each branch. The type which one of the constraint will be apllied is defined according to the <code>type</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function, <code>type = 1</code> for the apparent power flow, <code>type = 2</code> for the active power flow, or <code>type = 3</code> for the current magnitude. These limits are specified using the <code>longTerm</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function.   </p><p>By default, the <code>longTerm</code> keyword is associated with apparent power (<code>type = 1</code>). To access the rating constraints of branches at the &quot;from&quot; bus end, you can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.rating.from</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 (((0.7920250000000001 * magnitude[1] ^ 4.0 + 0.8000000000000002 * magnitude[1] ^ 2.0 * magnitude[2] ^ 2.0) - 2.0 * magnitude[1] ^ 3.0 * magnitude[2] * (0.7960000000000002 * cos(angle[1] + -1.0 * angle[2]) - 0.002 * sin(angle[1] + -1.0 * angle[2]))) - 0.15 ^ 2.0) - 0.0 ≤ 0
 (((0.7920250000000001 * magnitude[1] ^ 4.0 + 0.8000000000000002 * magnitude[1] ^ 2.0 * magnitude[3] ^ 2.0) - 2.0 * magnitude[1] ^ 3.0 * magnitude[3] * (0.7960000000000002 * cos(angle[1] + -1.0 * angle[3]) - 0.002 * sin(angle[1] + -1.0 * angle[3]))) - 0.1 ^ 2.0) - 0.0 ≤ 0
 (((0.7920250000000001 * magnitude[2] ^ 4.0 + 0.8000000000000002 * magnitude[2] ^ 2.0 * magnitude[3] ^ 2.0) - 2.0 * magnitude[2] ^ 3.0 * magnitude[3] * (0.7960000000000002 * cos(angle[2] + -1.0 * angle[3]) - 0.002 * sin(angle[2] + -1.0 * angle[3]))) - 0.25 ^ 2.0) - 0.0 ≤ 0</code></pre><p>Similarly, to acces the &quot;to&quot; bus end rating constraints of branches you can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.rating.to</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 (((0.7920250000000001 * magnitude[2] ^ 4.0 + 0.8000000000000002 * magnitude[1] ^ 2.0 * magnitude[2] ^ 2.0) - 2.0 * magnitude[1] * magnitude[2] ^ 3.0 * (0.7960000000000002 * cos(angle[1] + -1.0 * angle[2]) + 0.002 * sin(angle[1] + -1.0 * angle[2]))) - 0.15 ^ 2.0) - 0.0 ≤ 0
 (((0.7920250000000001 * magnitude[3] ^ 4.0 + 0.8000000000000002 * magnitude[1] ^ 2.0 * magnitude[3] ^ 2.0) - 2.0 * magnitude[1] * magnitude[3] ^ 3.0 * (0.7960000000000002 * cos(angle[1] + -1.0 * angle[3]) + 0.002 * sin(angle[1] + -1.0 * angle[3]))) - 0.1 ^ 2.0) - 0.0 ≤ 0
 (((0.7920250000000001 * magnitude[3] ^ 4.0 + 0.8000000000000002 * magnitude[2] ^ 2.0 * magnitude[3] ^ 2.0) - 2.0 * magnitude[2] * magnitude[3] ^ 3.0 * (0.7960000000000002 * cos(angle[2] + -1.0 * angle[3]) + 0.002 * sin(angle[2] + -1.0 * angle[3]))) - 0.25 ^ 2.0) - 0.0 ≤ 0</code></pre><p>If you want to exclude these constraints and skip their formation, you can use the <code>rating = false</code> keyword within the  <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function. By specifying this keyword, you indicate that the problem does not involve rating constraints.</p><hr/><h5 id="Active-and-Reactive-Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Capability-Constraints">Active and Reactive Power Capability Constraints</a><a id="Active-and-Reactive-Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Capability-Constraints" title="Permalink"></a></h5><p>The <code>capability</code> field contains references to the inequality constraints associated with the minimum and maximum active and reactive power outputs of the generators. </p><p>The constraints associated with the minimum and maximum active power output limits of the generators are defined using the <code>minActive</code> and <code>maxActive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. To access the constraints associated with these limits, you can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.capability.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ConstraintRef}:
 active[1] ∈ [0, 0.5]
 active[2] ∈ [0, 0.2]</code></pre><p>Similarly, the constraints associated with the minimum and maximum reactive power output limits of the generators are specified using the <code>minReactive</code> and <code>maxReactive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. To access these constraints, you can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.capability.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ConstraintRef}:
 reactive[1] ∈ [-0.1, 0.1]
 reactive[2] ∈ [-0.1, 0.1]</code></pre><p>If you want to exclude these constraints and skip their formation, you can use the <code>capability = false</code> keyword within the  <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function. By specifying this keyword, you indicate that the problem does not involve power capability constraints.</p><hr/><h5 id="Active-and-Reactive-Power-Piecewise-Constraints"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Piecewise-Constraints">Active and Reactive Power Piecewise Constraints</a><a id="Active-and-Reactive-Power-Piecewise-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Piecewise-Constraints" title="Permalink"></a></h5><p>The <code>piecewise</code> field contains references to the inequality constraints associated with the linear piecewise cost function. In this particular case, we are dealing with a single linear piecewise cost function associated with the active power. This function is defined using the <a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a> function, specifying <code>model = 1</code>. Consequently, the original cost function is replaced by a helper variable, and a set of linear constraints is established:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.piecewise.active[2]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ConstraintRef}:
 1.1479591836734695 active[2] - helperActive[1] ≤ 0.15535714285714342
 0.40247678018575866 active[2] - helperActive[1] ≤ -10.855417956656346</code></pre><p>As a result, for the generator labeled as 2, there exists a linear piecewise cost function comprising two segments. JuliaGrid defines the corresponding inequality constraints for each of these segments.</p><hr/><h5 id="Add-Constraints"><a class="docs-heading-anchor" href="#Add-Constraints">Add Constraints</a><a id="Add-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Constraints" title="Permalink"></a></h5><p>Users can effortlessly incorporate additional constraints into the defined AC optimal power flow model using the <a href="https://jump.dev/JuMP.jl/stable/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a> macro. For instance, a new constraint can be added as follows:</p><pre><code class="language-julia hljs">angle = model.jump[:angle]

JuMP.@constraint(model.jump, -2.1 &lt;= angle[1] - angle[2] &lt;= 2.1)</code></pre><hr/><h5 id="Delete-Constraints"><a class="docs-heading-anchor" href="#Delete-Constraints">Delete Constraints</a><a id="Delete-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Constraints" title="Permalink"></a></h5><p>To delete a constraint, users can utilize the <a href="https://jump.dev/JuMP.jl/stable/reference/constraints/#JuMP.delete"><code>delete</code></a> function from the JuMP package. When dealing with constraints created internally, users can utilize the constraint references stored in the <code>constraint</code> field of the <code>Model</code> type. For instance, to delete the first constraint that limits the voltage angle difference, the following code snippet can be employed:</p><pre><code class="language-julia hljs">JuMP.delete(model.jump, model.constraint.limit.angle[1])</code></pre><p>Additionally, if you need to delete constraints based on labels associated with buses, branches, or generators, you can easily define an index for the constraint using the labels stored in a dictionary. For example, let us say you want to delete the voltage angle difference limit constraint related to the second branch:</p><pre><code class="language-julia hljs">index = system.branch.label[2]
JuMP.delete(model.jump, model.constraint.limit.angle[index])</code></pre><p>It is worth noting that if the labels assigned to the buses, branches, or generators follow an increasing ordered set of integers, both approaches to deleting constraints are equivalent.</p><hr/><h2 id="ACObjectiveFunctionManual"><a class="docs-heading-anchor" href="#ACObjectiveFunctionManual">Objective Function</a><a id="ACObjectiveFunctionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACObjectiveFunctionManual" title="Permalink"></a></h2><p>The objective function of the AC optimal power flow is constructed using polynomial and linear piecewise cost functions of the generators, which are defined using the <a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.addReactiveCost!"><code>addReactiveCost!</code></a> functions. </p><p>In the provided example, the objective function that needs to be minimized to obtain the optimal values of the active and reactive power outputs of the generators and the bus voltage magnitudes and angles is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(model.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 active[1]² + 30.2 reactive[1]² + 10.3 reactive[2]² + 500 active[1] + 20 reactive[1] + 5.1 reactive[2] + helperActive[1] + 86.2</code></pre><hr/><h5 id="Change-Objective"><a class="docs-heading-anchor" href="#Change-Objective">Change Objective</a><a id="Change-Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Change-Objective" title="Permalink"></a></h5><p>The objective can be modified by the user using the <a href="https://jump.dev/JuMP.jl/stable/reference/objectives/#JuMP.set_objective_function"><code>set_objective_function</code></a> function from the JuMP package. Here is an example of how it can be done:</p><pre><code class="language-julia hljs">active = model.jump[:active]
helperActive = model.jump[:helperActive]
new = JuMP.@expression(model.jump, 1100.2 * active[1]^2 + 500 * active[1] + helperActive[1])

JuMP.set_objective_function(model.jump, new)</code></pre><hr/><h2 id="ACSetupPrimalStartingValuesManual"><a class="docs-heading-anchor" href="#ACSetupPrimalStartingValuesManual">Setup Primal Starting Values</a><a id="ACSetupPrimalStartingValuesManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACSetupPrimalStartingValuesManual" title="Permalink"></a></h2><p>There are two methods available to specify primal starting values for each variable: using the built-in function provided by JuMP or accessing and modifying values directly within the <code>voltage</code> and <code>power</code> fields of the <code>Model</code> type.</p><hr/><h5 id="Using-JuMP-Functions"><a class="docs-heading-anchor" href="#Using-JuMP-Functions">Using JuMP Functions</a><a id="Using-JuMP-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Using-JuMP-Functions" title="Permalink"></a></h5><p>One approach is to utilize the <a href="https://jump.dev/JuMP.jl/stable/reference/variables/#JuMP.set_start_value"><code>set_start_value</code></a> function from the JuMP package. This allows us to set primal starting values for the active power outputs of the generators and the bus voltage angles. Here is an example:</p><pre><code class="language-julia hljs">JuMP.set_start_value.(model.jump[:active], [0.0, 0.18])
JuMP.set_start_value.(model.jump[:reactive], [0.5, 0.1])
JuMP.set_start_value.(model.jump[:magnitude], [1.05, 1.0, 1.0])
JuMP.set_start_value.(model.jump[:angle], [0.17, 0.13, 0.14])</code></pre><p>To inspect the primal starting values that have been set, you can use the <a href="https://jump.dev/JuMP.jl/stable/reference/variables/#JuMP.start_value"><code>start_value</code></a> function from JuMP. Here is an example of how you can inspect the starting values for the active power outputs: We can inspect that starting values are set:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.start_value.(model.jump[:active])</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.18</code></pre><hr/><h5 id="Using-JuliaGrid-Variables"><a class="docs-heading-anchor" href="#Using-JuliaGrid-Variables">Using JuliaGrid Variables</a><a id="Using-JuliaGrid-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Using-JuliaGrid-Variables" title="Permalink"></a></h5><p>Alternatively, you can rely on the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function to assign starting values based on the <code>power</code> and <code>voltage</code> fields. By default, these values are initially defined according to the active and reactive power outputs of the generators and the initial bus voltage magnitudes and angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [model.power.active model.power.reactive]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: type Power has no field active</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [model.voltage.magnitude model.voltage.angle]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 1.05  0.17
 1.0   0.0
 1.0   0.0</code></pre><p>You can modify these values, and they will be used as primal starting values during the execution of the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Please note that if primal starting values are set using the <code>set_start_value</code> function or any other method prior to executing the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function, the values in the <code>power</code> and <code>voltage</code> fields will be ignored. This is because the starting point will be considered already defined.</p></div></div><hr/><h5 id="Using-AC-Power-Flow"><a class="docs-heading-anchor" href="#Using-AC-Power-Flow">Using AC Power Flow</a><a id="Using-AC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Using-AC-Power-Flow" title="Permalink"></a></h5><p>Another approach is to perform the AC power flow and use the resulting solution to set primal starting values. Here is an example of how it can be done:</p><pre><code class="language-julia hljs">powerFlow = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, powerFlow)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, powerFlow)
end</code></pre><p>After obtaining the solution, we can calculate the active and reactive power outputs of the generators and utilize the bus voltage magnitudes and angles to set the starting values. In this case, the <code>power</code> and <code>voltage</code> fields of the <code>Model</code> type can be employed to store the new starting values:</p><pre><code class="language-julia hljs">for (key, value) in system.generator.label
    output = powerGenerator(system, powerFlow; label = key)
    model.power.generator.active[value] = output.active
    model.power.generator.reactive[value] = output.reactive
end

for i = 1:system.bus.number
    model.voltage.magnitude[i] = powerFlow.voltage.magnitude[i]
    model.voltage.angle[i] = powerFlow.voltage.angle[i]
end</code></pre><p>Also, the user can make use of the <a href="https://jump.dev/JuMP.jl/stable/reference/variables/#JuMP.set_start_value"><code>set_start_value</code></a> function to set starting values from the AC power flow.</p><hr/><h2 id="ACOptimalPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowSolutionManual">Optimal Power Flow Solution</a><a id="ACOptimalPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowSolutionManual" title="Permalink"></a></h2><p>To establish the AC optimal power flow problem, you can utilize the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function. After setting up the problem, you can use the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function to compute the optimal values for the active and reactive power outputs of the generators and the bus voltage magnitudes angles. Here is an example:</p><pre><code class="language-julia hljs">solve!(system, model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit https://github.com/coin-or/Ipopt
******************************************************************************

This is Ipopt version 3.14.4, running with linear solver MUMPS 5.4.1.

Number of nonzeros in equality constraint Jacobian...:       42
Number of nonzeros in inequality constraint Jacobian.:       50
Number of nonzeros in Lagrangian Hessian.............:      187

Total number of variables............................:       11
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:        8
Total number of inequality constraints...............:       26
        inequality constraints with only lower bounds:        9
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       17

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  0.0000000e+00 1.09e+01 1.18e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1 -1.3068620e+00 1.09e+01 1.17e+01  -1.0 9.78e+00    -  1.08e-02 1.10e-02h  1
   2 -3.8169047e+00 1.02e+01 1.22e+01  -1.0 1.10e+01    -  2.48e-02 6.17e-02f  1
   3  3.3498171e+01 2.46e-03 1.21e+00  -1.0 1.03e+01    -  1.00e+00 1.00e+00h  1
   4  1.6096860e+01 3.58e-04 1.38e+00  -1.0 1.58e+00    -  9.19e-01 1.00e+00f  1
   5  1.2304825e+01 1.12e-05 3.08e-02  -1.0 1.07e+00    -  1.00e+00 1.00e+00f  1
   6  1.0957844e+01 2.04e-06 5.30e-01  -2.5 5.67e-01    -  1.00e+00 9.49e-01f  1
   7  1.0962297e+01 1.16e-06 4.25e-03  -2.5 7.78e-03    -  1.00e+00 1.00e+00f  1
   8  1.0935048e+01 9.16e-07 1.07e-03  -3.8 1.34e-02    -  1.00e+00 1.00e+00f  1
   9  1.0933445e+01 1.37e-04 3.24e-03  -5.7 1.44e-02    -  8.82e-01 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.0933213e+01 4.60e-04 5.20e-05  -5.7 2.64e-02    -  1.00e+00 1.00e+00h  1
  11  1.0933281e+01 3.80e-05 3.07e-06  -5.7 7.54e-03    -  1.00e+00 1.00e+00h  1
  12  1.0933287e+01 1.58e-06 1.10e-07  -5.7 1.54e-03    -  1.00e+00 1.00e+00h  1
  13  1.0933267e+01 3.09e-06 3.68e-06  -8.6 2.16e-03    -  9.87e-01 1.00e+00h  1
  14  1.0933268e+01 2.74e-08 1.35e-09  -8.6 2.03e-04    -  1.00e+00 1.00e+00h  1
  15  1.0933268e+01 1.52e-12 8.31e-14  -8.6 1.52e-06    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 15

                                   (scaled)                 (unscaled)
Objective...............:   2.1866535817447388e+00    1.0933267908723693e+01
Dual infeasibility......:   8.3117869215524904e-14    4.1558934607762452e-13
Constraint violation....:   1.5244056017493790e-12    1.5244056017493790e-12
Variable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00
Complementarity.........:   2.5059857577788005e-09    1.2529928788894003e-08
Overall NLP error.......:   2.5059857577788005e-09    1.2529928788894003e-08


Number of objective function evaluations             = 16
Number of objective gradient evaluations             = 16
Number of equality constraint evaluations            = 16
Number of inequality constraint evaluations          = 16
Number of equality constraint Jacobian evaluations   = 16
Number of inequality constraint Jacobian evaluations = 16
Number of Lagrangian Hessian evaluations             = 15
Total seconds in IPOPT                               = 3.587

EXIT: Optimal Solution Found.</code></pre><p>By executing this function, you will obtain the solution with the optimal values for the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [model.power.active model.power.reactive]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: type Power has no field active</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [model.voltage.magnitude model.voltage.angle]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 1.05     0.17
 1.00745  0.212023
 1.01106  0.168884</code></pre><hr/><h5 id="Objective-Value"><a class="docs-heading-anchor" href="#Objective-Value">Objective Value</a><a id="Objective-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Value" title="Permalink"></a></h5><p>To obtain the objective value of the optimal power flow solution, you can use the <a href="https://jump.dev/JuMP.jl/stable/reference/solutions/#JuMP.objective_value"><code>objective_value</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_value(model.jump)</code><code class="nohighlight hljs ansi" style="display:block;">10.933267908723693</code></pre><hr/><h5 id="Silent-Solver-Output"><a class="docs-heading-anchor" href="#Silent-Solver-Output">Silent Solver Output</a><a id="Silent-Solver-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Silent-Solver-Output" title="Permalink"></a></h5><p>To turn off the solver output within the REPL, you can use the <a href="https://jump.dev/JuMP.jl/stable/reference/models/#JuMP.set_silent"><code>set_silent</code></a> function before calling <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function. This will suppress the solver&#39;s output:</p><pre><code class="language-julia hljs">JuMP.set_silent(model.jump)</code></pre><hr/><h2 id="ACOptimalPowerCurrentAnalysisManual"><a class="docs-heading-anchor" href="#ACOptimalPowerCurrentAnalysisManual">Power and Current Analysis</a><a id="ACOptimalPowerCurrentAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerCurrentAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the AC optimal power flow, we can calculate various electrical quantities related to buses, branches, and generators using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, ACAnalysis}"><code>current!</code></a> functions. For instance, let us consider the power system for which we obtained the AC optimal power flow solution:</p><pre><code class="language-julia hljs">system = powerSystem()

@bus(minMagnitude = 0.9, maxMagnitude = 1.1)
addBus!(system; label = 1, type = 3, magnitude = 1.05, angle = 0.17)
addBus!(system; label = 2, active = 0.1, reactive = 0.01, conductance = 0.04)
addBus!(system; label = 3, active = 0.05, reactive = 0.02)

@branch(minDiffAngle = -pi, maxDiffAngle = pi, resistance = 0.5, susceptance = 0.01)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 1.0, longTerm = 0.15)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 1.0, longTerm = 0.10)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 1.0, longTerm = 0.25)

@generator(minActive = 0.0, minReactive = -0.1, maxReactive = 0.1)
addGenerator!(system; label = 1, bus = 1, active = 3.2, reactive = 0.5, maxActive = 0.5)
addGenerator!(system; label = 2, bus = 2, active = 0.2, reactive = 0.1, maxActive = 0.2)

addActiveCost!(system; label = 1, model = 2, polynomial = [1100.2; 500; 80])
addActiveCost!(system; label = 2, model = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])

addReactiveCost!(system; label = 1, model = 2, polynomial = [30.2; 20; 5])
addReactiveCost!(system; label = 2, model = 2, polynomial = [10.3; 5.1; 1.2])

acModel!(system)

model = acOptimalPowerFlow(system, Ipopt.Optimizer)
JuMP.set_silent(model.jump)

solve!(system, model)</code></pre><p>We can now utilize the provided functions to compute powers and currents. The following functions can be used for this purpose:</p><pre><code class="language-julia hljs">power!(system, model)
current!(system, model)</code></pre><p>For instance, if we want to show the active power injections at each bus and the current flow magnitudes at each &quot;from&quot; bus end of the branch, we can employ the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -9.523358542734561e-9
  0.10000000808891524
 -0.049999999999999684</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.current.from.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.04678438562671875
 0.025404705739790895
 0.036522381708935944</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers and current associated with buses and branches that are calculated by the <a href="manual/@ref power(::PowerSystem, ::ACPowerFlow)"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, ACAnalysis}"><code>current!</code></a> functions, we suggest referring to the tutorials on <a href="../../tutorials/acOptimalPowerFlow/#ACOptimalPowerAnalysisTutorials">AC optimal power flow analysis</a>.</p></div></div><hr/><h5 id="Powers-and-Currents-Related-to-Bus"><a class="docs-heading-anchor" href="#Powers-and-Currents-Related-to-Bus">Powers and Currents Related to Bus</a><a id="Powers-and-Currents-Related-to-Bus-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-and-Currents-Related-to-Bus" title="Permalink"></a></h5><p>To calculate specific quantities for particular components rather than calculating powers or currents for all components, users can utilize the following functions.</p><p>To calculate active and reactive power injections associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerInjection(system, model; label = 1)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Cartesian(-9.523358542734561e-9, -0.06724438370197126)</code></pre><p>To calculate active and reactive power injections from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerSupply(system, model; label = 1)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Cartesian(-9.523358904434632e-9, -0.06724438370197139)</code></pre><p>To calculate active and reactive powers associated with shunt element at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerShunt(system, model; label = 1)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Cartesian(0.0, 0.0)</code></pre><p>To calculate current injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; currentInjection(system, model; label = 1)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Polar(0.06404227019235421, 1.7407964684180037)</code></pre><hr/><h5 id="Powers-and-Currents-Related-to-Branch"><a class="docs-heading-anchor" href="#Powers-and-Currents-Related-to-Branch">Powers and Currents Related to Branch</a><a id="Powers-and-Currents-Related-to-Branch-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-and-Currents-Related-to-Branch" title="Permalink"></a></h5><p>Similarly, we can compute the active and reactive power flows at &quot;from&quot; bus end of the particular branch using the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerFrom(system, model; label = 2)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Cartesian(0.01648669099112411, -0.020970014281001377)</code></pre><p>Next, we can compute the active and reactive power flows at &quot;to&quot; bus end of the particular branch using the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerTo(system, model; label = 2)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Cartesian(-0.01625506027566635, 0.010333238640118975)</code></pre><p>To calculate the total reactive power injection by the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerCharging(system, model; label = 2)</code><code class="nohighlight hljs ansi" style="display:block;">0.011100037071797615</code></pre><p>To calculate active and reactive power losses at the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerLoss(system, model; label = 2)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Cartesian(0.00023163071545767482, 0.00046326143091534965)</code></pre><p>Further, we can compute the current at &quot;from&quot; bus end of the particular branch using the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; currentFrom(system, model; label = 2)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Polar(0.025404705739790895, 1.0745249067113736)</code></pre><p>To calculate the current at &quot;to&quot; bus end of the particular branch using the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; currentTo(system, model; label = 2)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Polar(0.01822063004276105, -2.4271583271545336)</code></pre><p>To calculate the current through series impedance of the branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; currentLine(system, model; label = 2)</code><code class="nohighlight hljs ansi" style="display:block;">JuliaGrid.Polar(0.021523508796554285, 0.9231913568995797)</code></pre><hr/><hr/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dcPowerFlow/">« DC Power Flow</a><a class="docs-footer-nextpage" href="../dcOptimalPowerFlow/">DC Optimal Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 1 August 2023 11:11">Tuesday 1 August 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
