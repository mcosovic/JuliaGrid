<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC State Estimation · JuliaGrid</title><meta name="title" content="DC State Estimation · JuliaGrid"/><meta property="og:title" content="DC State Estimation · JuliaGrid"/><meta property="twitter:title" content="DC State Estimation · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li class="is-active"><a class="tocitem" href>DC State Estimation</a><ul class="internal"><li><a class="tocitem" href="#DCSEBusTypeModificationManual"><span>Bus Type Modification</span></a></li><li><a class="tocitem" href="#DCSEObservabilityAnalysisManual"><span>Observability Analysis</span></a></li><li><a class="tocitem" href="#DCWLSStateEstimationSolutionManual"><span>WLS State Estimation Solution</span></a></li><li><a class="tocitem" href="#DCBadDataDetectionManual"><span>Bad Data Detection</span></a></li><li><a class="tocitem" href="#DCLAVtateEstimationSolutionManual"><span>LAV State Estimation Solution</span></a></li><li><a class="tocitem" href="#DCMeasurementsAlterationManual"><span>Measurement Set Alteration</span></a></li><li><a class="tocitem" href="#DCSEPowerAnalysisManual"><span>Power Analysis</span></a></li><li><a class="tocitem" href="#DCStateEstimationReferenceManual"><span>References</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>DC State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/dcStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DCStateEstimationManual"><a class="docs-heading-anchor" href="#DCStateEstimationManual">DC State Estimation</a><a id="DCStateEstimationManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCStateEstimationManual" title="Permalink"></a></h1><p>To perform the DC power flow, you first need to have the <code>PowerSystem</code> composite type that has been created with the <code>dc</code> model, alongside the <code>Measurement</code> composite type that retains measurement data. Subsequently, we can formulate the DC state estimation model encapsulated within the abstract type <code>DCStateEstimation</code> using the subsequent function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a>.</li></ul><p>For resolving the DC state estimation problem employing either the weighted least-squares (WLS) or the least absolute value (LAV) approach and obtaining bus voltage angles, utilize the following function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS}"><code>solve!</code></a>.</li></ul><p>After obtaining the solution for DC state estimation, JuliaGrid offers a post-processing analysis function to compute active powers associated with buses and branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a>.</li></ul><p>Additionally, there are specialized functions dedicated to calculating specific types of active powers related to particular buses or branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, AC}"><code>injectionPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, ACPowerFlow}"><code>supplyPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, DC}"><code>fromPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, DC}"><code>toPower</code></a>.</li></ul><p>Furthermore, users can initiate observability analysis to detect observable islands and restore observability before executing the function <a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a>:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.islandTopologicalFlow-Tuple{PowerSystem, Wattmeter}"><code>islandTopologicalFlow</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.islandTopological-Tuple{PowerSystem, Wattmeter}"><code>islandTopological</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, IslandWatt}"><code>restorationGram!</code></a>.</li></ul><p>Finally, after executing the function <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS}"><code>solve!</code></a>, where the user employs the WLS method, the user has the ability to check if the measurement set contains outliers throughout bad data analysis and remove those measurements using:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.residualTest!"><code>residualTest!</code></a>.</li></ul><hr/><h2 id="DCSEBusTypeModificationManual"><a class="docs-heading-anchor" href="#DCSEBusTypeModificationManual">Bus Type Modification</a><a id="DCSEBusTypeModificationManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEBusTypeModificationManual" title="Permalink"></a></h2><p>Similar to the explanation provided in the <a href="../dcPowerFlow/#DCBusTypeModificationManual">Bus Type Modification</a> section, when executing the <a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a> function, the initially designated slack bus undergoes evaluation and may be adjusted. If the bus designated as the slack bus (<code>type = 3</code>) lacks a connected in-service generator, its type will be changed to the demand bus (<code>type = 1</code>). Conversely, the first generator bus (<code>type = 2</code>) with an active in-service generator linked to it will be reassigned as the new slack bus (<code>type = 3</code>).</p><hr/><h2 id="DCSEObservabilityAnalysisManual"><a class="docs-heading-anchor" href="#DCSEObservabilityAnalysisManual">Observability Analysis</a><a id="DCSEObservabilityAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEObservabilityAnalysisManual" title="Permalink"></a></h2><p>To initiate the power system with measurements at specific locations, follow the provided example code:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.05)
addBus!(system; label = &quot;Bus 4&quot;, type = 1, active = 0.05)
addBus!(system; label = &quot;Bus 5&quot;, type = 1, active = 0.05)
addBus!(system; label = &quot;Bus 6&quot;, type = 1, active = 0.05)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 3&quot;, to = &quot;Bus 5&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 4&quot;, from = &quot;Bus 3&quot;, to = &quot;Bus 4&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 5&quot;, from = &quot;Bus 5&quot;, to = &quot;Bus 6&quot;, reactance = 0.01)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2)

device = measurement()

@wattmeter(label = &quot;Wattmeter ?: !&quot;)
addWattmeter!(system, device; from = &quot;Branch 1&quot;, active = 0.31, variance = 1e-4)
addWattmeter!(system, device; from = &quot;Branch 3&quot;, active = 0.09, variance = 1e-4)
addWattmeter!(system, device; bus = &quot;Bus 3&quot;, active = -0.05, variance = 1e-4)
addWattmeter!(system, device; bus = &quot;Bus 3&quot;, active = -0.05, variance = 1e-4)</code></pre><p>Attempting to solve this system immediately may not be possible because the gain matrix will be singular. To avoid this situation, users can perform observability analysis. The first step is to define the observable islands. JuliaGrid provides users with the option to obtain two types of observable islands: flow observable islands or maximal observable islands. The choice depends on the structure of the power system and available measurements. Detecting just flow observable islands reduces complexity in the island detection function but increases complexity in the restoration function. </p><hr/><h5 id="Flow-Observable-Islands"><a class="docs-heading-anchor" href="#Flow-Observable-Islands">Flow Observable Islands</a><a id="Flow-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Flow-Observable-Islands" title="Permalink"></a></h5><p>Now, let us identify flow observable islands:</p><pre><code class="language-julia hljs">flowIslands = islandTopologicalFlow(system, device.wattmeter)</code></pre><p>As a result, we have identified four flow observable islands. The first island is formed by <code>Bus 1</code> and <code>Bus 2</code>, the second island is formed by <code>Bus 3</code> and <code>Bus 5</code>, while <code>Bus 4</code> and <code>Bus 6</code> constitute the third and fourth islands, respectively:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; flowIslands.island</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 5]
 [4]
 [6]</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><hr/><h5 id="Maximal-Observable-Islands"><a class="docs-heading-anchor" href="#Maximal-Observable-Islands">Maximal Observable Islands</a><a id="Maximal-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-Observable-Islands" title="Permalink"></a></h5><p>Following that, we will instruct the user on obtaining maximal observable islands:</p><pre><code class="language-julia hljs">maxIslands = islandTopological(system, device.wattmeter)</code></pre><p>The outcome reveals the identification of two maximal observable islands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; maxIslands.island</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Vector{Int64}}:
 [1, 2, 3, 5, 4]
 [6]</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>It is evident that upon comparing this result with the flow observable islands, the merging of the two injection measurements at <code>Bus 3</code> consolidated the first, second, and third flow observable islands into a single island.</p><hr/><h5 id="Restore-Observability"><a class="docs-heading-anchor" href="#Restore-Observability">Restore Observability</a><a id="Restore-Observability-1"></a><a class="docs-heading-anchor-permalink" href="#Restore-Observability" title="Permalink"></a></h5><p>To reinstate observability, the user needs to identify either flow or maximal observable islands and establish a set of pseudo-measurements. Let us create that set:</p><pre><code class="language-julia hljs">pseudo = measurement()

addWattmeter!(system, pseudo; label = &quot;Pseudo 1&quot;, bus = &quot;Bus 1&quot;, active = 0.31)
addWattmeter!(system, pseudo; label = &quot;Pseudo 2&quot;, bus = &quot;Bus 6&quot;, active = -0.05)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The labels for specific pseudo-measurements must differ from those defined in the measurements stored in the <code>device</code> set. This is necessary because the next step involves adding pseudo-measurements to the <code>device</code> set.</p></div></div><p>Subsequently, the user can execute the <a href="../../api/stateEstimation/#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, IslandWatt}"><code>restorationGram!</code></a> function:</p><pre><code class="language-julia hljs">restorationGram!(system, device, pseudo, maxIslands)</code></pre><p>This function attempts to restore observability using pseudo-measurements. As a result, the <code>Pseudo 2</code> measurement restores observability, and this measurement is added to the device variable, which holds actual measurements:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; device.wattmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 5 entries:
  &quot;Wattmeter 1: From Branch 1&quot; =&gt; 1
  &quot;Wattmeter 2: From Branch 3&quot; =&gt; 2
  &quot;Wattmeter 3: Bus 3&quot;         =&gt; 3
  &quot;Wattmeter 4: Bus 3&quot;         =&gt; 4
  &quot;Pseudo 2&quot;                   =&gt; 5</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Consequently, the power system becomes observable, allowing the user to proceed with forming the DC state estimation model and solving it. Ensuring the observability of the system does not guarantee obtaining accurate estimates of the state variables. Numerical ill-conditioning may adversely impact the state estimation algorithm. However, in most cases, efficient estimation becomes feasible when the system is observable. <a href="#DCStateEstimationReferenceManual">[1]</a>. </p><p>Additionally, it is worth mentioning that restoration might encounter difficulties due to the default zero pivot threshold set at <code>1e-5</code>. This threshold can be modified using the <a href="../../api/stateEstimation/#JuliaGrid.restorationGram!-Tuple{PowerSystem, Measurement, Measurement, IslandWatt}"><code>restorationGram!</code></a> function.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Additionally, during the restoration step, the user can define bus voltage angle measurements from PMUs that will also participate in the restoration step. In this case, the system can become observable even if there are still more islands.</p></div></div><hr/><h2 id="DCWLSStateEstimationSolutionManual"><a class="docs-heading-anchor" href="#DCWLSStateEstimationSolutionManual">WLS State Estimation Solution</a><a id="DCWLSStateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCWLSStateEstimationSolutionManual" title="Permalink"></a></h2><p>To solve the DC state estimation and derive WLS estimates using JuliaGrid, the process initiates by defining the composite types <code>PowerSystem</code> and <code>Measurement</code>. Here is an illustrative example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.05)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2)
dcModel!(system)

device = measurement()

@wattmeter(label = &quot;Wattmeter ?&quot;)
addWattmeter!(system, device; bus = &quot;Bus 1&quot;, active = 0.13, variance = 1e-3)
addWattmeter!(system, device; bus = &quot;Bus 3&quot;, active = -0.02, variance = 1e-2)
addWattmeter!(system, device; from = &quot;Branch 1&quot;, active = 0.04, variance = 1e-4)
addWattmeter!(system, device; to = &quot;Branch 2&quot;, active = -0.11, variance = 1e-4)</code></pre><p>The <a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a> function serves to establish the DC state estimation problem:  </p><pre><code class="language-julia hljs">analysis = dcStateEstimation(system, device)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Here, the user triggers LU factorization as the default method for solving the DC state estimation problem. However, the user also has the option to select alternative factorization methods such as <code>LDLt</code> or <code>QR</code>, for instance.</p></div></div><p>To obtain the bus voltage angles, the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS}"><code>solve!</code></a> function can be invoked as shown:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Upon obtaining the solution, access the bus voltage angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: -0.001091576935958354
Bus 3: -0.0010497271431987403</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that readers refer to the tutorial on <a href="../../tutorials/dcStateEstimation/#DCSEModelTutorials">DC State Estimation</a> for insights into the implementation.</p></div></div><hr/><h5 id="Orthogonal-Factorization"><a class="docs-heading-anchor" href="#Orthogonal-Factorization">Orthogonal Factorization</a><a id="Orthogonal-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonal-Factorization" title="Permalink"></a></h5><p>When users opt for orthogonal factorization, specifying the <code>QR</code> argument in the <a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a> function, they are not solely choosing to solve the WLS problem using QR factorization. Instead, JuliaGrid implements a more robust approach to obtain the WLS estimator, especially beneficial when significant differences exist among measurement variances <a href="#DCStateEstimationReferenceManual">[2, Sec. 3.2]</a>. To derive this estimator, execute the following sequence of functions:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(system, device, QR)
solve!(system, analysis)</code></pre><hr/><h2 id="DCBadDataDetectionManual"><a class="docs-heading-anchor" href="#DCBadDataDetectionManual">Bad Data Detection</a><a id="DCBadDataDetectionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCBadDataDetectionManual" title="Permalink"></a></h2><p>After acquiring the WLS solution using the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS}"><code>solve!</code></a> function, users can conduct bad data analysis employing the largest normalized residual test. Continuing with our defined power system and measurement set, let us introduce a new wattmeter. Upon proceeding to find the solution for this updated state:</p><pre><code class="language-julia hljs">addWattmeter!(system, device; from = &quot;Branch 2&quot;, active = 4.1, variance = 1e-4)

analysis = dcStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>Following the solution acquisition, we can verify the presence of erroneous data. Detection of such data is determined by the <code>threshold</code> keyword. If the largest normalized residual&#39;s value exceeds the threshold, the measurement will be identified as bad data and consequently removed from the DC state estimation model:</p><pre><code class="language-julia hljs">residualTest!(system, device, analysis; threshold = 4.0)</code></pre><p>Users can examine the data obtained from the bad data analysis:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.bad.detect</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.bad.maxNormalizedResidual</code><code class="nohighlight hljs ansi" style="display:block;">291.440585315187</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.bad.label</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Wattmeter 5&quot;</code></pre><p>Therefore, upon detecting bad data, the <code>detect</code> variable will hold <code>true</code>. The <code>maxNormalizedResidual</code> variable retains the value of the largest normalized residual, while the <code>label</code> contains the label of the measurement identified as bad data.</p><p>JuliaGrid optimizes the algorithm for efficiency by not outright removing measurements from matrices and vectors. Instead, it sets non-zero elements to zero. The variable <code>index</code> contains positions within the vectors <code>weight</code> and <code>mean</code> that will be reset to zero. Additionally, it stores the row index within the coefficient matrix where non-zero elements will be adjusted to zero. Here is an example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.bad.index</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.coefficient</code><code class="nohighlight hljs ansi" style="display:block;">5×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 12 stored entries:
  120.0   -20.0  -100.0
 -100.0  -100.0   200.0
   20.0   -20.0      ⋅
 -100.0      ⋅    100.0
    0.0      ⋅      0.0</code></pre><p>Hence, after removing bad data, a new estimate can be computed without considering this specific measurement:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><hr/><h2 id="DCLAVtateEstimationSolutionManual"><a class="docs-heading-anchor" href="#DCLAVtateEstimationSolutionManual">LAV State Estimation Solution</a><a id="DCLAVtateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCLAVtateEstimationSolutionManual" title="Permalink"></a></h2><p>The LAV method presents an alternative estimation technique known for its increased robustness compared to WLS. While the WLS method relies on specific assumptions regarding measurement errors, robust estimators like LAV are designed to maintain unbiasedness even in the presence of various types of measurement errors and outliers. This characteristic often eliminates the need for extensive bad data processing procedures <a href="#DCStateEstimationReferenceManual">[2, Ch. 6]</a>. However, it is important to note that achieving robustness typically involves increased computational complexity.</p><p>To obtain an LAV estimator, users need to employ one of the <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> listed in the JuMP documentation. In many common scenarios, the Ipopt solver proves sufficient to obtain a solution:</p><pre><code class="language-julia hljs">using Ipopt

analysis = dcStateEstimation(system, device, Ipopt.Optimizer)
solve!(system, analysis)</code></pre><hr/><h5 id="Setup-Starting-Primal-Values"><a class="docs-heading-anchor" href="#Setup-Starting-Primal-Values">Setup Starting Primal Values</a><a id="Setup-Starting-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Starting-Primal-Values" title="Permalink"></a></h5><p>In JuliaGrid, the assignment of starting primal values for optimization variables takes place when the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS}"><code>solve!</code></a> function is executed. Starting primal values are determined based on the <code>voltage</code> fields within the <code>DCStateEstimation</code> type. By default, these values are initially established using the the initial bus voltage angles from <code>PowerSystem</code> type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: -0.00034082770434906706
Bus 3: -0.00022957414330448955</code></pre><p>You have the flexibility to adjust these values to your specifications, and they will be utilized as the starting primal values when you run the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS}"><code>solve!</code></a> function.</p><hr/><h2 id="DCMeasurementsAlterationManual"><a class="docs-heading-anchor" href="#DCMeasurementsAlterationManual">Measurement Set Alteration</a><a id="DCMeasurementsAlterationManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCMeasurementsAlterationManual" title="Permalink"></a></h2><p>After users define the <code>Measurement</code> type using the <a href="../../api/measurementModel/#JuliaGrid.measurement"><code>measurement</code></a> function and the <code>DCStateEstimation</code> type using the <a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a> function, they acquire the capability to modify measurements. As a result, there is no need to recreate the <code>DCStateEstimation</code> model from scratch. This streamlined process is facilitated by directly supplying the <code>DCStateEstimation</code> type as an argument to functions responsible for updating measurement devices. </p><p>The addition of new measurements after the creation of <code>DCStateEstimation</code> is not practical in terms of reusing the <code>DCStateEstimation</code> type. Instead, we recommend that users create a final set of measurements and then utilize update functions to manage devices, either putting them in-service or out-of-service throughout the process.</p><hr/><h5 id="Reusing-WLS-Matrix-Factorization"><a class="docs-heading-anchor" href="#Reusing-WLS-Matrix-Factorization">Reusing WLS Matrix Factorization</a><a id="Reusing-WLS-Matrix-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Reusing-WLS-Matrix-Factorization" title="Permalink"></a></h5><p>To elaborate further, let us continue with the previous example, where we establish a measurement set. Once again, we create the <code>DCStateEstimation</code> measurement model in the WLS framework and solve the problem:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>Now, our objective is to find a solution that involves modifications such as altering measurement values. For instance:</p><pre><code class="language-julia hljs">updateWattmeter!(system, device, analysis; label = &quot;Wattmeter 2&quot;, active = -0.015)
updateWattmeter!(system, device, analysis; label = &quot;Wattmeter 3&quot;, active = 0.03)</code></pre><p>These updates will affect both the <code>Measurement</code> and the <code>DCStateEstimation</code> types. Now, we can solve the problem once again: </p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>In this case, JuliaGrid will reuse the matrix factorization from the previous call of the <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}"><code>solve!</code></a> function, providing a more efficient solution.</p><hr/><h5 id="Sequential-WLS-Matrix-Factorization"><a class="docs-heading-anchor" href="#Sequential-WLS-Matrix-Factorization">Sequential WLS Matrix Factorization</a><a id="Sequential-WLS-Matrix-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Sequential-WLS-Matrix-Factorization" title="Permalink"></a></h5><p>If the user opts to modify the status of measurement devices or measurement variances, reusing the nodal matrix factorization becomes impractical. In this scenario, JuliaGrid will need to repeat the factorization step while ensuring the delivery of an accurate solution. Nevertheless, the user can effortlessly execute <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}"><code>solve!</code></a> as demonstrated below:</p><pre><code class="language-julia hljs">updateWattmeter!(system, device, analysis; label = &quot;Wattmeter 3&quot;, variance = 1e-3)

solve!(system, analysis)</code></pre><hr/><h5 id="LAV-State-Estimation"><a class="docs-heading-anchor" href="#LAV-State-Estimation">LAV State Estimation</a><a id="LAV-State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#LAV-State-Estimation" title="Permalink"></a></h5><p>Certainly, when a user creates an optimization problem using the LAV method, they can update measurement devices without the need to recreate the model from scratch, similar to the explanation provided for the WLS state estimation. This streamlined process allows for efficient modifications while retaining the existing optimization framework.</p><hr/><h2 id="DCSEPowerAnalysisManual"><a class="docs-heading-anchor" href="#DCSEPowerAnalysisManual">Power Analysis</a><a id="DCSEPowerAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEPowerAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the DC state estimation, calculating powers related to buses and branches is facilitated by using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> function. To illustrate this with a continuation of our previous example, we can compute active powers using the following function:</p><pre><code class="language-julia hljs">power!(system, analysis)</code></pre><p>For example, active power injections corresponding to buses are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.986036985598593
Bus 2: 1.880186915088157
Bus 3: -3.86622390068675</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers associated with buses, and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> function, we suggest referring to the tutorials on.</p></div></div><p>To calculate specific quantities related to particular buses or branches, rather than computing values for all buses and branches, users can utilize one of the provided functions below.</p><hr/><h5 id="Active-Power-Injection"><a class="docs-heading-anchor" href="#Active-Power-Injection">Active Power Injection</a><a id="Active-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection" title="Permalink"></a></h5><p>To calculate active power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = injectionPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">1.986036985598593</code></pre><hr/><h5 id="Active-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-Power-Injection-from-Generators">Active Power Injection from Generators</a><a id="Active-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate active power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = supplyPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">1.986036985598593</code></pre><hr/><h5 id="Active-Power-Flow"><a class="docs-heading-anchor" href="#Active-Power-Flow">Active Power Flow</a><a id="Active-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active power flow at both the &quot;from&quot; and &quot;to&quot; bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = fromPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">1.970915546954245</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = toPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">-1.970915546954245</code></pre><hr/><h2 id="DCStateEstimationReferenceManual"><a class="docs-heading-anchor" href="#DCStateEstimationReferenceManual">References</a><a id="DCStateEstimationReferenceManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCStateEstimationReferenceManual" title="Permalink"></a></h2><p>[1] G. N. Korres, <em>Observability analysis based on echelon form of a reduced dimensional Jacobian matrix</em>, IEEE Trans. Power Syst., vol. 26, no. 4, pp. 2572–2573, 2011. </p><p>[2] A. Abur and A. Exposito, <em>Power System State Estimation: Theory and Implementation</em>, ser. Power Engineering. Taylor &amp; Francis, 2004.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../measurementModel/">« Measurement Model</a><a class="docs-footer-nextpage" href="../../tutorials/acdcModel/">AC and DC Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 5 February 2024 13:40">Monday 5 February 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
