<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC Power Flow · JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li class="is-active"><a class="tocitem" href>AC Power Flow</a><ul class="internal"><li><a class="tocitem" href="#BusTypeModificationManual"><span>Bus Type Modification</span></a></li><li><a class="tocitem" href="#SetupStartingVoltagesManual"><span>Setup Starting Voltages</span></a></li><li><a class="tocitem" href="#ACPowerFlowSolutionManual"><span>Power Flow Solution</span></a></li><li><a class="tocitem" href="#ACPowerCurrentAnalysisManual"><span>Power and Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>AC Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/acPowerFlow.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ACPowerFlowManual"><a class="docs-heading-anchor" href="#ACPowerFlowManual">AC Power Flow</a><a id="ACPowerFlowManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerFlowManual" title="Permalink"></a></h1><p>To perform the AC power flow analysis, you will first need the <code>PowerSystem</code> composite type that has been created with the <code>ac</code> model. Then, you can create the <code>ACPowerFlow</code> abstract type using one of the following functions:</p><ul><li><a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>,</li><li><a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>,</li><li><a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>,</li><li><a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a>.</li></ul><p>These functions will set up the AC power flow framework. To obtain bus voltages and solve the power flow problem, you can use the following functions:</p><ul><li><a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>mismatch!</code></a>,</li><li><a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}"><code>solve!</code></a>.</li></ul><p>After obtaining the AC power flow solution, JuliaGrid offers post-processing analysis functions for calculating powers and currents associated with buses, branches, or generators:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a>.</li></ul><p>Furthermore, there are specialized functions dedicated to calculating specific types of powers related to particular buses, branches, or generators:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, AC}"><code>injectionPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, ACPowerFlow}"><code>supplyPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.shuntPower-Tuple{PowerSystem, AC}"><code>shuntPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, AC}"><code>fromPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, AC}"><code>toPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.seriesPower-Tuple{PowerSystem, AC}"><code>seriesPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.chargingPower-Tuple{PowerSystem, AC}"><code>chargingPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.generatorPower-Tuple{PowerSystem, ACPowerFlow}"><code>generatorPower</code></a>.</li></ul><p>Likewise, there are specialized functions dedicated to calculating specific types of currents related to particular buses or branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionCurrent-Tuple{PowerSystem, AC}"><code>injectionCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromCurrent-Tuple{PowerSystem, AC}"><code>fromCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toCurrent-Tuple{PowerSystem, AC}"><code>toCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.seriesCurrent-Tuple{PowerSystem, AC}"><code>seriesCurrent</code></a>.</li></ul><p>Additionally, the package provides two functions for reactive power limit validation of generators and adjusting the voltage angles to match an arbitrary bus angle:</p><ul><li><a href="../../api/powerFlow/#JuliaGrid.reactiveLimit!"><code>reactiveLimit!</code></a>,</li><li><a href="../../api/powerFlow/#JuliaGrid.adjustAngle!"><code>adjustAngle!</code></a>.</li></ul><hr/><h2 id="BusTypeModificationManual"><a class="docs-heading-anchor" href="#BusTypeModificationManual">Bus Type Modification</a><a id="BusTypeModificationManual-1"></a><a class="docs-heading-anchor-permalink" href="#BusTypeModificationManual" title="Permalink"></a></h2><p>Depending on how the system is constructed, the types of buses that are initially set are checked and can be changed during the initialization process, using one of the available functions such as <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a>. Assuming the Newton-Raphson method has been chosen, to explain the details, we can observe a power system with only buses and generators. The following code snippet can be used:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 2)
addBus!(system; label = &quot;Bus 3&quot;, type = 2)

addGenerator!(system; bus = &quot;Bus 2&quot;)

acModel!(system)

analysis = newtonRaphson(system)</code></pre><p>Initially, the <code>Bus 1</code> is set as the slack bus (<code>type = 3</code>), and the <code>Bus 2</code> and <code>Bus 3</code> are generator buses (<code>type = 2</code>). However, the <code>Bus 3</code> does not have a generator, and JuliaGrid considers this a mistake and changes the corresponding bus to a demand bus (<code>type = 1</code>).</p><p>After this step, JuliaGrid verifies the slack bus. Initially, the slack bus (<code>type = 3</code>) corresponds to <code>Bus 1</code>, but since it does not have an in-service generator connected to it, JuliaGrid recognizes it as an error. Therefore, JuliaGrid assigns a new slack bus from the available generator buses (<code>type = 2</code>) that have connected in-service generators. In this specific example, <code>Bus 2</code> becomes the new slack bus.</p><p>As a result, we can observe the updated array of bus types within the defined set of buses:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [collect(keys(sort(system.bus.label; byvalue = true))) system.bus.layout.type]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Any}:
 &quot;Bus 1&quot;  1
 &quot;Bus 2&quot;  3
 &quot;Bus 3&quot;  1</code></pre><p>Note that, if a bus is initially defined as the demand bus (<code>type = 1</code>) and later a generator is added to it, the bus type will not be changed to the generator bus (<code>type = 2</code>). Instead, it will remain as a demand bus.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The type of only those buses that are defined as generator buses (<code>type = 2</code>) but do not have a connected in-service generator will be changed to demand buses (<code>type = 1</code>).</p><p>The bus that is defined as the slack bus (<code>type = 3</code>) but lacks a connected in-service generator will have its type changed to the demand bus (<code>type = 1</code>). Meanwhile, the first generator bus (<code>type = 2</code>) with an in-service generator connected to it will be assigned as the new slack bus (<code>type = 3</code>).</p></div></div><hr/><h2 id="SetupStartingVoltagesManual"><a class="docs-heading-anchor" href="#SetupStartingVoltagesManual">Setup Starting Voltages</a><a id="SetupStartingVoltagesManual-1"></a><a class="docs-heading-anchor-permalink" href="#SetupStartingVoltagesManual" title="Permalink"></a></h2><p>To begin analysing the AC power flow in JuliaGrid, we must first establish the <code>PowerSystem</code> composite type and define the AC model by calling the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> function. Once the power system is set up, we can select one of the available methods for solving the AC power flow problem, such as <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a>. Assuming we have selected the Newton-Raphson method, we can use the following code snippet:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, magnitude = 1.0, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, magnitude = 0.9, angle = -0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 2, magnitude = 0.8, angle = -0.2)

addGenerator!(system; bus = &quot;Bus 1&quot;, magnitude = 1.3)
addGenerator!(system; bus = &quot;Bus 2&quot;, magnitude = 1.1)
addGenerator!(system; bus = &quot;Bus 3&quot;, magnitude = 1.2)

acModel!(system)

analysis = newtonRaphson(system)</code></pre><p>Here, in this code snippet, the function <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a> generates starting voltage vectors in polar coordinates, where the magnitudes and angles are constructed as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [analysis.voltage.magnitude analysis.voltage.angle]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 1.3   0.0
 0.9  -0.1
 1.2  -0.2</code></pre><p>The starting voltage magnitudes are determined by a combination of the initial values specified within the buses and the setpoints provided within the generators:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [system.bus.voltage.magnitude system.generator.voltage.magnitude]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 1.0  1.3
 0.9  1.1
 0.8  1.2</code></pre><p>On the other hand, the starting values for the voltage angles are defined based on the initial values given within the buses:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.1
 -0.2</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The rule governing the specification of starting voltage magnitudes is simple. If a bus has an in-service generator and is declared the generator bus (<code>type = 2</code>), then the starting voltage magnitudes are specified using the setpoint provided within the generator. This is because the generator bus has known values of voltage magnitude that are specified within the generator.</p><p>On the other hand, the slack bus (<code>type = 3</code>) always requires an in-service generator. The starting value of the voltage magnitude at the slack bus is determined exclusively by the setpoints provided within the generators connected to it. This is a result of the slack bus having a known voltage magnitude that must be maintained.</p></div></div><hr/><h5 id="Custom-Starting-Voltages"><a class="docs-heading-anchor" href="#Custom-Starting-Voltages">Custom Starting Voltages</a><a id="Custom-Starting-Voltages-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Starting-Voltages" title="Permalink"></a></h5><p>This method of specifying starting values has a significant advantage in that it allows the user to easily change the starting voltage magnitudes and angles, which play a crucial role in iterative methods. For instance, suppose we define our power system as follows:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, magnitude = 1.0, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, magnitude = 0.9, angle = -0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 2, magnitude = 0.8, angle = -0.2)

addGenerator!(system; bus = &quot;Bus 1&quot;, magnitude = 1.1)
addGenerator!(system; bus = &quot;Bus 3&quot;, magnitude = 1.2)

acModel!(system)</code></pre><p>Now, the user can initiate a &quot;flat start&quot; without interfering with the input data. This can be easily done as follows:</p><pre><code class="language-julia hljs">for i = 1:system.bus.number
    system.bus.voltage.magnitude[i] = 1.0
    system.bus.voltage.angle[i] = 0.0
end

analysis = newtonRaphson(system)</code></pre><p>The starting voltage values are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [analysis.voltage.magnitude analysis.voltage.angle]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 1.1  0.0
 1.0  0.0
 1.2  0.0</code></pre><p>Consequently, when using the Newton-Raphson method, the iteration begins with a fixed set of voltage magnitude values that remain constant throughout the process. The remaining values are initialized as part of the &quot;flat start&quot; approach.</p><hr/><h2 id="ACPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#ACPowerFlowSolutionManual">Power Flow Solution</a><a id="ACPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerFlowSolutionManual" title="Permalink"></a></h2><p>To solve the AC power flow problem using JuliaGrid, we first need to create the <code>PowerSystem</code> composite type and define the AC model by calling the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> function. Here is an example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)

addBranch!(system; from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, resistance = 0.01, reactance = 0.05)
addBranch!(system; from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, resistance = 0.02, reactance = 0.01)
addBranch!(system; from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, resistance = 0.01, reactance = 0.20)

addGenerator!(system; bus = &quot;Bus 1&quot;, active = 3.2, magnitude = 1.1)
addGenerator!(system; bus = &quot;Bus 2&quot;, active = 3.2, magnitude = 1.2)

acModel!(system)</code></pre><p>Once the AC model is defined, we can choose the method to solve the power flow problem. JuliaGrid provides four methods: <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, and <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a>. For example, to use the Newton-Raphson method to solve the power flow problem, we can call the <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a> function as follows:</p><pre><code class="language-julia hljs">analysis = newtonRaphson(system)</code></pre><p>This function sets up the desired method for an iterative process based on two functions: <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>mismatch!</code></a> and <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}"><code>solve!</code></a>. The <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>mismatch!</code></a> function calculates the active and reactive power injection mismatches using the given voltage magnitudes and angles, while <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, NewtonRaphson}"><code>solve!</code></a> computes the voltage magnitudes and angles.</p><p>To perform an iterative process with the Newton-Raphson or fast Newton-Raphson methods in JuliaGrid, the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>mismatch!</code></a> function must be included inside the iteration loop. For instance:</p><pre><code class="language-julia hljs">for iteration = 1:100
    mismatch!(system, analysis)
    solve!(system, analysis)
end</code></pre><p>Upon completion of the AC power flow analysis, the solution is conveyed through the bus voltage magnitudes and angles. Here are the values corresponding to the buses:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label = collect(keys(sort(system.bus.label; byvalue = true)));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [label analysis.voltage.magnitude analysis.voltage.angle]</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Any}:
 &quot;Bus 1&quot;  1.1      0.0
 &quot;Bus 2&quot;  1.11214  0.105644
 &quot;Bus 3&quot;  1.10239  0.00132581</code></pre><p>In contrast, the iterative loop of the Gauss-Seidel method does not require the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>mismatch!</code></a> function:</p><pre><code class="language-julia hljs">analysis = gaussSeidel(system)
for iteration = 1:100
    solve!(system, analysis)
end</code></pre><p>In these examples, the algorithms run until the specified number of iterations is reached.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that the reader refer to the tutorial on <a href="manual/@ref ACPowerFlowTutorials">AC power flow analysis</a>, where we explain the implementation of the methods and algorithm structures in detail.</p></div></div><hr/><h5 id="Breaking-the-Iterative-Process"><a class="docs-heading-anchor" href="#Breaking-the-Iterative-Process">Breaking the Iterative Process</a><a id="Breaking-the-Iterative-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Breaking-the-Iterative-Process" title="Permalink"></a></h5><p>You can terminate the iterative process using the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>mismatch!</code></a> function, which is why mismatches are computed separately. The following code shows an example of how to use the the function to break out of the iteration loop:</p><pre><code class="language-julia hljs">analysis = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end</code></pre><p>The <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, NewtonRaphson}"><code>mismatch!</code></a> function returns the maximum absolute values of active and reactive power injection mismatches, which are commonly used as a convergence criterion in iterative AC power flow algorithms. Note that the function can also be used to terminate the loop when using the Gauss-Seidel method, even though it is not required.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To ensure an accurate count of iterations, it is important for the user to place the iteration counter after the condition expressions within the if construct. Counting the iterations before this point can result in an incorrect number of iterations, as it leads to an additional iteration being performed.</p></div></div><hr/><h2 id="ACPowerCurrentAnalysisManual"><a class="docs-heading-anchor" href="#ACPowerCurrentAnalysisManual">Power and Current Analysis</a><a id="ACPowerCurrentAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerCurrentAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the AC power flow, we can calculate various electrical quantities related to buses, branches, and generators using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions. For instance, let us consider the power system for which we obtained the AC power flow solution:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05, susceptance = 0.03)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5, conductance = 0.02)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.04)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2)

acModel!(system)

analysis = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end</code></pre><p>We can now utilize the provided functions to compute powers and currents. The following functions can be used for this purpose:</p><pre><code class="language-julia hljs">power!(system, analysis)
current!(system, analysis)</code></pre><p>For instance, if we want to show the active power injections at each bus and the current flow angles at each &quot;to&quot; bus end of the branch, we can employ the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [collect(keys(sort(system.bus.label; byvalue = true))) analysis.power.injection.active]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Any}:
 &quot;Bus 1&quot;   0.528911
 &quot;Bus 2&quot;  -5.53986e-12
 &quot;Bus 3&quot;  -0.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [collect(keys(sort(system.branch.label; byvalue = true))) analysis.current.to.angle]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Any}:
 &quot;Branch 1&quot;   2.60136
 &quot;Branch 2&quot;  -2.89949
 &quot;Branch 3&quot;   3.11383</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers associated with buses, branches and generators that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions, we suggest referring to the tutorials on <a href="manual/@ref ACPowerAnalysisTutorials">AC power flow analysis</a>.</p></div></div><p>To calculate specific quantities for particular components rather than calculating powers or currents for all components, users can make use of the provided functions below.</p><hr/><h5 id="Active-and-Reactive-Power-Injection"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection">Active and Reactive Power Injection</a><a id="Active-and-Reactive-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection" title="Permalink"></a></h5><p>To calculate the active and reactive power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = injectionPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.5289114019107615, -0.08409787881071651)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection-from-Generators">Active and Reactive Power Injection from Generators</a><a id="Active-and-Reactive-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = supplyPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.0289114019107615, -0.08409787881071651)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Shunt-Element"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Shunt-Element">Active and Reactive Power at Shunt Element</a><a id="Active-and-Reactive-Power-at-Shunt-Element-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Shunt-Element" title="Permalink"></a></h5><p>To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = shuntPower(system, analysis; label = &quot;Bus 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.019347548006102597, -0.0)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Flow"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Flow">Active and Reactive Power Flow</a><a id="Active-and-Reactive-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active and reactive power flow at both the &quot;from&quot; and &quot;to&quot; bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = fromPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.37970481234852116, -0.13358097327102314)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = toPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-0.3764646858706327, 0.09540807848774045)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Charging-Admittances"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Charging-Admittances">Active and Reactive Power at Charging Admittances</a><a id="Active-and-Reactive-Power-at-Charging-Admittances-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Charging-Admittances" title="Permalink"></a></h5><p>To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = chargingPower(system, analysis; label = &quot;Branch 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(9.935819730892471e-5, -0.03974327892356988)</code></pre><p>Active powers indicate active losses within the branch&#39;s charging or shunt admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.</p><hr/><h5 id="Active-and-Reactive-Power-at-Series-Impedance"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Series-Impedance">Active and Reactive Power at Series Impedance</a><a id="Active-and-Reactive-Power-at-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Series-Impedance" title="Permalink"></a></h5><p>To calculate the active and reactive power across the series impedance of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = seriesPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0031407682805716475, 0.001570384140285824)</code></pre><p>The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance&#39;s inductive characteristics.</p><hr/><h5 id="Generator-Active-and-Reactive-Power-Output"><a class="docs-heading-anchor" href="#Generator-Active-and-Reactive-Power-Output">Generator Active and Reactive Power Output</a><a id="Generator-Active-and-Reactive-Power-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Active-and-Reactive-Power-Output" title="Permalink"></a></h5><p>We can compute the active and reactive power output of a particular generator using the function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = generatorPower(system, analysis; label = &quot;Generator 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.0289114019107615, -0.08409787881071651)</code></pre><hr/><h5 id="Current-Injection"><a class="docs-heading-anchor" href="#Current-Injection">Current Injection</a><a id="Current-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injection" title="Permalink"></a></h5><p>To calculate the current injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = injectionCurrent(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.5355555286724888, 0.1576818525442221)</code></pre><hr/><h5 id="Current-Flow"><a class="docs-heading-anchor" href="#Current-Flow">Current Flow</a><a id="Current-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow" title="Permalink"></a></h5><p>We can compute the current flow at both the &quot;from&quot; and &quot;to&quot; bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = fromCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.4025166095214699, 0.3382794044015979)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = toCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.3908830725090306, -2.899494319515784)</code></pre><hr/><h5 id="Current-Through-Series-Impedance"><a class="docs-heading-anchor" href="#Current-Through-Series-Impedance">Current Through Series Impedance</a><a id="Current-Through-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Through-Series-Impedance" title="Permalink"></a></h5><p>To calculate the current passing through the series impedance of the branch in the direction from the &quot;from&quot; bus end to the &quot;to&quot; bus end, you can use the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = seriesCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.3962807262895615, 0.2906942898121559)</code></pre><hr/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powerSystemModel/">« Power System Model</a><a class="docs-footer-nextpage" href="../dcPowerFlow/">DC Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 31 August 2023 11:11">Thursday 31 August 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
