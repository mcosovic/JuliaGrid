<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC Optimal Power Flow · JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>DC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#DCOptimizationVariablesManual"><span>Optimization Variables</span></a></li><li><a class="tocitem" href="#DCConstraintFunctionsManual"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#DCObjectiveFunctionManual"><span>Objective Function</span></a></li><li><a class="tocitem" href="#SetupPrimalStartingValuesManual"><span>Setup Primal Starting Values</span></a></li><li><a class="tocitem" href="#DCOptimalPowerFlowSolutionManual"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#DCOptimalPowerAnalysisManual"><span>Power Analysis</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/dcOptimalPowerFlow.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DCOptimalPowerFlowManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowManual">DC Optimal Power Flow</a><a id="DCOptimalPowerFlowManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowManual" title="Permalink"></a></h1><p>Similar to <a href="../acOptimalPowerFlow/#ACOptimalPowerFlowManual">AC Optimal Power Flow</a>, JuliaGrid utilizes the <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> package to construct optimal power flow models, enabling users to manipulate these models using the standard functions provided by JuMP. JuliaGrid supports popular <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> mentioned in the JuMP documentation to solve the optimization problem.</p><p>To perform the DC optimal power flow, you first need to have the <code>PowerSystem</code> composite type that has been created with the <code>dcModel</code>. After that, create the <code>Model</code> composite type to establish the DC optimal power flow framework using the function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a>.</li></ul><p>To solve the DC optimal power flow problem and acquire bus voltage angles and generator active power outputs, make use of the following function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}"><code>solve!</code></a>.</li></ul><p>After obtaining the solution for DC optimal power flow, JuliaGrid offers a post-processing analysis function to compute powers associated with buses and branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}"><code>power!</code></a>.</li></ul><p>Additionally, there are specialized functions dedicated to calculating specific types of active powers related to particular buses or branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.powerInjection-Tuple{PowerSystem, DCPowerFlow}"><code>powerInjection</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.powerSupply-Tuple{PowerSystem, DCPowerFlow}"><code>powerSupply</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.powerFrom-Tuple{PowerSystem, DCAnalysis}"><code>powerFrom</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.powerTo-Tuple{PowerSystem, DCAnalysis}"><code>powerTo</code></a>.</li></ul><hr/><h2 id="DCOptimizationVariablesManual"><a class="docs-heading-anchor" href="#DCOptimizationVariablesManual">Optimization Variables</a><a id="DCOptimizationVariablesManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimizationVariablesManual" title="Permalink"></a></h2><p>To set up the DC optimal power flow, we begin by creating the model. To illustrate this, consider the following example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, angle = 0.17)
addBus!(system; label = 2, active = 0.1, conductance = 0.04)
addBus!(system; label = 3, active = 0.05)

@branch(minDiffAngle = -pi, maxDiffAngle = pi)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05, longTerm = 0.15)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.01, longTerm = 0.10)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.01, longTerm = 0.25)

@generator(minActive = 0.0)
addGenerator!(system; label = 1, bus = 1, active = 3.2, maxActive = 0.5)
addGenerator!(system; label = 2, bus = 2, active = 0.2, maxActive = 0.2)

addActiveCost!(system; label = 1, model = 2, polynomial = [1100.2; 500; 80])
addActiveCost!(system; label = 2, model = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])

dcModel!(system)

model = dcOptimalPowerFlow(system, HiGHS.Optimizer)</code></pre><p>In the DC optimal power flow, the active power outputs of the generators are represented as linear functions of the bus voltage angles. Therefore, the variables in this model are the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.all_variables(model.jump)</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{VariableRef}:
 active[1]
 active[2]
 angle[1]
 angle[2]
 angle[3]
 helper[1]</code></pre><p>Furthermore, if there are linear piecewise cost functions with more than one segment, JuliaGrid automatically generates a helper variable for each linear piecewise cost function. Specifically, this cost function is modelled using a constrained cost variable method, where the cost function is replaced by the helper variable and the set of linear constraints.</p><hr/><h5 id="Add-Variables"><a class="docs-heading-anchor" href="#Add-Variables">Add Variables</a><a id="Add-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Variables" title="Permalink"></a></h5><p>The user has the ability to easily add new variables to the defined DC optimal power flow model by using the <a href="https://jump.dev/JuMP.jl/stable/reference/variables/#JuMP.@variable"><code>@variable</code></a> macro from the JuMP package. Here is an example:</p><pre><code class="language-julia hljs">JuMP.@variable(model.jump, new)</code></pre><p>We can verify that the new variable is included in the defined model by using the function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(model.jump, new)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><hr/><h5 id="Delete-Variables"><a class="docs-heading-anchor" href="#Delete-Variables">Delete Variables</a><a id="Delete-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Variables" title="Permalink"></a></h5><p>To delete a variable, the <a href="https://jump.dev/JuMP.jl/stable/reference/constraints/#JuMP.delete"><code>delete</code></a> function from the JuMP package can be used:</p><pre><code class="language-julia hljs">JuMP.delete(model.jump, new)</code></pre><p>After deletion, the variable is no longer part of the model:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(model.jump, new)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><hr/><h2 id="DCConstraintFunctionsManual"><a class="docs-heading-anchor" href="#DCConstraintFunctionsManual">Constraint Functions</a><a id="DCConstraintFunctionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCConstraintFunctionsManual" title="Permalink"></a></h2><p>JuliGrid keeps track of all the references to internally formed constraints in the <code>constraint</code> field of the <code>Model</code> composite type. These constraints are divided into six fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(model.constraint))</code><code class="nohighlight hljs ansi" style="display:block;">(:slack, :balance, :limit, :rating, :capability, :piecewise)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that readers refer to the tutorial on <a href="../../tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowTutorials">DC optimal power flow</a> for insights into the implementation.</p></div></div><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The <code>slack</code> field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function using the <code>angle</code> keyword:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.slack.angle</code><code class="nohighlight hljs ansi" style="display:block;">angle[1] = 0.17</code></pre><hr/><h5 id="Active-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Balance-Constraints">Active Power Balance Constraints</a><a id="Active-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Balance-Constraints" title="Permalink"></a></h5><p>The <code>balance</code> field contains references to the equality constraints associated with the active power balance equations defined for each bus. The constant terms in these equations are determined by the <code>active</code> and <code>conductance</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. Additionally, if there are phase shift transformers in the system, the constant terms can also be affected by the <code>shiftAngle</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.balance.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 -active[1] + 120 angle[1] - 20 angle[2] - 100 angle[3] = 0
 -active[2] - 20 angle[1] + 120 angle[2] - 100 angle[3] = -0.14
 -100 angle[1] - 100 angle[2] + 200 angle[3] = -0.05</code></pre><p>If you want to exclude these constraints and skip their formation, you can utilize the <code>balance = false</code> keyword within the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function. By specifying this keyword, you indicate that the problem does not involve active power balance constraints.</p><hr/><h5 id="Voltage-Angle-Difference-Limit-Constraints"><a class="docs-heading-anchor" href="#Voltage-Angle-Difference-Limit-Constraints">Voltage Angle Difference Limit Constraints</a><a id="Voltage-Angle-Difference-Limit-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Voltage-Angle-Difference-Limit-Constraints" title="Permalink"></a></h5><p>The <code>limit</code> field contains references to the inequality constraints associated with the minimum and maximum bus voltage angle difference between the &quot;from&quot; and &quot;to&quot; bus ends of each branch. These values are specified using the <code>minDiffAngle</code> and <code>maxDiffAngle</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.limit.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 angle[1] - angle[2] ∈ [-3.141592653589793, 3.141592653589793]
 angle[1] - angle[3] ∈ [-3.141592653589793, 3.141592653589793]
 angle[2] - angle[3] ∈ [-3.141592653589793, 3.141592653589793]</code></pre><p>Please note that if the limit constraints are set to <code>minDiffAngle = -2π</code> and <code>maxDiffAngle = 2π</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint. Additionally, if you want to exclude all voltage angle limit constraints and skip their formation, you can use the <code>limit = false</code> keyword within the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function.</p><hr/><h5 id="Active-Power-Rating-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Rating-Constraints">Active Power Rating Constraints</a><a id="Active-Power-Rating-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Rating-Constraints" title="Permalink"></a></h5><p>The <code>rating</code> field contains references to the inequality constraints associated with the active power flow limits at the &quot;from&quot; and &quot;to&quot; bus ends of each branch. These limits are specified using the <code>longTerm</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.rating.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 angle[1] - angle[2] ∈ [-0.0075, 0.0075]
 angle[1] - angle[3] ∈ [-0.001, 0.001]
 angle[2] - angle[3] ∈ [-0.0025, 0.0025]</code></pre><p>If you want to exclude these constraints and skip their formation, you can use the <code>rating = false</code> keyword within the  <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function. By specifying this keyword, you indicate that the problem does not involve active power rating constraints.</p><hr/><h5 id="Active-Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Capability-Constraints">Active Power Capability Constraints</a><a id="Active-Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Capability-Constraints" title="Permalink"></a></h5><p>The <code>capability</code> field contains references to the inequality constraints associated with the minimum and maximum active power outputs of the generators. These limits are specified using the <code>minActive</code> and <code>maxActive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.capability.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ConstraintRef}:
 active[1] ∈ [0, 0.5]
 active[2] ∈ [0, 0.2]</code></pre><p>If you want to exclude these constraints and skip their formation, you can use the <code>capability = false</code> keyword within the  <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function. By specifying this keyword, you indicate that the problem does not involve active power capability constraints.</p><hr/><h5 id="Active-Power-Piecewise-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Piecewise-Constraints">Active Power Piecewise Constraints</a><a id="Active-Power-Piecewise-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Piecewise-Constraints" title="Permalink"></a></h5><p>The <code>piecewise</code> field contains references to the inequality constraints associated with the linear piecewise cost function. In this case, the cost function is replaced by the helper variable and the set of linear constraints. These constraints are generated using the <a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a> function with <code>model = 1</code> specified:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.piecewise.active[2]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ConstraintRef}:
 1.1479591836734695 active[2] - helper[1] ≤ 0.15535714285714342
 0.40247678018575866 active[2] - helper[1] ≤ -10.855417956656346</code></pre><p>Therefore, for the generator labelled as 2, there is the linear piecewise cost function with two segments. JuliaGrid sets the corresponding inequality constraints for each segment.</p><hr/><h5 id="Add-Constraints"><a class="docs-heading-anchor" href="#Add-Constraints">Add Constraints</a><a id="Add-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Constraints" title="Permalink"></a></h5><p>Users can effortlessly incorporate additional constraints into the defined DC optimal power flow model using the <a href="https://jump.dev/JuMP.jl/stable/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a> macro. For instance, a new constraint can be added as follows:</p><pre><code class="language-julia hljs">angle = model.jump[:angle]

JuMP.@constraint(model.jump, -2.1 &lt;= angle[1] - angle[2] &lt;= 2.1)</code></pre><hr/><h5 id="Delete-Constraints"><a class="docs-heading-anchor" href="#Delete-Constraints">Delete Constraints</a><a id="Delete-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Constraints" title="Permalink"></a></h5><p>To delete a constraint, users can utilize the <a href="https://jump.dev/JuMP.jl/stable/reference/constraints/#JuMP.delete"><code>delete</code></a> function from the JuMP package. When dealing with constraints created internally, users can utilize the constraint references stored in the <code>constraint</code> field of the <code>Model</code> type. For instance, to delete the first constraint that limits the voltage angle difference, the following code snippet can be employed:</p><pre><code class="language-julia hljs">JuMP.delete(model.jump, model.constraint.limit.angle[1])</code></pre><p>Additionally, if you need to delete constraints based on labels associated with buses, branches, or generators, you can easily define an index for the constraint using the labels stored in a dictionary. For example, let us say you want to delete the voltage angle difference limit constraint related to the second branch:</p><pre><code class="language-julia hljs">index = system.branch.label[2]
JuMP.delete(model.jump, model.constraint.limit.angle[index])</code></pre><p>It is worth noting that if the labels assigned to the buses, branches, or generators follow an increasing ordered set of integers, both approaches to deleting constraints are equivalent.</p><hr/><h2 id="DCObjectiveFunctionManual"><a class="docs-heading-anchor" href="#DCObjectiveFunctionManual">Objective Function</a><a id="DCObjectiveFunctionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCObjectiveFunctionManual" title="Permalink"></a></h2><p>The objective function of the DC optimal power flow is constructed using polynomial and linear piecewise cost functions of the generators, which are defined using the <a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a> functions. It is important to note that only polynomial cost functions up to the second degree are included in the objective. If there are polynomials of higher degrees, JuliaGrid will exclude them from the objective function.</p><p>In the provided example, the objective function that needs to be minimized to obtain the optimal values of the active power outputs of the generators and the bus voltage angles is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(model.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 active[1]² + 500 active[1] + helper[1] + 80</code></pre><hr/><h5 id="Change-Objective"><a class="docs-heading-anchor" href="#Change-Objective">Change Objective</a><a id="Change-Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Change-Objective" title="Permalink"></a></h5><p>The objective can be modified by the user using the <a href="https://jump.dev/JuMP.jl/stable/reference/objectives/#JuMP.set_objective_function"><code>set_objective_function</code></a> function from the JuMP package. Here is an example of how it can be done:</p><pre><code class="language-julia hljs">active = model.jump[:active]
helper = model.jump[:helper]
new = JuMP.@expression(model.jump, 1100 * active[1] * active[1] + helper[1] + 80)

JuMP.set_objective_function(model.jump, new)</code></pre><hr/><h2 id="SetupPrimalStartingValuesManual"><a class="docs-heading-anchor" href="#SetupPrimalStartingValuesManual">Setup Primal Starting Values</a><a id="SetupPrimalStartingValuesManual-1"></a><a class="docs-heading-anchor-permalink" href="#SetupPrimalStartingValuesManual" title="Permalink"></a></h2><p>There are two methods available to specify primal starting values for each variable: using the built-in function provided by JuMP or accessing and modifying values directly within the <code>voltage</code> and <code>power</code> fields of the <code>Model</code> type.</p><hr/><h5 id="Using-JuMP-Functions"><a class="docs-heading-anchor" href="#Using-JuMP-Functions">Using JuMP Functions</a><a id="Using-JuMP-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Using-JuMP-Functions" title="Permalink"></a></h5><p>One approach is to utilize the <a href="https://jump.dev/JuMP.jl/stable/reference/variables/#JuMP.set_start_value"><code>set_start_value</code></a> function from the JuMP package. This allows us to set primal starting values for the active power outputs of the generators and the bus voltage angles. Here is an example:</p><pre><code class="language-julia hljs">JuMP.set_start_value.(model.jump[:active], [0.0, 0.18])
JuMP.set_start_value.(model.jump[:angle], [0.17, 0.13, 0.14])</code></pre><p>To inspect the primal starting values that have been set, you can use the <a href="https://jump.dev/JuMP.jl/stable/reference/variables/#JuMP.start_value"><code>start_value</code></a> function from JuMP. Here is an example of how you can inspect the starting values for the active power outputs: We can inspect that starting values are set:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.start_value.(model.jump[:active])</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.18</code></pre><hr/><h5 id="Using-JuliaGrid-Variables"><a class="docs-heading-anchor" href="#Using-JuliaGrid-Variables">Using JuliaGrid Variables</a><a id="Using-JuliaGrid-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Using-JuliaGrid-Variables" title="Permalink"></a></h5><p>Alternatively, you can rely on the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function to assign starting values based on the <code>power</code> and <code>voltage</code> fields. By default, these values are initially defined according to the active power outputs of the generators and the initial bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.power.generator.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 3.2
 0.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.17
 0.0
 0.0</code></pre><p>You can modify these values, and they will be used as primal starting values during the execution of the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Please note that if primal starting values are set using the <code>set_start_value</code> function or any other method prior to executing the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function, the values in the <code>power</code> and <code>voltage</code> fields will be ignored. This is because the starting point will be considered already defined.</p></div></div><hr/><h5 id="Using-DC-Power-Flow"><a class="docs-heading-anchor" href="#Using-DC-Power-Flow">Using DC Power Flow</a><a id="Using-DC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Using-DC-Power-Flow" title="Permalink"></a></h5><p>Another approach is to perform the DC power flow and use the resulting solution to set primal starting values. Here is an example of how it can be done:</p><pre><code class="language-julia hljs">flowModel = dcPowerFlow(system)
solve!(system, flowModel)</code></pre><p>After obtaining the solution, we can calculate the active power outputs of the generators and utilize the bus voltage angles to set the starting values. In this case, the <code>power</code> and <code>voltage</code> fields of the <code>Model</code> type can be employed to store the new starting values:</p><pre><code class="language-julia hljs">for (key, value) in system.generator.label
    model.power.generator.active[value] = powerGenerator(system, flowModel; label = key)
end

for i = 1:system.bus.number
    model.voltage.angle[i] = flowModel.voltage.angle[i]
end</code></pre><p>Also, the user can make use of the <a href="https://jump.dev/JuMP.jl/stable/reference/variables/#JuMP.set_start_value"><code>set_start_value</code></a> function to set starting values from the DC power flow.</p><hr/><h2 id="DCOptimalPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowSolutionManual">Optimal Power Flow Solution</a><a id="DCOptimalPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowSolutionManual" title="Permalink"></a></h2><p>To establish the DC optimal power flow problem, you can utilize the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function. After setting up the problem, you can use the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}"><code>solve!</code></a> function to compute the optimal values for the active power outputs of the generators and the bus voltage angles. Here is an example:</p><pre><code class="language-julia hljs">solve!(system, model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Running HiGHS 1.5.3 [date: 1970-01-01, git hash: 45a127b78]
Copyright (c) 2023 HiGHS under MIT licence terms
Iteration, Runtime, ObjVal, NullspaceDim
0, 0.000687, 90.931889, 0
6, 0.000761, 90.931852, 1
Model   status      : Optimal
QP ASM    iterations: 6
Objective value     :  9.0931851730e+01
HiGHS run time      :          0.00</code></pre><p>By executing this function, you will obtain the solution with the optimal values for the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.power.generator.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.00018294399099352663
 0.1898170560090035</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.17
 0.17035452937155726
 0.16992726468577862</code></pre><hr/><h5 id="Objective-Value"><a class="docs-heading-anchor" href="#Objective-Value">Objective Value</a><a id="Objective-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Value" title="Permalink"></a></h5><p>To obtain the objective value of the optimal power flow solution, you can use the <a href="https://jump.dev/JuMP.jl/stable/reference/solutions/#JuMP.objective_value"><code>objective_value</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_value(model.jump)</code><code class="nohighlight hljs ansi" style="display:block;">90.93185172953741</code></pre><hr/><h5 id="Silent-Solver-Output"><a class="docs-heading-anchor" href="#Silent-Solver-Output">Silent Solver Output</a><a id="Silent-Solver-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Silent-Solver-Output" title="Permalink"></a></h5><p>To turn off the solver output within the REPL, you can use the <a href="https://jump.dev/JuMP.jl/stable/reference/models/#JuMP.set_silent"><code>set_silent</code></a> function before calling <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}"><code>solve!</code></a> function. This will suppress the solver&#39;s output:</p><pre><code class="language-julia hljs">JuMP.set_silent(model.jump)</code></pre><hr/><h2 id="DCOptimalPowerAnalysisManual"><a class="docs-heading-anchor" href="#DCOptimalPowerAnalysisManual">Power Analysis</a><a id="DCOptimalPowerAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}"><code>power!</code></a> function. For instance, let us consider the power system for which we obtained the DC optimal power flow solution:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, angle = 0.17)
addBus!(system; label = 2, type = 2, active = 0.1, conductance = 0.04)
addBus!(system; label = 3, type = 1, active = 0.05)

@branch(minDiffAngle = -pi, maxDiffAngle = pi)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05, longTerm = 0.15)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.01, longTerm = 0.10)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.01, longTerm = 0.25)

addGenerator!(system; label = 1, bus = 1, active = 3.2, minActive = 0.0, maxActive = 0.5)
addGenerator!(system; label = 2, bus = 2, active = 0.2, minActive = 0.0, maxActive = 0.2)

addActiveCost!(system; label = 1, model = 2, polynomial = [1100.2; 500; 80])
addActiveCost!(system; label = 2, model = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])

dcModel!(system)

model = dcOptimalPowerFlow(system, HiGHS.Optimizer)
JuMP.set_silent(model.jump)

solve!(system, model)</code></pre><p>Now we can calculate the active powers using the following function:</p><pre><code class="language-julia hljs">power!(system, model)</code></pre><p>For example, to display the active power injections at each bus and active power flows at each &quot;from&quot; bus end of the branch, we can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
  0.09000000000000127
 -0.05</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.007142857142858339
  0.007142857142855563
  0.04285714285714726</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers associated with buses and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}"><code>power!</code></a> function, we suggest referring to the tutorials on <a href="../../tutorials/dcOptimalPowerFlow/#DCOptimalPowerAnalysisTutorials">DC optimal power flow analysis</a>.</p></div></div><hr/><h5 id="Powers-Related-to-Bus"><a class="docs-heading-anchor" href="#Powers-Related-to-Bus">Powers Related to Bus</a><a id="Powers-Related-to-Bus-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-Related-to-Bus" title="Permalink"></a></h5><p>Instead of calculating powers for all components, users have the option to compute specific quantities for particular components. In this regard, the following function can be utilized to calculate active powers associated with a specific bus:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerInjection(system, model; label = 1)</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerSupply(system, model; label = 1)</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code></pre><hr/><h5 id="Powers-Related-to-Branch"><a class="docs-heading-anchor" href="#Powers-Related-to-Branch">Powers Related to Branch</a><a id="Powers-Related-to-Branch-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-Related-to-Branch" title="Permalink"></a></h5><p>Similarly, we can compute the active powers related to a particular branch using the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerFrom(system, model; label = 2)</code><code class="nohighlight hljs ansi" style="display:block;">0.007142857142855563</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerTo(system, model; label = 2)</code><code class="nohighlight hljs ansi" style="display:block;">-0.007142857142855563</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acOptimalPowerFlow/">« AC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../../tutorials/acdcModel/">AC and DC Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 31 July 2023 11:51">Monday 31 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
