<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC Optimal Power Flow · JuliaGrid</title><meta name="title" content="DC Optimal Power Flow · JuliaGrid"/><meta property="og:title" content="DC Optimal Power Flow · JuliaGrid"/><meta property="twitter:title" content="DC Optimal Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>DC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#DCOptimalPowerFlowModelManual"><span>Optimal Power Flow Model</span></a></li><li><a class="tocitem" href="#DCOptimizationVariablesManual"><span>Optimization Variables</span></a></li><li><a class="tocitem" href="#DCConstraintFunctionsManual"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#DCObjectiveFunctionManual"><span>Objective Function</span></a></li><li><a class="tocitem" href="#SetupStartingPrimalValuesManual"><span>Setup Starting Primal Values</span></a></li><li><a class="tocitem" href="#DCOptimalPowerFlowSolutionManual"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#DCOptimalPowerAnalysisManual"><span>Power Analysis</span></a></li><li><a class="tocitem" href="#DCOptimalReusingPowerSystemModelManual"><span>Reusing Power System Model</span></a></li><li><a class="tocitem" href="#DCReusingOptimalPowerFlowModelManual"><span>Reusing Optimal Power Flow Model</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/dcOptimalPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DCOptimalPowerFlowManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowManual">DC Optimal Power Flow</a><a id="DCOptimalPowerFlowManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowManual" title="Permalink"></a></h1><p>Similar to <a href="../acOptimalPowerFlow/#ACOptimalPowerFlowManual">AC Optimal Power Flow</a>, JuliaGrid utilizes the <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> package to construct optimal power flow models, enabling users to manipulate these models using the standard functions provided by JuMP. JuliaGrid supports popular <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> mentioned in the JuMP documentation to solve the optimization problem.</p><p>To perform the DC optimal power flow, you first need to have the <code>PowerSystem</code> composite type that has been created with the <code>dc</code> model. After that, create the <code>DCOptimalPowerFlow</code> composite type to establish the DC optimal power flow framework using the function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a>.</li></ul><p>To solve the DC optimal power flow problem and acquire bus voltage angles and generator active power outputs, make use of the following function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}"><code>solve!</code></a>.</li></ul><p>After obtaining the solution for DC optimal power flow, JuliaGrid offers a post-processing analysis function to compute powers associated with buses and branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}"><code>power!</code></a>.</li></ul><p>Additionally, there are specialized functions dedicated to calculating specific types of active powers related to particular buses or branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, DCPowerFlow}"><code>injectionPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, DCPowerFlow}"><code>supplyPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, DC}"><code>fromPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, DC}"><code>toPower</code></a>.</li></ul><hr/><h2 id="DCOptimalPowerFlowModelManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowModelManual">Optimal Power Flow Model</a><a id="DCOptimalPowerFlowModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowModelManual" title="Permalink"></a></h2><p>To set up the DC optimal power flow, we begin by creating the model. To illustrate this, consider the following example:</p><pre><code class="language-julia hljs">using JuMP, HiGHS

system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, angle = 0.17)
addBus!(system; label = &quot;Bus 2&quot;, active = 0.1, conductance = 0.04)
addBus!(system; label = &quot;Bus 3&quot;, active = 0.05)

@branch(minDiffAngle = -3.1, maxDiffAngle = 3.1, longTerm = 0.12)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)

@generator(minActive = 0.0)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.6, maxActive = 0.8)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.1, maxActive = 0.3)
addGenerator!(system; label = &quot;Generator 3&quot;, bus = &quot;Bus 2&quot;, active = 0.2, maxActive = 0.4)

cost!(system; label = &quot;Generator 1&quot;, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; label = &quot;Generator 2&quot;, active = 1, piecewise = [8.0 11.0; 14.0 17.0])
cost!(system; label = &quot;Generator 3&quot;, active = 1, piecewise = [6.8 12.3; 8.7 16.8; 11.2 19.8])

dcModel!(system)</code></pre><p>Next, the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function is utilized to formulate the DC optimal power flow problem:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)</code></pre><hr/><h2 id="DCOptimizationVariablesManual"><a class="docs-heading-anchor" href="#DCOptimizationVariablesManual">Optimization Variables</a><a id="DCOptimizationVariablesManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimizationVariablesManual" title="Permalink"></a></h2><p>In the DC optimal power flow, the active power outputs of the generators are represented as linear functions of the bus voltage angles. Therefore, the variables in this model are the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.all_variables(analysis.jump)</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{VariableRef}:
 active[1]
 active[2]
 active[3]
 angle[1]
 angle[2]
 angle[3]
 actwise[3]</code></pre><p>Furthermore, it is important to highlight that when dealing with linear piecewise cost functions comprising multiple segments, as exemplified in the case of <code>Generator 3</code>, JuliaGrid automatically generates helper optimization variables, such as <code>actwise[3]</code>, and formulates a set of linear constraints to appropriately handle these cost functions. However, in instances where a linear piecewise cost function consists of only a single segment, as demonstrated by <code>Generator 2</code>, the function is modelled as a standard linear function, eliminating the necessity for additional helper optimization variables.</p><p>Please note that JuliaGrid keeps references to all variables categorized into three fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.variable))</code><code class="nohighlight hljs ansi" style="display:block;">(:active, :angle, :actwise)</code></pre><hr/><h5 id="Add-Variables"><a class="docs-heading-anchor" href="#Add-Variables">Add Variables</a><a id="Add-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Variables" title="Permalink"></a></h5><p>The user has the ability to easily add new variables to the defined DC optimal power flow model by using the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.@variable"><code>@variable</code></a> macro from the JuMP package. Here is an example:</p><pre><code class="language-julia hljs">JuMP.@variable(analysis.jump, newVariable)</code></pre><p>We can verify that the new variable is included in the defined model by using the function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(analysis.jump, newVariable)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><hr/><h5 id="Delete-Variables"><a class="docs-heading-anchor" href="#Delete-Variables">Delete Variables</a><a id="Delete-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Variables" title="Permalink"></a></h5><p>To delete a variable, the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.delete"><code>delete</code></a> function from the JuMP package can be used:</p><pre><code class="language-julia hljs">JuMP.delete(analysis.jump, newVariable)</code></pre><p>After deletion, the variable is no longer part of the model:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(analysis.jump, newVariable)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><hr/><h2 id="DCConstraintFunctionsManual"><a class="docs-heading-anchor" href="#DCConstraintFunctionsManual">Constraint Functions</a><a id="DCConstraintFunctionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCConstraintFunctionsManual" title="Permalink"></a></h2><p>JuliGrid keeps track of all the references to internally formed constraints in the <code>constraint</code> field of the <code>DCOptimalPowerFlow</code> composite type. These constraints are divided into six fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.constraint))</code><code class="nohighlight hljs ansi" style="display:block;">(:slack, :balance, :voltage, :flow, :capability, :piecewise)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that readers refer to the tutorial on <a href="../../tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowTutorials">DC Optimal Power Flow</a> for insights into the implementation.</p></div></div><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The <code>slack</code> field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function using the <code>angle</code> keyword:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: angle[1] = 0.17</code></pre><p>Users have the flexibility to modify this constraint by changing which bus serves as the slack bus and by adjusting the value of the bus angle. This can be achieved using the <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a> function, for example:</p><pre><code class="language-julia hljs">updateBus!(system, analysis; label = &quot;Bus 1&quot;, angle = -0.1)</code></pre><p>Subsequently, the updated slack constraint can be inspected as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: angle[1] = -0.1</code></pre><hr/><h5 id="Active-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Balance-Constraints">Active Power Balance Constraints</a><a id="Active-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Balance-Constraints" title="Permalink"></a></h5><p>The <code>balance</code> field contains references to the equality constraints associated with the active power balance equations defined for each bus. The constant terms in these equations are determined by the <code>active</code> and <code>conductance</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. Additionally, if there are phase shift transformers in the system, the constant terms can also be affected by the <code>shiftAngle</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: active[1] - 120 angle[1] + 20 angle[2] + 100 angle[3] = 0
Bus 2: active[2] + active[3] + 20 angle[1] - 120 angle[2] + 100 angle[3] = 0.14
Bus 3: 100 angle[1] + 100 angle[2] - 200 angle[3] = 0.05</code></pre><p>During the execution of functions that add or update power system components, these constraints are automatically adjusted to reflect the current configuration of the power system. An example of this adaptability is demonstrated below:</p><pre><code class="language-julia hljs">updateBus!(system, analysis; label = &quot;Bus 3&quot;, active = 0.1)
updateGenerator!(system, analysis; label = &quot;Generator 2&quot;, status = 0)</code></pre><p>Subsequently, the updated set of active power balance constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: active[1] - 120 angle[1] + 20 angle[2] + 100 angle[3] = 0
Bus 2: active[3] + 20 angle[1] - 120 angle[2] + 100 angle[3] = 0.14
Bus 3: 100 angle[1] + 100 angle[2] - 200 angle[3] = 0.1</code></pre><hr/><h5 id="Voltage-Angle-Difference-Constraints"><a class="docs-heading-anchor" href="#Voltage-Angle-Difference-Constraints">Voltage Angle Difference Constraints</a><a id="Voltage-Angle-Difference-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Voltage-Angle-Difference-Constraints" title="Permalink"></a></h5><p>The <code>voltage</code> field contains references to the inequality constraints associated with the minimum and maximum bus voltage angle difference between the &quot;from&quot; and &quot;to&quot; bus ends of each branch. These values are specified using the <code>minDiffAngle</code> and <code>maxDiffAngle</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: angle[1] - angle[2] ∈ [-3.1, 3.1]
Branch 2: angle[1] - angle[3] ∈ [-3.1, 3.1]
Branch 3: angle[2] - angle[3] ∈ [-3.1, 3.1]</code></pre><p>Please note that if the limit constraints are set to <code>minDiffAngle = -2π</code> and <code>maxDiffAngle = 2π</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.</p><p>Additionally, by employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function, you have the ability to modify these specific constraints as follows:</p><pre><code class="language-julia hljs">updateBranch!(system, analysis; label = &quot;Branch 1&quot;, minDiffAngle = -1.7, maxDiffAngle = 1.7)</code></pre><p>Subsequently, the updated set of voltage angle difference constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: angle[1] - angle[2] ∈ [-1.7, 1.7]
Branch 2: angle[1] - angle[3] ∈ [-3.1, 3.1]
Branch 3: angle[2] - angle[3] ∈ [-3.1, 3.1]</code></pre><hr/><h5 id="Active-Power-Flow-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Flow-Constraints">Active Power Flow Constraints</a><a id="Active-Power-Flow-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Flow-Constraints" title="Permalink"></a></h5><p>The <code>flow</code> field contains references to the inequality constraints associated with the active power flow limits at the &quot;from&quot; and &quot;to&quot; bus ends of each branch. These limits are specified using the <code>longTerm</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: angle[1] - angle[2] ∈ [-0.006, 0.006]
Branch 2: angle[1] - angle[3] ∈ [-0.0012, 0.0012]
Branch 3: angle[2] - angle[3] ∈ [-0.0012, 0.0012]</code></pre><p>Please note that if the limit constraints are set to <code>longTerm = 0.0</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.</p><p>Additionally, by employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function, you have the ability to modify these specific constraints, for example:</p><pre><code class="language-julia hljs">updateBranch!(system, analysis; label = &quot;Branch 1&quot;, status = 0)
updateBranch!(system, analysis; label = &quot;Branch 2&quot;, reactance = 0.03, longTerm = 0.14)</code></pre><p>Subsequently, the updated set of active power flow constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 2: angle[1] - angle[3] ∈ [-0.0042, 0.0042]
Branch 3: angle[2] - angle[3] ∈ [-0.0012, 0.0012]</code></pre><hr/><h5 id="Active-Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Capability-Constraints">Active Power Capability Constraints</a><a id="Active-Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Capability-Constraints" title="Permalink"></a></h5><p>The <code>capability</code> field contains references to the inequality constraints associated with the minimum and maximum active power outputs of the generators. These limits are specified using the <code>minActive</code> and <code>maxActive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: active[1] ∈ [0, 0.8]
Generator 2: active[2] = 0
Generator 3: active[3] ∈ [0, 0.4]</code></pre><p>As demonstrated, the active power output of <code>Generator 2</code> is currently fixed at zero due to the earlier action of setting this generator out-of-service. Consequently, you can adjust these specific constraints using the <a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a> function, for example:</p><pre><code class="language-julia hljs">updateGenerator!(system, analysis; label = &quot;Generator 2&quot;, status = 1, maxActive = 0.5)</code></pre><p>Subsequently, the updated set of active power capability constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: active[1] ∈ [0, 0.8]
Generator 2: active[2] ∈ [0, 0.5]
Generator 3: active[3] ∈ [0, 0.4]</code></pre><p>It is important to note that by bringing back <code>Generator 2</code> into service, it will also have an impact on the balance constraint, which will once again be influenced by the generator&#39;s output.</p><hr/><h5 id="Active-Power-Piecewise-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Piecewise-Constraints">Active Power Piecewise Constraints</a><a id="Active-Power-Piecewise-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Piecewise-Constraints" title="Permalink"></a></h5><p>In the context of active power modelling, the <code>piecewise</code> field serves as a reference to the inequality constraints related to linear piecewise cost functions. These constraints are created using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function with <code>active = 1</code> specified when dealing with linear piecewise cost functions comprising multiple segments. JuliaGrid takes care of establishing the appropriate inequality constraints for each segment of the linear piecewise cost:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.piecewise.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 3: 2.3684210526315796 active[3] - actwise[3] ≤ 3.805263157894739
Generator 3: 1.2 active[3] - actwise[3] ≤ -6.360000000000001</code></pre><p>It is worth noting that these constraints can also be automatically updated using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function, and readers can find more details in the section about the objective function.</p><hr/><h5 id="Add-Constraints"><a class="docs-heading-anchor" href="#Add-Constraints">Add Constraints</a><a id="Add-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Constraints" title="Permalink"></a></h5><p>Users can effortlessly introduce additional constraints into the defined DC optimal power flow model by utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> or <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> functions. Specifically, if a user wishes to include a new branch or generator in an already defined <code>PowerSystem</code> and <code>DCOptimalPowerFlow</code> type, using these functions will automatically add and update all constraints:</p><pre><code class="language-julia hljs">addBranch!(system, analysis; label = &quot;Branch 4&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 1)
addGenerator!(system, analysis; label = &quot;Generator 4&quot;, bus = &quot;Bus 1&quot;, maxActive = 0.2)</code></pre><p>As a result, the flow and capability constraints will be adjusted as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 2: angle[1] - angle[3] ∈ [-0.0042, 0.0042]
Branch 3: angle[2] - angle[3] ∈ [-0.0012, 0.0012]
Branch 4: angle[1] - angle[2] ∈ [-0.12, 0.12]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: active[1] ∈ [0, 0.8]
Generator 2: active[2] ∈ [0, 0.5]
Generator 3: active[3] ∈ [0, 0.4]
Generator 4: active[4] ∈ [0, 0.2]</code></pre><hr/><h5 id="Add-User-Defined-Constraints"><a class="docs-heading-anchor" href="#Add-User-Defined-Constraints">Add User-Defined Constraints</a><a id="Add-User-Defined-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-User-Defined-Constraints" title="Permalink"></a></h5><p>Users also have the option to include their custom constraints within the established DC optimal power flow model by employing the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.@constraint"><code>@constraint</code></a> macro. For example, the addition of a new constraint can be achieved as follows:</p><pre><code class="language-julia hljs">JuMP.@constraint(analysis.jump, 0.0 &lt;= analysis.variable.active[4] &lt;= 0.3)</code></pre><hr/><h5 id="Delete-Constraints"><a class="docs-heading-anchor" href="#Delete-Constraints">Delete Constraints</a><a id="Delete-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Constraints" title="Permalink"></a></h5><p>To delete a constraint, users can make use of the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.delete"><code>delete</code></a> function from the JuMP package. When handling constraints that have been internally created, users can refer to the constraint references stored in the <code>constraint</code> field of the <code>DCOptimalPowerFlow</code> type.</p><p>For example, if the intention is to eliminate constraints related to the capability of <code>Generator 4</code>, the following code snippet can be employed:</p><pre><code class="language-julia hljs">JuMP.delete(analysis.jump, analysis.constraint.capability.active[4])</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In the event that a user deletes a constraint and subsequently executes a function that updates bus, branch, or generator parameters, and if the deleted constraint is affected by these functions, JuliaGrid will automatically reinstate that constraint. Users should exercise caution when deleting constraints, as this action is considered potentially harmful since it operates independently of power system data.</p></div></div><hr/><h2 id="DCObjectiveFunctionManual"><a class="docs-heading-anchor" href="#DCObjectiveFunctionManual">Objective Function</a><a id="DCObjectiveFunctionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCObjectiveFunctionManual" title="Permalink"></a></h2><p>The objective function of the DC optimal power flow is constructed using polynomial and linear piecewise cost functions of the generators, which are defined using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions. It is important to note that only polynomial cost functions up to the second degree are included in the objective. If there are polynomials of higher degrees, JuliaGrid will exclude them from the objective function.</p><p>In the provided example, the objective function that needs to be minimized to obtain the optimal values of the active power outputs of the generators and the bus voltage angles is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 active[1]² + 500 active[1] + actwise[3] + active[2] + 83</code></pre><p>Additionally, JuliaGrid stores the objective function in a separate variable, allowing users to access it by referencing the variable <code>analysis.objective</code>.</p><hr/><h5 id="Update-Objective-Function"><a class="docs-heading-anchor" href="#Update-Objective-Function">Update Objective Function</a><a id="Update-Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Update-Objective-Function" title="Permalink"></a></h5><p>By utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions, users have the flexibility to modify the objective function by adjusting polynomial or linear piecewise cost coefficients or by changing the type of polynomial or linear piecewise function employed. For instance, consider <code>Generator 3</code>, which incorporates a piecewise cost structure with two segments. Now, we can define a polynomial function for this generator and activate it by specifying the keyword <code>active = 2</code> as shown:</p><pre><code class="language-julia hljs">cost!(system, analysis; label = &quot;Generator 3&quot;, active = 2, polynomial = [853.4; 257; 40])</code></pre><p>This results in the updated objective function, which can be observed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.objective</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 active[1]² + 853.4 active[3]² + 500 active[1] + active[2] + 257 active[3] + 123</code></pre><hr/><h5 id="User-Defined-Objective-Function"><a class="docs-heading-anchor" href="#User-Defined-Objective-Function">User-Defined Objective Function</a><a id="User-Defined-Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#User-Defined-Objective-Function" title="Permalink"></a></h5><p>Users can modify the objective function using the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.set_objective_function"><code>set_objective_function</code></a> function from the JuMP package. This operation is considered destructive because it is independent of power system data; however, in certain scenarios, it may be more straightforward than using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function for updates. Moreover, using this methodology, users can combine a defined function with a newly defined expression. Here is an example of how it can be achieved:</p><pre><code class="language-julia hljs">expr = 100.2 * analysis.variable.active[1] * analysis.variable.active[1] + 123
JuMP.set_objective_function(analysis.jump, analysis.objective - expr)</code></pre><p>You can now observe the updated objective function as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1000 active[1]² + 853.4 active[3]² + 500 active[1] + active[2] + 257 active[3]</code></pre><hr/><h2 id="SetupStartingPrimalValuesManual"><a class="docs-heading-anchor" href="#SetupStartingPrimalValuesManual">Setup Starting Primal Values</a><a id="SetupStartingPrimalValuesManual-1"></a><a class="docs-heading-anchor-permalink" href="#SetupStartingPrimalValuesManual" title="Permalink"></a></h2><p>In JuliaGrid, the assignment of starting primal values for optimization variables takes place when the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}"><code>solve!</code></a> function is executed. Starting primal values are determined based on the <code>generator</code> and <code>voltage</code> fields within the <code>DCOptimalPowerFlow</code> type. By default, these values are initially established using the active power outputs of the generators and the initial bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.6
Generator 2: 0.1
Generator 3: 0.2
Generator 4: 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: 0.0
Bus 3: 0.0</code></pre><p>You have the flexibility to adjust these values to your specifications, and they will be utilized as the starting primal values when you run the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}"><code>solve!</code></a> function.</p><hr/><h5 id="Using-DC-Power-Flow"><a class="docs-heading-anchor" href="#Using-DC-Power-Flow">Using DC Power Flow</a><a id="Using-DC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Using-DC-Power-Flow" title="Permalink"></a></h5><p>In this perspective, users have the capability to conduct the DC power flow analysis and leverage the resulting solution to configure starting primal values. Here is an illustration of how this can be achieved:</p><pre><code class="language-julia hljs">flow = dcPowerFlow(system)
solve!(system, flow)</code></pre><p>After obtaining the solution, we can calculate the active power outputs of the generators and utilize the bus voltage angles to set the starting values. In this case, the <code>generator</code> and <code>voltage</code> fields of the <code>DCOptimalPowerFlow</code> type can be employed to store the new starting values:</p><pre><code class="language-julia hljs">for (key, value) in system.generator.label
    analysis.power.generator.active[value] = generatorPower(system, flow; label = key)
end

for i = 1:system.bus.number
    analysis.voltage.angle[i] = flow.voltage.angle[i]
end</code></pre><hr/><h5 id="Using-DC-Optimal-Power-Flow"><a class="docs-heading-anchor" href="#Using-DC-Optimal-Power-Flow">Using DC Optimal Power Flow</a><a id="Using-DC-Optimal-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Using-DC-Optimal-Power-Flow" title="Permalink"></a></h5><p>Performing repeated executions of the DC optimal power flow problem, and opting to reuse the existing <code>DCOptimalPowerFlow</code> type without generating a new instance offers the benefit of a &quot;warm start&quot;. In such a situation, the initial primal values for the subsequent solving step align with the solution achieved in the prior step. Additional information can be found in the section dedicated to <a href="#DCReusingOptimalPowerFlowModelManual">Reusing Optimal Power Flow Model</a>.</p><hr/><h2 id="DCOptimalPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowSolutionManual">Optimal Power Flow Solution</a><a id="DCOptimalPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowSolutionManual" title="Permalink"></a></h2><p>To establish the DC optimal power flow problem, you can utilize the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function. After setting up the problem, you can use the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}"><code>solve!</code></a> function to compute the optimal values for the active power outputs of the generators and the bus voltage angles. Also, to turn off the solver output within the REPL, we use the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.set_silent"><code>set_silent</code></a> function before calling <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}"><code>solve!</code></a> function. Here is an example:</p><pre><code class="language-julia hljs">JuMP.set_silent(analysis.jump)
solve!(system, analysis)</code></pre><p>By executing this function, you will obtain the solution with the optimal values for the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.0
Generator 2: 0.09539999999999904
Generator 3: 0.0
Generator 4: 0.14460000000000023</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: -0.10460000000000001
Bus 3: -0.1042</code></pre><hr/><h5 id="Objective-Value"><a class="docs-heading-anchor" href="#Objective-Value">Objective Value</a><a id="Objective-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Value" title="Permalink"></a></h5><p>To obtain the objective value of the optimal power flow solution, you can use the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.objective_value"><code>objective_value</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_value(analysis.jump)</code><code class="nohighlight hljs ansi" style="display:block;">0.09539999999999904</code></pre><hr/><h2 id="DCOptimalPowerAnalysisManual"><a class="docs-heading-anchor" href="#DCOptimalPowerAnalysisManual">Power Analysis</a><a id="DCOptimalPowerAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}"><code>power!</code></a> function. For instance, let us consider the power system for which we obtained the DC optimal power flow solution:</p><pre><code class="language-julia hljs">using JuMP, HiGHS

system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, angle = 0.17)
addBus!(system; label = &quot;Bus 2&quot;, active = 0.1, conductance = 0.04)
addBus!(system; label = &quot;Bus 3&quot;, active = 0.05)

@branch(minDiffAngle = -pi, maxDiffAngle = pi, longTerm = 0.12)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)

@generator(minActive = 0.0)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, maxActive = 0.5)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.2, maxActive = 0.2)

cost!(system; label = &quot;Generator 1&quot;, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; label = &quot;Generator 2&quot;, active = 1, piecewise = [10.8 12.3; 14.7 16.8])

dcModel!(system)

analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)
solve!(system, analysis)</code></pre><p>Now we can calculate the active powers using the following function:</p><pre><code class="language-julia hljs">power!(system, analysis)</code></pre><p>Finally, to display the active power injections at each bus and active power flows at each &quot;from&quot; bus end of the branch, we can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: 0.09000000000000127
Bus 3: -0.05</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.power.from.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: -0.007142857142858339
Branch 2: 0.007142857142855563
Branch 3: 0.04285714285714726</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers associated with buses and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}"><code>power!</code></a> function, we suggest referring to the tutorials on <a href="../../tutorials/dcOptimalPowerFlow/#DCOptimalPowerAnalysisTutorials">DC Optimal Power Flow</a>.</p></div></div><p>To compute specific quantities for particular components, rather than calculating powers or currents for all components, users can utilize one of the provided functions below.</p><hr/><h5 id="Active-Power-Injection"><a class="docs-heading-anchor" href="#Active-Power-Injection">Active Power Injection</a><a id="Active-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection" title="Permalink"></a></h5><p>To calculate active power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = injectionPower(system, analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.09000000000000127</code></pre><hr/><h5 id="Active-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-Power-Injection-from-Generators">Active Power Injection from Generators</a><a id="Active-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate active power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = supplyPower(system, analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.19000000000000128</code></pre><hr/><h5 id="Active-Power-Flow"><a class="docs-heading-anchor" href="#Active-Power-Flow">Active Power Flow</a><a id="Active-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active power flow at both the &quot;from&quot; and &quot;to&quot; bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = fromPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.007142857142855563</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = toPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">-0.007142857142855563</code></pre><hr/><h2 id="DCOptimalReusingPowerSystemModelManual"><a class="docs-heading-anchor" href="#DCOptimalReusingPowerSystemModelManual">Reusing Power System Model</a><a id="DCOptimalReusingPowerSystemModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalReusingPowerSystemModelManual" title="Permalink"></a></h2><p>Similar to what we discussed in the section <a href="../dcPowerFlow/#DCReusingPowerSystemModelManual">Reusing Power System Model</a> concerning DC power flow, the <code>PowerSystem</code> composite type, along with its previously established <code>dc</code> field, offers remarkable versatility. This versatility extends to the use of the <code>PowerSystem</code> type in various DC analyses. As demonstrated when we employ initial conditions from DC power flow for DC optimal power flow, the <code>PowerSystem</code> type seamlessly integrates across different analysis types.</p><p>Furthermore, all fields within the <code>PowerSystem</code> type automatically adjust when any of the functions responsible for adding components or modifying their parameters are used. These functions encompass:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a>.</li></ul><p>This implies that users have the flexibility to add or update parameters after creating the <code>PowerSystem</code> composite type. Subsequently, they can utilize <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> to establish a DC optimal power flow model. However, as consistently emphasized throughout this manual, it is significantly more advantageous to reuse the optimal power flow model instead.</p><hr/><h2 id="DCReusingOptimalPowerFlowModelManual"><a class="docs-heading-anchor" href="#DCReusingOptimalPowerFlowModelManual">Reusing Optimal Power Flow Model</a><a id="DCReusingOptimalPowerFlowModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCReusingOptimalPowerFlowModelManual" title="Permalink"></a></h2><p>Efficiently modelling and solving large-scale power systems requires reusing the <code>DCOptimalPowerFlow</code> type, avoiding the need to run <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a>. Constructing an optimal power flow model can be time-consuming, especially for large systems. By creating the <code>DCOptimalPowerFlow</code> composite type once, users can easily adapt it to changes in the power system&#39;s structure, saving computational resources and time. This simplifies dynamic power system modifications without recreating the entire optimization model.</p><p>As demonstrated in this manual, this is achieved by using the <code>DCOptimalPowerFlow</code> type as an argument in functions that add or update components within the <code>PowerSystem</code> composite type. If these changes are valid and provide accurate solutions, these functions will automatically adjust the composite types, ensuring smooth integration for dynamic power system adjustments while maintaining the integrity of the DC optimal power flow analysis.</p><hr/><h5 id="Starting-Primal-Values"><a class="docs-heading-anchor" href="#Starting-Primal-Values">Starting Primal Values</a><a id="Starting-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Starting-Primal-Values" title="Permalink"></a></h5><p>Utilizing the <code>DCOptimalPowerFlow</code> type and proceeding directly to the solver offers the advantage of a &quot;warm start&quot;. In this scenario, the starting primal values for the subsequent solving step correspond to the solution obtained from the previous step.</p><p>In the previous example, we obtained the following solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.0
Generator 2: 0.19000000000000128</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.17
Bus 2: 0.17035714285714293
Bus 3: 0.16992857142857146</code></pre><p>Now, let us introduce changes to the power system from the previous example:</p><pre><code class="language-julia hljs">updateGenerator!(system, analysis; label = &quot;Generator 2&quot;, maxActive = 0.08)</code></pre><p>Next, solve this new power system. During the execution of the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, DCOptimalPowerFlow}"><code>solve!</code></a> function, the primal starting values will first be set, and these values will be defined according to the values given above.</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>As a result, we obtain a new solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.11000000000000565
Generator 2: 0.08</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.17
Bus 2: 0.16878571428571426
Bus 3: 0.16914285714285712</code></pre><p>Users retain the flexibility to reset these initial primal values to their default configurations at any juncture. This can be accomplished by utilizing the active power outputs of the generators and the initial bus voltage angles extracted from the <code>PowerSystem</code> composite type, employing the <a href="../../api/optimalPowerFlow/#JuliaGrid.startingPrimal!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>startingPrimal!</code></a> function:</p><pre><code class="language-julia hljs">startingPrimal!(system, analysis)</code></pre><p>These values are precisely identical to what we would obtain if we executed the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function following all the updates we performed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 3.2
Generator 2: 0.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.17
Bus 2: 0.0
Bus 3: 0.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acOptimalPowerFlow/">« AC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../../tutorials/acdcModel/">AC and DC Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Tuesday 3 October 2023 09:32">Tuesday 3 October 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
