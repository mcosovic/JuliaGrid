<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC Optimal Power Flow ¬∑ JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li class="is-active"><a class="tocitem" href>DC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#DCOptimizationProblemTutorials"><span>Optimization Problem</span></a></li><li><a class="tocitem" href="#DCOptimalPowerFlowSolutionTutorials"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#DCOptimalPowerAnalysisTutorials"><span>Power Analysis</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/dcOptimalPowerFlow.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DCOptimalPowerFlowTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowTutorials">DC Optimal Power Flow</a><a id="DCOptimalPowerFlowTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowTutorials" title="Permalink"></a></h1><p>To begin, the <code>PowerSystem</code> composite type must be provided to JuliaGrid through the use of the <a href="../../api/powerSystemModel/#JuliaGrid.powerSystem"><code>powerSystem</code></a> function, as illustrated by the following example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, angle = 0.17)
addBus!(system; label = 2, type = 2, active = 0.1, conductance = 0.04)
addBus!(system; label = 3, type = 1, active = 0.05)

@branch(minDiffAngle = -pi, maxDiffAngle = pi)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05, longTerm = 0.15)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.01, longTerm = 0.10)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.01, longTerm = 0.25)

addGenerator!(system; label = 1, bus = 1, active = 3.2, minActive = 0.0, maxActive = 0.5)
addGenerator!(system; label = 2, bus = 2, active = 0.4, minActive = 0.0, maxActive = 0.6)
addGenerator!(system; label = 3, bus = 2, active = 0.2, minActive = 0.0, maxActive = 0.3)

addActiveCost!(system; label = 1, model = 2, polynomial = [1100.2; 500; 80])
addActiveCost!(system; label = 2, model = 2, polynomial = [832.6; 258; 30])
addActiveCost!(system; label = 3, model = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where we have the set of buses <span>$\mathcal{N} = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> within the power system. This can be visualized as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí© = collect(keys(sort(system.bus.label)))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñ∞ = [system.branch.layout.from system.branch.layout.to]</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Matrix{Int64}:
 1  2
 1  3
 2  3</code></pre><p>Moreover, we identify the set of generators as <span>$\mathcal{P} = \{1, \dots, n_g\}$</span> within the power system. For the specific example at hand, it can be represented as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí´ = collect(keys(sort(system.generator.label)))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code></pre><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>In this section, when referring to a vector <span>$\mathbf{a}$</span>, we use the notation <span>$\mathbf{a} = [a_{i}]$</span> or <span>$\mathbf{a} = [a_{ij}]$</span>, where <span>$a_i$</span> denotes the generic element associated with bus <span>$i \in \mathcal{N}$</span> or generator <span>$i \in \mathcal{P}$</span>, while <span>$a_{ij}$</span> denotes the generic element associated with branch <span>$(i,j) \in \mathcal{E}$</span>.</p></div></div><hr/><h2 id="DCOptimizationProblemTutorials"><a class="docs-heading-anchor" href="#DCOptimizationProblemTutorials">Optimization Problem</a><a id="DCOptimizationProblemTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimizationProblemTutorials" title="Permalink"></a></h2><p>The DC optimal power flow problem has the form:</p><p class="math-container">\[\begin{aligned}
    &amp; {\text{minimize}} &amp; &amp; \sum_{i=1}^{n_\text{g}} f_i(P_{\text{g}i}) \\
    &amp; \text{subject\;to} &amp; &amp;  \theta_i  = \text{constant},\;\;\; i \in \mathcal{N_{\text{sb}}}  \\
    &amp; &amp; &amp; \sum_{k=1}^{n_{\text{g}i}} P_{\text{g}k} - \sum_{k = 1}^n {B}_{ik} \theta_k = P_{\text{d}i} + P_{\text{sh}i} + P_{\text{tr}i},\;\;\;  \forall i \in \mathcal{N} \\
    &amp; &amp; &amp;  - P_{ij}^{\text{max}} \leq \frac{1}{\tau_{ij} x_{ij} }(\theta_i - \theta_j - \phi_{ij}) \leq P_{ij}^{\text{max}},\;\;\; \forall (i,j) \in \mathcal{E} \\
     &amp; &amp; &amp; \theta_{ij}^\text{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\text{max},\;\;\; \forall (i,j) \in \mathcal{E} \\
    &amp; &amp; &amp; P_{\text{g}i}^\text{min} \leq P_{\text{g}i} \leq P_{\text{g}i}^\text{max} ,\;\;\; \forall i \in \mathcal{P}.
\end{aligned}\]</p><p>In this formulation, the optimization variables are the generator output active powers <span>$P_{\text{g}i}$</span>, <span>$i \in \mathcal{P}$</span>, and the bus voltage angles <span>$\theta_i$</span>, <span>$i \in \mathcal{N}$</span>. The objective function represents the sum of the active power cost functions <span>$f_i(P_{\text{g}i})$</span>, <span>$i \in \mathcal{P}$</span>, for each generator, where these cost functions can be polynomial or linear piecewise functions. It is important to note that only polynomial cost functions up to the second degree are included in the objective function. If higher-degree polynomials are present, they will be excluded from the objective function by JuliaGrid.</p><hr/><h5 id="Formulating-the-Optimization-Problem"><a class="docs-heading-anchor" href="#Formulating-the-Optimization-Problem">Formulating the Optimization Problem</a><a id="Formulating-the-Optimization-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Formulating-the-Optimization-Problem" title="Permalink"></a></h5><p>Firstly, the power system is loaded and the DC model is built using the following function:</p><pre><code class="language-julia hljs">dcModel!(system)</code></pre><p>Next, the above optimization problem is constructed by the function <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a>, and we need to specify the optimization solver as follows:</p><pre><code class="language-julia hljs">model = dcOptimalPowerFlow(system, HiGHS.Optimizer)</code></pre><hr/><h5 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h5><p>The first equality constraint is associated with the slack bus, where the bus voltage angle is fixed to a constant value represented by:</p><p class="math-container">\[\theta_i  = \text{constant},\;\;\; i \in \mathcal{N_{\text{sb}}}.\]</p><p>Here, the set <span>$\mathcal{N}_{\text{sb}}$</span> contains the index of the slack bus. This constraint is added using the <code>angle</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. To retrieve the equality constraint from the model, you can access the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.slack.angle</code><code class="nohighlight hljs ansi" style="display:block;">angle[1] = 0.17</code></pre><p>The second equality constraint in the optimization problem relates to the active power balance equations for each bus and can be derived using the <a href="../acdcModel/#DCUnifiedBranchModelTutorials">unified branch model</a>. The constraint is expressed as follows:</p><p class="math-container">\[\sum_{k=1}^{n_{\text{g}i}} P_{\text{g}k} - \sum_{k = 1}^n {B}_{ik} \theta_k = P_{\text{d}i} + P_{\text{sh}i} + P_{\text{tr}i},\;\;\;  \forall i \in \mathcal{N}.\]</p><p>In the equation above, <span>$P_{\text{g}k}$</span> represents the active power output of the <span>$k$</span>-th generator connected to bus <span>$i \in \mathcal{N}$</span>, and <span>$n_{\text{g}i}$</span> denotes the total number of generators connected to the same bus. The constant terms in these equations are determined by the active power demand at bus <span>$P_{\text{d}i}$</span> and the active power demanded by the shunt element <span>$P_{\text{sh}i}$</span>, which can be defined using the <code>active</code> and <code>conductance</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, respectively. If there are phase shift transformers in the system, the constant terms can also be affected by the <code>shiftAngle</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function, denoted as <span>$P_{\text{tr}i}$</span>. To retrieve this equality constraint from the model and access the corresponding variable, you can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.balance.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 -active[1] + 120 angle[1] - 20 angle[2] - 100 angle[3] = 0
 -active[2] - active[3] - 20 angle[1] + 120 angle[2] - 100 angle[3] = -0.14
 -100 angle[1] - 100 angle[2] + 200 angle[3] = -0.05</code></pre><p>Using the <a href="../acdcModel/#DCUnifiedBranchModelTutorials">unified branch model</a>, we can derive an inequality constraint related to active power rating constraints, which represents the thermal limit constraints on a branch. The constraint is defined as follows:</p><p class="math-container">\[- P_{ij}^{\text{max}} \leq \frac{1}{\tau_{ij} x_{ij} }(\theta_i - \theta_j - \phi_{ij}) \leq P_{ij}^{\text{max}},\;\;\; \forall (i,j) \in \mathcal{E}.\]</p><p>This inequality constraint, with lower and upper bounds, is associated with the active power flow limits at the &quot;to&quot; and &quot;from&quot; ends of the branch, respectively. The lower and upper bounds <span>$P_{ij}^{\text{max}}$</span>, <span>$(i,j) \in \mathcal{E}$</span>, are defined using the <code>longTerm</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. To retrieve this inequality constraint from the model and access the corresponding variable, you can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.rating.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 angle[1] - angle[2] ‚àà [-0.0075, 0.0075]
 angle[1] - angle[3] ‚àà [-0.001, 0.001]
 angle[2] - angle[3] ‚àà [-0.0025, 0.0025]</code></pre><p>The inequality constraint related to the minimum and maximum bus voltage angle difference between the &quot;from&quot; and &quot;to&quot; bus ends of each branch is defined as follows:</p><p class="math-container">\[\theta_{ij}^\text{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\text{max},\;\;\; \forall (i,j) \in \mathcal{E},\]</p><p>The values <span>$\theta_{ij}^\text{min}$</span> and <span>$\theta_{ij}^\text{max}$</span> are specified using the <code>minDiffAngle</code> and <code>maxDiffAngle</code> keywords, respectively, within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. To retrieve this inequality constraint from the model and access the corresponding variable, you can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.limit.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 angle[1] - angle[2] ‚àà [-3.141592653589793, 3.141592653589793]
 angle[1] - angle[3] ‚àà [-3.141592653589793, 3.141592653589793]
 angle[2] - angle[3] ‚àà [-3.141592653589793, 3.141592653589793]</code></pre><p>The inequality constraints associated with the minimum and maximum active power outputs of the generators are defined as follows:</p><p class="math-container">\[P_{\text{g}i}^\text{min} \leq P_{\text{g}i} \leq P_{\text{g}i}^\text{max} ,\;\;\; \forall i \in \mathcal{P},\]</p><p>These limits <span>$P_{\text{g}i}^\text{min}$</span> and <span>$P_{\text{g}i}^\text{max}$</span> are specified using the <code>minActive</code> and <code>maxActive</code> keywords, respectively, within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. To retrieve this equality constraint from the model, you can use the following code:  </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.capability.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 active[1] ‚àà [0, 0.5]
 active[2] ‚àà [0, 0.6]
 active[3] ‚àà [0, 0.3]</code></pre><hr/><h2 id="DCOptimalPowerFlowSolutionTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowSolutionTutorials">Optimal Power Flow Solution</a><a id="DCOptimalPowerFlowSolutionTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowSolutionTutorials" title="Permalink"></a></h2><p>To acquire the output active power of generators and the bus voltage angles, the user must invoke the function:</p><pre><code class="language-julia hljs">solve!(system, model)</code></pre><p>Therefore, to get the vector of output active power of generators <span>$\mathbf{P}_{\text{g}} = [P_{\text{g}i}]$</span>, <span>$i \in \mathcal{P}$</span>, you can use the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çí = model.power.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.19000000000000483</code></pre><p>Further, the resulting bus voltage angles <span>$\bm{\theta} = [\theta_{i}]$</span>, <span>$i \in \mathcal{N}$</span>, are saved in the vector as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõâ = model.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.17
 0.17035714285714293
 0.16992857142857146</code></pre><hr/><h2 id="DCOptimalPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerAnalysisTutorials">Power Analysis</a><a id="DCOptimalPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerAnalysisTutorials" title="Permalink"></a></h2><p>After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches, and generators using the <a href="../../api/analysis/#JuliaGrid.power-Tuple{PowerSystem, ACPowerFlow}"><code>power</code></a> function:  </p><pre><code class="language-julia hljs">powers = power(system, model)</code></pre><hr/><h5 id="Powers-Related-to-Buses"><a class="docs-heading-anchor" href="#Powers-Related-to-Buses">Powers Related to Buses</a><a id="Powers-Related-to-Buses-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-Related-to-Buses" title="Permalink"></a></h5><p>To obtain the active power injections at each bus <span>$i \in \mathcal{N}$</span>, we can refer to section <a href="../acdcModel/#DCModelTutorials">DC Model</a>, which provides the following expression:</p><p class="math-container">\[   P_i = \sum_{j = 1}^n {B}_{ij} \theta_j + P_{\text{tr}i} + P_{\text{sh}i},\;\;\; i \in \mathcal{N}.\]</p><p>Active power injections are stored as the vector <span>$\mathbf{P} = [P_i]$</span>, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè = powers.bus.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
  0.09000000000000483
 -0.05</code></pre><p>The active power supplied by generators to the buses can be calculated by summing the active power outputs of the generators obtained from the optimal DC power flow. This can be expressed as:</p><p class="math-container">\[    P_{\text{s}i} = \sum_{k=1}^{n_{\text{g}i}} P_{\text{g}k},\;\;\; i \in \mathcal{N}.\]</p><p>Here, <span>$P_{\text{g}k}$</span> represents the active power output of the <span>$k$</span>-th generator connected to bus <span>$i \in \mathcal{N}$</span>, and <span>$n_{\text{g}i}$</span> denotes the total number of generators connected to the same bus. We can obtain the vector of active power injected by generators to the buses, denoted as <span>$\mathbf{P}_{\text{s}} = [P_{\text{s}i}]$</span>, using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çõ = powers.bus.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.19000000000000483
 0.0</code></pre><hr/><h5 id="Powers-Related-to-Branches"><a class="docs-heading-anchor" href="#Powers-Related-to-Branches">Powers Related to Branches</a><a id="Powers-Related-to-Branches-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-Related-to-Branches" title="Permalink"></a></h5><p>The active power flows at each &quot;from&quot; bus end <span>$i \in \mathcal{N}$</span> of the branch can be obtained using the following equations:</p><p class="math-container">\[    P_{ij} = \cfrac{1}{\tau_{ij} x_{ij}} (\theta_{i} -\theta_{j}-\phi_{ij}),\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The resulting active power flows are stored as the vector <span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span>, which can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè·µ¢ = powers.branch.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.007142857142858339
  0.007142857142855563
  0.04285714285714726</code></pre><p>Similarly, the active power flows at each &quot;to&quot; bus end <span>$j \in \mathcal{N}$</span> of the branch can be obtained as:</p><p class="math-container">\[    P_{ji} = - P_{ij},\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The resulting active power flows are stored as the vector <span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span>, which can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚±º = powers.branch.to.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.007142857142858339
 -0.007142857142855563
 -0.04285714285714726</code></pre><hr/><h5 id="Powers-Related-to-Generators"><a class="docs-heading-anchor" href="#Powers-Related-to-Generators">Powers Related to Generators</a><a id="Powers-Related-to-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-Related-to-Generators" title="Permalink"></a></h5><p>For consistency, the <a href="../../api/analysis/#JuliaGrid.power-Tuple{PowerSystem, ACPowerFlow}"><code>power</code></a> function provides a variable that represents the output active power of generators. This variable is a reference to the <code>power</code> field of the <code>Model</code> type. It is important to note that the output active power of each generator <span>$i \in \mathcal{P}$</span> is an optimization variable obtained after solving the DC optimal power flow problem. To obtain the vector of output active power of generators, denoted as <span>$\mathbf{P}_{\text{g}} = [P_{\text{g}i}]$</span>, you can utilize the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çí = powers.generator.output.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.19000000000000483</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dcPowerFlow/">¬´ DC Power Flow</a><a class="docs-footer-nextpage" href="../../api/powerSystemModel/">Power System Model ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 24 July 2023 13:11">Monday 24 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
