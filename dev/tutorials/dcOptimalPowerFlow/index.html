<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC Optimal Power Flow ¬∑ JuliaGrid</title><meta name="title" content="DC Optimal Power Flow ¬∑ JuliaGrid"/><meta property="og:title" content="DC Optimal Power Flow ¬∑ JuliaGrid"/><meta property="twitter:title" content="DC Optimal Power Flow ¬∑ JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>DC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#DCOptimalPowerFlowModelTutorials"><span>Optimal Power Flow Model</span></a></li><li><a class="tocitem" href="#Objective-Function"><span>Objective Function</span></a></li><li><a class="tocitem" href="#Constraint-Functions"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#DCOptimalPowerFlowSolutionTutorials"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#DCOptimalPowerAnalysisTutorials"><span>Power Analysis</span></a></li></ul></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/dcOptimalPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DCOptimalPowerFlowTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowTutorials">DC Optimal Power Flow</a><a id="DCOptimalPowerFlowTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowTutorials" title="Permalink"></a></h1><p>To begin, let us generate the <code>PowerSystem</code> composite type, as illustrated by the following example:</p><pre><code class="language-julia hljs">using JuMP, HiGHS

system = powerSystem()

addBus!(system; label = 1, type = 3, angle = 0.17)
addBus!(system; label = 2, type = 2, active = 0.1, conductance = 0.04)
addBus!(system; label = 3, type = 1, active = 0.05)

@branch(minDiffAngle = -pi, maxDiffAngle = pi)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05, longTerm = 0.15)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.01, longTerm = 0.10)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.01, longTerm = 0.25)

@generator(minActive = 0.0)
addGenerator!(system; label = 1, bus = 1, active = 3.2, maxActive = 0.5)
addGenerator!(system; label = 2, bus = 2, active = 0.2, maxActive = 0.3)

cost!(system; label = 1, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; label = 2, active = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where we have the set of buses <span>$\mathcal{N} = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí© = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;1&quot;
 &quot;2&quot;
 &quot;3&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñ∞ = [ùí©[system.branch.layout.from] ùí©[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Matrix{String}:
 &quot;1&quot;  &quot;2&quot;
 &quot;1&quot;  &quot;3&quot;
 &quot;2&quot;  &quot;3&quot;</code></pre><p>Moreover, we identify the set of generators as <span>$\mathcal{S} = \{1, \dots, n_\text{g}\}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùíÆ = collect(keys(system.generator.label))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;1&quot;
 &quot;2&quot;</code></pre><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>Here, when referring to a vector <span>$\mathbf{a}$</span>, we use the notation <span>$\mathbf{a} = [a_{i}]$</span> or <span>$\mathbf{a} = [a_{ij}]$</span>, where <span>$a_i$</span> represents the element related with bus <span>$i \in \mathcal{N}$</span> or generator <span>$i \in \mathcal{S}$</span>, while <span>$a_{ij}$</span> denotes the element related with branch <span>$(i,j) \in \mathcal{E}$</span>.</p></div></div><hr/><h2 id="DCOptimalPowerFlowModelTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowModelTutorials">Optimal Power Flow Model</a><a id="DCOptimalPowerFlowModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowModelTutorials" title="Permalink"></a></h2><p>In the DC optimal power flow, the active power outputs of the generators <span>$\mathbf {P}_{\text{g}} = [{P}_{\text{g}i}]$</span>, <span>$i \in \mathcal{S}$</span>, are represented as linear functions of the bus voltage angles <span>$\bm{\Theta} = [{\theta}_{i}]$</span>, <span>$i \in \mathcal{N}$</span>. Thus, the optimization variables in this model are the active power outputs of the generators and the bus voltage angles.</p><p>The DC optimal power flow model has the form:</p><p class="math-container">\[\begin{aligned}
    &amp; {\text{minimize}} &amp; &amp; \sum_{i \in \mathcal{S}} f_i(P_{\text{g}i}) \\
    &amp; \text{subject\;to} &amp; &amp;  \theta_i - \theta_{\text{s}} = 0,\;\;\; i \in \mathcal{N_{\text{sb}}}  \\[3pt]
    &amp; &amp; &amp; h_{P_i}(\mathbf {P}_{\text{g}}, \bm{\Theta}) = 0,\;\;\;  \forall i \in \mathcal{N} \\[3pt]
    &amp; &amp; &amp; \theta_{ij}^\text{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\text{max},\;\;\; \forall (i,j) \in \mathcal{E} \\[3pt]
    &amp; &amp; &amp;  - P_{ij}^{\text{max}} \leq h_{P_{ij}}(\theta_i, \theta_j) \leq P_{ij}^{\text{max}},\;\;\; \forall (i,j) \in \mathcal{E} \\[3pt]
    &amp; &amp; &amp; P_{\text{g}i}^\text{min} \leq P_{\text{g}i} \leq P_{\text{g}i}^\text{max} ,\;\;\; \forall i \in \mathcal{S}.
\end{aligned}\]</p><p>Essentially, the DC optimal power flow is focused on the minimization of the objective function related to the costs associated with the active power output of generators, all while ensuring the satisfaction of various constraints. This optimization task holds a crucial role in the efficient and timely management of electrical power systems. However, it is important to note that the solutions provided by the DC optimal power flow are approximate in nature.</p><hr/><h5 id="Build-Optimal-Power-Flow-Model"><a class="docs-heading-anchor" href="#Build-Optimal-Power-Flow-Model">Build Optimal Power Flow Model</a><a id="Build-Optimal-Power-Flow-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Build-Optimal-Power-Flow-Model" title="Permalink"></a></h5><p>To build the DC optimal power flow model, we must first load the power system and establish the DC model using:</p><pre><code class="language-julia hljs">dcModel!(system)</code></pre><p>Afterward, the DC optimal power flow model is created using the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)</code></pre><hr/><h5 id="Optimization-Variables"><a class="docs-heading-anchor" href="#Optimization-Variables">Optimization Variables</a><a id="Optimization-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Variables" title="Permalink"></a></h5><p>Hence, the variables in this model encompass the active power outputs of the generators denoted as <span>$\mathbf{P}_{\text{g}} = [{P}_{\text{g}i}]$</span>, where <span>$i \in \mathcal{S}$</span>, and the bus voltage angles represented by <span>$\bm{\Theta} = [{\theta}_{i}]$</span>, where <span>$i \in \mathcal{N}$</span>. You can access these variables using the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çí = analysis.method.variable.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{VariableRef}:
 active[1]
 active[2]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùöØ = analysis.method.variable.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{VariableRef}:
 angle[1]
 angle[2]
 angle[3]</code></pre><hr/><h2 id="Objective-Function"><a class="docs-heading-anchor" href="#Objective-Function">Objective Function</a><a id="Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Function" title="Permalink"></a></h2><p>The objective function represents the sum of the active power cost functions <span>$f_i(P_{\text{g}i})$</span>, <span>$i \in \mathcal{S}$</span>, for each generator, where these cost functions can be polynomial or linear piecewise functions. It is important to note that only polynomial cost functions up to the second degree are included in the objective function. If higher-degree polynomials are present, they will be excluded from the objective function by JuliaGrid.</p><hr/><h5 id="Polynomial-Active-Power-Cost-Function"><a class="docs-heading-anchor" href="#Polynomial-Active-Power-Cost-Function">Polynomial Active Power Cost Function</a><a id="Polynomial-Active-Power-Cost-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Active-Power-Cost-Function" title="Permalink"></a></h5><p>The DC optimal power flow in JuliaGrid allows the cost function <span>$f_i(P_{\text{g}i})$</span> to be represented as a polynomial of up to the second degree, making it possible to express the cost function as linear or quadratic. The possible representations are as follows:</p><p class="math-container">\[\begin{aligned}
  f_i(P_{\text{g}i}) &amp;= a_1P_{\text{g}i} + a_0 \\
  f_i(P_{\text{g}i}) &amp;= a_2 P_{\text{g}i}^2 + a_1P_{\text{g}i} + a_0.
\end{aligned}\]</p><p>Furthermore, it is worth noting that the function can be given simply as a constant with only the coefficient <span>$a_0$</span>, which implies that the cost of the generator remains constant regardless of the active power outputs. In conclusion, as illustrated in Figure 1, typical scenarios involve linear or quadratic cost functions, resulting in a best-case scenario for a linear optimization problem and a worst-case scenario for a quadratic optimization problem.</p><img src="../../assets/cost_function_dc.svg" class="center" width="500"/>
<figcaption>Figure 1: The polynomial cost functions of generator active power output.</figcaption>
&nbsp;<p>When utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function within JuliaGrid, employing the <code>polynomial</code> keyword results in the polynomial being constructed with coefficients ordered from the highest degree to the lowest. For instance, in the provided case study, we created a quadratic polynomial represented as:</p><p class="math-container">\[\begin{aligned}
  f_1(P_{\text{g}1}) &amp;= 1100.2 P_{\text{g}1}^2 + 500 P_{\text{g}1} + 80.
\end{aligned}\]</p><p>To access these coefficients, users can utilize the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f‚ÇÅ = system.generator.cost.active.polynomial[1]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1100.2
  500.0
   80.0</code></pre><hr/><h5 id="Linear-Piecewise-Active-Power-Cost-Function"><a class="docs-heading-anchor" href="#Linear-Piecewise-Active-Power-Cost-Function">Linear Piecewise Active Power Cost Function</a><a id="Linear-Piecewise-Active-Power-Cost-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Piecewise-Active-Power-Cost-Function" title="Permalink"></a></h5><p>The DC optimal power flow in JuliaGrid offers another option for defining cost functions by using linear piecewise functions as approximations of the polynomial functions, as depicted in Figure 2.</p><img src="../../assets/cost_function_piecewise_dc.svg" class="center" width="500"/>
<figcaption>Figure 2: The linear piecewise cost functions of active power output.</figcaption>
&nbsp;<p>To define linear piecewise functions in JuliaGrid, users can utilize the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function with the <code>piecewise</code> keyword. The linear piecewise function is constructed using a matrix where each row defines a single point. The first column holds the generator&#39;s active power output, while the second column corresponds to the associated cost value. For example, in the provided case study, a linear piecewise function is created and can be accessed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f‚ÇÇ = system.generator.cost.active.piecewise[2]</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Matrix{Float64}:
 10.85  12.3
 14.77  16.8
 18.0   18.1</code></pre><p>Similar to how convex linear piecewise functions are treated in the <a href="../acOptimalPowerFlow/#ACOptimalPowerFlowTutorials">AC Optimal Power Flow</a>, JuliaGrid adopts a constrained cost variable method for the linear piecewise functions. In this method, the piecewise linear cost function is converted into a series of linear inequality constraints for each segment, which are defined by two adjacent points along the line, along with a helper variable specific to the piecewise function. However, for linear piecewise functions that have only one segment defined by two points, JuliaGrid simplifies it into a standard linear function without requiring a helper variable.</p><p>Consequently, for a piecewise cost function denoted as <span>$f_i(P_{\text{g}i})$</span> with <span>$k$</span> segments (where <span>$k &gt; 1$</span>), the <span>$j$</span>-th segment, defined by the points <span>$[P_{\text{g}i,j}, f_i(P_{\text{g}i,j})]$</span> and <span>$[P_{\text{g}i,j+1}, f_i(P_{\text{g}i,j+1})]$</span>, is characterized by the following inequality constraints:</p><p class="math-container">\[\cfrac{f_i(P_{\text{g}i,j+1}) - f_i(P_{\text{g}i,j})}{P_{\text{g}i,j+1} - P_{\text{g}i,j}}(P_{\text{g}i} - P_{\text{g}i,j}) + f_i(P_{\text{g}i,j}) \leq H_i, \;\;\; i \in \mathcal{S}, \;\;\; j = 1,\dots,k,\]</p><p>where <span>$H_i$</span> represents the helper variable. To finalize this method, we simply need to include the helper variable <span>$H_i$</span> in the objective function. This approach efficiently handles linear piecewise cost functions, providing the flexibility to capture nonlinear characteristics while still benefiting from the advantages of linear optimization techniques.</p><p>As an example, in the provided case study, the helper variable is defined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; H‚ÇÇ = analysis.method.variable.actwise[2]</code><code class="nohighlight hljs ansi" style="display:block;">actwise[2]</code></pre><p>Lastly, the set of constraints introduced by the linear piecewise cost function is displayed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.piecewise.active)</code><code class="nohighlight hljs ansi" style="display:block;">1.1479591836734695 active[2] - actwise[2] ‚â§ 0.15535714285714342
0.40247678018575866 active[2] - actwise[2] ‚â§ -10.855417956656346</code></pre><hr/><h5 id="Objective-Function-2"><a class="docs-heading-anchor" href="#Objective-Function-2">Objective Function</a><a class="docs-heading-anchor-permalink" href="#Objective-Function-2" title="Permalink"></a></h5><p>As previously explained, the objective function relies on the defined polynomial or linear piecewise cost functions and represents the sum of these costs. In the provided example, the objective function that must be minimized to obtain the optimal values for the active power output of the generators and the bus voltage angles can be accessed using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 active[1]¬≤ + 500 active[1] + actwise[2] + 80</code></pre><hr/><h2 id="Constraint-Functions"><a class="docs-heading-anchor" href="#Constraint-Functions">Constraint Functions</a><a id="Constraint-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Functions" title="Permalink"></a></h2><p>In the following section, we will examine the various constraints defined within the DC optimal power flow model.</p><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The first equality constraint is linked to the slack bus, where the bus voltage angle denoted as <span>$\theta_i$</span> is fixed to a constant value <span>$\theta_{\text{s}}$</span>. It can be expressed as follows:</p><p class="math-container">\[\theta_i - \theta_{\text{s}} = 0,\;\;\; i \in \mathcal{N_{\text{sb}}},\]</p><p>where the set <span>$\mathcal{N}_{\text{sb}}$</span> contains the index of the slack bus. To access the equality constraint from the model, we can utilize the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">angle[1] = 0.17</code></pre><hr/><h5 id="Active-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Balance-Constraints">Active Power Balance Constraints</a><a id="Active-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Balance-Constraints" title="Permalink"></a></h5><p>The second equality constraint in the optimization problem is associated with the active power balance equation:</p><p class="math-container">\[h_{P_i}(\mathbf {P}_{\text{g}}, \bm{\Theta}) = 0,\;\;\;  \forall i \in \mathcal{N}.\]</p><p>As elaborated in the <a href="../powerSystemModel/#DCNodalNetworkEquationsTutorials">Nodal Network Equations</a> section, we can express the equation as follows:</p><p class="math-container">\[h_{P_i}(\mathbf {P}_{\text{g}}, \bm{\Theta}) = \sum_{k \in \mathcal{S}_i} P_{\text{g}k} - \sum_{k = 1}^n {B}_{ik} \theta_k - P_{\text{d}i} - P_{\text{sh}i} - P_{\text{tr}i}.\]</p><p>In this equation, the set <span>$\mathcal{S}_i \subseteq \mathcal{S}$</span> encompasses all generators connected to bus <span>$i \in \mathcal{N}$</span>, and <span>$P_{\text{g}k}$</span> represents the active power output of the <span>$k$</span>-th generator within the set <span>$\mathcal{S}_i$</span>. More precisely, the variable <span>$P_{\text{g}k}$</span> represents the optimization variable, as well as the bus voltage angle <span>$\theta_k$</span>.</p><p>The constant terms in these equations are determined by the active power demand at bus <span>$P_{\text{d}i}$</span>, the active power demanded by the shunt element <span>$P_{\text{sh}i}$</span>, and power related to the shift angle of the phase transformers <span>$P_{\text{tr}i}$</span>. The values representing these constant terms <span>$\mathbf{P}_{\text{d}} = [P_{\text{d}i}]$</span>, <span>$\mathbf{P}_{\text{sh}} = [P_{\text{sh}i}]$</span>, and <span>$\mathbf{P}_{\text{tr}} = [P_{\text{tr}i}]$</span>, <span>$i, \in \mathcal{N}$</span>, can be accessed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çí = system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.1
 0.05</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çõ‚Çï = system.bus.shunt.conductance</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.04
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çú·µ£ = system.model.dc.shiftPower</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>To retrieve constraints from the model, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">active[1] - 120 angle[1] + 20 angle[2] + 100 angle[3] = 0
active[2] + 20 angle[1] - 120 angle[2] + 100 angle[3] = 0.14
100 angle[1] + 100 angle[2] - 200 angle[3] = 0.05</code></pre><hr/><h5 id="Voltage-Angle-Difference-Constraints"><a class="docs-heading-anchor" href="#Voltage-Angle-Difference-Constraints">Voltage Angle Difference Constraints</a><a id="Voltage-Angle-Difference-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Voltage-Angle-Difference-Constraints" title="Permalink"></a></h5><p>The inequality constraint related to the minimum and maximum bus voltage angle difference between the from-bus and to-bus ends of each branch is defined as follows:</p><p class="math-container">\[\theta_{ij}^\text{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\text{max},\;\;\; \forall (i,j) \in \mathcal{E},\]</p><p>where <span>$\theta_{ij}^\text{min}$</span> represents the minimum, while <span>$\theta_{ij}^\text{max}$</span> represents the maximum of the angle difference between adjacent buses. The values representing the voltage angle difference, denoted as <span>$\bm{\Theta}_{\text{lm}} = [\theta_{ij}^\text{min}, \theta_{ij}^\text{max}]$</span>, <span>$(i,j) \in \mathcal{E}$</span>, are provided as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùöØ‚Çó‚Çò = [system.branch.voltage.minDiffAngle system.branch.voltage.maxDiffAngle]</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Matrix{Float64}:
 -3.14159  3.14159
 -3.14159  3.14159
 -3.14159  3.14159</code></pre><p>To retrieve constraints from the model, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">angle[1] - angle[2] ‚àà [-3.141592653589793, 3.141592653589793]
angle[1] - angle[3] ‚àà [-3.141592653589793, 3.141592653589793]
angle[2] - angle[3] ‚àà [-3.141592653589793, 3.141592653589793]</code></pre><hr/><h5 id="Active-Power-Flow-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Flow-Constraints">Active Power Flow Constraints</a><a id="Active-Power-Flow-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Flow-Constraints" title="Permalink"></a></h5><p>The inequality constraint related to active power flow is used to represent thermal limits on power transmission. This constraint is defined as follows:</p><p class="math-container">\[- P_{ij}^{\text{max}} \leq h_{P_{ij}}(\theta_i, \theta_j) \leq P_{ij}^{\text{max}},\;\;\; \forall (i,j) \in \mathcal{E}.\]</p><p>Here, the lower and upper bounds are determined based on the vector <span>$\mathbf{P}_{\text{max}} = [P_{ij}^\text{max}]$</span>, <span>$(i,j) \in \mathcal{E}$</span>. These bounds can be accessed using the following variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çò‚Çê‚Çì = system.branch.flow.longTerm</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.15
 0.1
 0.25</code></pre><p>The active power flow at branch <span>$(i,j) \in \mathcal{E}$</span> can be derived using the <a href="../powerSystemModel/#DCBranchNetworkEquationsTutorials">Branch Network Equations</a> and is given by:</p><p class="math-container">\[h_{P_{ij}}(\theta_i, \theta_j) = \frac{1}{\tau_{ij} x_{ij} }(\theta_i - \theta_j - \phi_{ij}).\]</p><p>To retrieve constraints from the model, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">angle[1] - angle[2] ‚àà [-0.0075, 0.0075]
angle[1] - angle[3] ‚àà [-0.001, 0.001]
angle[2] - angle[3] ‚àà [-0.0025, 0.0025]</code></pre><hr/><h5 id="Active-Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Capability-Constraints">Active Power Capability Constraints</a><a id="Active-Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Capability-Constraints" title="Permalink"></a></h5><p>The inequality constraints associated with the minimum and maximum active power outputs of the generators are defined as follows:</p><p class="math-container">\[P_{\text{g}i}^\text{min} \leq P_{\text{g}i} \leq P_{\text{g}i}^\text{max} ,\;\;\; \forall i \in \mathcal{S}.\]</p><p>In this representation, the lower and upper bounds are determined by the vector <span>$\mathbf{P}_{\text{lm}} = [P_{\text{g}i}^\text{min}, P_{\text{g}i}^\text{max}]$</span>, <span>$i \in \mathcal{S}$</span>. We can access these bounds using the following variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çó‚Çò = [system.generator.capability.minActive system.generator.capability.maxActive]</code><code class="nohighlight hljs ansi" style="display:block;">2√ó2 Matrix{Float64}:
 0.0  0.5
 0.0  0.3</code></pre><p>To retrieve constraints from the model, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">active[1] ‚àà [0, 0.5]
active[2] ‚àà [0, 0.3]</code></pre><hr/><h2 id="DCOptimalPowerFlowSolutionTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowSolutionTutorials">Optimal Power Flow Solution</a><a id="DCOptimalPowerFlowSolutionTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowSolutionTutorials" title="Permalink"></a></h2><p>To acquire the output active power of generators and the bus voltage angles, the user must invoke the function:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Therefore, to get the vector of output active power of generators <span>$\mathbf{P}_{\text{g}} = [P_{\text{g}i}]$</span>, <span>$i \in \mathcal{S}$</span>, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çí = analysis.power.generator.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.19000000000000128</code></pre><p>Further, the resulting bus voltage angles <span>$\bm{\Theta} = [\theta_{i}]$</span>, <span>$i \in \mathcal{N}$</span>, are saved in the vector as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùöØ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.17
 0.17035714285714293
 0.16992857142857146</code></pre><hr/><h2 id="DCOptimalPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerAnalysisTutorials">Power Analysis</a><a id="DCOptimalPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerAnalysisTutorials" title="Permalink"></a></h2><p>After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> function:</p><pre><code class="language-julia hljs">power!(system, analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Power-Injections"><a class="docs-heading-anchor" href="#Power-Injections">Power Injections</a><a id="Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injections" title="Permalink"></a></h5><p><a href="../powerSystemModel/#DCBusInjectionTutorials">Active power injections</a> are stored as the vector <span>$\mathbf{P} = [P_i]$</span>, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè = analysis.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
  0.09000000000000127
 -0.05</code></pre><hr/><h5 id="Generator-Power-Injections"><a class="docs-heading-anchor" href="#Generator-Power-Injections">Generator Power Injections</a><a id="Generator-Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Power-Injections" title="Permalink"></a></h5><p>The active power supplied by generators to the buses can be calculated by summing the active power outputs of the generators obtained from the optimal DC power flow. This can be expressed as:</p><p class="math-container">\[    P_{\text{p}i} = \sum_{k=1}^{n_{\text{g}i}} P_{\text{g}k},\;\;\; \forall i \in \mathcal{N}.\]</p><p>Here, <span>$P_{\text{g}k}$</span> represents the active power output of the <span>$k$</span>-th generator connected to bus <span>$i \in \mathcal{N}$</span>, and <span>$n_{\text{g}i}$</span> denotes the total number of generators connected to the same bus. We can obtain the vector of active power injected by generators to the buses, denoted as <span>$\mathbf{P}_{\text{p}} = [P_{\text{p}i}]$</span>, using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çö = analysis.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.19000000000000128
 0.0</code></pre><hr/><h5 id="Power-Flows"><a class="docs-heading-anchor" href="#Power-Flows">Power Flows</a><a id="Power-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flows" title="Permalink"></a></h5><p>The resulting <a href="../powerSystemModel/#DCBranchNetworkEquationsTutorials">active power flows</a> are stored as the vector <span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span>, which can be retrieved using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè·µ¢ = analysis.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.007142857142858339
  0.007142857142855563
  0.04285714285714726</code></pre><p>Similarly, the resulting <a href="../powerSystemModel/#DCBranchNetworkEquationsTutorials">active power flows</a> are stored as the vector <span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span>, which can be retrieved using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚±º = analysis.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.007142857142858339
 -0.007142857142855563
 -0.04285714285714726</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acOptimalPowerFlow/">¬´ AC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../measurementModel/">Measurement Model ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 30 April 2024 13:41">Tuesday 30 April 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
