<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC Optimal Power Flow ¬∑ JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>DC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#DCOptimizationProblemTutorials"><span>Optimization Problem</span></a></li><li><a class="tocitem" href="#DCOptimalPowerFlowSolutionTutorials"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#DCOptimalPowerAnalysisTutorials"><span>Power Analysis</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/dcOptimalPowerFlow.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DCOptimalPowerFlowTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowTutorials">DC Optimal Power Flow</a><a id="DCOptimalPowerFlowTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowTutorials" title="Permalink"></a></h1><p>To begin, the <code>PowerSystem</code> composite type must be provided to JuliaGrid through the use of the <a href="../../api/powerSystemModel/#JuliaGrid.powerSystem"><code>powerSystem</code></a> function, as illustrated by the following example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, angle = 0.17)
addBus!(system; label = 2, type = 2, active = 0.1, conductance = 0.04)
addBus!(system; label = 3, type = 1, active = 0.05)

@branch(minDiffAngle = -pi, maxDiffAngle = pi)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05, longTerm = 0.15)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.01, longTerm = 0.10)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.01, longTerm = 0.25)

addGenerator!(system; label = 1, bus = 1, active = 3.2, minActive = 0.0, maxActive = 0.5)
addGenerator!(system; label = 2, bus = 2, active = 0.4, minActive = 0.0, maxActive = 0.6)
addGenerator!(system; label = 3, bus = 2, active = 0.2, minActive = 0.0, maxActive = 0.3)

addActiveCost!(system; label = 1, model = 2, polynomial = [1100.2; 500; 80])
addActiveCost!(system; label = 2, model = 2, polynomial = [832.6; 258; 30])
addActiveCost!(system; label = 3, model = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where we have the set of buses <span>$\mathcal{N} = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> within the power system. This can be visualized as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí© = collect(keys(sort(system.bus.label)))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñ∞ = [system.branch.layout.from system.branch.layout.to]</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Matrix{Int64}:
 1  2
 1  3
 2  3</code></pre><p>Moreover, we identify the set of generators as <span>$\mathcal{P} = \{1, \dots, n_g\}$</span> within the power system. For the specific example at hand, it can be represented as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí´ = collect(keys(sort(system.generator.label)))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code></pre><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>In this section, when referring to a vector <span>$\mathbf{a}$</span>, we use the notation <span>$\mathbf{a} = [a_{i}]$</span> or <span>$\mathbf{a} = [a_{ij}]$</span>, where <span>$a_i$</span> denotes the generic element associated with bus <span>$i \in \mathcal{N}$</span> or generator <span>$i \in \mathcal{P}$</span>, while <span>$a_{ij}$</span> denotes the generic element associated with branch <span>$(i,j) \in \mathcal{E}$</span>.</p></div></div><hr/><h2 id="DCOptimizationProblemTutorials"><a class="docs-heading-anchor" href="#DCOptimizationProblemTutorials">Optimization Problem</a><a id="DCOptimizationProblemTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimizationProblemTutorials" title="Permalink"></a></h2><p>In the DC optimal power flow, the active power outputs of the generators <span>$\mathbf {P}_{\text{g}} = [{P}_{\text{g}i}]$</span>, <span>$i \in \mathcal{P}$</span>, are represented as linear functions of the bus voltage angles <span>$\boldsymbol{\theta} = [{\theta}_{i}]$</span>, <span>$i \in \mathcal{N}$</span>. Therefore, the optimization variables in this model are the active power outputs of the generators and the bus voltage angles. The DC optimal power flow problem has the form:</p><p class="math-container">\[\begin{aligned}
    &amp; {\text{minimize}} &amp; &amp; \sum_{i=1}^{n_\text{g}} f_i(P_{\text{g}i}) \\
    &amp; \text{subject\;to} &amp; &amp;  \theta_i - \theta_{\text{slack}} = 0,\;\;\; i \in \mathcal{N_{\text{sb}}}  \\[3pt]
    &amp; &amp; &amp; h_{P_i}(\mathbf {P}_{\text{g}}, \boldsymbol{\theta}) = 0,\;\;\;  \forall i \in \mathcal{N} \\[3pt]
    &amp; &amp; &amp; \theta_{ij}^\text{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\text{max},\;\;\; \forall (i,j) \in \mathcal{E} \\[3pt]
    &amp; &amp; &amp;  - P_{ij}^{\text{max}} \leq h_{P_{ij}}(\theta_i, \theta_j) \leq P_{ij}^{\text{max}},\;\;\; \forall (i,j) \in \mathcal{E} \\[3pt]
    &amp; &amp; &amp; P_{\text{g}i}^\text{min} \leq P_{\text{g}i} \leq P_{\text{g}i}^\text{max} ,\;\;\; \forall i \in \mathcal{P}.
\end{aligned}\]</p><p>The objective function represents the sum of the active power cost functions <span>$f_i(P_{\text{g}i})$</span>, <span>$i \in \mathcal{P}$</span>, for each generator, where these cost functions can be polynomial or linear piecewise functions. It is important to note that only polynomial cost functions up to the second degree are included in the objective function. If higher-degree polynomials are present, they will be excluded from the objective function by JuliaGrid.</p><hr/><h5 id="Polynomial-Active-Power-Cost-Function"><a class="docs-heading-anchor" href="#Polynomial-Active-Power-Cost-Function">Polynomial Active Power Cost Function</a><a id="Polynomial-Active-Power-Cost-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Active-Power-Cost-Function" title="Permalink"></a></h5><p>The DC optimal power flow in JuliaGrid allows the cost function <span>$f_i(P_{\text{g}i})$</span> to be represented as a polynomial of up to the second degree, making it possible to express the cost function as linear or quadratic. The possible representations are as follows:</p><p class="math-container">\[\begin{aligned}
  f_i(P_{\text{g}i}) &amp;= a_1P_{\text{g}i} + a_0 \\
  f_i(P_{\text{g}i}) &amp;= a_2 P_{\text{g}i}^2 + a_1P_{\text{g}i} + a_0 \\
\end{aligned}\]</p><p>When using the <a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a> function in JuliaGrid with the <code>polynomial</code> keyword, the polynomial is formed with the coefficients arranged from the highest degree to the lowest. For instance, in the case of a quadratic polynomial, the structure will be:</p><p class="math-container">\[\text{polynomial} = [a_2, a_1, a_0].\]</p><p>Furthermore, it is worth noting that the function can be given simply as a constant with only the coefficient <span>$a_0$</span>, which implies that the cost of the generator remains constant regardless of the active power outputs. In conclusion, as illustrated in Figure 1, typical scenarios involve linear or quadratic cost functions, resulting in a best-case scenario for a linear optimization problem and a worst-case scenario for a quadratic optimization problem.</p><img src="../assets/cost_function_dc.svg" class="center" width="500"/>
<figcaption>Figure 1: The polynomial cost functions of generator active power output.</figcaption>
&nbsp;<hr/><h5 id="Linear-Piecewise-Active-Power-Cost-Function"><a class="docs-heading-anchor" href="#Linear-Piecewise-Active-Power-Cost-Function">Linear Piecewise Active Power Cost Function</a><a id="Linear-Piecewise-Active-Power-Cost-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Piecewise-Active-Power-Cost-Function" title="Permalink"></a></h5><p>The DC optimal power flow in JuliaGrid offers another option for defining cost functions by using linear piecewise functions as approximations of the polynomial functions, as depicted in Figure 2.</p><img src="../assets/cost_function_piecewise_dc.svg" class="center" width="500"/>
<figcaption>Figure 2: The linear piecewise cost functions of active power output.</figcaption>
&nbsp;<p>To define the linear piecewise functions in JuliaGrid, you can use the <a href="../../api/powerSystemModel/#JuliaGrid.addActiveCost!"><code>addActiveCost!</code></a> function with the <code>piecewise</code> keyword. The linear piecewise function is formed using a matrix of <span>$m$</span> points, where each row contains the generator active power output and the corresponding cost value:</p><p class="math-container">\[\text{piecewise} = \begin{bmatrix}
P_{\text{g}i,1} &amp; f_i(P_{\text{g}i,1}) \\
\vdots &amp;\\
P_{\text{g}i,m} &amp; f_i(P_{\text{g}i,m})
\end{bmatrix}.\]</p><p>Similar to how convex linear piecewise functions are treated in the <a href="../acOptimalPowerFlow/#ACOptimalPowerFlowTutorials">AC Optimal Power Flow</a>, JuliaGrid adopts a constrained cost variable method for the linear piecewise functions. In this approach, the piecewise linear cost function is transformed into a set of linear inequality constraints using a helper variable for each segment defined by two neighboring points along the line. However, for linear piecewise functions that have only one segment defined by two points, JuliaGrid simplifies it into a standard linear function without requiring a helper variable.</p><p>For an arbitrary segment of the piecewise function defined by the points <span>$(P_{\text{g}i,j}, f_i(P_{\text{g}i,j}))$</span> and <span>$(P_{\text{g}i,j+1}, f_i(P_{\text{g}i,j+1}))$</span>, the function <span>$f_i(P_{\text{g}i})$</span> can be represented by an additional inequality constraint involving the helper variable <span>$H_i$</span>:</p><p class="math-container">\[H_{i} \geq \cfrac{f_i(P_{\text{g}i,j+1}) - f_i(P_{\text{g}i,j})}{P_{\text{g}i,j+1} - P_{\text{g}i,j}}(P_{\text{g}i} - P_{\text{g}i,j}) + f_i(P_{\text{g}i,j}),\;\;\;j = 1,\dots,m/2.\]</p><p>To complete the method, we simply add the helper variable <span>$H_{i}$</span> to the objective function. Using this approach, JuliaGrid efficiently handles linear piecewise cost functions, offering flexibility in capturing non-linear characteristics while maintaining the advantages of linear optimization methods. </p><hr/><h5 id="Formulating-the-Optimization-Problem"><a class="docs-heading-anchor" href="#Formulating-the-Optimization-Problem">Formulating the Optimization Problem</a><a id="Formulating-the-Optimization-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Formulating-the-Optimization-Problem" title="Permalink"></a></h5><p>Firstly, the power system is loaded and the DC model is built using the following function:</p><pre><code class="language-julia hljs">dcModel!(system)</code></pre><p>Next, the above optimization problem is constructed by the function <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a>, and we need to specify the optimization solver as follows:</p><pre><code class="language-julia hljs">model = dcOptimalPowerFlow(system, HiGHS.Optimizer)</code></pre><hr/><h5 id="Objective-Function"><a class="docs-heading-anchor" href="#Objective-Function">Objective Function</a><a id="Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Function" title="Permalink"></a></h5><p>In the provided example, the objective function that needs to be minimized to obtain the optimal values of the active power output of the generators and the bus voltage angles is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(model.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 active[1]¬≤ + 832.6 active[2]¬≤ + 500 active[1] + 258 active[2] + helper[1] + 110</code></pre><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The first equality constraint is linked to the slack bus, where the bus voltage angle denoted as <span>$\theta_i$</span> is fixed to a constant value <span>$\theta_{\text{slack}}$</span>. It can be expressed as follows:</p><p class="math-container">\[\theta_i - \theta_{\text{slack}} = 0,\;\;\; i \in \mathcal{N_{\text{sb}}}.  \]</p><p>Here, the set <span>$\mathcal{N}_{\text{sb}}$</span> contains the index of the slack bus. This constraint is added using the <code>angle</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. </p><p>To retrieve the equality constraint from the model, you can access the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.slack.angle</code><code class="nohighlight hljs ansi" style="display:block;">angle[1] = 0.17</code></pre><hr/><h5 id="Active-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Balance-Constraints">Active Power Balance Constraints</a><a id="Active-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Balance-Constraints" title="Permalink"></a></h5><p>The second equality constraint in the optimization problem is associated with the active power balance equation denoted as <span>$h_{P_i}(\mathbf x)$</span> for each bus <span>$i \in \mathcal{N}$</span>: </p><p class="math-container">\[h_{P_i}(\mathbf {P}_{\text{g}}, \boldsymbol{\theta}) = 0,\;\;\;  \forall i \in \mathcal{N}.\]</p><p>The equation is derived using the <a href="../acdcModel/#DCUnifiedBranchModelTutorials">unified branch model</a> and can be represented as:</p><p class="math-container">\[h_{P_i}(\mathbf {P}_{\text{g}}, \boldsymbol{\theta}) = \sum_{k=1}^{n_{\text{g}i}} P_{\text{g}k} - \sum_{k = 1}^n {B}_{ik} \theta_k - P_{\text{d}i} - P_{\text{sh}i} - P_{\text{tr}i}.\]</p><p>In the equation above, <span>$P_{\text{g}k}$</span> represents the active power output of the <span>$k$</span>-th generator connected to bus <span>$i \in \mathcal{N}$</span>, and <span>$n_{\text{g}i}$</span> denotes the total number of generators connected to the same bus. The constant terms in these equations are determined by the active power demand at bus <span>$P_{\text{d}i}$</span> and the active power demanded by the shunt element <span>$P_{\text{sh}i}$</span>, which can be defined using the <code>active</code> and <code>conductance</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, respectively. If there are phase shift transformers in the system, the constant terms can also be affected by the <code>shiftAngle</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function, denoted as <span>$P_{\text{tr}i}$</span>. </p><p>To retrieve this equality constraint from the model and access the corresponding variable, you can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.balance.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 -active[1] + 120 angle[1] - 20 angle[2] - 100 angle[3] = 0
 -active[2] - active[3] - 20 angle[1] + 120 angle[2] - 100 angle[3] = -0.14
 -100 angle[1] - 100 angle[2] + 200 angle[3] = -0.05</code></pre><hr/><h5 id="Voltage-Angle-Difference-Limit-Constraints"><a class="docs-heading-anchor" href="#Voltage-Angle-Difference-Limit-Constraints">Voltage Angle Difference Limit Constraints</a><a id="Voltage-Angle-Difference-Limit-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Voltage-Angle-Difference-Limit-Constraints" title="Permalink"></a></h5><p>The inequality constraint related to the minimum and maximum bus voltage angle difference between the &quot;from&quot; and &quot;to&quot; bus ends of each branch is defined as follows:</p><p class="math-container">\[\theta_{ij}^\text{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\text{max},\;\;\; \forall (i,j) \in \mathcal{E}.\]</p><p>The values <span>$\theta_{ij}^\text{min}$</span> and <span>$\theta_{ij}^\text{max}$</span> are specified using the <code>minDiffAngle</code> and <code>maxDiffAngle</code> keywords, respectively, within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. </p><p>To retrieve this inequality constraint from the model and access the corresponding variable, you can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.limit.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 angle[1] - angle[2] ‚àà [-3.141592653589793, 3.141592653589793]
 angle[1] - angle[3] ‚àà [-3.141592653589793, 3.141592653589793]
 angle[2] - angle[3] ‚àà [-3.141592653589793, 3.141592653589793]</code></pre><hr/><h5 id="Active-Power-Rating-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Rating-Constraints">Active Power Rating Constraints</a><a id="Active-Power-Rating-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Rating-Constraints" title="Permalink"></a></h5><p>The inequality constraint concerning the active power flow rating is used to represent thermal limits on the power transmission. This constraint is defined as follows:</p><p class="math-container">\[- P_{ij}^{\text{max}} \leq h_{P_{ij}}(\theta_i, \theta_j) \leq P_{ij}^{\text{max}},\;\;\; \forall (i,j) \in \mathcal{E}. \]</p><p>The active power flow at branch <span>$(i,j) \in \mathcal{E}$</span> can be derived using the <a href="../acdcModel/#DCUnifiedBranchModelTutorials">unified branch model</a> and is given by the equation:</p><p class="math-container">\[h_{P_{ij}}(\theta_i, \theta_j) = \frac{1}{\tau_{ij} x_{ij} }(\theta_i - \theta_j - \phi_{ij}).\]</p><p>Hence, this inequality constraint, with lower and upper bounds, is associated with the active power flow limits at the &quot;to&quot; and &quot;from&quot; ends of the branch, respectively. The lower and upper bounds <span>$P_{ij}^{\text{max}}$</span>, <span>$(i,j) \in \mathcal{E}$</span>, are defined using the <code>longTerm</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. </p><p>To retrieve this inequality constraint from the model and access the corresponding variable, you can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.rating.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 angle[1] - angle[2] ‚àà [-0.0075, 0.0075]
 angle[1] - angle[3] ‚àà [-0.001, 0.001]
 angle[2] - angle[3] ‚àà [-0.0025, 0.0025]</code></pre><hr/><h5 id="Active-Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Capability-Constraints">Active Power Capability Constraints</a><a id="Active-Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Capability-Constraints" title="Permalink"></a></h5><p>The inequality constraints associated with the minimum and maximum active power outputs of the generators are defined as follows:</p><p class="math-container">\[P_{\text{g}i}^\text{min} \leq P_{\text{g}i} \leq P_{\text{g}i}^\text{max} ,\;\;\; \forall i \in \mathcal{P}.\]</p><p>These limits <span>$P_{\text{g}i}^\text{min}$</span> and <span>$P_{\text{g}i}^\text{max}$</span> are specified using the <code>minActive</code> and <code>maxActive</code> keywords, respectively, within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. To retrieve this equality constraint from the model, you can use the following code:  </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; model.constraint.capability.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ConstraintRef}:
 active[1] ‚àà [0, 0.5]
 active[2] ‚àà [0, 0.6]
 active[3] ‚àà [0, 0.3]</code></pre><hr/><h2 id="DCOptimalPowerFlowSolutionTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowSolutionTutorials">Optimal Power Flow Solution</a><a id="DCOptimalPowerFlowSolutionTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowSolutionTutorials" title="Permalink"></a></h2><p>To acquire the output active power of generators and the bus voltage angles, the user must invoke the function:</p><pre><code class="language-julia hljs">solve!(system, model)</code></pre><p>Therefore, to get the vector of output active power of generators <span>$\mathbf{P}_{\text{g}} = [P_{\text{g}i}]$</span>, <span>$i \in \mathcal{P}$</span>, you can use the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çí = model.power.active</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: type DCPower has no field active</code></pre><p>Further, the resulting bus voltage angles <span>$\bm{\theta} = [\theta_{i}]$</span>, <span>$i \in \mathcal{N}$</span>, are saved in the vector as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõâ = model.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.17
 0.17035714285714293
 0.16992857142857146</code></pre><hr/><h2 id="DCOptimalPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerAnalysisTutorials">Power Analysis</a><a id="DCOptimalPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerAnalysisTutorials" title="Permalink"></a></h2><p>After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}"><code>power!</code></a> function:  </p><pre><code class="language-julia hljs">power!(system, model)</code></pre><hr/><h5 id="Active-Power-Injections"><a class="docs-heading-anchor" href="#Active-Power-Injections">Active Power Injections</a><a id="Active-Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injections" title="Permalink"></a></h5><p>To obtain the active power injections at each bus <span>$i \in \mathcal{N}$</span>, we can refer to section <a href="../acdcModel/#DCModelTutorials">DC Model</a>, which provides the following expression:</p><p class="math-container">\[   P_i = \sum_{j = 1}^n {B}_{ij} \theta_j + P_{\text{tr}i} + P_{\text{sh}i},\;\;\; i \in \mathcal{N}.\]</p><p>Active power injections are stored as the vector <span>$\mathbf{P} = [P_i]$</span>, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè = model.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
  0.09000000000000483
 -0.05</code></pre><h5 id="Active-Power-Injections-From-the-Generators"><a class="docs-heading-anchor" href="#Active-Power-Injections-From-the-Generators">Active Power Injections From the Generators</a><a id="Active-Power-Injections-From-the-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injections-From-the-Generators" title="Permalink"></a></h5><p>The active power supplied by generators to the buses can be calculated by summing the active power outputs of the generators obtained from the optimal DC power flow. This can be expressed as:</p><p class="math-container">\[    P_{\text{s}i} = \sum_{k=1}^{n_{\text{g}i}} P_{\text{g}k},\;\;\; i \in \mathcal{N}.\]</p><p>Here, <span>$P_{\text{g}k}$</span> represents the active power output of the <span>$k$</span>-th generator connected to bus <span>$i \in \mathcal{N}$</span>, and <span>$n_{\text{g}i}$</span> denotes the total number of generators connected to the same bus. We can obtain the vector of active power injected by generators to the buses, denoted as <span>$\mathbf{P}_{\text{s}} = [P_{\text{s}i}]$</span>, using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çõ = model.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.19000000000000483
 0.0</code></pre><hr/><h5 id="Active-Power-Flows"><a class="docs-heading-anchor" href="#Active-Power-Flows">Active Power Flows</a><a id="Active-Power-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Flows" title="Permalink"></a></h5><p>The active power flows at each &quot;from&quot; bus end <span>$i \in \mathcal{N}$</span> of the branch can be obtained using the following equations:</p><p class="math-container">\[    P_{ij} = \cfrac{1}{\tau_{ij} x_{ij}} (\theta_{i} -\theta_{j}-\phi_{ij}),\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The resulting active power flows are stored as the vector <span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span>, which can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè·µ¢ = model.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.007142857142858339
  0.007142857142855563
  0.04285714285714726</code></pre><p>Similarly, the active power flows at each &quot;to&quot; bus end <span>$j \in \mathcal{N}$</span> of the branch can be obtained as:</p><p class="math-container">\[    P_{ji} = - P_{ij},\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The resulting active power flows are stored as the vector <span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span>, which can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚±º = model.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.007142857142858339
 -0.007142857142855563
 -0.04285714285714726</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acOptimalPowerFlow/">¬´ AC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../../api/powerSystemModel/">Power System Model ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 31 July 2023 11:51">Monday 31 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
