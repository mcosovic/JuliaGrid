<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC State Estimation ¬∑ JuliaGrid</title><meta name="title" content="DC State Estimation ¬∑ JuliaGrid"/><meta property="og:title" content="DC State Estimation ¬∑ JuliaGrid"/><meta property="twitter:title" content="DC State Estimation ¬∑ JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li class="is-active"><a class="tocitem" href>DC State Estimation</a><ul class="internal"><li><a class="tocitem" href="#DCSEModelTutorials"><span>State Estimation Model</span></a></li><li><a class="tocitem" href="#DCSEWLSStateEstimationTutorials"><span>WLS State Estimation</span></a></li><li><a class="tocitem" href="#DCSEBadDataTutorials"><span>Bad Data Processing</span></a></li><li><a class="tocitem" href="#DCSELAVTutorials"><span>LAV State Estimation</span></a></li><li><a class="tocitem" href="#DCSEObservabilityAnalysisTutorials"><span>Observability Analysis</span></a></li><li><a class="tocitem" href="#DCSEPowerAnalysisTutorials"><span>Power Analysis</span></a></li><li><a class="tocitem" href="#DCSEReferenceTutorials"><span>References</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>DC State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/dcStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DCStateEstimationTutorials"><a class="docs-heading-anchor" href="#DCStateEstimationTutorials">DC State Estimation</a><a id="DCStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCStateEstimationTutorials" title="Permalink"></a></h1><p>To initiate the process, let us construct the <code>PowerSystem</code> composite type and formulate the DC model:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, angle = 0.0)
addBus!(system; label = 2, type = 1, active = 0.1)
addBus!(system; label = 3, type = 1, active = 1.3)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.2)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.1)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.3)
addGenerator!(system; label = 1, bus = 1, active = 3.2)

dcModel!(system)</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where we have the set of buses <span>$\mathcal{N} = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí© = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;1&quot;
 &quot;2&quot;
 &quot;3&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñ∞ = [ùí©[system.branch.layout.from] ùí©[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Matrix{String}:
 &quot;1&quot;  &quot;2&quot;
 &quot;1&quot;  &quot;3&quot;
 &quot;2&quot;  &quot;3&quot;</code></pre><hr/><p>Subsequently, we will establish the <code>Measurement</code> composite type and incorporate a set of active power measurements into the graph <span>$\mathcal{G}$</span>. These measurements are conceptualized through a set of wattmeters <span>$\mathcal{P}$</span>:</p><pre><code class="language-julia hljs">device = measurement()

@wattmeter(label = &quot;Wattmeter ?&quot;)
addWattmeter!(system, device; from = 1, active = 0.27, variance = 1e-4, noise = false)
addWattmeter!(system, device; bus = 3, active = -1.21, variance = 1e-3, noise = false)
addWattmeter!(system, device; to = 1, active = -0.28, variance = 1e-4, noise = false)</code></pre><p>In typical scenarios, the DC state estimation model relies solely on active power measurements. However, we allow the possibility for the user to include bus voltage angle measurements from PMUs, represented as the set <span>$\bar{\mathcal{P}}$</span>:</p><pre><code class="language-julia hljs">@pmu(label = &quot;PMU ?&quot;, varianceAngleBus = 1e-5)
addPmu!(system, device; bus = 2, magnitude = 1.0, angle = -0.06, noise = false)
addPmu!(system, device; bus = 3, magnitude = 1.0, angle = -0.12, noise = false)</code></pre><p>As a result, JuliaGrid is capable of conducting DC state estimation utilizing a set of measurement devices denoted as <span>$\mathcal{M} = \mathcal{P} \cup \bar{\mathcal{P}}$</span>, which includes active power flow and injection measurements obtained from wattmeters, as well as bus voltage angle measurements from PMUs.</p><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>In this section, when referring to a vector <span>$\mathbf{a}$</span>, we use the notation <span>$\mathbf{a} = [a_{i}]$</span> or <span>$\mathbf{a} = [a_{ij}]$</span>, where <span>$a_i$</span> represents the element associated with bus <span>$i \in \mathcal{N}$</span> or measurement <span>$i \in \mathcal{M}$</span>, and <span>$a_{ij}$</span> represents the element associated with branch <span>$(i,j) \in \mathcal{E}$</span>.</p></div></div><hr/><h2 id="DCSEModelTutorials"><a class="docs-heading-anchor" href="#DCSEModelTutorials">State Estimation Model</a><a id="DCSEModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEModelTutorials" title="Permalink"></a></h2><p>In accordance with the <a href="../acdcModel/#DCModelTutorials">DC Model</a>, the DC state estimation is derived through the linearization of the non-linear model. In this linearized model, all bus voltage magnitudes are assumed to be <span>$V_i \approx 1$</span>, <span>$i \in \mathcal{N}$</span>. Additionally, shunt elements and branch resistances are neglected. This simplification implies that the DC model disregards reactive powers and transmission losses, focusing solely on active powers. Consequently, the DC state estimation considers only bus voltage angles, represented as <span>$\mathbf x \equiv \bm {\Theta}$</span>, as the state variables. As a result, the total number of state variables is <span>$n-1$</span>, with one voltage angle corresponding to the slack bus.</p><p>Within the JuliaGrid framework for DC state estimation, the methodology encompasses both active power flow and injection measurements from the set <span>$\mathcal{P}$</span>, along with bus voltage angle measurements represented by the set <span>$\bar{\mathcal{P}}$</span>. These measurements contribute to the construction of a linear system of equations:</p><p class="math-container">\[    \mathbf{z}=\mathbf{h}(\bm {\Theta})+\mathbf{u},\]</p><p>where <span>$\mathbf{h}(\bm {\Theta})=$</span> <span>$[h_1(\bm {\Theta})$</span>, <span>$\dots$</span>, <span>$h_k(\bm {\Theta})]^{{T}}$</span> is the vector of linear measurement functions, <span>$\mathbf{z} = [z_1,\dots,z_k]^{\mathrm{T}}$</span> is the vector of measurement values, and <span>$\mathbf{u} = [u_1,\dots,u_k]^{\mathrm{T}}$</span> is the vector of uncorrelated measurement errors, and this defines the vector of measurement variances <span>$\mathbf{v} = [v_1,\dots,v_k]^{\mathrm{T}}$</span>, where <span>$k = |\mathcal{M}|$</span>. </p><p>Therefore, the linear system of equations can be represented based on the specific devices from which measurements originate, whether wattmeters or PMUs:</p><p class="math-container">\[    \begin{bmatrix}    	 
      \mathbf{z}_\mathcal{P}\\[3pt]
      \mathbf{z}_{\bar{\mathcal{P}}}
    \end{bmatrix} =
    \begin{bmatrix}    	 
      \mathbf{h}_\mathcal{P}(\bm {\Theta})\\[3pt]
      \mathbf{h}_{\bar{\mathcal{P}}}(\bm {\Theta})
    \end{bmatrix} + 
    \begin{bmatrix}    	 
      \mathbf{u}_\mathcal{P}\\[3pt]
      \mathbf{u}_{\bar{\mathcal{P}}}
    \end{bmatrix}\]</p><p>In summary, upon user definition of the measurement devices, each <span>$i$</span>-th measurement device is linked to the measurement function <span>$h_i(\bm {\Theta})$</span>, the corresponding measurement value <span>$z_i$</span>, and the measurement variance <span>$v_i$</span>.</p><hr/><h5 id="Active-Power-Flow-Measurement-Functions"><a class="docs-heading-anchor" href="#Active-Power-Flow-Measurement-Functions">Active Power Flow Measurement Functions</a><a id="Active-Power-Flow-Measurement-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Flow-Measurement-Functions" title="Permalink"></a></h5><p>The vector <span>$\mathbf{h}_\mathcal{P}(\bm {\Theta})$</span> comprises functions representing active power flow measurements. Following the guidelines outlined in the <a href="../acdcModel/#DCBranchNetworkEquationsTutorials">DC Model</a>, the functions describing active power flows at the branch <span>$(i,j) \in \mathcal{E}$</span> at the &quot;from&quot; and &quot;to&quot; bus ends are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    h_{P_{ij}}(\cdot) &amp;= \cfrac{1}{\tau_{ij} x_{ij}} (\theta_{i} -\theta_{j}-\phi_{ij})\\
    h_{P_{ji}}(\cdot) &amp;= -\cfrac{1}{\tau_{ij} x_{ij}} (\theta_{i} -\theta_{j}-\phi_{ij}).
  \end{aligned}  \]</p><hr/><h5 id="Active-Power-Injection-Measurement-Functions"><a class="docs-heading-anchor" href="#Active-Power-Injection-Measurement-Functions">Active Power Injection Measurement Functions</a><a id="Active-Power-Injection-Measurement-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection-Measurement-Functions" title="Permalink"></a></h5><p>Moreover, the vector <span>$\mathbf{h}_\mathcal{P}(\bm {\Theta})$</span> incorporates functions designed for measuring active power injections. Utilizing the <a href="../acdcModel/#DCNodalNetworkEquationsTutorials">DC Model</a>, the function defining the active power injection into bus <span>$i \in \mathcal{N}$</span> can be derived as follows:</p><p class="math-container">\[   h_{P_{i}}(\cdot) = B_{ii}\theta_i + \sum_{j \in \mathcal{N}_i \setminus i} {B}_{ij} \theta_j + P_{\text{tr}i} + P_{\text{sh}i},\]</p><p>where <span>$\mathcal{N}_i \setminus i$</span> contains buses incident to bus <span>$i$</span>, excluding bus <span>$i$</span>.</p><hr/><h5 id="Bus-Voltage-Angle-Measurement-Functions"><a class="docs-heading-anchor" href="#Bus-Voltage-Angle-Measurement-Functions">Bus Voltage Angle Measurement Functions</a><a id="Bus-Voltage-Angle-Measurement-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Voltage-Angle-Measurement-Functions" title="Permalink"></a></h5><p>The vector <span>$\mathbf{h}_{\bar{\mathcal{P}}}(\bm {\Theta})$</span> comprises functions for measuring bus voltage angles. The function defining the bus voltage angle at bus <span>$i \in \mathcal{N}$</span> is straightforward:</p><p class="math-container">\[    h_{\theta_{i}}(\cdot) = \theta_{i}.\]</p><hr/><h5 id="Measurement-Values-and-Variances"><a class="docs-heading-anchor" href="#Measurement-Values-and-Variances">Measurement Values and Variances</a><a id="Measurement-Values-and-Variances-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Values-and-Variances" title="Permalink"></a></h5><p>The vectors containing the measurement values <span>$\mathbf{z}_\mathcal{P} = [z_i]$</span> and variances <span>$\mathbf{v}_\mathcal{P} = [v_i]$</span> for wattmeters, where <span>$i \in \mathcal{P}$</span>, are stored in the variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥‚Çö = device.wattmeter.active.mean</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.27
 -1.21
 -0.28</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ‚Çö = device.wattmeter.active.variance</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0001
 0.001
 0.0001</code></pre><p>Similarly, the vectors containing the measurement values <span>$\mathbf{z}_{\bar{\mathcal{P}}} = [z_i]$</span> and variances <span>$\mathbf{v}_{\bar{\mathcal{P}}} = [v_i]$</span> for PMUs, where <span>$i \in \bar{\mathcal{P}}$</span>, are stored in the variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥ÃÑ‚Çö = device.pmu.angle.mean</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.06
 -0.12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØÃÑ‚Çö = device.pmu.angle.variance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.0e-5
 1.0e-5</code></pre><hr/><h2 id="DCSEWLSStateEstimationTutorials"><a class="docs-heading-anchor" href="#DCSEWLSStateEstimationTutorials">WLS State Estimation</a><a id="DCSEWLSStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEWLSStateEstimationTutorials" title="Permalink"></a></h2><p>The solution to the DC state estimation problem is determined by solving the linear weighted least-squares (WLS) problem, represented by the following formula:</p><p class="math-container">\[	\mathbf H^{T} \bm \Sigma^{-1} \mathbf H \bm {\Theta} = \mathbf H^{T} \bm \Sigma^{-1} (\mathbf z - \mathbf{c}).\]</p><p>Here, the vector of measurement values <span>$\mathbf z \in \mathbb {R}^{k}$</span>, the vector of constant terms <span>$\mathbf c \in \mathbb {R}^{k}$</span>, the coefficient matrix <span>$\mathbf {H} \in \mathbb {R}^{k \times n}$</span>, and the diagonal measurement error covariance matrix <span>$\bm \Sigma \in \mathbb {R}^{k \times k}$</span>, where the diagonal elements hold measurement variances, are defined as follows:</p><p class="math-container">\[    \mathbf z =
    \begin{bmatrix}    	 
      \mathbf{z}_\mathcal{P}\\[3pt]
      \mathbf{z}_{\bar{\mathcal{P}}}
    \end{bmatrix}; \;\;\;
    \mathbf c =
    \begin{bmatrix}    	 
      \mathbf{c}_\mathcal{P}\\[3pt]
      \mathbf{c}_{\bar{\mathcal{P}}}\\[3pt]
    \end{bmatrix}; \;\;\;
    \mathbf H =
    \begin{bmatrix}
      \mathbf {H}_\mathcal{P} \\[3pt]
      \mathbf {H}_{\bar{\mathcal{P}}}
	\end{bmatrix}; \;\;\;
  \bm \Sigma = 	
    \begin{bmatrix}
	   \bm \Sigma_\mathcal{P} &amp; \mathbf{0} \\
     \mathbf{0} &amp; \bm \Sigma_{\bar{\mathcal{P}}} 
	\end{bmatrix}.\]</p><p>The inclusion of the vector <span>$\mathbf{c}_\mathcal{P}$</span> is necessary due to the fact that measurement functions associated with active power measurements may include constant terms, especially when there are non-zero shift angles of transformers or shunt elements in the system consuming active powers, as evident from the provided measurement functions. On the other hand, the presence of <span>$\mathbf{c}_{\bar{\mathcal{P}}}$</span> is required when the angle of the slack bus is non-zero.</p><hr/><h5 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h5><p>JuliaGrid initiates the DC state estimation framework by setting up the WLS model, as illustrated in the following code segment:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(system, device)</code></pre><hr/><h5 id="Coefficient-Matrix"><a class="docs-heading-anchor" href="#Coefficient-Matrix">Coefficient Matrix</a><a id="Coefficient-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Coefficient-Matrix" title="Permalink"></a></h5><p>To generate the coefficient matrix in JuliaGrid, measurement functions are utilized. Specifically, for active power flow measurements, the coefficient expressions corresponding to the measurement functions <span>$h_{P_{ij}}(\cdot)$</span> and <span>$h_{P_{ji}}(\cdot)$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{P_{ij}}(\cdot)}}{\mathrm \partial \theta_{i}} = \cfrac{1}{\tau_{ij} x_{ij}}; \;\;\;
    \cfrac{\mathrm \partial{{h_{P_{ij}}}(\cdot)}}{\mathrm \partial \theta_{j}} = -\cfrac{1}{\tau_{ij} x_{ij}} \\
    \cfrac{\mathrm \partial{h_{P_{ji}}(\cdot)}}{\mathrm \partial \theta_{i}} = -\cfrac{1}{\tau_{ij} x_{ij}}; \;\;\;
  \cfrac{\mathrm \partial{{h_{P_{ji}}}(\cdot)}}{\mathrm \partial \theta_{j}} = \cfrac{1}{\tau_{ij} x_{ij}}.
  \end{aligned}  \]</p><p>Furthermore, for active power injection measurements, the coefficient expressions corresponding to the measurement function <span>$h_{P_{i}}(\cdot)$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{P_{i}}(\cdot)}}{\mathrm \partial \theta_{i}} = B_{ii}; \;\;\;
  \cfrac{\mathrm \partial{{h_{P_{i}}}(\cdot)}}{\mathrm \partial \theta_{j}} = {B}_{ij}.
  \end{aligned}  \]</p><p>Lastly, for bus voltage angle measurements, the coefficient expressions are as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{\theta_{i}}(\cdot)}}{\mathrm \partial \theta_{i}} = 1; \;\;\;
    \cfrac{\mathrm \partial{{h_{\theta_{i}}}(\cdot)}}{\mathrm \partial \theta_{j}} = 0.
  \end{aligned}  \]</p><p>Using the above-described equations, JuliaGrid forms the coefficient matrix <span>$\mathbf{H} \in \mathbb{R}^{k \times n}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêá = analysis.method.coefficient</code><code class="nohighlight hljs ansi" style="display:block;">5√ó3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:
   5.0  -5.0        ‚ãÖ
 -10.0  -3.33333  13.3333
  -5.0   5.0        ‚ãÖ
    ‚ãÖ    1.0        ‚ãÖ
    ‚ãÖ     ‚ãÖ        1.0</code></pre><p>Each row in the matrix corresponds to a specific measurement. The first <span>$|\mathcal{P}|$</span> rows correspond to wattmeters, ordered as users add wattmeters, while the last <span>$|{\bar{\mathcal{P}}}|$</span> rows correspond to PMUs, also in the order users add PMUs.</p><hr/><h5 id="Precision-Matrix"><a class="docs-heading-anchor" href="#Precision-Matrix">Precision Matrix</a><a id="Precision-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-Matrix" title="Permalink"></a></h5><p>JuliaGrid opts not to retain the covariance matrix <span>$\bm \Sigma$</span> but rather stores its inverse, the precision or weighting matrix denoted as <span>$\mathbf W = \bm \Sigma^{-1}$</span>. The order of these values corresponds to the description provided for the coefficient matrix. Users can access these values using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêñ = analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">5√ó5 SparseArrays.SparseMatrixCSC{Float64, Int64} with 5 stored entries:
 10000.0      ‚ãÖ        ‚ãÖ         ‚ãÖ         ‚ãÖ
      ‚ãÖ   1000.0       ‚ãÖ         ‚ãÖ         ‚ãÖ
      ‚ãÖ       ‚ãÖ   10000.0        ‚ãÖ         ‚ãÖ
      ‚ãÖ       ‚ãÖ        ‚ãÖ   100000.0        ‚ãÖ
      ‚ãÖ       ‚ãÖ        ‚ãÖ         ‚ãÖ   100000.0</code></pre><hr/><h5 id="Mean-Vector"><a class="docs-heading-anchor" href="#Mean-Vector">Mean Vector</a><a id="Mean-Vector-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Vector" title="Permalink"></a></h5><p>Users can access the vector <span>$\mathbf z - \mathbf{c}$</span>, which contains the means of Gaussian distributions describing each measurement, using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥ = analysis.method.mean</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
  0.27
 -1.21
 -0.28
 -0.06
 -0.12</code></pre><p>In the context of the power system, where phase-shifting transformers and shunt elements consuming active powers are absent, and the slack angle has a zero value, the vector <span>$\mathbf{c}= \mathbf{0}$</span>. Consequently, the vector of means holds values that are equal to the measurement values.</p><hr/><h5 id="Estimate-of-State-Variables"><a class="docs-heading-anchor" href="#Estimate-of-State-Variables">Estimate of State Variables</a><a id="Estimate-of-State-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Estimate-of-State-Variables" title="Permalink"></a></h5><p>Once the model is established, we solve the WLS equation to derive the estimate of bus voltage angles:</p><p class="math-container">\[	\hat{\bm {\Theta}} = [\mathbf H^{T} \bm \Sigma^{-1} \mathbf H]^{-1} \mathbf H^{T} \bm \Sigma^{-1} (\mathbf z - \mathbf{c}).\]</p><p>This process is executed using the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS{LinearWLS}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>The initial step involves the LU factorization of the gain matrix:</p><p class="math-container">\[	\mathbf G = \mathbf H^{T} \bm \Sigma^{-1} \mathbf H = \mathbf L \mathbf U.\]</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>By default, JuliaGrid utilizes LU factorization as the primary method to factorize the gain matrix. However, users maintain the flexibility to opt for alternative factorization methods such as LDLt or QR.</p></div></div><p>Access to the factorized gain matrix is available through:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêã = analysis.method.factorization.L</code><code class="nohighlight hljs ansi" style="display:block;">3√ó3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 1.0    ‚ãÖ         ‚ãÖ
  ‚ãÖ    1.0        ‚ãÖ
  ‚ãÖ   -0.147962  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêî = analysis.method.factorization.U</code><code class="nohighlight hljs ansi" style="display:block;">3√ó3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 1.0   ‚ãÖ          ‚ãÖ
  ‚ãÖ   0.932203  -0.0677966
  ‚ãÖ    ‚ãÖ         0.852038</code></pre><p>Finally, the estimated bus voltage angles <span>$\hat{\bm {\Theta}} = [\hat{\theta}_i]$</span>, <span>$i \in \mathcal{N}$</span>, can be retrieved using the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùöØ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.056238410596026495
 -0.11027814569536426</code></pre><p>It is essential to note that the slack bus voltage angle is temporarily excluded from the gain matrix <span>$\mathbf G$</span> during computation. It is important to emphasize that this internal handling does not alter the stored elements, such as the coefficient matrix.</p><hr/><h5 id="DCSEOrthogonalWLSStateEstimationTutorials"><a class="docs-heading-anchor" href="#DCSEOrthogonalWLSStateEstimationTutorials">Alternative Formulation</a><a id="DCSEOrthogonalWLSStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEOrthogonalWLSStateEstimationTutorials" title="Permalink"></a></h5><p>The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from converging to a satisfactory solution. In such cases, users may opt for an alternative formulation of the WLS state estimation, namely, employing an approach called orthogonal factorization <a href="../../manual/dcStateEstimation/#DCStateEstimationReferenceManual">[1, Sec. 3.2]</a>.</p><p>To address ill-conditioned situations arising from significant differences in measurement variances, users can employ an alternative approach:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(system, device, Orthogonal)</code></pre><p>To explain the method, we begin with the WLS equation:</p><p class="math-container">\[	\mathbf H^{T} \mathbf W \mathbf H \bm {\Theta} = \mathbf H^{T} \mathbf W (\mathbf z - \mathbf{c}),\]</p><p>where <span>$\mathbf W = \bm \Sigma^{-1}$</span>. Subsequently, we can write:</p><p class="math-container">\[  \left({\mathbf W^{1/2}} \mathbf H\right)^{T}  {\mathbf W^{1/2}} \mathbf H  \bm {\Theta} = \left({\mathbf W^{1/2}} \mathbf H\right)^{T} {\mathbf W^{1/2}} (\mathbf z - \mathbf{c}).\]</p><p>Consequently, we have:</p><p class="math-container">\[  \bar{\mathbf{H}}^{T}  \bar{\mathbf{H}} \bm {\Theta} = \bar{\mathbf{H}}^{T}  \bar{\mathbf{z}}, \]</p><p>where:</p><p class="math-container">\[  \bar{\mathbf{H}} = {\mathbf W^{1/2}} \mathbf H; \;\;\; \bar{\mathbf{z}} = {\mathbf W^{1/2}} (\mathbf z - \mathbf{c}).\]</p><p>At this point, QR factorization is performed on the rectangular matrix:</p><p class="math-container">\[  \bar{\mathbf{H}} = {\mathbf W^{1/2}} \mathbf H = \mathbf{Q}\mathbf{R}. \]</p><p>Executing this procedure involves the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS{LinearWLS}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Access to the factorized matrix is possible through:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê = analysis.method.factorization.Q</code><code class="nohighlight hljs ansi" style="display:block;">5√ó5 SuiteSparse.SPQR.QRSparseQ{Float64, Int64}:
 -0.8   0.0488273  -0.386014   0.386014   0.244137
 -0.6  -0.0651031   0.514685  -0.514685  -0.325515
  0.0   0.643356    0.617241   0.382759   0.242078
  0.0  -0.643356    0.382759   0.617241  -0.242078
  0.0  -0.406894    0.242078  -0.242078   0.846896</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêë = analysis.method.factorization.R</code><code class="nohighlight hljs ansi" style="display:block;">3√ó3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 -527.046    84.3274   ‚ãÖ
     ‚ãÖ     -777.174    ‚ãÖ
     ‚ãÖ         ‚ãÖ       ‚ãÖ</code></pre><p>To obtain the solution, JuliaGrid avoids materializing the orthogonal matrix <span>$\mathbf{Q}$</span> and proceeds to solve the system, resulting in the estimate of state variables <span>$\hat{\bm {\Theta}} = [\hat{\theta}_i]$</span>, where <span>$i \in \mathcal{N}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùöØ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.0562384105960265
 -0.11027814569536422</code></pre><hr/><h2 id="DCSEBadDataTutorials"><a class="docs-heading-anchor" href="#DCSEBadDataTutorials">Bad Data Processing</a><a id="DCSEBadDataTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEBadDataTutorials" title="Permalink"></a></h2><p>Besides the state estimation algorithm, one of the essential state estimation routines is the bad data processing, whose main task is to detect and identify measurement errors, and eliminate them if possible. This is usually done by processing the measurement residuals <a href="#DCSEReferenceTutorials">[1, Ch. 5]</a>, and typically, the largest normalized residual test is used to identify bad data. The largest normalized residual test is performed after we obtained the solution of the state estimation in the repetitive process of identifying and eliminating bad data measurements one after another <a href="#DCSEReferenceTutorials">[2]</a>. </p><p>To illustrate this process, let us introduce a new measurement that contains an obvious outlier:</p><pre><code class="language-julia hljs">addWattmeter!(system, device; bus = 3, active = 5.1, variance = 1e-4, noise = false)</code></pre><p>Subsequently, we will construct the WLS state estimation model and solve it:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>Now, the bad data processing can be executed:</p><pre><code class="language-julia hljs">residualTest!(system, device, analysis; threshold = 4.0)</code></pre><p>In this step, we employ the largest normalized residual test, guided by the analysis outlined in <a href="#DCSEReferenceTutorials">[1, Sec. 5.7]</a>. To be more precise, we compute all measurement residuals based on the obtained estimate of state variables:</p><p class="math-container">\[    r_{i} = z_i - h_i(\hat {\bm {\Theta}}), \;\;\; i \in \mathcal{M}.\]</p><p>The normalized residuals for all measurements are computed as follows:</p><p class="math-container">\[    c_{i} = \cfrac{|r_i|}{\sqrt{C_{ii}}} = \cfrac{|r_i|}{\sqrt{S_{ii}\Sigma_{ii}}}, \;\;\; i \in \mathcal{M},\]</p><p>In this equation, we denote the diagonal entries of the residual covariance matrix <span>$\mathbf C \in \mathbb{R}^{k \times k}$</span> as <span>$C_{ii} = S_{ii}\Sigma_{ii}$</span>, where <span>$S_{ii}$</span> is the diagonal entry of the residual sensitivity matrix <span>$\mathbf S$</span> representing the sensitivity of the measurement residuals to the measurement errors. For this specific configuration, the relationship is expressed as:</p><p class="math-container">\[    \mathbf C = \mathbf S \bm \Sigma = \bm \Sigma - \mathbf H [\mathbf H^T \bm \Sigma^{-1} \mathbf H]^{-1} \mathbf H^T.\]</p><p>It is important to note that only the diagonal entries of <span>$\mathbf C$</span> are required. To obtain the inverse, the JuliaGrid package utilizes a computationally efficient sparse inverse method, retrieving only the necessary elements of the inverse.</p><p>The subsequent step involves selecting the largest normalized residual, and the <span>$j$</span>-th measurement is then suspected as bad data and potentially removed from the measurement set <span>$\mathcal{M}$</span>:  </p><p class="math-container">\[    c_j = \text{max} \{c_i, i \in \mathcal{M} \},\]</p><p>Users can access this information using the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.bad.maxNormalizedResidual</code><code class="nohighlight hljs ansi" style="display:block;">234.26351429811731</code></pre><p>If the largest normalized residual, denoted as <span>$c_j$</span>, satisfies the inequality:</p><p class="math-container">\[    c_{j} \ge \epsilon,\]</p><p>the corresponding measurement is identified as bad data and subsequently removed. In this example, the bad data identification <code>threshold</code> is set to <span>$\epsilon = 4$</span>. Users can verify the satisfaction of this inequality by inspecting the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.bad.detect</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>This indicates that the measurement labeled as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.bad.label</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Wattmeter 4&quot;</code></pre><p>is removed from the DC model and marked as out-of-service.</p><p>Subsequently, we can immediately solve the system again, but this time without the removed measurement:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Following that, we check for outliers once more:</p><pre><code class="language-julia hljs">residualTest!(system, device, analysis; threshold = 4.0)</code></pre><p>To examine the value:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.bad.maxNormalizedResidual</code><code class="nohighlight hljs ansi" style="display:block;">3.855688724578144</code></pre><p>As this value is now less than the <code>threshold</code> <span>$\epsilon = 4$</span>, the measurement is not removed, or there are no outliers. This can also be verified by observing the bad data flag:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.bad.detect</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><hr/><h2 id="DCSELAVTutorials"><a class="docs-heading-anchor" href="#DCSELAVTutorials">LAV State Estimation</a><a id="DCSELAVTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSELAVTutorials" title="Permalink"></a></h2><p>The least absolute value (LAV) method provides an alternative estimation approach that is considered more robust in comparison to the WLS method. The WLS state estimation problem relies on specific assumptions about measurement errors, whereas robust estimators aim to remain unbiased even in the presence of various types of measurement errors and outliers. This characteristic eliminates the need for bad data processing, as discussed in <a href="#DCSEReferenceTutorials">[1, Ch. 6]</a>. It is important to note that robustness often comes at the cost of increased computational complexity.</p><p>It can be demonstrated that the problem can be expressed as a linear programming problem. This section outlines the method as described in <a href="#DCSEReferenceTutorials">[1, Sec. 6.5]</a>. To revisit, we consider the system of linear equations:</p><p class="math-container">\[  \mathbf{z}=\mathbf{h}(\bm {\Theta})+\mathbf{u}.\]</p><p>Subsequently, the LAV state estimator is derived as the solution to the optimization problem:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf a^T |\mathbf r(\bm {\Theta})|\\
    \text{subject\;to}&amp; \;\;\; \mathbf{z} - \mathbf{H}\bm {\Theta} =\mathbf r(\mathbf x).
  \end{aligned}\]</p><p>Here, <span>$\mathbf a \in \mathbb {R}^{k}$</span> is the vector with all entries equal to one, and <span>$\mathbf r (\bm {\Theta})$</span> represents the vector of measurement residuals. Additionally, we introduce <span>$\bm \eta$</span>:</p><p class="math-container">\[  |\mathbf r(\bm {\Theta})| \preceq \bm \eta,\]</p><p>and replace the above inequality with two equalities using the introduction of two non-negative slack variables <span>$\mathbf q \in \mathbb {R}_{\ge 0}^{k}$</span> and <span>$\mathbf w \in \mathbb {R}_{\ge 0}^{k}$</span>:</p><p class="math-container">\[  \begin{aligned}
    \mathbf r(\bm {\Theta}) - \mathbf q &amp;= -\bm \eta \\
    \mathbf r(\bm {\Theta}) + \mathbf w &amp;= \bm \eta.
  \end{aligned}\]</p><p>Let us now define four additional non-negative variables:</p><p class="math-container">\[    \bm {\Theta}_x \in \mathbb {R}_{\ge 0}^{n}; \;\;\; \bm {\Theta}_y  \in \mathbb {R}_{\ge 0}^{n}; \;\;\;  
    \mathbf {r}_x \in \mathbb {R}_{\ge 0}^{k}; \;\;\; \mathbf {r}_y \in \mathbb {R}_{\ge 0}^{k},\]</p><p>where:</p><p class="math-container">\[    \bm {\Theta} = \bm {\Theta}_x - \bm {\Theta}_y; \;\;\; \mathbf r(\bm {\Theta}) = \mathbf {r}_x - \mathbf {r}_y\\
    \mathbf {r}_x = \cfrac{1}{2} \mathbf q; \;\;\;  \mathbf {r}_y = \cfrac{1}{2} \mathbf w.\]</p><p>Then, the above two equalities become:</p><p class="math-container">\[  \begin{aligned}
    \mathbf r(\bm {\Theta}) - 2\mathbf {r}_x &amp;= -2\bm \eta \\
    \mathbf r(\bm {\Theta}) + 2 \mathbf {r}_y &amp;= 2\bm \eta,
  \end{aligned}\]</p><p>that is:</p><p class="math-container">\[  \begin{aligned}
    \mathbf {r}_x + \mathbf {r}_y = \bm \eta; \;\;\; \mathbf r(\bm {\Theta}) = \mathbf {r}_x - \mathbf {r}_y.
  \end{aligned}\]</p><p>Hence, the optimization problem can be written:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf a^T (\mathbf {r}_x + \mathbf {r}_y)\\
    \text{subject\;to}&amp; \;\;\; \mathbf{H}(\bm {\Theta}_x - \bm {\Theta}_y) + \mathbf {r}_x - \mathbf {r}_y = \mathbf{z}   \\
                       &amp; \;\;\; \bm {\Theta}_x \succeq \mathbf 0, \; \bm {\Theta}_y \succeq \mathbf 0 \\
                       &amp; \;\;\; \mathbf {r}_x \succeq \mathbf 0, \; \mathbf {r}_y \succeq \mathbf 0.
  \end{aligned}\]</p><p>To form the above optimization problem, the user can call the following function:</p><pre><code class="language-julia hljs">using Ipopt

analysis = dcStateEstimation(system, device, Ipopt.Optimizer)</code></pre><p>Then the user can solve the optimization problem by:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>As a result, we obtain optimal values for the four additional non-negative variables, while the state estimator is obtained by:</p><p class="math-container">\[    \hat{\bm {\Theta}} = \bm {\Theta}_x - \bm {\Theta}_y.\]</p><p>Users can retrieve the estimated bus voltage angles <span>$\hat{\bm {\Theta}} = [\hat{\theta}_i]$</span>, <span>$i \in \mathcal{N}$</span>, using the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùöØ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.060000001489243004
 -0.10574999820971698</code></pre><hr/><h2 id="DCSEObservabilityAnalysisTutorials"><a class="docs-heading-anchor" href="#DCSEObservabilityAnalysisTutorials">Observability Analysis</a><a id="DCSEObservabilityAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEObservabilityAnalysisTutorials" title="Permalink"></a></h2><p>The state estimation algorithm aims to estimate the values of the state variables based on the measurement model described as a system of equations. Prior to applying the state estimation algorithm, the observability analysis determines the existence and uniqueness of the solution for the underlying system of equations. In cases where a unique solution is not guaranteed, the observability analysis identifies observable islands and prescribes an additional set of equations (pseudo-measurements) to achieve a unique solution <a href="#DCSEReferenceTutorials">[3]</a>.</p><hr/><h5 id="Identification-of-Observable-Islands"><a class="docs-heading-anchor" href="#Identification-of-Observable-Islands">Identification of Observable Islands</a><a id="Identification-of-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Identification-of-Observable-Islands" title="Permalink"></a></h5><p>Within the DC state estimation framework, observable islands are defined exclusively using measurements from wattmeters. This approach aligns with the standard observability analysis for nonlinear state estimation in power systems, typically performed on the linear decoupled measurement model <a href="#DCSEReferenceTutorials">[4, Ch. 7]</a>.</p><p>Let us illustrate this concept with the following example, where measurements form an unobservable system:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.05)
addBus!(system; label = &quot;Bus 4&quot;, type = 1, active = 0.05)
addBus!(system; label = &quot;Bus 5&quot;, type = 1, active = 0.05)
addBus!(system; label = &quot;Bus 6&quot;, type = 1, active = 0.05)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 3&quot;, to = &quot;Bus 5&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 4&quot;, from = &quot;Bus 3&quot;, to = &quot;Bus 4&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 5&quot;, from = &quot;Bus 5&quot;, to = &quot;Bus 6&quot;, reactance = 0.01)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2)

device = measurement()

@wattmeter(label = &quot;Wattmeter ?: !&quot;)
addWattmeter!(system, device; from = &quot;Branch 1&quot;, active = 0.31, variance = 1e-4)
addWattmeter!(system, device; from = &quot;Branch 3&quot;, active = 0.09, variance = 1e-4)
addWattmeter!(system, device; bus = &quot;Bus 3&quot;, active = -0.05, variance = 1e-4)
addWattmeter!(system, device; bus = &quot;Bus 3&quot;, active = -0.05, variance = 1e-4)</code></pre><p>If the system lacks observability, the observability analysis needs to identify all potential observable islands that can be independently solved. An observable island is defined as follows: It is a segment of the power system where the flows across all branches within that island can be calculated solely from the available measurements. This independence holds regardless of the values chosen for angular reference <a href="#DCSEReferenceTutorials">[4, Sec. 7.1.1]</a>. Within this context, two types of observable islands are evident:</p><ul><li>flow observale islands,</li><li>maximal observable islands.</li></ul><p>The selection between them relies on the power system&#39;s structure and the available measurements. Opting for detecting only flow observable islands simplifies the island detection function&#39;s complexity but increases the complexity in the restoration function compared to identifying maximal observable islands.</p><hr/><h5 id="Flow-Observale-Islands"><a class="docs-heading-anchor" href="#Flow-Observale-Islands">Flow Observale Islands</a><a id="Flow-Observale-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Flow-Observale-Islands" title="Permalink"></a></h5><p>To identify flow observable islands, JuliaGrid employs a topological method outlined in <a href="#DCSEReferenceTutorials">[5]</a>. The process begins with the examination of all active power flow measurements from wattmeters, aiming to determine the largest sets of connected buses within the network linked by branches with active power flow measurements. Subsequently, the analysis considers individual boundary or tie active power injection measurements, involving two islands that may potentially be merged into a single observable island. The user can initiate this process by calling the following function:</p><pre><code class="language-julia hljs">islands = islandTopologicalFlow(system, device.wattmeter)</code></pre><p>As a result, four flow observable islands are identified. The first island comprises <code>Bus 1</code> and <code>Bus 2</code>, the second island is formed by <code>Bus 3</code> and <code>Bus 5</code>, while the third and fourth islands consist of <code>Bus 4</code> and <code>Bus 6</code>, respectively:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 5]
 [4]
 [6]</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Additionally, users can inspect the tie buses and branches resulting from the observability analysis we conducted:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.tie.bus</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 5 elements:
  5
  4
  6
  2
  3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.tie.branch</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 3 elements:
  5
  4
  2</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>This tie data will be utilized throughout the restoration step, where we introduce pseudo-measurements to merge the observable flow islands obtained.</p><hr/><h5 id="Maximal-Observale-Islands"><a class="docs-heading-anchor" href="#Maximal-Observale-Islands">Maximal Observale Islands</a><a id="Maximal-Observale-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-Observale-Islands" title="Permalink"></a></h5><p>To identify maximal observable islands, we extend the analysis with an additional processing step. After processing individual injection tie measurements, we are left with a series of injection measurements that are not entirely contained within any observable zone. In this set of remaining tie injections, we now examine pairs involving three and only three previously determined observable zones (including individual buses). If we find such a pair, the three islands may be merged, and all injection measurements involving only nodes of this new island are excluded from further consideration. The procedure then restarts at the stage where we process tie active power injection measurements involving two and only two islands. If no mergers are possible with pairs, we then consider sets of three injection measurements involving four islands, and so on <a href="#DCSEReferenceTutorials">[5]</a>. The user can initiate this by calling the function:</p><pre><code class="language-julia hljs">islands = islandTopological(system, device.wattmeter)</code></pre><p>The outcome reveals the identification of two maximal observable islands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Vector{Int64}}:
 [1, 2, 3, 5, 4]
 [6]</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>It is evident that upon comparing this result with the flow observable islands, the merging of the two injection measurements at <code>Bus 3</code> consolidated the first, second, and third flow observable islands into a single island.</p><p>Here we can observe tie data:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.tie.bus</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 2 elements:
  5
  6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.tie.branch</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 1 element:
  5</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Compared to the tie data obtained after detecting flow observable islands, we now have a smaller set, indicating that the restoration step will be more computationally efficient.</p><hr/><h5 id="Observability-Restoration"><a class="docs-heading-anchor" href="#Observability-Restoration">Observability Restoration</a><a id="Observability-Restoration-1"></a><a class="docs-heading-anchor-permalink" href="#Observability-Restoration" title="Permalink"></a></h5><p>After determining the islands, the observability analysis merges these islands in a manner that protect previously determined observable states from being altered by the new set of equations defined by the additional measurements, called pseudo-measurements. In general, this can be achieved by ensuring that the set of new measurements forms a non-redundant set <a href="#DCSEReferenceTutorials">[4, Sec. 7.3.2]</a>, i.e., the set of equations must be linearly independent with respect to the global system. The goal of observability restoration is to find this non-redundant set.</p><p>As a consequence, the power system is divided into <span>$m$</span> islands. Subsequently, we focus on the set of measurements <span>$\mathcal{M}_\text{r} \subset \mathcal{M}$</span>, which exclusively consists of:</p><ul><li>active power injection measurements at tie buses,</li><li>bus voltage angle measurements.</li></ul><p>These measurements are retained from the phase where we identify observable islands and are crucial in determining whether or not we need additional pseudo-measurements to be included in the measurement set <span>$\mathcal{M}$</span>. In this specific example, we do not have active power injection measurements at tie buses remaining after the identification of maximal observable islands. However, if we proceed with flow observable islands to the restoration step, we will have two injection measurements at <code>Bus 3</code>.</p><p>However, let us introduce the matrix <span>$\mathbf W_{\text{r}} \in \mathbb{R}^{r \times m}$</span>, where <span>$r = |\mathcal{M}_\text{r}|$</span>. This matrix can be conceptualized as the coefficient matrix of a reduced network with <span>$m$</span> columns corresponding to islands and <span>$r$</span> rows associated with the set <span>$\mathcal{M}_\text{r}$</span>. The measurement functions linked to the set <span>$\mathcal{M}_\text{r}$</span> define the coefficient matrix <span>$\mathbf H_\text{r}$</span>, and the matrix <span>$\mathbf W_{\text{r}}$</span> can be constructed by summing the columns of <span>$\mathbf H_\text{r}$</span> that belong to a specific island <a href="#DCSEReferenceTutorials">[6]</a>.</p><p>Subsequently, we require the set of pseudo-measurements <span>$\mathcal{M}_\text{p}$</span>. For instance, let us define this set as follows:</p><pre><code class="language-julia hljs">pseudo = measurement()

addWattmeter!(system, pseudo; label = &quot;Pseudo 1&quot;, bus = &quot;Bus 1&quot;, active = 0.31)
addWattmeter!(system, pseudo; label = &quot;Pseudo 2&quot;, bus = &quot;Bus 6&quot;, active = -0.05)</code></pre><p>Next, we define the reduced coefficient matrix <span>$\mathbf W_{\text{p}} \in \mathbb{R}^{p \times m}$</span> associated with the pseudo-measurement set <span>$\mathcal{M}_\text{p}$</span>. From all pseudo-measurements forming the matrix<span>$\mathbf W_{\text{p}}$</span>, the restoration step will utilize only the following:</p><ul><li>active power flow measurements between tie buses,</li><li>active power injection measurements at tie buses,</li><li>bus voltage angle measurements,</li></ul><p>where <span>$p = |\mathcal{M}_\text{p}|$</span>. In the current example, the pseudo-measurement <code>Pseudo 2</code> will contribute to the construction of the matrix <span>$\mathbf W_{\text{p}}$</span>. Similar to the previous case, measurement functions linked to the set <span>$\mathcal{M}_\text{p}$</span> define the coefficient matrix <span>$\mathbf H_\text{p}$</span>, and the matrix <span>$\mathbf W_{\text{p}}$</span> can be viewed as the sum of the columns of <span>$\mathbf H_\text{p}$</span> belonging to a specific flow island. Additionally, users have the option to include bus voltage angle measurements from PMUs. In this scenario, restoration can be conducted without merging observable islands into one island, as each island becomes globally observable when one angle is known.</p><p>Additionally, it is important to note that during the restoration step, JuliaGrid initially processes active power measurements and subsequently handles bus voltage angle measurements if they are present in the set of pseudo-measurements. Consequently, users can execute the observability restoration procedure with the following command:</p><pre><code class="language-julia hljs">restorationGram!(system, device, pseudo, islands; threshold = 1e-6)</code></pre><p>The function constructs the reduced coefficient matrix as follows:</p><p class="math-container">\[  \mathbf W = \begin{bmatrix} \mathbf W_{\text{r}} \\ \mathbf W_{\text{p}} \end{bmatrix},\]</p><p>and forms the corresponding Gram matrix:</p><p class="math-container">\[  \mathbf M = \mathbf W \mathbf W^T.\]</p><p>The decomposition of <span>$\mathbf M$</span> into its <span>$\mathbf Q$</span> and <span>$\mathbf R$</span> factors is achieved through QR factorization. Non-redundant measurements are identified by non-zero diagonal elements in <span>$\mathbf R$</span>. Specifically, if the diagonal element satisfies:</p><p class="math-container">\[    |R_{ii}| &lt; \epsilon,\]</p><p>JuliaGrid designates the corresponding measurement as redundant, where <span>$\epsilon$</span> represents a pre-determined zero pivot <code>threshold</code>, set to <code>1e-6</code> in this example. The minimal set of pseudo-measurements for observability restoration corresponds to the non-zero diagonal elements at positions associated with the candidate pseudo-measurements. It is essential to note that an inappropriate choice of the zero pivot threshold may adversely affect observability restoration. Additionally, there is a possibility that the set of pseudo-measurements <span>$\mathcal{M}_\text{p}$</span> may not be sufficient for achieving observability restoration.</p><p>Consequently, the <code>Pseudo 2</code> measurement successfully restores observability, and this measurement is added to the <code>device</code> variable, which stores actual measurements:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; device.wattmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 5 entries:
  &quot;Wattmeter 1: From Branch 1&quot; =&gt; 1
  &quot;Wattmeter 2: From Branch 3&quot; =&gt; 2
  &quot;Wattmeter 3: Bus 3&quot;         =&gt; 3
  &quot;Wattmeter 4: Bus 3&quot;         =&gt; 4
  &quot;Pseudo 2&quot;                   =&gt; 5</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Here, we can verify the updated islands structure with the inclusion of the new pseudo-measurement:</p><pre><code class="language-julia hljs">islands = islandTopological(system, device.wattmeter)</code></pre><p>Furthermore, we can confirm that the system is observable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Vector{Int64}}:
 [1, 2, 4, 6, 3, 5]</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Next, we can construct the DC state estimation model and resolve it to obtain estimates of bus voltage angles:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(system, device)
solve!(system, analysis)</code></pre><hr/><h2 id="DCSEPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#DCSEPowerAnalysisTutorials">Power Analysis</a><a id="DCSEPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEPowerAnalysisTutorials" title="Permalink"></a></h2><p>After obtaining the solution from the DC state estimation, we can calculate powers related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> function:</p><pre><code class="language-julia hljs">power!(system, analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the <a href="../acdcModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Power-Injections"><a class="docs-heading-anchor" href="#Power-Injections">Power Injections</a><a id="Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injections" title="Permalink"></a></h5><p><a href="../acdcModel/#DCBusInjectionTutorials">Active power injections</a> are stored as the vector <span>$\mathbf{P} = [P_i]$</span>, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè = analysis.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Float64}:
  0.30947050146048016
 -1.8216832206389202
 -0.05925007455644793
  1.6828073806109274
 -0.015406841800040344
 -0.09593774507599892</code></pre><hr/><h5 id="Generator-Power-Injections"><a class="docs-heading-anchor" href="#Generator-Power-Injections">Generator Power Injections</a><a id="Generator-Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Power-Injections" title="Permalink"></a></h5><p>We can determine the active power supplied by generators to the buses by summing the active power injections and the active power demanded by consumers at each bus:</p><p class="math-container">\[    P_{\text{p}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}.\]</p><p>The vector of active power injected by generators to the buses, denoted by <span>$\mathbf{P}_{\text{p}} = [P_{\text{p}i}]$</span>, can be obtained using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çö = analysis.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Float64}:
  0.30947050146048016
 -1.72168322063892
 -0.009250074556447926
  1.7328073806109274
  0.03459315819995966
 -0.04593774507599892</code></pre><hr/><h5 id="Power-Flows"><a class="docs-heading-anchor" href="#Power-Flows">Power Flows</a><a id="Power-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flows" title="Permalink"></a></h5><p>The resulting <a href="../acdcModel/#DCBranchNetworkEquationsTutorials">active power flows</a> are stored as the vector <span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span>, which can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè·µ¢ = analysis.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
  0.30947050146048016
 -1.5122127191784402
  0.11134458687603929
 -1.6828073806109276
  0.09593774507599892</code></pre><p>Similarly, the resulting <a href="../acdcModel/#DCBranchNetworkEquationsTutorials">active power flows</a> are stored as the vector <span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span>, which can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚±º = analysis.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 -0.30947050146048016
  1.5122127191784402
 -0.11134458687603929
  1.6828073806109276
 -0.09593774507599892</code></pre><hr/><h2 id="DCSEReferenceTutorials"><a class="docs-heading-anchor" href="#DCSEReferenceTutorials">References</a><a id="DCSEReferenceTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEReferenceTutorials" title="Permalink"></a></h2><p>[1] A. Abur and A. Exposito, <em>Power System State Estimation: Theory and Implementation</em>, ser. Power Engineering. Taylor &amp; Francis, 2004.</p><p>[2] G. N. Korres, &quot;A distributed multiarea state estimation,&quot; <em>IEEE Trans. Power Syst.</em>, vol. 26, no. 1, pp. 73‚Äì84, Feb. 2011.</p><p>[3] M. Cosovic, M. Delalic, D. Raca, and D. Vukobratovic, &quot;Observability analysis for large-scale power systems using factor graphs,&quot; <em>IEEE Trans. Power Syst.</em>, 36(5), 4791-4799.</p><p>[4] A. Monticelli, <em>State Estimation in Electric Power Systems: A Generalized Approach</em>, ser. Kluwer international series in engineering and computer science. Springer US, 1999.</p><p>[5] H. Horisberger, &quot;Observability analysis for power systems with measurement deficiencies,&quot; <em>IFAC Proceedings Volumes</em>, vol. 18, no. 7, pp.51‚Äì58, 1985.</p><p>[6] N. M. Manousakis and G. N. Korres, &quot;Observability analysis for power systems including conventional and phasor measurements,&quot; <em>in Proc. MedPower 2010</em>, Agia Napa, 2010, pp. 1-8.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../measurementModel/">¬´ Measurement Model</a><a class="docs-footer-nextpage" href="../../api/powerSystemModel/">Power System Model ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 15 February 2024 13:55">Thursday 15 February 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
