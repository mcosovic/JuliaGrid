<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power and Current Analysis ¬∑ JuliaGrid</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/powerFlowAnalysis/">Power Flow Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../modelACDC/">AC and DC Model</a></li><li><a class="tocitem" href="../powerFlowSolution/">Power Flow Solution</a></li><li class="is-active"><a class="tocitem" href>Power and Current Analysis</a><ul class="internal"><li><a class="tocitem" href="#BusPowersCurrentsTutorials"><span>Bus Powers and Currents</span></a></li><li><a class="tocitem" href="#BranchPowersCurrentsTutorials"><span>Branch Powers and Currents</span></a></li><li><a class="tocitem" href="#GeneratorPowersTutorials"><span>Generator Powers</span></a></li><li><a class="tocitem" href="#DCAnalysisTutorials"><span>DC Analysis</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlowSolution/">Power Flow Solution</a></li><li><a class="tocitem" href="../../api/postprocessing/">Post-processing Analysis</a></li><li><a class="tocitem" href="../../api/unit/">Unit System</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Power and Current Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power and Current Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/powerCurrentAnalysis.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerCurrentAnalysisTutorials"><a class="docs-heading-anchor" href="#PowerCurrentAnalysisTutorials">Power and Current Analysis</a><a id="PowerCurrentAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PowerCurrentAnalysisTutorials" title="Permalink"></a></h1><p>After the computation of voltage magnitudes and angles at each bus, various electrical quantities can be determined. JuliaGrid offers the <a href="../../api/postprocessing/#JuliaGrid.bus!"><code>bus!</code></a>, <a href="../../api/postprocessing/#JuliaGrid.branch!"><code>branch!</code></a>, and <a href="../../api/postprocessing/#JuliaGrid.generator!"><code>generator!</code></a> functions for calculating powers and currents associated with buses, branches, and generators. To illustrate, let us create the power system and obtain the bus voltages using the AC power flow framework:</p><pre><code class="language-julia hljs">@power(MW, MVAr, MVA)

system = powerSystem()

addBus!(system; label = 1, type = 3)
addBus!(system; label = 2, type = 1, active = 21.7, reactive = 12.7)
addBus!(system; label = 3, type = 2, conductance = 2.1, susceptance = 1.2)

addBranch!(system; label = 1, from = 1, to = 2, resistance = 0.02, reactance = 0.06)
addBranch!(system; label = 2, from = 1, to = 3, resistance = 0.05, reactance = 0.21)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.26, susceptance = 0.1)

addGenerator!(system; label = 1, bus = 1, active = 20.0, reactive = 22.4)
addGenerator!(system; label = 2, bus = 1, active = 10.0, reactive = 12.4)
addGenerator!(system; label = 3, bus = 3, active = 5.1, reactive = 2.1)

acModel!(system)

result = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, result)
    if all(stopping .&lt; 1e-8)
        break
    end
    solvePowerFlow!(system, result)
end</code></pre><p>This section uses the vector notation <span>$\mathbf{a}$</span> to represent a vector, which can be denoted as either <span>$\mathbf{a} = [a_{i}]$</span> or <span>$\mathbf{a} = [a_{ij}]$</span>. Here, <span>$a_{i}$</span> represents an element associated with the bus <span>$i \in \mathcal{N}$</span>, and <span>$a_{ij}$</span> represents an element related to the branch <span>$(i,j) \in \mathcal{E}$</span>. To obtain the sets of buses <span>$\mathcal{N}$</span> and branches <span>$\mathcal{E}$</span>, the following commands can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí© = collect(keys(sort(system.bus.label)))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñ∞ = [system.branch.layout.from system.branch.layout.to]</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Matrix{Int64}:
 1  2
 1  3
 2  3</code></pre><p>For each bus in the set <span>$i \in \mathcal{N}$</span>, the AC power flow solution provides vectors of bus voltage magnitudes <span>$\mathbf{V} = [V_i]$</span> and angles <span>$\bm{\theta} = [\theta_i]$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêï = result.bus.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 0.9931512582066986
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõâ = result.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.009990084936105577
 -0.0009800692623795637</code></pre><hr/><h2 id="BusPowersCurrentsTutorials"><a class="docs-heading-anchor" href="#BusPowersCurrentsTutorials">Bus Powers and Currents</a><a id="BusPowersCurrentsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#BusPowersCurrentsTutorials" title="Permalink"></a></h2><p>JuliaGrid provides the <a href="../../api/postprocessing/#JuliaGrid.bus!"><code>bus!</code></a> function to compute powers and currents linked to buses, which populates the <code>bus</code> field of the <code>Result</code> type. Here is an example code snippet:</p><pre><code class="language-julia hljs">bus!(system, result)</code></pre><p>This function computes various electrical quantities, and the computed currents are stored in the polar coordinate system, while the powers are stored in the rectangular coordinate system:</p><ul><li>current injections: <span>$\mathbf{I} = [I_i]$</span>, <span>$\bm{\psi} = [\psi_i]$</span></li><li>power injections: <span>$\mathbf{P} = [P_i]$</span>, <span>$\mathbf{Q} = [Q_i]$</span></li><li>power injected by the generators:  <span>$\mathbf{P}_{\text{s}} = [P_{\text{s}i}]$</span>, <span>$\mathbf{Q}_{\text{s}} = [Q_{\text{s}i}]$</span></li><li>power associated with shunt elements: <span>$\mathbf{P}_{\text{sh}} = [{P}_{\text{sh}i}]$</span>, <span>$\mathbf{Q}_{\text{sh}} = [{Q}_{\text{sh}i}]$</span>.</li></ul><hr/><h5 id="Current-Injections"><a class="docs-heading-anchor" href="#Current-Injections">Current Injections</a><a id="Current-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injections" title="Permalink"></a></h5><p>To obtain the complex current injection at the specific bus, we use the following equation:</p><p class="math-container">\[    \bar{I}_{i} = I_i \text{e}^{\text{j}\psi_i} = \sum\limits_{j = 1}^n {Y}_{ij} \bar{V}_{j},\;\;\; i \in \mathcal{N}.\]</p><p>In JuliaGrid, these complex current injections are stored in a vector of magnitudes denoted as <span>$\mathbf{I} = [I_i]$</span> and a vector of angles represented as <span>$\bm{\psi} = [\psi_i]$</span>. You can retrieve them using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêà = result.bus.current.injection.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.19501969318829046
 0.25316576629286613
 1.2235132837190783</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõô = result.bus.current.injection.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.27425733663126173
  2.60209668690783
  1.5281209356055034</code></pre><hr/><h5 id="Power-Injections"><a class="docs-heading-anchor" href="#Power-Injections">Power Injections</a><a id="Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injections" title="Permalink"></a></h5><p>The computation of active and reactive power injections at the bus is expressed by the following equation:</p><p class="math-container">\[    {S}_{i} = P_i + \text{j}Q_i = \bar{V}_{i}\bar{I}_{i}^*,\;\;\; i \in \mathcal{N}.\]</p><p>Active and reactive power injections are stored as the vectors <span>$\mathbf{P} = [P_i]$</span> and <span>$\mathbf{Q} = [Q_i]$</span>, respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè = result.bus.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.18773114421817083
 -0.21699999999999764
  0.05099999999999977</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê = result.bus.power.injection.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.05281759386597695
 -0.1269999999999993
 -1.2224498989476182</code></pre><hr/><h5 id="Power-Injected-by-the-Generators"><a class="docs-heading-anchor" href="#Power-Injected-by-the-Generators">Power Injected by the Generators</a><a id="Power-Injected-by-the-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injected-by-the-Generators" title="Permalink"></a></h5><p>The <a href="../../api/postprocessing/#JuliaGrid.bus!"><code>bus!</code></a> function in JuliaGrid also computes the active and reactive powers that generators inject to the buses. The active power supplied by the generators to the buses can be calculated by summing the given generator active powers in the input data, except for the slack bus, which can be determined as:</p><p class="math-container">\[    P_{\text{s}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{sb}},\]</p><p>where <span>$P_{\text{d}i}$</span> represents the active power demanded by consumers at the slack bus. The vector of active power injected by generators to the buses, denoted by <span>$\mathbf{P}_{\text{s}} = [P_{\text{s}i}]$</span>, can be obtained using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çõ = result.bus.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.18773114421817083
 0.0
 0.051</code></pre><p>Similarly, the reactive power injected by the generators to the buses can be obtained using the following equation:</p><p class="math-container">\[    Q_{\text{s}i} = Q_i + Q_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{pv}} \cup \mathcal{N}_{\text{sb}},\]</p><p>where <span>$Q_{\text{d}i}$</span> represents the reactive power demanded by consumers at the corresponding bus. Further, the reactive power injected by the generators at buses from <span>$\mathcal{N}_{\text{pq}}$</span> can be calculated by summing the given generator reactive powers in the input data. The vector of these reactive power injections by the generators to the buses, denoted by <span>$\mathbf{Q}_{\text{s}} = [Q_{\text{s}i}]$</span>, can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚Çõ = result.bus.power.supply.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.05281759386597695
  0.0
 -1.2224498989476182</code></pre><hr/><h5 id="Power-Associated-with-Shunt-Elements"><a class="docs-heading-anchor" href="#Power-Associated-with-Shunt-Elements">Power Associated with Shunt Elements</a><a id="Power-Associated-with-Shunt-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Associated-with-Shunt-Elements" title="Permalink"></a></h5><p>To obtain the active and reactive powers associated with the shunt element at each bus, you can use the following equation:</p><p class="math-container">\[  {S}_{\text{sh}i} = {P}_{\text{sh}i} + \text{j}{Q}_{\text{sh}i} = \bar{V}_{i}\bar{I}_{\text{sh}i}^* = {y}_{\text{sh}i}^*|\bar{V}_{i}|^2,\;\;\; i \in \mathcal{N}.\]</p><p>The active power demanded by the shunt element at each bus is represented by the vector <span>$\mathbf{P}_{\text{sh}} = [{P}_{\text{sh}i}]$</span>, while the reactive power injected or demanded by the shunt element at each bus is represented by the vector <span>$\mathbf{Q}_{\text{sh}} = [{Q}_{\text{sh}i}]$</span>. To retrieve these powers in JuliaGrid, use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çõ‚Çï = result.bus.power.shunt.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 1.2000000000000002</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚Çõ‚Çï = result.bus.power.shunt.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.0
 -1.2</code></pre><hr/><h2 id="BranchPowersCurrentsTutorials"><a class="docs-heading-anchor" href="#BranchPowersCurrentsTutorials">Branch Powers and Currents</a><a id="BranchPowersCurrentsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#BranchPowersCurrentsTutorials" title="Permalink"></a></h2><p>JuliaGrid provides the <a href="../../api/postprocessing/#JuliaGrid.branch!"><code>branch!</code></a> function to compute powers and currents linked to branches, which populates the <code>branch</code> field of the <code>Result</code> type. Here is an example code snippet:</p><pre><code class="language-julia hljs">branch!(system, result)</code></pre><p>The function stores the currents in the polar coordinate system and the powers in the rectangular coordinate system. It calculates the following quantities:</p><ul><li>current flow at from bus ends: <span>$\mathbf{I}_{\text{i}} = [I_{ij}]$</span>, <span>$\bm{\psi}_{\text{i}} = [\psi_{ij}]$</span></li><li>current flow at to bus ends: <span>$\mathbf{I}_{\text{j}} = [I_{ji}]$</span>, <span>$\bm{\psi}_{\text{j}} = [\psi_{ji}]$</span></li><li>current flow through series impedances: <span>$\mathbf{I}_{\text{s}} = [I_{\text{s}ij}]$</span>, <span>$\bm{\psi}_{\text{s}} = [\psi_{\text{s}ij}]$</span></li><li>power flow at from bus ends: <span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span>, <span>$\mathbf{Q}_{\text{i}} = [Q_{ij}]$</span></li><li>power flow at to bus ends: <span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span>, <span>$\mathbf{Q}_{\text{j}} = [Q_{ji}]$</span></li><li>power losses: <span>$\mathbf{P}_{\text{l}} = [P_{\text{l}ij}]$</span>, <span>$\mathbf{Q}_{\text{l}} = [Q_{\text{l}ij}]$</span></li><li>reactive power injections: <span>$\mathbf{Q}_{\text{r}} = [ Q_{\text{r}ij}]$</span>.</li></ul><hr/><h5 id="Current-Flow-at-From-Bus-Ends"><a class="docs-heading-anchor" href="#Current-Flow-at-From-Bus-Ends">Current Flow at From Bus Ends</a><a id="Current-Flow-at-From-Bus-Ends-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow-at-From-Bus-Ends" title="Permalink"></a></h5><p>To calculate the complex current flow at from bus end <span>$i \in \mathcal{N}$</span>, the <a href="../modelACDC/#UnifiedBranchModelTutorials">unified branch model</a> can be utilized:</p><p class="math-container">\[    \bar{I}_{ij} = I_{ij} \text{e}^{\text{j}\psi_{ij}} = \cfrac{1}{\tau_{ij}^2}({y}_{ij} + y_{\text{s}ij}) \bar{V}_{i} - \alpha_{ij}^*{y}_{ij} \bar{V}_{j},\;\;\; (i,j) \in \mathcal{E}.\]</p><p>To obtain the vectors of magnitudes <span>$\mathbf{I}_{\text{i}} = [I_{ij}]$</span> and angles <span>$\bm{\psi}_{\text{i}} = [\psi_{ij}]$</span> for the resulting complex current flows at the from bus end, you can use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêà·µ¢ = result.branch.current.from.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.19106459647050528
 0.004540083005271143
 0.08338456301573274</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõô·µ¢ = result.branch.current.from.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.285806012620471
  0.23325314623774807
  1.989392965699328</code></pre><hr/><h5 id="Current-Flow-at-To-Bus-Ends"><a class="docs-heading-anchor" href="#Current-Flow-at-To-Bus-Ends">Current Flow at To Bus Ends</a><a id="Current-Flow-at-To-Bus-Ends-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow-at-To-Bus-Ends" title="Permalink"></a></h5><p>Similarly, we can obtain the complex current flow at the to bus end <span>$j \in \mathcal{N}$</span> using the unified branch model, given by:</p><p class="math-container">\[    \bar{I}_{ji} = I_{ji} \text{e}^{\text{j}\psi_{ji}} = -\alpha_{ij}{y}_{ij} \bar{V}_{i} + ({y}_{ij} + y_{\text{s}ij}) \bar{V}_{j},\;\;\; (i,j) \in \mathcal{E}.\]</p><p>We can obtain the vectors of magnitudes <span>$\mathbf{I}_{\text{j}} = [I_{ji}]$</span> and angles <span>$\bm{\psi}_{\text{j}} = [\psi_{ji}]$</span> of the resulting complex current flows at the to bus end using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêà‚±º = result.branch.current.to.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.19106459647050528
 0.004540083005271143
 0.041676004647983045</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõô‚±º = result.branch.current.to.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  2.855786640969322
 -2.908339507352045
  0.5981944213124066</code></pre><hr/><h5 id="Current-Flow-Through-Series-Impedances"><a class="docs-heading-anchor" href="#Current-Flow-Through-Series-Impedances">Current Flow Through Series Impedances</a><a id="Current-Flow-Through-Series-Impedances-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow-Through-Series-Impedances" title="Permalink"></a></h5><p>To obtain the complex current flow through the series impedance of a branch in the direction from bus <span>$i \in \mathcal{N}$</span> to bus <span>$j \in \mathcal{N}$</span>, one can use the expression:</p><p class="math-container">\[    \bar{I}_{\text{s}ij} = I_{\text{s}ij} \text{e}^{\psi_{\text{s}ij}} =  y_{ij} (\alpha_{ij}\bar{V}_{i} - \bar{V}_{j}),,\;\;\; (i,j) \in \mathcal{E}.\]</p><p>To obtain the vectors of magnitudes <span>$\mathbf{I}_{\text{s}} = [I_{\text{s}ij}]$</span> and angles <span>$\bm{\psi}_{\text{s}} = [\psi_{\text{s}ij}]$</span> of the resulting complex current flow through the series impedance, one can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêà‚Çõ = result.branch.current.impedance.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.1910645964705052
 0.004540083005271245
 0.04343415026910934</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõô‚Çõ = result.branch.current.impedance.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.2858060126204748
  0.2332531462377481
  2.4845075731664954</code></pre><hr/><h5 id="Power-Flow-at-From-Bus-Ends"><a class="docs-heading-anchor" href="#Power-Flow-at-From-Bus-Ends">Power Flow at From Bus Ends</a><a id="Power-Flow-at-From-Bus-Ends-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-at-From-Bus-Ends" title="Permalink"></a></h5><p>The active and reactive power flows at from bus end <span>$i \in \mathcal{N}$</span> can be obtained using the following equations based on the <a href="../modelACDC/#UnifiedBranchModelTutorials">unified branch model</a>:</p><p class="math-container">\[    S_{ij} = P_{ij} + \text{j}Q_{ij} = \bar{V}_{i}\bar{I}_{ij}^*,\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The resulting active and reactive power flows at from bus end are stored as the vectors <span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span> and <span>$\mathbf{Q}_{\text{i}} = [Q_{ij}]$</span>, respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè·µ¢ = result.branch.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.1833140084769047
  0.004417135741267231
 -0.03441610512358245</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê·µ¢ = result.branch.power.from.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.05386700586227455
 -0.0010494119962967119
 -0.07532333493919008</code></pre><hr/><h5 id="Power-Flow-at-To-Bus-Ends"><a class="docs-heading-anchor" href="#Power-Flow-at-To-Bus-Ends">Power Flow at To Bus Ends</a><a id="Power-Flow-at-To-Bus-Ends-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-at-To-Bus-Ends" title="Permalink"></a></h5><p>Similarly, we can determine the active and reactive power flows at the to bus end <code>j \in \mathcal{N}</code> using the equations:</p><p class="math-container">\[    {S}_{ji} = P_{ji} + \text{j}Q_{ji} = \bar{V}_{j}\bar{I}_{ji}^*,\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The vectors of active and reactive power flows at the to bus end are stored as <span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span> and <span>$\mathbf{Q}_{\text{j}} = [Q_{ji}]$</span>, respectively, and can be retrieved using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚±º = result.branch.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.18258389487641596
 -0.004416105123582493
  0.034416105123582445</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚±º = result.branch.power.to.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.051676665060808334
  0.00105374059057261
 -0.023503639538191238</code></pre><hr/><h5 id="Power-Losses"><a class="docs-heading-anchor" href="#Power-Losses">Power Losses</a><a id="Power-Losses-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Losses" title="Permalink"></a></h5><p>The active and reactive power losses in the branch are caused by its series impedance <span>$z_{ij}$</span>. These losses can be obtained using the following equations:</p><p class="math-container">\[    \begin{aligned}
        P_{\text{l}ij} &amp;= r_{ij}|\bar{I}_{\text{b}ij}|^2 \\
        Q_{\text{l}ij} &amp;= x_{ij}|\bar{I}_{\text{b}ij}|^2,
    \end{aligned}\]</p><p>where <span>$(i,j) \in \mathcal{E}$</span>. We can retrieve the vectors of active and reactive power losses, <span>$\mathbf{P}_{\text{l}} = [P_{\text{l}ij}]$</span> and <span>$\mathbf{Q}_{\text{l}} = [Q_{\text{l}ij}]$</span>, respectively, using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çó = result.branch.power.loss.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0007301136004887397
 1.0306176847376388e-6
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚Çó = result.branch.power.loss.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.002190340801466219
 4.328594275898083e-6
 0.0004904966064958883</code></pre><hr/><h5 id="Reactive-Power-Injections"><a class="docs-heading-anchor" href="#Reactive-Power-Injections">Reactive Power Injections</a><a id="Reactive-Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Reactive-Power-Injections" title="Permalink"></a></h5><p>The branch&#39;s capacitive susceptances cause reactive power injection. We can calculate the total reactive power injected by the branch using the following equation:</p><p class="math-container">\[    Q_{\text{r}ij} = b_{\text{s}i} (|\alpha_{ij}\bar{V}_{i}|^2 - |\bar{V}_{j}|^2),\;\;\; (i,j) \in \mathcal{E}.\]</p><p>To retrieve the vector of injected reactive powers <span>$\mathbf{Q}_{\text{r}} = [Q_{\text{r}ij}]$</span>, use the following Julia command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê·µ£ = result.branch.power.shunt.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.09931747108387744</code></pre><hr/><h2 id="GeneratorPowersTutorials"><a class="docs-heading-anchor" href="#GeneratorPowersTutorials">Generator Powers</a><a id="GeneratorPowersTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#GeneratorPowersTutorials" title="Permalink"></a></h2><p>The <a href="../../api/postprocessing/#JuliaGrid.generator!"><code>generator!</code></a> function provided by JuliaGrid can be used to compute powers associated with generators. This function populates the <code>generator</code> field of the <code>Result</code> type. Here is an example code snippet:</p><pre><code class="language-julia hljs">generator!(system, result)</code></pre><p>The powers are stored in the rectangular coordinate system, and only the output power of the generators is calculated. The output powers are stored in vectors as <span>$\mathbf{P}_{\text{g}} = [P_{\text{g}i}]$</span> and <span>$\mathbf{Q}_{\text{g}} = [Q_{\text{g}i}]$</span>.</p><p>To obtain the output active power of generators connected to bus <span>$i \in \mathcal{N}_{\text{pv}} \cup \mathcal{N}_{\text{pq}}$</span>, the given active power in the input data is utilized. For the generator connected to the slack bus, the output active power is determined using the equation:</p><p class="math-container">\[    P_{\text{g}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{sb}}.\]</p><p>In the case of multiple generators connected to the slack bus, the first generator in the input data is assigned the obtained value of <span>$P_{\text{g}i}$</span>. Then, this amount of power is reduced by the output active power of the other generators. Therefore, to get the vector of output active power of generators, i.e., <span>$\mathbf{P}_{\text{g}} = [P_{\text{g}i}]$</span>, you can use the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çí = result.generator.power.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.08773114421817083
 0.1
 0.051</code></pre><p>The output reactive power of a generator located at the bus is obtained by adding the reactive power specified in the input data to the reactive power demand at the bus:</p><p class="math-container">\[    Q_{\text{g}i} = Q_i + Q_{\text{d}i},\;\;\; i \in \mathcal{N}.\]</p><p>If there are multiple generators at the same bus, the reactive power is allocated proportionally among the generators based on their reactive power capabilities. To obtain the vector of output reactive power of generators<span>$\mathbf{Q}_{\text{g}} = [Q_{\text{g}i}]$</span>, the following command can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚Çí = result.generator.power.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.026408796932988476
  0.026408796932988476
 -1.2224498989476182</code></pre><hr/><h2 id="DCAnalysisTutorials"><a class="docs-heading-anchor" href="#DCAnalysisTutorials">DC Analysis</a><a id="DCAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCAnalysisTutorials" title="Permalink"></a></h2><p>To compute the powers associated with buses, branches, and generators within the DC framework, the same functions <a href="../../api/postprocessing/#JuliaGrid.bus!"><code>bus!</code></a>, <a href="../../api/postprocessing/#JuliaGrid.branch!"><code>branch!</code></a>, and <a href="../../api/postprocessing/#JuliaGrid.generator!"><code>generator!</code></a> can be utilized. Once the power system is created, the bus voltages can be obtained using the DC power flow framework as follows:</p><pre><code class="language-julia hljs">dcModel!(system)
result = solvePowerFlow(system)</code></pre><p>To retrieve the bus voltage angles, use the command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõâ = result.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.010832830188679244
 -0.0013550943396226413</code></pre><hr/><h5 id="Bus-Powers"><a class="docs-heading-anchor" href="#Bus-Powers">Bus Powers</a><a id="Bus-Powers-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Powers" title="Permalink"></a></h5><p>JuliaGrid&#39;s <a href="../../api/postprocessing/#JuliaGrid.bus!"><code>bus!</code></a> function can be used to compute powers associated with buses, which fills the <code>bus</code> field of the <code>Result</code> type. Here is an example code snippet:</p><pre><code class="language-julia hljs">bus!(system, result)</code></pre><p>To obtain the active power injection at bus <span>$i \in \mathcal{N}$</span>, we can refer to section <a href="../modelACDC/#DCModelTutorials">DC Model</a>, which provides the following expression:</p><p class="math-container">\[   P_i = \sum_{j = 1}^n {B}_{ij} \theta_j + P_{\text{tr}i} + P_{\text{sh}i},\;\;\; i \in \mathcal{N}.\]</p><p>Active power injections are stored as the vector <span>$\mathbf{P} = [P_i]$</span>, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè = result.bus.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.18699999999999997
 -0.217
  0.051</code></pre><p>The active power supplied by generators to the buses can be calculated by summing the given generator active powers in the input data, except for the slack bus, which can be determined as:</p><p class="math-container">\[    P_{\text{s}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{sb}},\]</p><p>where <span>$P_{\text{d}i}$</span> represents the active power demanded by consumers at the slack bus. The vector of active power injected by generators to the buses, denoted by <span>$\mathbf{P}_{\text{s}} = [P_{\text{s}i}]$</span>, can be obtained using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çõ = result.bus.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.18699999999999997
 0.0
 0.051</code></pre><hr/><h5 id="Branch-Powers"><a class="docs-heading-anchor" href="#Branch-Powers">Branch Powers</a><a id="Branch-Powers-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-Powers" title="Permalink"></a></h5><p>To compute powers associated with branches, JuliaGrid provides the <a href="../../api/postprocessing/#JuliaGrid.branch!"><code>branch!</code></a> function, which populates the <code>branch</code> field of the <code>Result</code> type. Here is an example code snippet:</p><pre><code class="language-julia hljs">branch!(system, result)</code></pre><p>The active power flows at from bus end <span>$i \in \mathcal{N}$</span> can be obtained using the following equations:</p><p class="math-container">\[    P_{ij} = \cfrac{1}{\tau_{ij} x_{ij}} (\theta_{i} -\theta_{j}-\phi_{ij}),\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The resulting active power flows at from bus end are stored as the vector <span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span>, which can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè·µ¢ = result.branch.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.18054716981132074
  0.006452830188679244
 -0.03645283018867924</code></pre><p>Similarly, the active power flows at to bus end <span>$j \in \mathcal{N}$</span> can be obtained as:</p><p class="math-container">\[    P_{ji} = - P_{ij},\;\;\; (i,j) \in \mathcal{E}.\]</p><p>The resulting active power flows at to bus end are stored as the vector <span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span>, which can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚±º = result.branch.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.18054716981132074
 -0.006452830188679244
  0.03645283018867924</code></pre><hr/><h5 id="Generator-Powers"><a class="docs-heading-anchor" href="#Generator-Powers">Generator Powers</a><a id="Generator-Powers-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Powers" title="Permalink"></a></h5><p>To compute powers associated with generators, JuliaGrid provides the <a href="../../api/postprocessing/#JuliaGrid.generator!"><code>generator!</code></a> function, which populates the <code>generator</code> field of the <code>Result</code> type. Here is an example code snippet:</p><pre><code class="language-julia hljs">generator!(system, result)</code></pre><p>The active power output of a generator located at bus <span>$i \in \mathcal{N}_{\text{pv}} \cup \mathcal{N}_{\text{pq}}$</span> is equal to the active power specified in the input data. If there are multiple generators, their active power outputs are also equal to the active power specified in the input data. However, the active power output of a generator located at the slack bus is determined as:</p><p class="math-container">\[    P_{\text{g}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}_{\text{sb}}.\]</p><p>In the case of multiple generators connected to the slack bus, the first generator in the input data is assigned the obtained value of <span>$P_{\text{g}i}$</span>. Then, this amount of power is reduced by the output active power of the other generators. Therefore, to get the vector of output active power of generators, i.e., <span>$\mathbf{P}_{\text{g}} = [P_{\text{g}i}]$</span>, you can use the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çí = result.generator.power.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.08699999999999997
 0.1
 0.051</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powerFlowSolution/">¬´ Power Flow Solution</a><a class="docs-footer-nextpage" href="../../api/powerSystemModel/">Power System Model ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 29 April 2023 16:04">Saturday 29 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
