# [Power System Model](@id powerSystemModelManual)

The JuliaGrid supports the composite type `PowerSystem` to preserve power system data, with the following fields: `bus`, `branch`, `generator`, `base`, `acModel`, and `dcModel`. The fields `bus`, `branch`, and `generator` hold data related to buses, branches, and generators, respectively. The `base` field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes (VA) for the base power and line-to-line voltages measured in volts (V) for base voltages. The macro command [`@base`](@ref @base) can be used to change the default unit settings for the base quantities of the composite type `PowerSystem` after it is created.

The composite type `PowerSystem` can be created using a function:
* [`powerSystem`](@ref powerSystem).
JuliaGrid supports three modes for populating the `PowerSystem` type: using built-in functions, using HDF5 file format, and using [Matpower](https://matpower.org) case files. It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:
* [`savePowerSystem`](@ref savePowerSystem).
This function allows to save power systems that were either loaded from Matpower case files or created using built-in functions in the HDF5 format.

Once the `PowerSystem` type is created, you can add buses, branches, and generators using the following functions:
* [`addBus!`](@ref addBus!)
* [`addBranch!`](@ref addBranch!)
* [`addGenerator!`](@ref addGenerator!).
In addition, it is possible to manipulate the parameters of buses, branches, and generators using the following functions:
* [`shuntBus!`](@ref shuntBus!)
* [`statusBranch!`](@ref statusBranch!)
* [`parameterBranch!`](@ref parameterBranch!)
* [`statusGenerator!`](@ref statusGenerator!)
* [`outputGenerator!`](@ref outputGenerator!).
Executing these functions will automatically update all fields affected by them. You can also change other parameters of the power system by accessing and modifying the values in the `bus`, `branch`, `generator`, and `base` fields of the `PowerSystem` composite type. The input electrical quantities should be entered in per-units or radians, but this default setting can be altered using the following macros [`@power`](@ref @power), [`@voltage`](@ref @voltage), and [`@parameter`](@ref @parameter).

After adding the generator, JualiGrid provides the following functions to incorporate costs for the active and reactive power generated by the generator:
* [`addActiveCost!`](@ref addActiveCost!)
* [`addReactiveCost!`](@ref addReactiveCost!).

To create vectors and matrices based on the power system topology and parameters, you can use the following functions:
* [`acModel!`](@ref acModel!)
* [`dcModel!`](@ref dcModel!).
Note that these functions can be executed at any time once all power system buses are defined. Specifically, using the [`addBranch!`](@ref addBranch!) function to add a new branch will automatically update the `acModel` and `dcModel` fields. However, adding a new bus using [`addBus!`](@ref addBus!) requires executing the [`acModel!`](@ref acModel!) and [`dcModel!`](@ref dcModel!) functions again. In addition, executing functions related to parameter manipulation of buses and branches will also automatically update the `acModel` and `dcModel` fields.

---

## [Build Model](@id buildModelManual)
The [`powerSystem`](@ref powerSystem) function generates the `PowerSystem` composite type and requires a string-formatted path to either Matpower case or HDF5 files as input. Alternatively, the `PowerSystem` can be generated from scratch using the same function.

---

##### Matpower or HDF5 File
To create the `PowerSystem` type using the Matpower case file for the IEEE 14-bus test case, which is named `case14.m` and located in the folder `C:\matpower`, the following Julia code can be used:
```julia
system = powerSystem("C:/matpower/case14.m")
```

In order to use the HDF5 file as input to create the `PowerSystem` object, it is necessary to have saved the data using the [`savePowerSystem`](@ref savePowerSystem) function beforehand. As an example, let's say we saved the power system as `case14.h5` in the directory `C:\matpower`. In this case, the following Julia code can be used to construct the `PowerSystem` composite type:
```julia
system = powerSystem("C:/matpower/case14.h5")
```

!!! note "Loading Time"
    It is recommended to load the power system from the HDF5 file to reduce the loading time.

---

##### Model from Scratch
Alternatively, the model can be build from the scratch using built-in functions, for example:
```@example buildModelScratch
using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)

addBranch!(system; label = 1, from = 1, to = 2, resistance = 0.008, reactance = 0.05)
```

---

##### Base Units
The `system` stores all its electrical quantities in per-units (pu) and radians (rad), except for the base values of power and voltages. The base power value is expressed in volt-amperes (VA), while the base voltages are given in volts (V). For instance, if you run the previous example, the base power can be obtained as follows:
```@repl buildModelScratch
system.base.power.value, system.base.power.unit
```
Likewise, the base voltages are specified as:
```@repl buildModelScratch
system.base.voltage.value, system.base.voltage.unit
```

---

##### Change Base Units
By using the [`@base`](@ref @base) macro, users can change the prefixes of the base units. For instance, if the user wishes to convert base power and base voltage values to megavolt-amperes (MVA) and kilovolts (kV) respectively, they can execute the following command:
```@example buildModelScratch
@base(system, MVA, kV)
nothing # hide
```
After executing the macro, the updated base power is:
```@repl buildModelScratch
system.base.power.value, system.base.power.unit
```
Likewise, the updated base voltage values can be retrieved using the following command:
```@repl buildModelScratch
system.base.voltage.value, system.base.voltage.unit
```
Therefore, by using the [`@base`](@ref @base) macro to modify the base unit, users can convert the output data from various analyses to specific units with desired prefixes.

---

## Save Model
Once the `system` variable has been created using one of the methods outlined in [Build Model](@ref buildModelManual), the current data can be stored in the HDF5 file by executing the following Julia code:
```julia
savePowerSystem(system; path = "C:/matpower/case14.h5", reference = "IEEE 14-bus test case")
```
All electrical quantities saved in the HDF5 file are in per-units (pu) and radians (rad), except for base values for power and voltages, which are given in volt-amperes (VA) and volts (V). It is important to note that even if the user modifies the base units using the [@base](@ref @base) macro, the units will still be saved in the default settings.

---

## Add Bus
We have the option to add buses to a loaded power system or to one created from scratch. As an illustration, we can initiate the `PowerSystem` type and then incorporate two buses by utilizing the [`addBus!`](@ref addBus!) function:
```@example addBus
using JuliaGrid # hide


system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, angle = -0.03491, base = 138e3)
```

In this case, we have created two buses, where the active and reactive powers demanded by consumers at buses labelled with 1 and 2 are specified in per-units (pu), which are the same units used to store electrical quantities:
```@repl addBus
system.bus.demand.active 
system.bus.demand.reactive
```
We recommend reading the documentation for the [`addBus!`](@ref addBus!) function, where all the keywords used in the function are explained in detail.

---

##### Change Input Units
By default, all keywords related to electrical quantities must be given in per-units (pu) and radians (rad). To specify some of the units other than the default per-units (pu) and radians (rad), users can utilize macros such as the following:
```@example addBusUnit
using JuliaGrid # hide

@power(MW, MVAr, MVA)
@voltage(pu, deg)
nothing # hide
```
We can create identical two buses as before using new system of units as follows:
```@example addBusUnit
system = powerSystem()

addBus!(system; label = 1, type = 3, active = 10.0, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 5.0, angle = -2.0, base = 138e3)
```
It should be emphasized that electrical quantities will be stored in the per-units (pu) and radians (rad) format. For example:
```@repl addBusUnit
system.bus.demand.active 
system.bus.demand.reactive
```

Here, the `base` keyword is related to base voltages, and its default units are in volts (V):
```@repl addBusUnit
system.base.voltage.value, system.base.voltage.unit
```

The input unit of the `base` keyword can be changed using the [`@base`](@ref @base) macro. For example:
```@example addBusBase
using JuliaGrid # hide

@power(MW, MVAr, MVA)
@voltage(pu, deg)

system = powerSystem()
@base(system, MVA, kV)

addBus!(system; label = 1, type = 3, active = 10.0, base = 138.0)
addBus!(system; label = 2, type = 1, reactive = 5.0, angle = -2.0, base = 138.0)
```
Unlike the preceding examples where base voltages are given in volts (V), the current illustration adopts units of kilovolts (kV):
```@repl addBusBase
system.base.voltage.value, system.base.voltage.unit
```

---


## Add Branch
After adding buses with unique labels, we can define branches between them. The branch cannot be added unless the buses are already defined, and the `from` and `to` keywords should correspond to the already defined bus labels. Additionally, each branch should be labelled with its own unique label. For instance:
```@example addBranch
using JuliaGrid # hide
@default(all)  # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, angle = -0.03491, base = 138e3)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)
```
Here, we created branch from bus 1 to bus 2 with following parameters:
```@repl addBranch
system.branch.parameter.reactance
system.branch.parameter.shiftAngle
```
It is recommended to consult the documentation for the [`addBranch!`](@ref addBranch!) function, which provides an explanation of all the keywords used in the function.

---

##### Change Input Units
To use units other than per-units (pu) and radians (rad), macros can be employed to change the input units for branches. For example, if the `reactance` is required in ohms (Ω) and the `shiftAngle` in degrees (deg), the following macros can be used:
```@example addBranchUnit
using JuliaGrid # hide

@parameter(Ω, pu)
@voltage(pu, deg)

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, angle = -2.0, base = 138e3)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 22.8528, shiftAngle = 10.0)
```
Still, all electrical quantities are stored in per-units (pu) and radians (rad), and the same branch as before is created, as shown in the following output:
```@repl addBranchUnit
system.branch.parameter.reactance 
system.branch.parameter.shiftAngle
```

---

## Add Generator
Once the buses are defined, generators can be added to the `system` variable. It is crucial to note that each generator must be assigned a unique label, and the `bus` keyword should match the unique label of the bus to which it is connected. For example:
```julia
system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)

addGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)
```
It is recommended to refer to the documentation for the [`addGenerator!`](@ref addGenerator!) function, which explains all the keywords used in the function. Similar to buses and branches, the input units can be changed to units other than per-units (pu) and radians (rad) using different macros.

---

## AC and DC Model
When we constructed the power system, we can create an AC and/or DC model, which include vectors and matrices related to the power system's topology and parameters. The following code snippet demonstrates this:
```@example ACDCModel
using JuliaGrid # hide
@default(all) # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)
addBus!(system; label = 3, type = 1, susceptance = 0.05, base = 138e3)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)
addBranch!(system; label = 2, from = 2, to = 3, resistance = 0.008, reactance = 0.05)

acModel!(system)
dcModel!(system)

nothing # hide
```
The AC model is used for AC power flow, AC optimal power flow, nonlinear state estimation or state estimation with PMUs. The DC model is essential for different DC or linear analysis. For example, the DC nodal matrix in the current example is as follows:
```@repl ACDCModel
system.dcModel.nodalMatrix
```

---

##### New Branch Triggers Model Update
We can execute the [`acModel!`](@ref acModel!) and [`dcModel!`](@ref dcModel!) functions after defining the final number of buses, and each new branch added will trigger an update of the AC and DC vectors and matrices. Here's an example:
```@example ACDCModelUpdate
using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)
addBus!(system; label = 3, type = 1, susceptance = 0.05, base = 138e3)

acModel!(system)
dcModel!(system)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)
addBranch!(system; label = 2, from = 2, to = 3, resistance = 0.008, reactance = 0.05)

nothing # hide
```
The DC nodal matrix has the same values as before:
```@repl ACDCModelUpdate
system.dcModel.nodalMatrix
```

!!! note "Model Update"
    It is not fully recommended to create AC and DC models before adding a large number of branches if the execution time of functions is important. Instead, triggering updates to the AC and DC models using the [`addBranch!`](@ref addBranch!) function is useful for power systems that require the addition of several branches. This update avoids the need to recreate vectors and matrices from scratch.

---

##### New Bus Triggers Model Erasure
The AC and DC models must be defined when a finite number of buses are defined, otherwise, adding a new bus will delete them. For example, if we attempt to add a new bus to the `system` variable, the current DC and AC models will be completely erased:
```@repl ACDCModelUpdate
addBus!(system; label = 4, type = 2, base = 138e3)
system.dcModel.nodalMatrix
```

---

## Alter Shunt Elements 
To modify or add new shunt element at bus, you can use the function [`shuntBus!`](@ref shuntBus!). If AC and DC models have not yet been created, you can directly access the `bus.shunt.conductance` and `bus.shunt.susceptance` variables to change their values. However, if AC and DC models have been created, using the [`shuntBus!`](@ref shuntBus!) function will automatically update all relevant fields, including nodal matrices, in these models. This avoids the need to recreate the AC and DC models from scratch. 

Therefore, it is recommended to use this function after executing the [`acModel!`](@ref acModel!) and [`dcModel!`](@ref dcModel!) functions. Here is an example code that demonstrates the usage of [`shuntBus!`](@ref shuntBus!) function:
```julia
system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)

acModel!(system)
dcModel!(system)

shuntBus!(system; label = 1, conductance = 0.04)
shuntBus!(system; label = 2, susceptance = 0.02)

```
In this example, we add the shunt element at bus 1 by setting its conductance, and change the susceptance value of the shunt element at bus 2.

---

## Change Branch Status
We can use the [`statusBranch!`](@ref statusBranch!) function to switch the branch's status between in-service and out-of-service. If the AC and DC models are not created, the function will perform the same operation as accessing `branch.layout.status` and changing the value from 1 to 0 or vice versa. However, if the AC and DC models are created, the function will trigger updates to all affected vectors and matrices. 

Therefore, it is recommended to use this function after executing the [`acModel!`](@ref acModel!) and [`dcModel!`](@ref dcModel!) functions. The following code demonstrates the usage of the [`statusBranch!`](@ref statusBranch!) function:
```@example statusBranch
using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)
addBus!(system; label = 3, type = 1, susceptance = 0.05, base = 138e3)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)
addBranch!(system; label = 2, from = 2, to = 3, resistance = 0.008, reactance = 0.05)

acModel!(system)
dcModel!(system)

statusBranch!(system; label = 1, status = 0)

nothing # hide
```

This code sets the branch labeled with 1 to out-of-service. For example, the DC nodal matrix has the following form:
```@repl statusBranch
system.dcModel.nodalMatrix
```

---

##### Drop Zeros
After the execution of the [`statusBranch!`](@ref statusBranch!) function, the nodal matrices will contain zeros, as demonstrated in the code example. If needed, the user can remove these zeros by using the `dropzeros!` function, as shown below:
```@repl statusBranch
using SparseArrays
dropzeros!(system.dcModel.nodalMatrix)
```

!!! note "Keeping Zeros"
    It should be noted that in simulations conducted with the JuliaGrid package, the accuracy of the results will not be affected by leaving zeros.

---

## Change Branch Parameters
The [`parameterBranch!`](@ref parameterBranch!) function is used to modify the parameters of a branch, which include resistance, reactance, susceptance, turns ratio, and shift angle. Although one can modify these parameters by accessing the corresponding variables within the `branch.parameter` field, using the [`parameterBranch!`](@ref parameterBranch!) function will update all affected vectors and matrices, provided that the AC and DC models have been created.

Therefore, this function is useful after executing the [`acModel!`](@ref acModel!) and [`dcModel!`](@ref dcModel!) functions. By specifying the parameter names as keywords along with their corresponding new values, one can modify the desired parameters:
```@example parameterBranch
using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12, shiftAngle = 0.1745)

acModel!(system)
dcModel!(system)

parameterBranch!(system; label = 1, reactance = 0.10, resistance = 0.02)

nothing # hide
```
In this case, we modified the reactance value and introduced resistance to the branch with the label 1, while keeping the shift angle the same as before.

---

## [Change Generator Status](@id changeGeneratorStatusManual)
The [`statusGenerator!`](@ref statusGenerator!) function can be used to change the status of a generator between in-service and out-of-service. It is important to always use this function when changing the status of a previously defined generator. Directly accessing the corresponding variable to change the status can result in incorrect results because it will not affect the variable that holds the active and reactive powers generated by the generators that supply buses. Therefore, using the [`statusGenerator!`](@ref statusGenerator!) function is a safe way to put a generator in or out of service.

Let us create the power system with two generators connected to the same bus:
```@example statusGenerator
using JuliaGrid # hide
@default(all) # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)

addGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)
addGenerator!(system; label = 2, bus = 2, active = 0.5, reactive = 0.1)

nothing # hide
```

You can inspect the variables that contain the powers generated by the generators supplying the buses using the following code:
```@repl statusGenerator
system.bus.supply.active
system.bus.supply.reactive
```

To put the second generator out of service, you can use the [statusGenerator!](@ref statusGenerator!) function:
```@example statusGenerator
statusGenerator!(system; label = 2, status = 0)
nothing # hide
```
Here, we can see the updated supply variables, where the second generator has been taken out of the system:
```@repl statusGenerator
system.bus.supply.active
system.bus.supply.reactive
```

---

## Change Generator Outputs
The function [`outputGenerator!`](@ref outputGenerator!) can be utilized to change the output of a generator. Similar to the [Change Generator Status](@ref changeGeneratorStatusManual), this function provides a safe way to modify the active and reactive powers produced by the previously defined generator.

To demonstrate how to use this function, we can use the same example as in [Change Generator Status](@ref changeGeneratorStatusManual):
```@example outputGenerator
using JuliaGrid # hide
@default(all) # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)

addGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)
addGenerator!(system; label = 2, bus = 2, active = 0.5, reactive = 0.1)

outputGenerator!(system; label = 1, active = 1.0)
nothing # hide
```
In this example, we increase the power output of the first generator, and the results can be observed below:
```@repl outputGenerator
system.generator.output.active
system.bus.supply.active
```

---

## Add Active and Reactive Costs
The [`addActiveCost!`](@ref addActiveCost!) and [`addReactiveCost!`](@ref addReactiveCost!) functions are responsible for adding costs for the active and reactive power produced by the corresponding generator. These costs are added only if the corresponding generator is defined. We will be using the [`addActiveCost!`](@ref addActiveCost!) function throughout this manual. The same steps can be applied for the [`addReactiveCost!`](@ref addReactiveCost!) function.

To begin, let us create an example of the power system using the following code:
```@example addActiveCost
using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)

addGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)

nothing # hide
```

---

##### Polynomial Cost
Let us define a quadratic polynomial cost function ``f(P_1) = 1100P^2_1 + 500P_1 + 150`` for the active power produced by the generator labelled with 1 using the following code:
```@example addActiveCost
addActiveCost!(system; label = 1, model = 2, polynomial = [1100.0; 500.0; 150.0])
```
As previously, the default input units are related with per-units (pu), and the coefficients of the cost function have units of currency/pu²hr for 1100, currency/puhr for 500, and currency/hr for 150. Hence, the coefficients are stored exactly as entered:
```@repl addActiveCost
system.generator.cost.active.polynomial
```
By setting `model = 2` in the [`addActiveCost!`](@ref addActiveCost!) function, we specify that the quadratic polynomial cost is being used for the corresponding generator. This can be particularly useful if we have also defined a piecewise linear cost function for the same generator. In such cases, we can choose between these two cost functions depending on our simulation requirements.
   
---

##### Picewise Linear Cost
We can also create a piecewise linear cost function for the active power of the same generator by using the following code:
```@example addActiveCost
addActiveCost!(system; label = 1, piecewise =  [0.1085 12.3; 0.1477 16.8; 0.18 18.1])
nothing # hide
```
In this case, the first column specifies the active power outputs of the generator in per-units (pu), while the second column specifies the corresponding costs for the specified active power output in currency/hr. Thus, the data is stored exactly as entered: 
```@repl addActiveCost
system.generator.cost.active.piecewise
```
If we want to use this piecewise linear cost function instead of the polynomial cost function that was defined earlier, we need to set `model = 1`.

---

##### Change Input Units
Changing input units from per-units (pu) can be particularly useful since cost functions are usually related to SI units of powers. To demonstrate this, let us set active powers in megawatts (MW) while keeping the rest of the units in per-units (pu):
```@example addActiveCostUnit
using JuliaGrid # hide
@power(MW, pu, pu)

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 10, base = 138e3)
addBus!(system; label = 2, type = 1, reactive = 0.05, base = 138e3)

addGenerator!(system; label = 1, bus = 2, active = 50, reactive = 0.1)

nothing # hide
```

Now, we can add the quadratic polynomial function using megawatts (MW):
```@example addActiveCost
addActiveCost!(system; label = 1, model = 2, polynomial = [0.11; 5.0; 150.0])
```
After inspecting the resulting cost data, we can see that it is the same as before:
```@repl addActiveCost
system.generator.cost.active.polynomial
```
Similarly, we can define the linear piecewise cost:
```@example addActiveCost
addActiveCost!(system; label = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])
nothing # hide
```
Upon inspection, we can see that the stored data is the same as before:
```@repl addActiveCost
system.generator.cost.active.piecewise
```
