# [Power System Model](@id PowerSystemModelManual)

The JuliaGrid supports the composite type `PowerSystem` to preserve power system data, with the following fields: `bus`, `branch`, `generator`, `base`, and `model`. The fields `bus`, `branch`, and `generator` hold data related to buses, branches, and generators, respectively. The `base` field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes for the base power and line-to-line voltages measured in volts for base voltages. The `model` stores vectors and matrices that are related to the topology and parameters of the power system.

The composite type `PowerSystem` can be created using a function:
* [`powerSystem`](@ref powerSystem).
JuliaGrid supports three modes for populating the `PowerSystem` type: using built-in functions, using HDF5 file format, and using [Matpower](https://matpower.org) case files.

It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:
* [`savePowerSystem`](@ref savePowerSystem).

Once the `PowerSystem` type is created, you can add buses, branches, and generators using the following functions:
* [`addBus!`](@ref addBus!),
* [`addBranch!`](@ref addBranch!),
* [`addGenerator!`](@ref addGenerator!).
Additionally, JuliaGrid provides macros [`@bus`](@ref @bus), [`@branch`](@ref @branch), and [`@generator`](@ref @generator) to define templates that aid in creating buses, branches, and generators. These templates help avoid entering the same parameters repeatedly.

To create vectors and matrices based on the power system topology and parameters, you can use the following functions:
* [`acModel!`](@ref acModel!),
* [`dcModel!`](@ref dcModel!).

In addition, it is possible to manipulate the parameters of buses, branches, and generators using the following functions:
* [`shuntBus!`](@ref shuntBus!),
* [`statusBranch!`](@ref statusBranch!),
* [`parameterBranch!`](@ref parameterBranch!),
* [`statusGenerator!`](@ref statusGenerator!),
* [`outputGenerator!`](@ref outputGenerator!).
Executing these functions will automatically update all fields affected by them within `PowerSystem` composite type. You can also change other parameters of the power system by accessing and modifying the values in the `bus`, `branch`, `generator`, and `base` fields of the `PowerSystem` type.

Finally, after adding the generator, JualiGrid provides the following functions to incorporate costs for the active and reactive power generated by the generator:
* [`addActiveCost!`](@ref addActiveCost!),
* [`addReactiveCost!`](@ref addReactiveCost!).

---

## [Build Model](@id BuildModelManual)
The [`powerSystem`](@ref powerSystem) function generates the `PowerSystem` composite type and requires a string-formatted path to either Matpower case or HDF5 files as input. Alternatively, the `PowerSystem` can be created without any initial data by initializing it as empty, allowing the user to construct the power system from scratch.

---

##### Matpower or HDF5 File
For example, to create the `PowerSystem` type using the Matpower case file for the IEEE 14-bus test case, which is named `case14.m` and located in the folder `C:\matpower`, the following Julia code can be used:
```julia
system = powerSystem("C:/matpower/case14.m")
```

In order to use the HDF5 file as input to create the `PowerSystem` object, it is necessary to have saved the data using the [`savePowerSystem`](@ref savePowerSystem) function beforehand. As an example, let us say we saved the power system as `case14.h5` in the directory `C:\hdf5`. In this case, the following Julia code can be used to construct the `PowerSystem` composite type:
```julia
system = powerSystem("C:/hdf5/case14.h5")
```

!!! tip "Tip"
    It is recommended to load the power system from the HDF5 file to reduce the loading time.

---

##### Model from Scratch
Alternatively, the model can be build from the scratch using built-in functions, for example:
```@example buildModelScratch
using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = "Bus 1", type = 3, active = 0.1, base = 345e3)
addBus!(system; label = "Bus 2", type = 1, reactive = 0.05, base = 345e3)

addBranch!(system; label = "Branch 1", from = "Bus 1", to = "Bus 2", reactance = 0.05)
```

---

##### Internal Unit System
The `PowerSystem` composite type stores all electrical quantities in per-units and radians, except for the base values of power and voltages. The base power value is expressed in volt-amperes, while the base voltages are given in volts.

---

##### Change Internal Base Unit Prefixes
As an example, if you execute the previous code snippet, you can retrieve the base power and base voltage values and units as shown below:
```@repl buildModelScratch
system.base.power.value, system.base.power.unit
system.base.voltage.value, system.base.voltage.unit
```

By using the [`@base`](@ref @base) macro, users can change the prefixes of the base units. For instance, if the user wishes to convert base power and base voltage values to megavolt-amperes (MVA) and kilovolts (kV) respectively, they can execute the following macro:
```@example buildModelScratch
@base(system, MVA, kV)
nothing # hide
```
Upon execution of the macro, the base power and voltage values and units will be modified accordingly:
```@repl buildModelScratch
system.base.power.value, system.base.power.unit
system.base.voltage.value, system.base.voltage.unit
```

Therefore, by using the [`@base`](@ref @base) macro to modify the prefixes of the base units, users can convert the output data from various analyses to specific units with the desired prefixes.

---

## [Save Model](@id SaveModelManual)
Once the `PowerSystem` type has been created using one of the methods outlined in [Build Model](@ref BuildModelManual), the current data can be stored in the HDF5 file by using  [`savePowerSystem`](@ref savePowerSystem) function:
```julia
savePowerSystem(system; path = "C:/matpower/case14.h5", reference = "IEEE 14-bus test case")
```
All electrical quantities saved in the HDF5 file are in per-units and radians, except for base values for power and voltages, which are given in volt-amperes and volts. It is important to note that even if the user modifies the base units using the [`@base`](@ref @base) macro, the units will still be saved in the default settings.

---

## [Labels](@id LabelsManual)
JuliaGrid mandates a distinctive label for every bus, branch, or generator. These labels are stored in dictionaries, functioning as pairs of strings and integers. The string signifies the exclusive label for the specific component, whereas the integer maintains an internal numbering of buses, branches, or generators.

If users prefere to input labels as integers in different functions, this is permissible. However, these labels are still retained as strings. For instance, we guide users to the following section that outlines the procedure for incorporating buses into the power system.

Furthermore, in functions that append any of these components, users also have the option to exclude the `label` keyword. This allows JuliaGrid to autonomously assign unique labels for buses, branches, or generators.

---

## [Add Bus](@id AddBusManual)
We have the option to add buses to a loaded power system or to one created from scratch. As an illustration, we can initiate the `PowerSystem` type and then incorporate two buses by utilizing the [`addBus!`](@ref addBus!) function:
```@example addBus
using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = "Bus 1", type = 3, active = 0.1, base = 345e3)
addBus!(system; label = "Bus 2", type = 1, angle = -0.034907, base = 345e3)
```

In this case, we have created two buses where the active power demanded by the consumer at `Bus 1` is specified in per-units, which are the same units used to store electrical quantities:
```@repl addBus
system.bus.demand.active
```

In addition, it is worth noting that the `base` keyword is used to specify the base voltages, and its default input unit is in volts (V).
```@repl addBus
system.base.voltage.value, system.base.voltage.unit
```

Finally, we set the bus voltage angle in radians for the `Bus 2` to its initial value:
```@repl addBus
system.bus.voltage.angle
```

!!! note "Info"
    We recommend reading the documentation for the [`addBus!`](@ref addBus!) function, where all the keywords used in the function are explained in detail.

---

##### Change Input Unit System
Typically, all keywords associated with electrical quantities are expected to be provided in per-units (pu) and radians (rad) by default, with the exception of base voltages, which should be specified in volts (V). However, users can choose to use different units than the default per-units and radians or modify the prefix of the base voltage unit by using macros such as the following:
```@example addBusUnit
using JuliaGrid # hide

@power(MW, MVAr, MVA)
@voltage(pu, deg, kV)
nothing # hide
```

We can create identical two buses as before using new system of units as follows:
```@example addBusUnit
system = powerSystem()

addBus!(system; label = "Bus 1", type = 3, active = 10.0, base = 345.0)
addBus!(system; label = "Bus 2", type = 1, angle = -2.0, base = 345.0)
```
As can be observed, electrical quantities will continue to be stored in per-units and radians format:
```@repl addBusUnit
system.bus.demand.active
system.bus.voltage.angle
```

The base voltage values will still be stored in volts (V) since we only changed the input unit prefix, and did not modify the internal unit prefix, as shown below:
```@repl addBusUnit
system.base.voltage.value, system.base.voltage.unit
```
To modify the internal unit prefix, the following macro can be used:
```@example addBusUnit
@base(system, VA, kV)
nothing # hide
```
After executing this macro, the base voltage values will be stored in kilovolts (kV):
```@repl addBusUnit
system.base.voltage.value, system.base.voltage.unit
```

---

##### Bus Labels
Within JuliaGrid, the collection of bus labels is consistently managed through internal assignment and preservation within a dictionary. To illustrate, consider a scenario where we wish to include buses labeled simply as `30` or `20`. To streamline this process and eliminate the need for redundant string entries, users can conveniently input labels directly as integers:
```@example addBusLabels
using JuliaGrid # hide

system = powerSystem()

addBus!(system; label = 30, type = 3, active = 0.1, base = 345e3)
addBus!(system; label = 20, type = 1, angle = -0.034907, base = 345e3)
```

These bus labels are contained within the variable:
```@repl addBusLabels
system.bus.label
```

For optimization purposes, JuliaGrid employs a non-sequential dictionary structure for label storage. This implies that if a user desires to extract labels in the order that corresponds to the sequence of bus definitions, the following code can be employed:
```@repl addBusLabels
label = collect(keys(sort(system.bus.label; byvalue = true)))
```

##### Automated Bus Labels
JuliaGrid also provides the option for internally assigned labels, allowing users to omit the use of the `label` keyword. For example, let us add a new bus to the previous system while excluding the `label` keyword:
```@example BusLabels
addBus!(system; type = 1, base = 345.0)

nothing # hide
```

Now, the bus labels are as follows:
```@repl addBusLabels
system.bus.label
```
It is notable that JuliaGrid identifies the maximum value among the stored labels and increments it by one for any absent label, ensuring the preservation of label uniqueness.

---
